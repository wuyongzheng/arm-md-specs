## D2.8 Breakpoint exceptions

This section describes Breakpoint exceptions in stage 1 of an AArch64 translation regime.

The PE is using an AArch64 translation regime when it is executing one of the following:

- In an Exception level that is using AArch64.
- At EL0 using AArch32 when EL1 is using AArch64.
- At EL0 using AArch32 when FEAT\_VHE is implemented, EL2 is implemented and enabled in the current Security state, and the Effective value of HCR\_EL2.{E2H, TGE} == {1, 1}.

This section contains the following subsections:

- About Breakpoint exceptions.
- Breakpoint types and linking of breakpoints.
- Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Breakpoint instruction address comparisons.
- Breakpoint context comparisons.
- Breakpoint usage constraints.
- Preferred return address.
- Pseudocode description of Breakpoint exceptions taken from an AArch64 stage 1 translation regime.

## D2.8.1 About Breakpoint exceptions

A breakpoint is an event that results from the execution of an instruction, which is based on either:

- The instruction address, the PE context, or both. This type of breakpoint is called a hardware breakpoint.
- The instruction itself. That is, the instruction is a breakpoint instruction . These can be included in the program that the PE executes. This type of breakpoint is called a software breakpoint .

Breakpoint exceptions are generated by Breakpoint debug events . Breakpoint debug events are generated by hardware breakpoints. Software breakpoints are described in Breakpoint Instruction exceptions.

An implementation can include between 2-64 hardware breakpoints.

If AArch32 is supported at EL1 or FEAT\_Debugv8p9 is not implemented, then the PE does not implement more than 16 breakpoints.

When more than 16 breakpoints are implemented, the number of breakpoints is identified to software by ID\_AA64DFR1\_EL1.BRPs and EDDFR1.BRPs. Otherwise ID\_AA64DFR0\_EL1.BRPs shows how many are implemented.

To use an implemented hardware breakpoint, a debugger programs the following registers for the breakpoint:

- The Breakpoint Control Register , DBGBCR&lt;n&gt;\_EL1. This contains controls for the breakpoint, for example an enable control.
- The Breakpoint Value Register , DBGBVR&lt;n&gt;\_EL1. This holds the value used for breakpoint matching, which is one of:
- -An instruction virtual address.
- -AContext ID.
- -AVMIDvalue.
- -Aconcatenation of both a Context ID value and a VMID value.
- -If FEAT\_VHE is implemented, a concatenation of two Context ID values.

These registers are numbered, so that:

- DBGBCR0\_EL1 and DBGBVR0\_EL1 are for breakpoint number zero.

- DBGBCR1\_EL1 and DBGBVR1\_EL1 are for breakpoint number one.
- . . .
- DBGBCR&lt;n-1&gt;\_EL1 and DBGBVR&lt;n-1&gt;\_EL1 are for breakpoint number (n-1).

Adebugger can link a breakpoint that is programmed with an address and a breakpoint that is programmed with anything other than an address together, so that a Breakpoint debug event is generated only if both breakpoints match.

For each instruction in the program flow, all of the breakpoints are tested. When a breakpoint is tested, it generates a Breakpoint debug event if all of the following are true:

- The breakpoint is enabled. That is, the Effective value of DBGBCR&lt;n&gt;\_EL1.E is 1.
- The conditions specified in the DBGBCR&lt;n&gt;\_EL1 are met.
- The comparison with the value held in the DBGBVR&lt;n&gt;\_EL1 is successful.
- If the breakpoint is linked to another breakpoint, the comparisons made by that other breakpoint are also successful.
- The instruction is committed for execution.

The address of each instruction is compared against the DBGBVR&lt;n&gt;\_EL1 values of all Address matching breakpoints with linking disabled that can generate a breakpoint match at the current Exception level in the current Security state, possibly after the application of a breakpoint mask, and:

- The Boolean equality comparison results of all the address match breakpoints are OR'd together to generate a first result.

- The Boolean inequality comparison results of all the address mismatch breakpoints are AND'd together to generate a second result.

Note

Because ranges have power-of-two sizes and are aligned, it is not possible to configure strictly overlapping pairs of ranges. Only non-overlapping or subsets can be selected.

The resulting address match is:

- False, if there are no such breakpoints.
- The first result, if all such breakpoints are address match breakpoints.
- The second result, if all such breakpoints are address mismatch breakpoints.
- The logical-AND of the first result and the second result, if there is a mix of address match and address mismatch breakpoints.

This address match result is OR'd with the Boolean results of all Context matching breakpoints with linking disabled that are enabled and can generate a breakpoint match at the current Exception level in the current Security state. The breakpoint generates the Breakpoint debug event regardless of the following:

- Whether the instruction passes its Condition code check.
- The instruction type.

Note

This does not apply to breakpoints with linking enabled. A breakpoint with linking enabled only delivers its result to the breakpoint(s) and/or watchpoint(s) linked to it, if any.

If halting is allowed and EDSCR.HDE is 1, Breakpoint debug events cause entry to Debug state.

Otherwise, if debug exceptions are:

- Enabled, Breakpoint debug events generate Breakpoint exceptions.
- Disabled, Breakpoint debug events are ignored.

Note

The remainder of this Breakpoint exceptions section, including all subsections, describes breakpoints as generating Breakpoint exceptions.

However, the behavior described also applies if breakpoints are causing entry to Debug state.

Example D2-1 shows an example of setting an address match breakpoint and an address mismatch breakpoint, and the conditions that cause a breakpoint exception.

Example D2-1 Breakpoint address match and breakpoint address mismatch

Two breakpoints are programmed as follows:

- Breakpoint 0 is programmed with:
- -DBGBCR0\_EL1.{BT2, BT} = Address match breakpoint .
- -DBGBCR0\_EL1.MASK = M0, where M0 &gt; 2.
- -DBGBVR0\_EL1 = A0, where A0 is aligned to 2 M0 .

This means that breakpoint 0 will match an instruction address B if it is within a range, as follows:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

- ⇒ (A0 ≤ ∧
- Breakpoint 1 is programmed with:
- -DBGBCR1\_EL1.{BT2, BT} = Address mismatch breakpoint .
- -DBGBCR1\_EL1.MASK = M1, where M1 &gt; 2.
- -DBGBVR1\_EL1 = A1, where A1 is aligned to 2 M1 .

<!-- formula-not-decoded -->

- Such that {A1, A1 + 4, . . . (A1 + 2 M1 - 4)} ⊂ {A0, A0 + 4, . . . (A0 + 2 M0 - 4)}.
- ⇒ (B &lt; A1) ∨ (B ≥ A1 + 2
- Both breakpoints match at the current Exception level in the current Security state.

Then the combination of these two breakpoints will only generate a breakpoint for an instruction address B if it is both within the first range and outside of the second range, as follows:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

- ⇒ ((A0 ≤ B) ∧ (B &lt; A1)) ∨ ((B ≥ A1 + 2 M1 ) ∧ (B &lt; A0 + 2 M0 ))

The debug exception enable controls describes the enable controls for Breakpoint debug events.

## D2.8.2 Accessing breakpoint System registers

RMLTYN

RJGQGB

RKSCWV

When any of the following are true, the Effective value of MDSELR\_EL1.BANK is zero:

- Executing at EL3 and MDCR\_EL3.EBWE is 0.
- Executing at EL2 and the Effective value of MDCR\_EL2.EBWE is 0.
- Executing at EL1 and the Effective value of MDSCR\_EL1.EMBWE is 0.

If all of the following are true, MDSELR\_EL1 is RES0:

- FEAT\_Debugv8p9 is implemented.
- 16 or fewer breakpoints are implemented.
- 16 or fewer watchpoints are implemented.

The MRS and MSR System register names for accessing breakpoint control registers DBGBCR&lt;n&gt;\_EL1 and breakpoint value registers DBGBVR&lt;n&gt;\_EL1 are mapped to physical registers as follows:

IHMNFZ

- The register names DBGBCR0\_EL1 through DBGBCR15\_EL1 are mapped to the physical registers DBGBCR&lt;BANK × 16+0&gt;\_EL1 through DBGBCR&lt;BANK × 16+15&gt;\_EL1.
- The register names DBGBVR0\_EL1 through DBGBVR15\_EL1 are mapped to the physical registers DBGBVR&lt;BANK × 16+0&gt;\_EL1 through DBGBVR&lt;BANK × 16+15&gt;\_EL1.

MSR and MRS instructions using the breakpoint System register names in RKSCWV make indirect reads of MDSELR\_EL1.BANK. This means that direct writes to MDSELR\_EL1.BANK must be explicitly synchronized before a direct read or direct write using any of these System register names.

## D2.8.3 Breakpoint types and linking of breakpoints

Each implemented breakpoint is one of the following:

- A context-aware breakpoint. This is a breakpoint that can be programmed to generate a Breakpoint exception on any one of the following:
- -An instruction address match or mismatch.
- -AContext ID match, with the value held in CONTEXTIDR\_EL1 or the value held in CONTEXTIDR\_EL2.
- -AVMIDmatch, with the VMID value held in VTTBR\_EL2.
- -Both a Context ID match and a VMID match.
- Abreakpoint that is not context-aware . These can only be programmed to generate a Breakpoint exception on an instruction address match.

If more than 16 context-aware breakpoints are implemented, the number of context-aware breakpoints is identified to software by ID\_AA64DFR1\_EL1.CTX\_CMPs and EDDFR1.CTX\_CMPs. Otherwise ID\_AA64DFR0\_EL1.CTX\_CMPs indicates how many are implemented.

At least one breakpoint must be context-aware .

If 16 or fewer breakpoints are implemented, the highest numbered are context-aware .

If more than 16 breakpoints are implemented:

- If 16 or fewer are context-aware , these are the highest numbered breakpoints up to breakpoint number 15.
- Otherwise, context-aware breakpoints are numbered consecutively beginning at breakpoint number 0.

Any breakpoint that is programmed to generate a Breakpoint exception on an instruction address match is categorized as an Address breakpoint . Breakpoints that are programmed to match on anything else are categorized as Context breakpoints .

When a debugger programs a breakpoint to be an Address or a Context breakpoint, it must also program that breakpoint so that it is either:

- Used in isolation. In this case, the breakpoint is called an Unlinked breakpoint .
- Linked to another Context matching breakpoint. In this case, the breakpoint is called a Linked breakpoint .
- Enabled for linking from another breakpoint or watchpoint. In this case, the breakpoint has Linking enabled and does not generate debug events in isolation.

By linking an Address breakpoint and a Context breakpoint together, the debugger can create a breakpoint pair that generates a Breakpoint exception only if the PE is in a particular context when an instruction address match occurs. This is shown in Example D2-2.

For example, a debugger might:

1. Program breakpoint number one to be a Linked Address Match breakpoint .
2. Program breakpoint number five to be a Context matching breakpoint with linking enabled .
3. Link these two breakpoints together. A Breakpoint exception is generated only if both the instruction address matches and the Context ID matches.

The Breakpoint Type fields for a breakpoint, DBGBCR&lt;n&gt;\_EL1.{BT2, BT}, control the breakpoint type and whether the breakpoint is enabled for linking.

If AArch32 state is implemented, Address breakpoints can be programmed to generate Breakpoint exceptions on addresses that are halfword-aligned but not word-aligned. This makes it possible to breakpoint on T32 instructions. See Specifying the halfword-aligned address that an Address breakpoint matches on.

## D2.8.3.1 Rules for linking breakpoints

The rules for breakpoint linking are as follows:

- Only Linked Address breakpoint types can be linked.
- Any type of Linked Address breakpoint can link to any type of Context matching breakpoint with linking enabled.

The Linked Breakpoint Number field, DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN}, for the Linked Address breakpoint specifies the particular Context matching breakpoint that the Linked Address breakpoint links to, and:

- -The {LBNX,LBN} fields are ignored if the breakpoint is not a Linked Address breakpoint.
- -DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} for the Linked Address breakpoint define the execution conditions that the breakpoint pair generates Breakpoint exceptions for. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- -DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} for the Context matching breakpoint with linking enabled are ignored.
- Linked Address breakpoints cannot link to watchpoints. The {LBNX, LBN} fields always specify a breakpoint.
- If a Linked Address breakpoint links to a breakpoint that is not context-aware or does not have linking enabled, the behavior of the Linked Address breakpoint is CONSTRAINED UNPREDICTABLE. See Other usage constraints for Address breakpoints.

Asingle Context matching breakpoint with linking enabled might be linked to by all, or any combination of, the following:

- Multiple Linked Address breakpoints.
- Multiple Linked watchpoints.

If FEAT\_ABLE is implemented, a single Address matching breakpoint with linking enabled might be linked to by multiple Linked watchpoints.

Note

If FEAT\_NV2 is implemented, the hypervisor must use the {0b0, 0b1101} , CONTEXTIDR\_EL2 Match breakpoint with linking enabled type to guarantee a linked match, see Interaction with self-hosted and External debug.

If no linked breakpoints and no linked watchpoints link to a breakpoint programmed with linking enabled, then the breakpoint does not generate any Breakpoint exceptions or debug events.

Figure D2-1 shows an example of permitted breakpoint and watchpoint linking.

## Example D2-2 Linking an Address breakpoint and a Context breakpoint

Figure D2-1 The role of linking in Breakpoint and Watchpoint exception generation

<!-- image -->

In Figure D2-1, each Linked Address breakpoint can generate a Breakpoint exception only if the comparisons made by both it, and the breakpoint that it links to, are successful. Similarly, each Linked watchpoint can only generate a Watchpoint exception if the comparisons made by both it, and the breakpoint that it links to, are successful.

## D2.8.3.2 Breakpoint types defined by DBGBCR&lt;n&gt;\_EL1.{BT2, BT}

If FEAT\_ABLE is not implemented then the Effective value of DBGBCR&lt;n&gt;\_EL1.BT2 is 0.

The following lists provides more detail about each breakpoint type:

{0b0, 0b0000} , Unlinked Address Match breakpoint

Generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC}. These define the execution conditions for which the breakpoint generates Breakpoint exceptions. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Asuccessful address match, as described in Breakpoint instruction address comparisons.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN} for this breakpoint are ignored.

{0b0, 0b0001} , Linked Address Match breakpoint

Generation of a Breakpoint exception depends on all of the following:

- DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} for this breakpoint. These define the execution conditions that the breakpoint generates Breakpoint exceptions for. See Execution conditions for which a breakpoint generates Breakpoint exceptions.

- Asuccessful address match defined by this breakpoint, as described in Breakpoint instruction address comparisons.
- Asuccessful context match defined by the Context breakpoint with linking enabled that this breakpoint links to.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN} for this breakpoint selects the Context breakpoint with linking enabled that this breakpoint links to.

## {0b0, 0b0010} , Context ID Match breakpoint

{BT2, BT} == { 0b0 , 0b0010 } is a reserved value if the breakpoint is not a context-aware breakpoint.

For context-aware breakpoints, generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC}. These define the execution conditions for which the breakpoint generates Breakpoint exceptions. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Asuccessful Context ID match, as described in Breakpoint context comparisons.

The value of DBGBVR&lt;n&gt;\_EL1.ContextID is compared with the current Context ID.

CONTEXTIDR\_EL2 holds the current Context ID when all of:

- The implementation includes FEAT\_VHE.
- EL2 is implemented and enabled in the current Security state.
- EL2 using AArch64 and the Effective value of HCR\_EL2.E2H is 1.
- The PE is executing at EL0 and HCR\_EL2.TGE is 1, or the PE is executing at EL2.

Otherwise, CONTEXTIDR\_EL1 holds the current Context ID.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, BAS} for this breakpoint are ignored

## {0b0, 0b0011} , Context ID Match breakpoint with linking enabled

{BT2, BT} == { 0b0 , 0b0011 } is a reserved value if the breakpoint is not a context-aware breakpoint.

For context-aware breakpoints, one of the following applies:

- If no Linked breakpoints or Linked watchpoints link to this breakpoint, then the breakpoint does not generate any debug exceptions.
- Generation of a Breakpoint exception depends on both:
- -Asuccessful instruction address match, defined by a Linked Address breakpoint that links to this breakpoint, see Breakpoint instruction address comparisons.
- -Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.
- Generation of a Watchpoint exception depends on both:
- -Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.
- -Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.

The value of DBGBVR&lt;n&gt;\_EL1.ContextID is compared with the current Context ID.

CONTEXTIDR\_EL2 holds the current Context ID when all of:

- The implementation includes FEAT\_VHE.
- EL2 is implemented and enabled in the current Security state.
- EL2 using AArch64 and the Effective value of HCR\_EL2.E2H is 1.
- The PE is executing at EL0 and HCR\_EL2.TGE is 1, or the PE is executing at EL2.

Otherwise, CONTEXTIDR\_EL1 holds the current Context ID.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, SSCE, SSC, HMC, BAS, PMC} for this breakpoint are ignored.

{0b0, 0b0100} , Unlinked Address Mismatch breakpoint

{BT2, BT} == { 0b0 , 0b0100 } is a reserved value unless one of the following applies:

- FEAT\_BWE is implemented.
- EL1 is using AArch32.

In stage 1 of an AArch64 translation regime, generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC}. These define the execution conditions that the breakpoint generates Breakpoint exceptions for. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Asuccessful address mismatch, as described in Breakpoint instruction address comparisons.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN} for this breakpoint is ignored.

0b0100 , Unlinked Address Mismatch breakpoint describes the behavior of Address Mismatch breakpoints in stage 1 of an AArch32 translation regime.

{0b0, 0b0101} , Linked Address Mismatch breakpoint

{BT2, BT} == { 0b0 , 0b0101 } is a reserved value unless one of the following applies:

- FEAT\_BWE is implemented.
- EL1 is using AArch32.

In stage 1 of an AArch64 translation regime, generation of a Breakpoint exception depends on all of the following:

- DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC}. These define the execution conditions that the breakpoint generates Breakpoint exceptions for. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Asuccessful address mismatch defined by this breakpoint, as described in Breakpoint instruction address comparisons.
- Asuccessful context match defined by the Context matching breakpoint that this breakpoint links to.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN} for this breakpoint selects the Context matching breakpoint that this breakpoint links to.

0b0101 , Linked Address Mismatch breakpoint describes the behavior of Address Mismatch breakpoints in stage 1 of an AArch32 translation regime.

{0b0, 0b0110} , CONTEXTIDR\_EL1 Match breakpoint

{BT2, BT} == { 0b0 , 0b0110 } is a reserved value if either:

- The breakpoint is not a context-aware breakpoint.
- The implementation does not include FEAT\_VHE.

In an implementation that includes FEAT\_VHE, for context-aware breakpoints, generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC}. These define the execution conditions for which the breakpoint generates Breakpoint exceptions.
- Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.

The Context ID check is made against the value in CONTEXTIDR\_EL1. The value of DBGBVR&lt;n&gt;\_EL1.ContextID is compared with the Context ID value held in CONTEXTIDR\_EL1.

Note

The operation of this breakpoint does not depend on the Effective value of HCR\_EL2.E2H.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, BAS} for this breakpoint are ignored.

{0b0, 0b0111} , CONTEXTIDR\_EL1 Match breakpoint with linking enabled

{BT2, BT} == { 0b0 , 0b0111 } is a reserved value if either:

- The breakpoint is not a context-aware breakpoint.
- The implementation does not include FEAT\_VHE.

In an implementation that includes FEAT\_VHE, for context-aware breakpoints, one of the following applies:

- If no Linked breakpoints or Linked watchpoints link to this breakpoint, then the breakpoint does not generate any debug exceptions.
- Generation of a Breakpoint exception depends on both:
- -Asuccessful instruction address match, defined by a Linked Address match breakpoint that links to this breakpoint, see Breakpoint instruction address comparisons.
- -Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.
- Generation of a Watchpoint exception depends on both:
- -Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.
- -Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.

The Context ID check is made against the value in CONTEXTIDR\_EL1. The value of DBGBVR&lt;n&gt;\_EL1.ContextID is compared with the Context ID value held in CONTEXTIDR\_EL1.

Note

The operation of this breakpoint does not depend on the Effective value of HCR\_EL2.E2H.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, SSCE, SSC, HMC, BAS, PMC} for this breakpoint are ignored.

## {0b0, 0b1000} , VMID Match breakpoint

{BT2, BT} == { 0b0 , 0b1000 } is a reserved value if either:

- The breakpoint is not a context-aware breakpoint.
- EL2 is not implemented.

For context-aware breakpoints, generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC}. These define the execution conditions for which the breakpoint generates Breakpoint exceptions. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Asuccessful VMID match, as described in Breakpoint context comparisons.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, BAS} for this breakpoint are ignored.

{0b0, 0b1001} , VMID Match breakpoint with linking enabled

{BT2, BT} == { 0b0 , 0b1001 } is a reserved value if either:

- The breakpoint is not a context-matching breakpoint.
- EL2 is not implemented.

For context-aware breakpoints, one of the following applies:

- If no Linked breakpoints or Linked watchpoints link to this breakpoint, then the breakpoint does not generate any debug exceptions.
- Generation of a Breakpoint exception depends on both:
- -Asuccessful instruction address match, defined by a Linked Address Match breakpoint that links to this breakpoint. See Breakpoint instruction address comparisons.
- -Asuccessful VMID match defined by this breakpoint, as described in Breakpoint context comparisons.
- Generation of a Watchpoint exception depends on both:
- -Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.

- -Asuccessful VMID match defined by this breakpoint, as described in Breakpoint context comparisons.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, SSCE, SSC, HMC, BAS, PMC} for this breakpoint are ignored.

{0b0, 0b1010} , Context ID and VMID Match breakpoint

{BT2, BT} == { 0b0 , 0b1010 } is a reserved value if either:

- The breakpoint is not a context-aware breakpoint.
- EL2 is not implemented.

When EL2 is implemented, for context-aware breakpoints, generation of a Breakpoint exception depends on all of the following:

- DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC}. These define the execution conditions that the breakpoint generates a Breakpoint exception for. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Asuccessful Context ID match, as described in Breakpoint context comparisons.
- Asuccessful VMID match.

The value of DBGBVR&lt;n&gt;\_EL1.ContextID is compared with CONTEXTIDR\_EL1.

Breakpoint context comparisons describes the requirements for a successful Context ID match and a successful VMID match.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, BAS} for this breakpoint are ignored.

## {0b0, 0b1011} , Context ID and VMID Match breakpoint with linking enabled

{BT2, BT} == { 0b0 , 0b1011 } is a reserved value if either:

- The breakpoint is not a context-aware breakpoint.
- EL2 is not implemented.

When EL2 is implemented, for context-aware breakpoints, one of the following applies:

- If no Linked breakpoints or Linked watchpoints link to this breakpoint, then the breakpoint does not generate any debug exceptions.
- Generation of a Breakpoint exception depends on all of the following:
- -Asuccessful instruction address match, defined by a Linked Address breakpoint that links to this breakpoint, see Breakpoint instruction address comparisons.
- -Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.
- -Asuccessful VMID match defined by this breakpoint.
- Generation of a Watchpoint exception depends on all of the following:
- -Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.
- -Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.
- -Asuccessful VMID match defined by this breakpoint.

The value of DBGBVR&lt;n&gt;\_EL1.ContextID is compared with CONTEXTIDR\_EL1.

Breakpoint context comparisons describes the requirements for a successful Context ID match and a successful VMID match by this breakpoint.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, SSCE, SSC, HMC, BAS, PMC} for this breakpoint are ignored.

{0b0, 0b1100} , CONTEXTIDR\_EL2 Match breakpoint

{BT2, BT} == { 0b0 , 0b1100 } is a reserved value if either:

- The breakpoint is not a context-aware breakpoint.
- FEAT\_VHE is not implemented and FEAT\_Debugv8p2 is not implemented, which means the implementation does not include CONTEXTIDR\_EL2.

In an implementation in which FEAT\_VHE is implemented or FEAT\_Debugv8p2 is implemented, for context-aware breakpoints, generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC}. These define the execution conditions for which the breakpoint generates Breakpoint exceptions.
- Asuccessful CONTEXTIDR\_EL2 match, as described in Breakpoint context comparisons.

The Context ID check is made against the value in CONTEXTIDR\_EL2. The value of DBGBVR&lt;n&gt;\_EL1 is compared with the Context ID value held in CONTEXTIDR\_EL2.

Note

The operation of this breakpoint does not depend on the Effective value of HCR\_EL2.E2H.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, BAS} for this breakpoint are ignored.

## {0b0, 0b1101} , CONTEXTIDR\_EL2 Match breakpoint with linking enabled

{BT2, BT} == { 0b0 , 0b1101 } is a reserved value if either:

- The breakpoint is not a context-aware breakpoint.
- FEAT\_VHE is not implemented and FEAT\_Debugv8p2 is not implemented, which means the implementation does not include CONTEXTIDR\_EL2.

In an implementation in which FEAT\_VHE is implemented or FEAT\_Debugv8p2 is implemented, for context-aware breakpoints, either:

- If no Linked breakpoints or Linked watchpoints link to this breakpoint, then the breakpoint does not generate any debug exceptions.
- Generation of a Breakpoint exception depends on both:
- -Asuccessful instruction address match, defined by a Linked Address match breakpoint that links to this breakpoint, see Breakpoint instruction address comparisons.
- -Asuccessful CONTEXTIDR\_EL2 match, as described in Breakpoint context comparisons.
- Generation of a Watchpoint exception depends on both:
- -Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.
- -Asuccessful CONTEXTIDR\_EL2 match, as described in Breakpoint context comparisons.

The Context ID check is made against the value in CONTEXTIDR\_EL2. The value of DBGBVR&lt;n&gt;\_EL1 is compared with the Context ID value held in CONTEXTIDR\_EL2.

Note

The operation of this breakpoint does not depend on the Effective value of HCR\_EL2.E2H.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, SSCE, SSC, HMC, BAS, PMC} for this breakpoint are ignored.

## {0b0, 0b1110} , Full Context ID Match breakpoint

{BT2, BT} == { 0b0 , 0b1110 } is a reserved value if either:

- The breakpoint is not a context-aware breakpoint.
- FEAT\_VHE is not implemented and FEAT\_Debugv8p2 is not implemented, which means the implementation does not include CONTEXTIDR\_EL2.

In an implementation in which FEAT\_VHE is implemented or FEAT\_Debugv8p2 is implemented, for context-aware breakpoints, generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC}. These define the execution conditions for which the breakpoint generates Breakpoint exceptions.
- Asuccessful Context ID match, as described in Breakpoint context comparisons.

The Context ID check is made against the values in both CONTEXTIDR\_EL1 and CONTEXTIDR\_EL2. The value of DBGBVR&lt;n&gt;\_EL1[31:0] is compared with the Context ID value

held in CONTEXTIDR\_EL1, and the value of DBGBVR&lt;n&gt;\_EL1[63:32] is compared with the Context ID value held in CONTEXTIDR\_EL2. Both comparisons must match for the Context ID check.

Note

The operation of this breakpoint does not depend on the Effective value of HCR\_EL2.E2H.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, BAS} for this breakpoint are ignored.

{0b0, 0b1111} , Full Context ID Match breakpoint with linking enabled

{BT2, BT} == { 0b0 , 0b1111 } is a reserved value if either:

- The breakpoint is not a context-aware breakpoint.
- FEAT\_VHE is not implemented and FEAT\_Debugv8p2 is not implemented, which means the implementation does not include CONTEXTIDR\_EL2.

In an implementation in which FEAT\_VHE is implemented or FEAT\_Debugv8p2 is implemented, for context-aware breakpoints, one of the following applies:

- If no Linked breakpoints or Linked watchpoints link to this breakpoint, then the breakpoint does not generate any debug exceptions.
- Generation of a Breakpoint exception depends on both:
- -Asuccessful instruction address match, defined by a Linked Address match breakpoint that links to this breakpoint, see Breakpoint instruction address comparisons.
- -Asuccessful Context ID match, as described in Breakpoint context comparisons.
- Generation of a Watchpoint exception depends on both:
- -Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.
- -Asuccessful Context ID match, as described in Breakpoint context comparisons.

The Context ID check is made against the values in both CONTEXTIDR\_EL1 and CONTEXTIDR\_EL2. The value of DBGBVR&lt;n&gt;\_EL1[31:0] is compared with the Context ID value held in CONTEXTIDR\_EL1, and the value of DBGBVR&lt;n&gt;\_EL1[63:32] is compared with the Context ID value held in CONTEXTIDR\_EL2. Both comparisons must match for the Context ID check.

Note

The operation of this breakpoint does not depend on the Effective value of HCR\_EL2.E2H.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, SSCE, SSC, HMC, BAS, PMC} for this breakpoint are ignored.

{0b1, 0b0000} , Unlinked Address Match breakpoint with linking enabled

{BT2, BT} == { 0b1 , 0b0000 } is a reserved value if the breakpoint does not support being configured as an address matching breakpoint with linking enabled.

Otherwise, one of the following applies:

- If no Linked watchpoints link to this breakpoint, then the breakpoint does not generate any debug exceptions.
- Generation of a Watchpoint exception by an instruction depends on the following:
- -Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.
- -Asuccessful instruction address match, as described in Breakpoint instruction address comparisons.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, SSCE, SSC, HMC, PMC} for this breakpoint are ignored.

{0b1, 0b0001} , Linked Address Match breakpoint with linking enabled

{BT2, BT} == { 0b1 , 0b0001 } is a reserved value if the breakpoint does not support being configured as an address matching breakpoint with linking enabled.

Otherwise, one of the following applies:

- If no Linked watchpoints link to this breakpoint, then the breakpoint does not generate any debug exceptions.

- Generation of a Watchpoint exception by an instruction depends on the following:

- [ ] - Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.

- [ ] - Asuccessful instruction address match defined by this breakpoint, as described in Breakpoint instruction address comparisons.

- [ ] - Asuccessful context match defined by the Context matching breakpoint with linking enabled that this breakpoint links to.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN} for this breakpoint selects the Context matching breakpoint with linking enabled that this breakpoint links to.

DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} for this breakpoint are ignored.

{0b1, 0b0100} , Unlinked Address Mismatch breakpoint with linking enabled

{BT2, BT} == { 0b1 , 0b0100 } is a reserved value if one of the following applies:

- The breakpoint does not support being configured as an address matching breakpoint with linking enabled.

- FEAT\_BWE is not implemented.

Otherwise, one of the following applies:

- If no Linked watchpoints link to this breakpoint, then the breakpoint does not generate any debug exceptions.

- Generation of a Watchpoint exception by an instruction depends on the following:

- Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.

- Asuccessful instruction address match, as described in Breakpoint instruction address comparisons.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, SSCE, SSC, HMC, PMC} for this breakpoint are ignored.

{0b1, 0b0101} , Linked Address Mismatch breakpoint with linking enabled

{BT2, BT} == { 0b1 , 0b0100 } is a reserved value if one of the following applies:

- The breakpoint does not support being configured as an address matching breakpoint with linking enabled.

- FEAT\_BWE is implemented.

Otherwise, one of the following applies:

- If no Linked watchpoints link to this breakpoint, then the breakpoint does not generate any debug exceptions.

- Generation of a Watchpoint exception by an instruction depends on the following:

- Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.

- Asuccessful instruction address match defined by this breakpoint, as described in Breakpoint instruction address comparisons.

- Asuccessful context match defined by the Context matching breakpoint with linking enabled that this breakpoint links to.

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN} for this breakpoint selects the Context matching breakpoint that this breakpoint links to.

DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} for this breakpoint are ignored.

Note

See Reserved DBGBCR&lt;n&gt;\_EL1.{BT2, BT} values for the behavior of breakpoints programmed with reserved {BT2, BT} values.

## D2.8.4 Execution conditions for which a breakpoint generates Breakpoint exceptions

Each breakpoint can be programmed so that it generates Breakpoint exceptions only for certain execution conditions. For example, a breakpoint might be programmed to generate Breakpoint exceptions only when the PE is executing at EL0 in Secure state.

DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} defines the execution conditions the breakpoint generates Breakpoint exceptions for, as follows:

## Security State Control Extension, SSCE, and Security State Control, SSC

SSCE and SSC control whether the breakpoint generates Breakpoint exceptions in only one Security state or in multiple Security states.

Note

This is determined by the Security state of the PE, not from the physical address space attribute returned by the translation of the virtual address on which the breakpoint is set.

## Higher Mode Control, HMC, and Privileged Mode Control, PMC

HMCand PMC together control which Exception levels the breakpoint generates Breakpoint exceptions in.

Table D2-8 shows the valid combinations of the values of HMC, SSCE, SSC, and PMC, and for each combination shows which Exception levels breakpoints generate Breakpoint exceptions in.

In the table:

NS

Non-secure state.

S

Secure state.

RL

In implementations that include FEAT\_RME, Realm state.

RT

In implementations that include FEAT\_RME, Root state.

Yor -

Means that a breakpoint programmed with the values of HMC, SSCE, SSC, and PMC shown in that row:

Y

Can generate Breakpoint exceptions in that Exception level and Security state.

-

Cannot generate Breakpoint exceptions in that Exception level and Security state.

## Table D2-8 Summary of breakpoint HMC, SSCE, SSC, and PMC encodings

|   HMC |   SSCE |   SSC |   PMC | Security states   | EL3 a   | EL2   | EL1   | EL0   |
|-------|--------|-------|-------|-------------------|---------|-------|-------|-------|
|     0 |      0 |    00 |    01 | RL, S, NS         | -       | -     | Y     | -     |
|     0 |      0 |    00 |    10 | RL, S, NS         | -       | -     | -     | Y     |
|     0 |      0 |    00 |    11 | RL, S, NS         | -       | -     | Y     | Y     |
|     0 |      0 |    01 |    01 | NS                | -       | -     | Y     | -     |
|     0 |      0 |    01 |    10 | NS                | -       | -     | -     | Y     |
|     0 |      0 |    01 |    11 | NS                | -       | -     | Y     | Y     |
|     0 |      0 |    10 |    01 | S                 | -       | -     | Y     | -     |
|     0 |      0 |    10 |    10 | S                 | -       | -     | -     | Y     |
|     0 |      0 |    10 |    11 | S                 | -       | -     | Y     | Y     |

|   HMC |   SSCE |   SSC |   PMC | Security states   | EL3 a   | EL2   | EL1   | EL0   |
|-------|--------|-------|-------|-------------------|---------|-------|-------|-------|
|     0 |      0 |    11 |    00 | S                 | -       | Y     | -     | -     |
|     0 |      0 |    11 |    01 | S                 | -       | Y     | Y     | -     |
|     0 |      0 |    11 |    11 | S                 | -       | Y     | Y     | Y     |
|     0 |      1 |    01 |    01 | RL                | -       | -     | Y     | -     |
|     0 |      1 |    01 |    10 | RL                | -       | -     | -     | Y     |
|     0 |      1 |    01 |    11 | RL                | -       | -     | Y     | Y     |
|     1 |      0 |    00 |    01 | RT, RL, S, NS     | Y       | Y     | Y     | -     |
|     1 |      0 |    00 |    11 | RT, RL, S, NS     | Y       | Y     | Y     | Y     |
|     1 |      0 |    01 |    00 | NS                | -       | Y     | -     | -     |
|     1 |      0 |    01 |    01 | NS                | -       | Y     | Y     | -     |
|     1 |      0 |    01 |    11 | NS                | -       | Y     | Y     | Y     |
|     1 |      0 |    10 |    00 | RT or S b         | Y       | -     | -     | -     |
|     1 |      0 |    10 |    01 | RT, S             | Y       | Y     | Y     | -     |
|     1 |      0 |    10 |    11 | RT, S             | Y       | Y     | Y     | Y     |
|     1 |      0 |    11 |    00 | RL, S, NS         | -       | Y     | -     | -     |
|     1 |      0 |    11 |    01 | RL, S, NS         | -       | Y     | Y     | -     |
|     1 |      0 |    11 |    11 | RL, S, NS         | -       | Y     | Y     | Y     |
|     1 |      1 |    01 |    00 | RL                | -       | Y     | -     | -     |
|     1 |      1 |    01 |    01 | RL                | -       | Y     | Y     | -     |
|     1 |      1 |    01 |    11 | RL                | -       | Y     | Y     | Y     |

b. If FEAT\_RME is implemented, this combination specifies Root state. Otherwise, Secure state.

All combinations of HMC, SSCE, SSC, and PMC that Table D2-8 does not show are reserved. A combination in Table D2-8 might be reserved if an Exception level or Security state is not implemented. For information about which combinations of HMC, SSCE, SSC and PMC are reserved if an Exception level or Security state are not implemented, See Reserved DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} values.

## D2.8.5 Breakpoint instruction address comparisons

In this subsection, the term AddrTop represents the most significant bit of a virtual address used by breakpoint data address comparisons. AddrTop is:

- 55, if address tagging is used for the address. See Address tagging.
- 63, otherwise.

Note

When stage 1 translation is enabled, in AArch64 state, the virtual address size is determined by the configured input address size for the stage 1 translation. Software can configure a smaller address width for a virtual address, see Input address size configuration. Attempting to translate an address that is larger than the configured input address size generates a Translation fault.

When stage 1 translation is disabled, using an address that is larger than the implemented PA size generates an Address size fault. The implemented PA size is IMPLEMENTATION DEFINED, as described in Implemented physical address size. These faults have a higher priority than breakpoints.

An address comparison is successful if bits [ AddrTop :2] of the current instruction virtual address are equal to DBGBVR&lt;n&gt;\_EL1[ AddrTop :2].

Note

DBGBVR&lt;n&gt;\_EL1 is a 64-bit register. The most significant bits of this register are sign-extension bits. DBGBVR&lt;n&gt;\_EL1[1:0] are RES0 and are ignored.

If EL1 is using AArch64 and EL0 is using AArch32, T32 and A32 instructions can be executed in stage 1 of an AArch64 translation regime. In this case, the instruction addresses are zero-extended before comparison with the breakpoint.

## D2.8.5.1 Specifying the halfword-aligned address that an Address breakpoint matches on

For Address Match breakpoints, if the implementation supports AArch32 state, a debugger must program the Byte Address Selection field, DBGBCR&lt;n&gt;\_EL1.BAS.

Table D2-9 Programmable BAS values

| BAS    | Match instruction at   | Constraint for debuggers          |
|--------|------------------------|-----------------------------------|
| 0b0011 | DBGBVR<n>_EL1          | Use for T32 instructions.         |
| 0b1100 | DBGBVR<n>_EL1 + 2      | Use for T32 instructions.         |
| 0b1111 | DBGBVR<n>_EL1          | Use for A64 and A32 instructions. |

If the implementation is an AArch64-only implementation, all instructions are word-aligned and DBGBCR&lt;n&gt;\_EL1.BAS is RES1.

Figure D2-2 shows a summary of when Address Match breakpoints programmed with particular BAS values generate Breakpoint exceptions. The figure contains four parts:

- Acolumn showing the row number, on the left.
- An instruction set and instruction size table.
- Alocation of instruction figure.
- ABASfield values table, on the right.

To use the figure, read across the rows. For example, row 7 shows that a breakpoint with DBGBCR&lt;n&gt;\_EL1.BAS programmed as either 0b0011 or 0b1111 generates Breakpoint exceptions for A64 instructions. A64 instructions are always at word-aligned addresses.

Note

To breakpoint on an A64 instruction, Arm recommends that the debugger programs DBGBCR&lt;n&gt;\_EL1.BAS as 0b1111 .

In the figure:

| Yes   | Means that the breakpoint generates a Breakpoint exception.                                                                                              |
|-------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| No    | Means that the breakpoint does not generate a Breakpoint exception.                                                                                      |
| UNP   | Means that is it CONSTRAINED UNPREDICTABLE whether the breakpoint generates a Breakpoint exception. See Other usage constraints for Address breakpoints. |

<!-- image -->

|       | Instruction set   | Size   |
|-------|-------------------|--------|
| Row 1 | T32               | 16-bit |
| ROW 2 |                   | 16-bit |
| ROW 3 | T32               | 32-bit |
| Row 4 |                   | 32-bit |
| ROW 5 |                   | 32-bit |
| Row 6 | A32               | 32-bit |
| Row 7 | A64               | 32-bit |

| 0b0011 BAS[3:0]   | 0b1100   | 0b1111   |
|-------------------|----------|----------|
| Yes               | No       | Yes      |
| No                | Yes      | UNP      |
| UNP               | No       | UNP      |
| Yes               | UNP      | Yes      |
| No                | Yes      | UNP      |
| Yes               | UNP      | Yes      |
| Yes               | UNP      | Yes      |

- a.  0 means the word-aligned address held in the DBGBVR&lt;n&gt;\_EL1[maxAddressSize:2]:00. The other locations are as follows:
-    -2 means ((DBGBVR&lt;n&gt;\_EL1[maxAddressSize:2]:00) - 2).
-    -1 means ((DBGBVR&lt;n&gt;\_EL1[maxAddressSize:2]:00) - 1).

•    ...

•    ...

-    +5 means ((DBGBVR&lt;n&gt;\_EL1[maxAddressSize:2]:00) + 5).

The solid areas show the location of the instruction.

Figure D2-2 Summary of BAS field meanings for Address Match breakpoints

## D2.8.5.2 Address Mismatch breakpoints

If FEAT\_BWE is not implemented, then mismatch breakpoints do not generate a breakpoint match in AArch64 state.

If FEAT\_BWE is implemented, then mismatch breakpoints can generate a breakpoint match in AArch64 state and this can cause entry to Debug state.

The behavior of an address mismatch breakpoint is the same as for an address match breakpoint, except that the result is inverted such that only addresses other than the specified address, or addresses outside of the range of addresses, generate a breakpoint match.

Other breakpoint conditions specified by DBGBCR&lt;n&gt;\_EL1 are not inverted.

## D2.8.5.3 Programming a breakpoint range with eight or more bytes

Adebugger can use the DBGBCR&lt;n&gt;\_EL1.MASK field to program a single breakpoint with an instruction address range if all of the following are true:

- It is a size that is:
- -Apower-of-two.
- -Aminimum of eight bytes.
- -Amaximum of 2GB.
- It starts at an address that is aligned to the size.

If m least significant address bits are masked, the breakpoint generates a Breakpoint exception on all of the following:

- Address DBGBCR&lt;n&gt;\_EL1[ AddrTop : m ]:000 . . .
- Address DBGBCR&lt;n&gt;\_EL1[ AddrTop : m ]:111 . . .
- Any address between these two addresses.

For example, if the four least significant address bits are masked, Breakpoint exceptions are generated for all addresses between DBGBCR&lt;n&gt;\_EL1[ AddrTop :4]:0000 and DBGBCR&lt;n&gt;\_EL1[ AddrTop :4]:1111, including these addresses.

When masking address bits, a debugger must both:

- Program DBGBCR&lt;n&gt;\_EL1.BAS to be 0b1111 . See Programming dependencies of the BAS and MASK fields.
- In DBGBVR&lt;n&gt;\_EL1, set the masked address bits to zero. See Other usage constraints.

## D2.8.6 Breakpoint context comparisons

The breakpoint type defined by DBGBCR&lt;n&gt;\_EL1.BT determines what context comparison is required, if any. Table D2-10 shows the BT values that require a comparison, and the match required for the comparison to be successful.

Table D2-10 Breakpoint Context ID and VMID comparison tests

| DBGBCR<n>.BT   | Test required for successful context comparison                                                                                                                                                                                                                                                                                       |
|----------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b001x         | • When FEAT_VHE is implemented, EL2 is using AArch64, the Effective value of HCR_EL2.E2H is 1, and either the PE is executing at EL0 with HCR_EL2.TGE set to 1, or the PE is executing at EL2, CONTEXTIDR_EL2 must match the DBGBVR<n>_EL1.ContextID value. • Otherwise, CONTEXTIDR_EL1 must match the DBGBVR<n>_EL1.ContextID value. |
| 0b011x         | CONTEXTIDR_EL1 must match the DBGBVR<n>_EL1.ContextID value.                                                                                                                                                                                                                                                                          |
| 0b100x         | VTTBR_EL2.VMID must match the DBGBVR<n>_EL1.VMID value.                                                                                                                                                                                                                                                                               |
| 0b101x         | CONTEXTIDR_EL1 must match the DBGBVR<n>_EL1.ContextID value and VTTBR_EL2.VMID must match the DBGBVR<n>_EL1.VMID value.                                                                                                                                                                                                               |
| 0b110x         | CONTEXTIDR_EL2 must match the DBGBVR<n>_EL1.ContextID2 value, DBGBVR<n>_EL1[63:32].                                                                                                                                                                                                                                                   |
| 0b111x         | Both: • CONTEXTIDR_EL1 must match the DBGBVR<n>_EL1.ContextID value, DBGBVR<n>_EL1[31:0]. • CONTEXTIDR_EL2 must match the DBGBVR<n>_EL1.ContextID2 value, DBGBVR<n>_EL1[63:32].                                                                                                                                                       |

No Context ID or VMID comparison is required for other valid DBGBCR.BT values.

Context breakpoints do not generate Breakpoint exceptions when any of:

- The comparison uses the value of CONTEXTIDR\_EL1 and any of:
- -The PE is executing at EL3 using AArch64.
- -The PE is executing at EL2.
- -FEAT\_VHE is implemented, EL2 is using AArch64, EL2 is enabled in the current Security state, and the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.
- The comparison uses the value of CONTEXTIDR\_EL2 and any of:
- -Neither FEAT\_VHE is implemented, nor FEAT\_Debugv8p2 is implemented.
- -The PE is in Secure state, and either FEAT\_SEL2 is not implemented, or Secure EL2 is disabled.
- -The PE is executing at EL3.
- -EL2 is using AArch32.
- -EL2 is not implemented.
- The comparison uses the current VMID value and any of:
- -EL2 is not implemented.
- -The PE is in Secure state, and either FEAT\_SEL2 is not implemented, or Secure EL2 is disabled.
- -The PE is executing at EL2.
- -The PE is executing at EL3.
- -FEAT\_VHE is implemented, EL2 is using AArch64, EL2 is enabled in the current Security state, and the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

## Note

- For all Context breakpoints, DBGBCR&lt;n&gt;\_EL1.BAS is RES1 and is ignored.
- For Context matching breakpoints with linking enabled, DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN, SSCE, SSC, HMC, PMC} are RES0 and are ignored.

## D2.8.7 Breakpoint usage constraints

See the following sections:

- Reserved DBGBCR&lt;n&gt;\_EL1.{BT2, BT} values.
- Reserved DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} values.
- Programming dependencies of the BAS and MASK fields.
- Reserved DBGBCR&lt;n&gt;\_EL1.BAS values.
- Usage constraints on DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN} values.
- Reserved DBGWCR&lt;n&gt;\_EL1.MASK values.
- Other usage constraints for Address breakpoints.
- Other usage constraints for Context breakpoints.

## D2.8.7.1 Reserved DBGBCR&lt;n&gt;\_EL1.{BT2, BT} values

Table D2-11 shows when particular DBGBCR&lt;n&gt;\_EL1.BT values are reserved.

Table D2-11 Reserved BT values when the Effective value of DBGBCR&lt;n&gt;\_EL1.BT2 is 0

| BT value   | Breakpoint type          | Reserved                                                                                                                                         |
|------------|--------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b001x     | Context ID Match         | If the breakpoint is not context-aware .                                                                                                         |
| 0b010x     | Address Mismatch         | If FEAT_BWE is not implemented and one of the following: • In stage 1 of an AArch64 translation regime. • EDSCR.HDE is 1 and halting is allowed. |
| 0b011x     | CONTEXTIDR_EL1 Match     | If FEAT_VHE is not implemented, or the breakpoint is not context-aware .                                                                         |
| 0b100x     | VMIDMatch                | If EL2 is not implemented, or the breakpoint is not context-aware .                                                                              |
| 0b101x     | Context ID and VMIDMatch | If EL2 is not implemented, or the breakpoint is not context-aware .                                                                              |
| 0b110x     | CONTEXTIDR_EL2 Match     | If FEAT_VHE is not implemented and FEAT_Debugv8p2 is not implemented, or if the breakpoint is not context-aware .                                |
| 0b111x     | Full Context ID Match    | If FEAT_VHE is not implemented and FEAT_Debugv8p2 is not implemented, or if the breakpoint is not context-aware .                                |

If FEAT\_ABLE is implemented and BT2 is 1, all values of BT other than 0b0x0x are reserved.

If a breakpoint is programmed with one of these reserved {BT2, BT} values:

- The breakpoint must behave as if it is either:
- -Disabled.
- -Programmed with a {BT2, BT} value that is not reserved, other than for a direct or external read of DBGBCR&lt;n&gt;\_EL1.
- For a direct or external read of DBGBCR&lt;n&gt;\_EL1, if the reserved {BT2, BT} value:
- -Has no function for any execution conditions, the value read back is UNKNOWN.
- -Has a function for execution conditions other than the current execution conditions, the value read back is the value written. This permits software to save and restore the {BT2, BT} value so that the breakpoint functions for the other execution conditions.

The behavior of breakpoints with reserved {BT2, BT} values might change in future revisions of the architecture. For this reason, software must not rely on the behavior described here.

## D2.8.7.2 Reserved DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} values

Table D2-12 shows when particular combinations of DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} are reserved in stage 1 of an AArch64 translation regime.

Table D2-12 Reserved HMC, SSCE, SSC, and PMC combinations

| HMC, SSCE, SSC, and PMC combination                                                                                                                                                                       | Reserved                                            |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------|
| All combinations with SSCE set to 1.                                                                                                                                                                      | When FEAT_RME is not implemented.                   |
| All combinations with HMCset to 0, SSCE set to 0, and SSC set to 0b01 or 0b10 .                                                                                                                           | When Secure state is not implemented.               |
| All combinations with SSCE set to 0 and SSC set to 0b01 or 0b10 , except for the combination with HMCset to 1, SSCE set to 0, SSC set to 0b01 , and PMCset to 0b00 .                                      | When EL3 is not implemented and EL2 is implemented. |
| Any combination with SSCE set to 0 where HMCorSSCis nonzero, except for the combination with HMCset to 1, SSCE set to 0, SSC set to 0b01 , and PMCset to 0b00 , or combinations when SSC is set to 0b11 . | When both of EL2 and EL3 are not implemented.       |
| The combination with HMCset to 1, SSCE set to 0, SSC set to 0b11 , and PMCset to 0b00 .                                                                                                                   | When EL2 is not implemented.                        |
| The combinations with SSC set to 0b11 except the combination with HMCset to 1, SSCE set to 0, SSC set to 0b11 and PMCset to 0b00 .                                                                        | When Secure EL2 is not implemented.                 |
| The combination with HMCset to 1, SSCE set to 0, SSC set to 0b01 and PMCset to 0b00 .                                                                                                                     | When Secure EL2 is not implemented.                 |
| Combinations not included in Table D2-8.                                                                                                                                                                  | Always.                                             |

For all breakpoints except Context matching breakpoints with linking enabled, if a breakpoint is programmed with one of these reserved combinations:

- If the reserved combination has a function for other execution conditions:
- -The breakpoint must behave as if it is disabled.
- -Adirect or external read of DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} returns the values written. This means that software can save and restore the combination so that the breakpoint can function for the other execution conditions.
- If the reserved combination does not have a function for other execution conditions:
- -It must behave either as if it is programmed with a combination that is not reserved or as if it is disabled.
- -Adirect or external read of DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} returns UNKNOWN values.

If the breakpoint is a Context matching breakpoint with linking enabled, then:

- The values of HMC, SSCE, SSC, and PMC are ignored.
- Adirect or external read of DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} returns UNKNOWN values

The behavior of breakpoints with reserved combinations of HMC, SSCE, SSC, and PMC might change in future revisions of the architecture. For this reason, software must not rely on the behavior described here.

## D2.8.7.3 Programming dependencies of the BAS and MASK fields

When programming a breakpoint, a debugger must use either:

- The MASK field, to program the breakpoint with an address range that can be eight bytes to 2GB.
- The BAS field. Table D2-9 gives the valid values of the DBGBCR&lt;n&gt;\_EL1.BAS field .

If the debugger uses the:

- MASKfield, it must program BAS to be 0b1111 , so that all bytes in the doubleword or word are selected.
- BAS field, it must program MASK to be 0b00000 , so that the MASK field does not indicate any address ranges.

If any of the following apply, then it is CONSTRAINED UNPREDICTABLE whether or not a Breakpoint exception is generated:

- DBGBCR&lt;n&gt;\_EL1.MASK is programmed with a reserved value.
- DBGBCR&lt;n&gt;\_EL1.MASK is a valid nonzero value and any of the following apply:
- -DBGBCR&lt;n&gt;\_EL1.BAS is not 0b1111 , and AArch32 is supported at EL0.
- -DBGBVR&lt;n&gt;\_EL1[(MASK-1):0] is nonzero.
- -DBGBCR&lt;n&gt;\_EL1.{BT2, BT} is { 0b0 , 0b0x1x } or { 0b0 , 0b1xxx }, indicating a Context matching breakpoint.
- DBGBCR&lt;n&gt;\_EL1.MASK is zero, DBGBCR&lt;n&gt;\_EL1.{BT2, BT} is { 0b0 , 0b010x }, indicating an address mismatch breakpoint without linking enabled, and AArch32 is not supported at EL1.

Breakpoint &lt;n&gt; does not match in AArch64 state. A stand-alone mismatch of a single address is not supported in AArch64 state.

When any of these conditions apply, the PE behaves as if one of the following applies:

- DBGBCR&lt;n&gt;\_EL1.MASK has been programmed with a defined value, which might be 0b00000 (no mask), other than for a direct read of DBGBCR&lt;n&gt;\_EL1.
- The breakpoint is disabled.

The UNPREDICTABLE behavior is constrained to the generation of Breakpoint and Watchpoint exceptions and debug events.

## D2.8.7.4 Reserved DBGBCR&lt;n&gt;\_EL1.BAS values

In an AArch64-only implementation, DBGBCR&lt;n&gt;\_EL1.BAS for all breakpoints is RES1.

Otherwise:

## For all Context breakpoints

DBGBCR&lt;n&gt;\_EL1.BAS is RES1 and is ignored.

## For all Address breakpoints

Table D2-9 gives the valid values of the DBGBCR&lt;n&gt;\_EL1.BAS field.

If a breakpoint is programmed with a reserved BAS value:

- The breakpoint must behave as if it is either:
- -Disabled.
- -Programmed with a BAS value that is not reserved, other than for a direct or external read of DBGBCR&lt;n&gt;\_EL1.
- Adirect or external read of DBGBCR&lt;n&gt;\_EL1.BAS returns an UNKNOWN value.

Software must not rely on these properties as the behavior of reserved values might change in a future revision of the architecture.

## D2.8.7.5 Usage constraints on DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN} values

## For Linked Address breakpoints

ALinked Address breakpoint must link to a context-aware breakpoint. For a Linked Address breakpoint, any DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN} value that is not for a context-aware breakpoint is reserved.

If a Linked Address breakpoint links to a breakpoint that is not implemented, or that is not context-aware , then reads of DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN} return an UNKNOWN value and behavior is CONSTRAINED UNPREDICTABLE. The Linked Address breakpoint behaves as if it is either:

- Disabled.
- Linked to an UNKNOWN context-aware breakpoint.

If a Linked Address breakpoint links to a breakpoint that is implemented and that is context-aware , but that is either not enabled or not programmed as a Context matching breakpoint with linking enabled, it behaves as if it is disabled.

## For all other breakpoint types

DBGBCR&lt;n&gt;\_EL1.{LBNX, LBN} reads UNKNOWN and its value is ignored.

## D2.8.7.6 Other usage constraints for Address breakpoints

## For all Address breakpoints

- DBGBVR&lt;n&gt;\_EL1[1:0] are RES0 and are ignored.
- If the implementation supports AArch32 state:
- -For 32-bit instructions, if a breakpoint matches on the address of the second halfword but not the address of the first halfword, it is CONSTRAINED UNPREDICTABLE whether the breakpoint generates a Breakpoint exception.
- -If DBGBCR&lt;n&gt;.BAS is 0b1111 , it is CONSTRAINED UNPREDICTABLE whether the breakpoint generates a Breakpoint exception for a T32 instruction starting at address ((DBGBVR&lt;n&gt;[48:2]:00) + 2). For T32 instructions, Arm recommends that the debugger programs the BAS field with either 0b0011 or 0b1100 .

## D2.8.7.7 Other usage constraints for Context breakpoints

## For all Context breakpoints

Any bits of DBGBVR&lt;n&gt;\_EL1 that are not used to specify Context ID or VMID are RES0 and are ignored.

## For breakpoints with linking enabled

If no Linked Address breakpoints or Linked watchpoints link to a breakpoint with linking enabled, the breakpoint with linking enabled does not generate any Breakpoint exceptions.

## D2.8.8 Preferred return address

The preferred return address of a Breakpoint exception is the address of the instruction that was not executed because the PE took the Breakpoint exception instead.

This means that the preferred return address is the address of the instruction that caused the exception.

## D2.8.9 Pseudocode description of Breakpoint exceptions taken from an AArch64 stage 1 translation regime

AArch64.BreakpointValueMatch() tests the value in DBGBVR&lt;n&gt;\_EL1.

AArch64.StateMatch () tests the values in DBGBCR&lt;n&gt;\_EL1.{SSCE, SSC, HMC, PMC} and, if the breakpoint links to a breakpoint with linking enabled, also tests the Context matching breakpoint.

AArch64.BreakpointMatch() tests a committed instruction against all breakpoints.

AArch64.CheckBreakpoint() generates a Breakpoint exception if all of the following are true:

- MDSCR\_EL1.MDE is 1.
- Debug exceptions are enabled from the current Exception level and Security state. See Enabling debug exceptions from the current Exception level and Security state.
- All of the conditions required for Breakpoint exception generation are met. See About Breakpoint exceptions.

Note

AArch64.CheckBreakpoint() might halt the PE and cause it to enter Debug state. External debug uses Debug state.

AArch64.BreakpointException() is called to generate a Breakpoint exception.

These functions are defined in A-profile Architecture Pseudocode.