## D12.2 The AArch64 view of the Generic Timer

The following sections describe the components and features of a PE implementation of the Generic Timer, as seen from AArch64 state:

- The physical counter.
- The virtual counter.
- Event streams.
- Timers.

## D12.2.1 The physical counter

The PE includes a physical counter that contains the count value of the system counter. The CNTPCT\_EL0 register holds the current physical counter value. This is defined as the pseudocode function PhysicalCountInt ().Reads of CNTPCT\_EL0 register at EL2 or EL3 return the current value of PhysicalCountInt ().

When FEAT\_ECV is implemented, the CNTPOFF\_EL2 register holds the optional physical offset that can be applied at EL0 and EL1 whether EL0 and EL1 are using AArch64 state or AArch32 state.

For more information, see The physical offset register.

Reads of CNTPCT\_EL0 can occur speculatively and out of order relative to other instructions executed on the same PE.

## D12.2.1.1 The self-synchronized view of the physical counter

When FEAT\_ECV is implemented, an alternative way to read the physical counter is supported. The CNTPCTSS\_EL0 register is a non-speculative view of the physical counter, as seen from the Exception level that CNTPCTSS\_EL0 is read from.

Accesses to the CNTPCTSS\_EL0 are subject to the same traps as accesses to the CNTPCT\_EL0.

Reads of CNTPCT\_EL0 occur in program order relative to reads of CNTPCT\_EL0 or CNTPCTSS\_EL0.

Reads of CNTPCTSS\_EL0 occur in program order relative to reads of CNTPCT\_EL0 or CNTPCTSS\_EL0.

Example D12-1 Ensuring reads of the physical counter occur after signal read from memory

If a read from memory is used to obtain a signal from another agent that indicates that CNTPCT\_EL0 must be read, an ISB is used to ensure that the read of CNTPCT\_EL0 occurs after the signal has been read from memory, as shown in the following code sequence:

```
loop ; polling for some communication to indicate a requirement to ; read the timer LDR X1, [X2] CMP X1, #1 ; has had the value 1 written to it B.NE loop ISB ; without this the CNTPCT_EL0 could be read before the memory ; location in [X2] MRS X1, CNTPCT_EL0
```

When FEAT\_ECV is implemented, an access to CNTPCTSS\_EL0 can be used in place of the CNTPCT\_EL0 which, because it cannot be accessed speculatively, allows the ISB to be removed. This means that the following code sequence can be used:

```
loop ; polling for some communication to indicate a requirement to ; read the timer LDR X1, [X2] CMP X1, #1 ; has had the value 1 written to it B.NE loop MRS X1, CNTPCTSS_EL0
```

Similarly where a read of the physical counter is required to take place after the completion of all loads and stores appearing in program order before the read of the counter, then the following code sequences can be used:

```
... ; earlier loads and stores DSB ; completes the earlier loads and stores ISB ; without this the CNTPCT_EL0 could be read before the completion ; of the earlier loads and stores MRS X1, CNTPCT_EL0
```

## Or, if FEAT\_ECV is implemented:

```
... ; earlier loads and stores DSB ; completes earlier loads and stores MRS X1, CNTPCTSS_EL0
```

Neither view of the physical counter ensures that:

- Context changes occurring in program order before the read of the counter have been synchronized.
- Accesses to memory appearing in program order after the read of the counter are executed before the counter has been read.

Where there is a Dependency through registers dependency from the read of the physical counter to a Register effect generated by a read or write, the read or write will be executed after the read of the counter.

Example D12-2 Ensuring reads of the physical counter occur after previous memory accesses

To ensure that all previous memory accesses have completed and all previous context changes have been synchronized before the read of the counter, one of the following sequences should be used:

## either:

```
DSB ISB MRS Xn, CNTPCT{SS}_EL0 ; either view of the physical counter has the same effect in ; this example
```

or

```
DMB LDR Xa, [Xd] ; this could be any memory location, for example the stack pointer CBZ Xa, next next ISB ; this ISB is not needed if the MRS is accessing CNTPCTSS_EL0 MRS Xn, CNTPCT{SS}_EL0
```

To ensure that a memory access occurs only after a read of the counter, then either of the following sequences should be used:

```
MRS Xn, CNTPCT{SS}_EL0 ; either view of the physical counter has the same effect in ; this example ISB LDR Xa, [Xb] ; this load will be executed after the timer has been read or MRS Xn, CNTPCT{SS}_EL0 ; either view of the physical counter has the same effect in ; this example EOR Xm, Xn, Xn LDR Xa, [Xb, Xm] ; this load will be executed after the timer has been read
```

## D12.2.1.2 The physical offset register

When FEAT\_ECV\_POFF is implemented, the CNTPOFF\_EL2 register allows an offset to be applied to the physical counter, as viewed from EL1 and EL0, and to the EL1 physical timer. The functionality of this 64-bit register is affected by CNTHCTL\_EL2.ECV.

When CNTHCTL\_EL2.ECV is 1, an MRS to CNTPCT\_EL0 or CNTPCTSS\_EL0 from either EL0 or EL1 that is not trapped returns the value (PhysicalCountInt() -CNTPOFF\_EL2) . For information on how the EL1 physical timer interrupt is triggered when CNTHCTL\_EL2.ECV is 1, see Operation of the CompareValue views of the timers.

When EL2 is not enabled for the current Security state, or when CNTHCTL\_EL2.ECV is 0, then:

- An MRS to CNTPCT\_EL0 from either EL0 or EL1 that is not trapped will return the value PhysicalCountInt ().
- The physical offset is treated as zero for all timer and counter calculations involving the physical offset.

When EL2 is not enabled for the current Security state, or when CNTHCTL\_EL2.ECV is 0, then the behavior of the counters and timers is as described for Armv8.5 and the optional physical offset is not used.

When SCR\_EL3.ECVEn is 0, the value of CNTPOFF\_EL2 is treated as 0 for all purposes other than direct reads or writes to CNTPOFF\_EL2 from EL3.

## D12.2.2 The virtual counter

An implementation of the Generic Timer always includes a virtual counter, which indicates virtual time.

The virtual counter contains the value of the physical counter minus a 64-bit virtual offset. When executing at EL1 or EL0, the virtual offset value relates to the current virtual machine.

The CNTVOFF\_EL2 register contains the virtual offset, see The virtual offset register.

The CNTVCT\_EL0 register holds the current virtual counter value.

Reads of CNTVCT\_EL0 can occur speculatively and out of order relative to other instructions executed on the same PE.

## D12.2.2.1 The self-synchronized view of the virtual counter

When FEAT\_ECV is implemented, an alternative way to read the virtual counter is supported. The CNTVCTSS\_EL0 register is a non-speculative view of the virtual counter, as seen from the Exception level that CNTVCTSS\_EL0 is read from.

Accesses to the CNTVCTSS\_EL0 are subject to the same traps as accesses to the CNTVCT\_EL0.

Reads of CNTVCT\_EL0 occur in program order relative to reads of CNTVCT\_EL0 or CNTVCTSS\_EL0.

Reads of CNTVCTSS\_EL0 occur in program order relative to reads of CNTVCT\_EL0 or CNTVCTSS\_EL0.

## Example D12-3 Ensuring reads of the virtual counter occur after signal read from memory

If a read from memory is used to obtain a signal from another agent that indicates that CNTVCT\_EL0 must be read, an ISB is used to ensure that the read of CNTVCT\_EL0 occurs after the signal has been read from memory, as shown in the following code sequence:

```
loop ; polling for some communication to indicate a requirement to ; read the timer LDR X1, [X2] CMP X1, #1 ; has had the value 1 written to it B.NE loop ISB ; without this the CNTVCT_EL0 could be read before the memory ; location in [X2] MRS X1, CNTVCT_EL0
```

When FEAT\_ECV is implemented, an access to CNTVCTSS\_EL0 can be used in place of the CNTVCT\_EL0, which, because it cannot be accessed speculatively, allows the ISB to be removed. This means that the following code sequence can be used:

```
loop ; polling for some communication to indicate a requirement to ; read the timer LDR X1, [X2] CMP X1, #1 ; has had the value 1 written to it B.NE loop MRS X1, CNTVCTSS_EL0
```

Similarly where a read of the virtual counter is required to take place after the completion of all loads and stores appearing in program order before the read of the counter, then the following two sequences can be used:

```
... ; earlier loads and stores DSB ; completes earlier loads and stores ISB ; without this CNTPCT_EL0 could be read before the completion ; of the earlier loads and stores MRS X1, CNTVCT_EL0
```

## Or, if FEAT\_ECV is implemented:

```
... ; earlier loads and stores DSB ; completes earlier loads and stores MRS X1, CNTVCTSS_EL0
```

Neither view of the virtual counter ensures that:

- Context changes occurring in program order before the read of the counter have been synchronized.
- Accesses to memory appearing in program order after the read of the counter are executed before the counter has been read.

Where there is a Dependency through registers dependency from the read of the virtual counter to a Register effect generated by a read or write, the read or write will be executed after the read of the counter.

## Example D12-4 Ensuring reads of the virtual counter occur after previous memory accesses

To ensure that all previous memory accesses have completed and all previous context changes have been synchronized before the read of the counter, one of the following sequences should be used:

## either:

```
DSB ISB MRS Xn, CNTVCT{SS}_EL0 ; either view of the virtual counter has the same effect in ; this example
```

## or

```
DMB LDR Xa, [Xd] ; this could be any memory location, for example the stack pointer CBZ Xa, next next ISB ; this ISB is not needed if the MRS is accessing CNTVCT{SS}_EL0 MRS Xn, CNTVCT{SS}_EL0
```

To ensure that a memory access occurs only after a read of the counter, then either of the following sequences should be used:

```
MRS Xn, CNTVCT{SS}_EL0 ; either view of the virtual counter has the same effect in ; this example ISB LDR Xa, [Xb] ; this load will be executed after the timer has been read
```

```
or
```

```
MRS Xn, CNTVCT{SS}_EL0 ; either view of the virtual counter has the same effect in ; this example EOR Xm, Xn, Xn LDR Xa, [Xb, Xm] ; this load will be executed after the timer has been read
```

## D12.2.2.2 The virtual offset register

The virtual counter is a counter that has a virtual offset relative to the physical counter as viewed from EL2 and EL3. This virtual offset is held in the register CNTVOFF\_EL2. The virtual counter value is the count compared by the EL1 virtual timer.

If EL2 is not implemented, then the virtual counter uses a fixed offset of zero.

## D12.2.3 Event streams

An implementation that includes the Generic Timer can use the system counter to generate one or more event streams , to generate periodic wakeup events as part of the mechanism described in Wait for Event.

## D12.2.4 Timers

Note

An event stream might be used:

- To impose a time-out on a Wait For Event polling loop.
- To safeguard against any programming error that means an expected event is not generated.

The CNTKCTL\_EL1.{EVNTEN, EVNTDIR, EVNTI, EVNTIS} fields define an event stream that is generated from the virtual counter.

In all implementations, the CNTHCTL\_EL2.{EVNTEN, EVNTDIR, EVNTI, EVNTIS} fields define an event stream that is generated from the physical counter.

The event stream is configured as follows:

- EVNTI selects the counter bit that triggers the event.
- If FEAT\_ECV is not implemented, EVNTI selects between bits[0:15].
- If FEAT\_ECV is implemented, EVNTIS selects whether ENVTI selects between bits[0:15] or bits[8:23].
- EVNTDIR selects whether the event is generated on each 0 to 1 transition, or each 1 to 0 transition, of the selected counter bit.

Note

If the event stream is configured to produce events from the low order bits of the counter when the effective frequency is very high (for example 1GHz), then the practical update rate of the counter might mean that the event stream is not generated as the low order bit might not change. Software can rely on an event stream rate of at least 1MHz in normal operation.

The pseudocode descriptions of the operation of an event stream are SetEventRegister , TestEventCNTV , and TestEventCNTP .

In an implementation of the Generic Timer that includes EL3, if EL3 can use AArch64, the following timers are implemented:

- An EL1 physical timer, which:
- -In Non-secure state, can be accessed from EL1 unless those accesses are trapped to EL2.
- -In Secure state, can be accessed from EL1.
- -In Realm state, can be accessed from EL1 unless those accesses are trapped to EL2.

When this timer can be accessed from EL1, an EL1 control determines whether it can be accessed from EL0.

- ANon-secure EL2 physical timer.
- An EL3 physical timer. SCR\_EL3.{ST, EEL2} determines whether this register is accessible from Secure EL1.
- An EL1 virtual timer.
- When FEAT\_VHE is implemented, a Non-secure EL2 virtual timer.
- When FEAT\_SEL2 is implemented, a Secure EL2 physical timer.
- When FEAT\_SEL2 is implemented, a Secure EL2 virtual timer.

The output of each implemented timer:

- Provides an output signal to the system.
- If the PE interfaces to a Generic Interrupt Controller (GIC), signals a Private Peripheral Interrupt (PPI) to that GIC. In a multiprocessor implementation, each PE must use the same interrupt number for each timer.

Each timer:

- Is based around a 64-bit CompareValue that provides a 64-bit unsigned upcounter.

- Provides an alternative view of the CompareValue, called the TimerValue, that appears to operate as a 32-bit downcounter.
- Has, in addition, a 32-bit Control register.

Table D12-1 Physical timer registers summary for the Generic Timer

| Timer a register   | EL1 physical timer   | EL2 physical timer   | Secure EL2 physical timer b   | EL3 physical timer   |
|--------------------|----------------------|----------------------|-------------------------------|----------------------|
| CV                 | CNTP_CVAL_EL0        | CNTHP_CVAL_EL2       | CNTHPS_CVAL_EL2               | CNTPS_CVAL_EL1       |
| TV                 | CNTP_TVAL_EL0        | CNTHP_TVAL_EL2       | CNTHPS_TVAL_EL2               | CNTPS_TVAL_EL1       |
| Control            | CNTP_CTL_EL0         | CNTHP_CTL_EL2        | CNTHPS_CTL_EL2                | CNTPS_CTL_EL1        |

## Table D12-2 Virtual timer register summary for the Generic Timer

| Timer a register   | EL1 virtual timer   | EL2 virtual timer b   | Secure EL2 virtual timer c   |
|--------------------|---------------------|-----------------------|------------------------------|
| CV                 | CNTV_CVAL_EL0       | CNTHV_CVAL_EL2        | CNTHVS_CVAL_EL2              |
| TV                 | CNTV_TVAL_EL0       | CNTHV_TVAL_EL2        | CNTHVS_TVAL_EL2              |
| Control            | CNTV_CTL_EL0        | CNTHV_CTL_EL2         | CNTHVS_CTL_EL2               |

- c. Present only when the implementation includes FEAT\_SEL2.

## D12.2.4.1 Operation of the CompareValue views of the timers

The CompareValue view of a timer operates as a 64-bit upcounter. The timer condition is met when the appropriate counter reaches the value programmed into its CompareValue register.

When the timer condition is met, an interrupt is generated if the interrupt is not masked in the corresponding timer control register, CNTP\_CTL\_EL0, CNTHP\_CTL\_EL2, CNTHPS\_CTL\_EL2, CNTPS\_CTL\_EL1, CNTV\_CTL\_EL0, CNTHV\_CTL\_EL2 or CNTHVS\_CTL\_EL2. For CNTP\_CTL\_EL0, the asserted interrupt is the same as the interrupt asserted by the Non-secure instance of the AArch32 register CNTP\_CTL.

The operation of this view of a timer is:

```
TimerConditionMet = (((PhysicalCountInt() Offset)[63:0] CompareValue[63:0]) >= 0)
```

## Where:

TimerConditionMet Is TRUE if the timer condition for this counter is met, and FALSE otherwise.

PhysicalCountInt() The physical counter value, which can be read from the CNTPCT\_EL0 register when read from EL2 or EL3.

Offset

For the EL1 physical timer, the offset value is the value held in the CNTPOFF\_EL2 register when all of the following are true:

- SCR\_EL3.{NS, EEL2} is not {0, 0}.
- SCR\_EL3.ECVEn is 1,

CompareValue

- CNTHCTL\_EL2.ECV is 1.
- The Effective value of HCR\_EL2.{E2H, TGE} is not {1, 1}.

Otherwise the offset value of the EL1 physical timer is zero.

For the EL1 virtual timer, the offset value is held in the CNTVOFF\_EL2 register.

For the EL3 timer, the EL2 Secure physical timer, the EL2 Non-secure physical timer, the EL2 Secure virtual timer, and the EL2 Non-secure virtual timer the offset value is zero.

The value of the appropriate CompareValue register, CNTP\_CVAL\_EL0, CNTHP\_CVAL\_EL2, CNTPS\_CVAL\_EL1, CNTHPS\_CVAL\_EL2, CNTV\_CVAL\_EL0, CNTHV\_CVAL\_EL2, or CNTHVS\_CVAL\_EL2.

In this view of a timer, PhysicalCountInt (), Offset , and CompareValue are all 64-bit unsigned values.

Note

This means that a timer with a CompareValue of, or close to, 0xFFFF\_FFFF\_FFFF\_FFFF might never meet its timer condition. However, there is no practical requirement to use values close to the counter wrap value. Software can observe the counter value by the offset in some situations by reading CNTVCT\_EL0.

## D12.2.4.2 Operation of the TimerValue views of the timers

The TimerValue view of a timer appears to operate as a signed 32-bit downcounter. A TimerValue register is programmed with a count value. This value decrements on each increment of the appropriate counter, and the timer condition is met when the value reaches zero. When the timer condition is met, an interrupt is generated if the interrupt is not masked in the corresponding timer control register, CNTP\_CTL\_EL0, CNTHP\_CTL\_EL2, CNTHPS\_CTL\_EL2, CNTPS\_CTL\_EL1, CNTV\_CTL\_EL0, CNTHV\_CTL\_EL2, or CNTHVS\_CTL\_EL2.

This view of a timer depends on the following behavior of accesses to TimerValue registers:

```
Reads TimerValue = (CompareValue[63:0] - (PhysicalCountInt()[63:0] Offset[63:0]))[31:0] Writes CompareValue = ((PhysicalCountInt()[63:0] Offset[63:0])[63:0] + ↪ → SignExtend(TimerValue[31:0]))[63:0]
```

Where the arguments other than TimerValue have the definitions used in Operation of the CompareValue views of the timers, and in addition:

TimerValue

The value of a TimerValue register, CNTP\_TVAL\_EL0, CNTHP\_TVAL\_EL2, CNTHPS\_TVAL\_EL2, CNTPS\_TVAL\_EL1, CNTV\_TVAL\_EL0, CNTHV\_TVAL\_EL2, or CNTHVS\_TVAL\_EL2.

In this view of a timer, values are signed in standard two's complement form.

Aread of a TimerValue register after the timer condition has been met indicates the time since the timer condition was met.

Note

- Operation of the CompareValue views of the timers gives a strict definition of TimerConditionMet . However, provided that the TimerValue is not expected to wrap as a 32-bit signed value when decremented from 0x8000\_0000 , the TimerValue view can be used as giving an effect equivalent to:
- Programming TimerValue to a negative number with magnitude greater than (Counter - Offset) can lead to an arithmetic overflow that causes the CompareValue to be a large positive value. This potentially delays meeting the timer condition for a long period of time.

```
TimerConditionMet = (TimerValue ≤ 0)
```

## Chapter D13 The Performance Monitors Extension

This chapter describes the implementation of the Arm Performance Monitors, which are an optional non-invasive debug component. It describes version 3 of the Performance Monitor Unit (PMU) architecture, FEAT\_PMUv3. It contains the following sections:

- About the Performance Monitors.
- Accuracy of the Performance Monitors.
- Behavior on overflow.
- Attributability.
- Controlling the PMU counters.
- Multithreaded implementations.
- Event filtering.
- Event threshold and edge counting.
- PMUsnapshots.
- Performance Monitors and Debug state.
- Counter access.
- Performance Monitors Extension registers.

Note

Table K14-2 disambiguates the general register references used in this chapter.