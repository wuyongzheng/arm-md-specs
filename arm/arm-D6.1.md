## D6.1 About the Trace Buffer Extension

IMRFPK

IFGGXR

IFGPMM

ISTZGC

The Trace Buffer Extension feature is identified as FEAT\_TRBE.

When FEAT\_TRBE is implemented, the PE includes a Trace Buffer Unit. There is one logical Trace Buffer Unit for each PE in the processor.

When the Trace Buffer Unit is enabled, Program Flow Trace generated by the trace unit is written directly to memory by the Trace Buffer Unit, rather than routing it to a trace fabric. Figure D6-1 shows this.

Figure D6-1 Logical organization of an Armv9-A PE including a trace unit and a Trace Buffer Unit

<!-- image -->

In this figure:

- EIS is an internal representation of the executed instruction stream.
- The trace unit converts the EIS into formatted trace data.
- Sink is described by the section Trace Buffer Unit disabled.

To allow use by self-hosted software in a platform OS environment, a Trace Buffer Unit or ETR must support a trace buffer that is mapped to a set of non-contiguous physical blocks in memory. The Trace Buffer Unit achieves this by using the PE VMSA-based MMU.

This means that all of the following apply:

- The trace buffer is normally virtually addressed.
- The trace buffer has an owning Exception level and owning Security state that define the translation regime the trace buffer uses.
- FEAT\_TRBE provides a synchronization instruction, TSB CSYNC , that is used with a DSB operation to flush trace to the trace buffer.
- For FEAT\_TRBE, trace is implicitly prohibited when the owning translation regime is not in context. That is, trace is prohibited if executing at a higher Exception level than the owning Exception level, or not executing in the owning Security state. This is in addition to the behavior in FEAT\_ETE and FEAT\_TRF for when trace is prohibited.

FEAT\_TRBE also allows the trace buffer to be defined using physical addresses. This allows the Trace Buffer Unit to be used for debugging software that changes the virtual address mappings. In this configuration, the buffer must be contiguously mapped in physical memory.

The Trace Buffer Unit supports the following operational modes:

Trace buffer mode

Controls how the Trace Buffer Unit uses the trace buffer.

RPLYXP

IPTDZC

## Trigger mode

Controls how the Trace Buffer Unit reacts to a trigger condition signaled by the trace unit.

Other than where stated otherwise, this chapter describes a simple sequential model of the Trace Buffer Unit. That is, one which performs the simple loop of:

1. Collect a single byte of trace data from the trace unit.
2. If required, translate the current write pointer virtual address to a physical address.
3. If permitted, write the byte of trace data to the write address.
4. If collection is not stopped, increment the current write pointer .
5. If necessary, decrement the Trigger Counter .

Trace buffer management events are processed as part of this operation loop.

Implementations compliant with the architecture conform with the described behavior of the Trace Buffer Unit. Except where the architecture specifies differently, the programmer-visible behavior of an implementation that is compliant with this specification is the same as a simple sequential model. Trace appears to be written sequentially by the Trace Buffer Unit.

If FEAT\_TRBE\_EXT is implemented, then the Trace Buffer Unit can be controlled externally from the PE instead of by self-hosted software. The following are possible methods of external Trace Buffer Unit control:

- An external trace debugger that programs the Trace Buffer Unit through an external debug interface.
- An external trace debugger executing on the same SoC as the PE being traced where trace is controlled through the memory-mapped external debug interface.

For more information, see Trace buffer External mode.

## D6.1.1 The trace buffer pointers

RWKBRT

The trace buffer is defined by three trace buffer pointer addresses:

- The Base pointer .
- The Limit pointer .
- The current write pointer .

RFVPBS The trace buffer starts at the Base pointer and extends to the Limit pointer. The location at the Base pointer is included in the trace buffer. The location at the Limit pointer is not included in the trace buffer.

RXBLPK The Base pointer and Limit pointer must be aligned by software to the smallest implemented translation granule size.

RVHNTF For each byte of trace that the Trace Buffer Unit accepts and writes to the trace buffer at the address in the current write pointer, one of the following applies:

- If the current write pointer is not equal to the Limit pointer minus one, then the current write pointer is incremented by one.
- If the current write pointer is equal to the Limit pointer minus one, then all of the following occur:
- -The current write pointer is wrapped by setting it to the Base pointer.
- -Atrace buffer management event might be generated. See Trace buffer management.
- -TRBSR\_ELx.WRAP is set to 1, where ELx is the value in the Other event column of Table D6-7. The other fields in TRBSR\_ELx and the other TRBSR\_ELx registers are unchanged if no trace buffer management event is generated.
- -The TRB\_WRAP event is generated.

| R BGBCJ   | The current write pointer is not incremented when collection is stopped.                                                           |
|-----------|------------------------------------------------------------------------------------------------------------------------------------|
| R VMVJH   | The required alignment of the current write pointer is IMPLEMENTATION DEFINED.                                                     |
| I BTSCF   | The Trace Buffer Unit can write trace data to memory in quantized units. The behavior is as if the bytes are written sequentially. |
| R JMPCB   | The Base pointer is (TRBBASER_EL1.BASE << 12). Bits [11:0] of the Base pointer are zero.                                           |

RLLBBS

The Limit pointer is (TRBLIMITR\_EL1.LIMIT &lt;&lt; 12). Bits [11:0] of the Limit pointer are zero.

RKXRTY

The current write pointer is TRBPTR\_EL1.PTR[63:0].

RPBGNS

The Trigger Counter is TRBTRG\_EL1.TRG.

## D6.1.2 System events

IXDSQV

The trace unit can be configured to react to PE events and events from the CTI. The CTI is for use by external debuggers. As part of FEAT\_TRBE and FEAT\_ETE, the PMU and FEAT\_ETE event sources are unified into a single event number space. Unless otherwise stated, all architecturally defined common events that can be counted by the PMU are usable as an event at the trace unit.

The following architecturally-defined events are provided:

- The CTI\_TRIGOUT&lt;n&gt; events, such as CTI\_TRIGOUT4, are defined to map the system events from the CTI into the PMU event number space. As well as defining these events for the trace unit, this also provides a standard mechanism for counting external events passed to the PE .
- The TRCEXTOUT&lt;n&gt; events, such as TRCEXTOUT0, are defined to allow the PMU to count the events that a FEAT\_ETE implementation of the trace unit might generate.
- The PMU\_OVFS and PMU\_HOVFS events are defined to allow the trace unit to trigger directly from a PMU overflow without using the Performance Monitors overflow trigger for PMU counters accessible to EL1 and EL0, and EL2, respectively.
- The TRB\_WRAP event is defined to allow the trace unit to trigger when the current write pointer reaches the end of the trace buffer and is wrapped.