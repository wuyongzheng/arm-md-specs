## G1.19 Mechanisms for entering a low-power state

The following sections describe the architectural mechanisms that a PE can use to request entry to a low-power state:

- Wait For Event and Send Event.
- Wait For Interrupt.

## G1.19.1 Wait For Event and Send Event

The Wait For Event (WFE) mechanism permits a PE to request entry to a low-power state, and, if the request succeeds, to remain in that state until an event is generated by a Send Event operation, or another WFE wakeup event occurs. Example G1-2 describes how a spinlock implementation might use this mechanism to save energy.

## Example G1-2 Spinlock as an example of using Wait For Event and Send Event

A multiprocessor operating system requires locking mechanisms to protect data structures from being accessed simultaneously by multiple PEs. These mechanisms prevent the data structures becoming inconsistent or corrupted if different PEs try to make conflicting changes. If a lock is busy, because a data structure is being used by one PE, it might not be practical for another PE to do anything except wait for the lock to be released. For example, if a PE is handling an interrupt from a device it might need to add data received from the device to a queue. If another PE is removing data from the queue, it will have locked the memory area that holds the queue. The first PE cannot add the new data until the queue is in a consistent state and the lock has been released. It cannot return from the interrupt handler until the data has been added to the queue, so it must wait.

Typically, a spin-lock mechanism is used in these circumstances:

- A PE requiring access to the protected data attempts to obtain the lock using single-copy atomic synchronization primitives such as the Load-Exclusive and Store-Exclusive operations described in Synchronization and semaphores.
- If the PE obtains the lock, it performs its memory operation and releases the lock.
- If the PE cannot obtain the lock, it reads the lock value repeatedly in a tight loop until the lock becomes available. At this point, it again attempts to obtain the lock.

Aspin-lock mechanism is not ideal for all situations:

- In a low-power system, the tight read loop is undesirable because it uses energy to no effect.
- In a multithreaded implementation, the execution of spin-locks by waiting threads can significantly degrade overall performance.

Using the Wait For Event and Send Event mechanism can improve the energy efficiency of a spinlock. In this situation, a PE that fails to obtain a lock can execute a Wait For Event instruction, WFE , to request entry to a low-power state. When a PE releases a lock, it must execute a Send Event instruction, SEV , causing any waiting PEs to wake up. Then, these PEs can attempt to gain the lock again.

The execution of a WFE instruction can cause suspension of execution only if all of the following are true:

- The instruction does not cause any other exception.
- When the instruction is executed:
- -The Event Register is not set.
- -There is not a pending WFE wakeup event.

For more information about the trap to EL2, see HCR.{WFI, WFE}.

The architecture does not define the exact nature of the low power state entered as a result of executing a WFE instruction, but the execution of a WFE instruction must not cause a loss of memory coherency or architectural state.

Note

Although a complex operating system can contain thousands of distinct locks, the event sent by this mechanism does not indicate which lock has been released. If the event relates to a different lock, or if another PE acquires the lock more quickly, the PE fails to acquire the lock and can reenter the low-power state waiting for the next event.

The Wait For Event system relies on hardware and software working together to achieve energy saving:

- The hardware provides the mechanism to enter the Wait For Event low-power state.
- The operating system software is responsible for issuing:
- -AWait For Event instruction, to request entry to the low-power state, used in the example when waiting for a spin-lock.
- -ASend Event instruction, required in the example when releasing a spin-lock.

The mechanism depends on the interaction of:

- WFEwakeup events, see WFE wakeup events.
- The Event Register, see The Event Register.
- The Send Event instructions, see The Send Event instructions.
- The Wait For Event instruction, see The Wait For Event instruction.

## G1.19.1.1 The Event Register

The Event Register is a single bit register for each PE. When set, an event register indicates that an event has occurred, since the register was last cleared, that might require some action by the PE. Therefore, the PE must not suspend operation on issuing a WFE instruction.

The reset value of the Event Register is UNKNOWN.

The Event Register for a PE is set by:

- The execution of an SEV instruction on any PE in the multiprocessor system.
- The execution of an SEVL instruction by the PE.
- An exception return.
- An event from a Generic Timer event stream, see Event streams.
- An event sent by some IMPLEMENTATION DEFINED mechanism.

As shown in this list, the Event Register might be set by IMPLEMENTATION DEFINED mechanisms.

The Event Register is cleared only by a Wait For Event instruction.

Software cannot read or write the value of the Event Register directly.

## G1.19.1.2 The Wait For Event instruction

The action of the Wait For Event instruction depends on the state of the Event Register:

- If the Event Register is 1, the instruction clears the register and completes immediately. Normally, if this happens the software makes another attempt to claim the lock.
- If the Event Register is 0, the PE can suspend execution, and hardware might enter a low-power state. The PE can remain suspended until a WFE wakeup event or a reset occurs. When a WFE wakeup event occurs, or earlier if the implementation chooses, the WFE instruction completes.

The execution in AArch32 state of a WFE instruction that would otherwise cause suspension of execution might be trapped, see:

- SCTLR.{nTWE, nTWI}.
- HCR.{TWE, TWI}.
- SCR.{TWE, TWI}.

The Wait For Event instruction, WFE , is available at all privilege levels, see WFE.

Software using the Wait For Event mechanism must tolerate spurious wakeup events, including multiple wake ups.

## G1.19.1.3 WFE wakeup events

The following events are WFEwakeup events :

- The execution of an SEV instruction on any PE in the system.
- The execution of an SEVL instruction on the PE.
- Aphysical IRQ interrupt, unless masked by the PSTATE.I bit.
- Aphysical FIQ interrupt, unless masked by the PSTATE.F bit.
- Aphysical SError exception, unless masked by the PSTATE.A bit.
- In Non-secure state in any mode other than Hyp mode:
- -When HCR.IMO is set to 1, a virtual IRQ interrupt, unless masked by the PSTATE.I bit.
- -When HCR.FMO is set to 1, a virtual FIQ interrupt, unless masked by the PSTATE.F bit.
- -When HCR.AMO is set to 1, a virtual SError exception, unless masked by the PSTATE.A bit.
- An asynchronous External Debug Request debug event, if halting is allowed. For the definition of halting is allowed , see Halting allowed and halting prohibited.

See also External Debug Request debug event.

- An event sent by the timer event stream, see Event streams.
- An event sent by some IMPLEMENTATION DEFINED mechanism.
- An event caused by the clearing of the global monitor associated with the PE.

In addition to the possible masking of WFE wakeup events shown in this list, when invasive debug is enabled and EDSCR.HDE is set to 1, EDSCR.INTdis can mask interrupts, including masking them acting as WFE wakeup events. See the register description for more information.

As shown in the list of wakeup events, an implementation can include IMPLEMENTATION DEFINED hardware mechanisms to generate wakeup events.

Note

For more information about PSTATE masking, see Asynchronous exception masking controls. If the configuration of the masking controls provided by EL2 and EL3 mean that a PSTATE mask bit cannot mask the corresponding exception, then the physical exception is a WFE wakeup event, regardless of the value of the PSTATE mask bit.

## G1.19.1.4 The Send Event instructions

The Send Event instructions are:

- SEV, Send Event This causes an event to be signaled to all PEs in the multiprocessor system.

## SEVL, Send Event Local

This must set the local Event Register. It might signal an event to other PEs, but is not required to do so.

The mechanism that signals an event to other PEs is IMPLEMENTATION DEFINED. The PE is not required to guarantee the ordering of this event with respect to the completion of memory accesses by instructions before the SEV instruction. Therefore, Arm recommends that software includes a DSB instruction before any SEV instruction.

Note

A DSB instruction ensures that no instruction, including any SEV instruction, that appears in program order after the DSB instruction, can execute until the DSB instruction has completed. For more information, see Data Synchronization Barrier.

The SEVL instruction appears to execute in program order relative to any subsequent WFE instruction executed on the same PE, without the need for any explicit insertion of barrier instructions.

Execution of the Send Event instruction sets the Event Register.

The Send Event instructions are available at all privilege levels.

## G1.19.1.5 Pseudocode description of the Wait For Event mechanism

This section defines pseudocode functions that describe the operation of the Wait For Event mechanism.

The ClearEventRegister() pseudocode procedure clears the Event Register of the current PE.

The IsEventRegisterSet() pseudocode function returns TRUE if the Event Register of the current PE is 1 and FALSE if it is 0.

The WaitForEvent() pseudocode procedure optionally suspends execution until a WFE wakeup event or reset occurs, or until some earlier time if the implementation chooses. It is IMPLEMENTATION DEFINED whether restarting execution after the period of suspension causes a ClearEventRegister() to occur.

The SendEvent() pseudocode procedure sets the Event Register of every PE in the system.

## G1.19.2 Wait For Interrupt

AArch32 state supports Wait For Interrupt through an instruction, WFI , which is provided in the T32 and A32 instruction sets. For more information, see WFI.

When a PE issues a WFI instruction, its execution can be suspended, and a low-power state can be entered.

The execution in AArch32 state of a WFI instruction that would otherwise cause suspension of execution might be trapped, see:

- SCTLR.nTWI.
- HCR.WFI.
- SCR.WFI.

The execution of a WFI instruction can cause suspension of execution only if both:

- The instruction does not cause any other exception.
- When the instruction is executed, there is not a pending WFI wakeup event.

## G1.19.2.1 WFI wakeup events

The PE can remain suspended in its WFI state until it is reset, or one of the following WFI wakeup events occurs:

- Aphysical IRQ interrupt, regardless of the value of the PSTATE.I bit.
- Aphysical FIQ interrupt, regardless of the value of the PSTATE.F bit.
- Aphysical SError exception, regardless of the value of the PSTATE.A bit.
- In Non-secure state in any mode other than Hyp mode:
- -When HCR.IMO is set to 1, a virtual IRQ interrupt, regardless of the value of the PSTATE.I bit.
- -When HCR.FMO is set to 1, a virtual FIQ interrupt, regardless of the value of the PSTATE.F bit.
- -When HCR.AMO is set to 1, a virtual SError exception, regardless of the value of the PSTATE.A bit.
- An asynchronous External Debug Request debug event, if halting is allowed. For the definition of halting is allowed , see Halting allowed and halting prohibited. See also External Debug Request debug event.

An implementation can include other IMPLEMENTATION DEFINED hardware mechanisms to generate WFI wakeup events.

When a WFI wakeup event is detected, or earlier if the implementation chooses, the WFI instruction completes.

WFI wakeup events cannot be masked by the mask bits in the PSTATE.

The architecture does not define the exact nature of the low power state, except that:

- The execution of a WFI instruction must not cause a loss of memory coherency.
- If the system is configured such that the WFI instruction can be completed, then the WFI instruction must not cause a loss of architectural state.

Note

In some implementations, based on the configuration of system specific registers, WFI can be used as part of a powerdown sequence where no interrupts will cause WFI wakeup events, and restoration of power involves resetting of the PE. In those cases, the WFI is permitted to cause a loss of architectural state, as it is assumed that this state will have been saved by software as part of the powerdown sequence before the WFI.

Note

- Because debug events are WFI wakeup events, Arm strongly recommends that Wait For Interrupt is used as part of an idle loop rather than waiting for a single specific interrupt event to occur and then moving forward. This ensures the intervention of debug while waiting does not significantly change the function of the program being debugged.
- In some previous implementations of Wait For Interrupt, the idle loop is followed by exit functions that must be executed before taking the interrupt. The operation of Wait For Interrupt remains consistent with this model, and therefore differs from the operation of Wait For Event.
- Some implementations of Wait For Interrupt drain down any pending memory activity before suspending execution. The Arm architecture does not require this operation, and software must not rely on Wait For Interrupt operating in this way.

## G1.19.2.2 Using WFI to indicate an idle state on bus interfaces

Acommon implementation practice is to complete any entry into powerdown routines with a WFI instruction. Typically, the WFI instruction:

1. Forces the completion of execution of any instructions that are in progress, and of all associated bus activity.
2. Suspends the execution of instructions by the PE.

The control logic required to do this tracks the activity of the bus interfaces used by the PE. This means it can signal to an external power controller when there is no ongoing bus activity.

However, memory-mapped and external debug interface accesses to debug registers must continue to be processed while the PE is in the WFI state. The indication of idle state to the system normally only applies to the non-debug functional interfaces used by the PE, not the debug interfaces.

If FEAT\_DoubleLock is implemented and the value of DBGOSDLR.DLK, the OS Double Lock status bit, is set to 1, this idle state must not be signaled to the PE unless the system can guarantee, also, that the debug interface is idle.

Note

When separate Core and Debug power domains are implemented, the debug interface referred to in this section is the interface between the Core and Debug power domains, since the signal to the power controller indicates that the Core power domain is idle. For more information about the power domains, see Power domains and debug.

The exact nature of this interface is IMPLEMENTATION DEFINED, but the use of Wait For Interrupt as the only architecturally-defined mechanism that completely suspends execution makes it very suitable as the preferred powerdown entry mechanism.

## G1.19.2.3 Pseudocode description of Wait For Interrupt

The WaitForInterrupt () pseudocode function optionally suspends execution until a WFI wakeup event or reset occurs, or until some earlier time if the implementation chooses.