## D1.4 Exceptions

## D1.4.1 Exception entry terminology

## D1.4.1.1 Taken, taken from, and taken to

RVDFHD When the PE responds to an exception, an exception is taken .

RFXGFX The PE state immediately before taking the exception is the state the exception is taken from .

RWTMVN The PE state immediately after taking the exception is the state the exception is taken to .

## D1.4.1.2 Exception generating instructions

RQPPFN Exception generating instructions intentionally produce a precise exception in the instruction stream immediately after the exception generating instruction. They are:

- HVC .
- SMC .
- SVC .

## D1.4.1.3 Synchronous and asynchronous exceptions

RFQHGR If all of the following apply, an exception is synchronous :

- The exception is generated as a result of direct execution or attempted execution of an instruction.
- The preferred exception return address has an architecturally defined relationship with the instruction that caused the exception.
- The exception is precise.

RPCXDH An exception is asynchronous if it is not synchronous.

RJPZPR Asynchronous exceptions taken to AArch64 state are also known as interrupts.

## D1.4.1.4 Definition of a precise exception and imprecise exception

An exception is precise if on taking the exception, the PE state and the memory system state is consistent with the PE having executed all of the instructions up to but not including the point in the instruction stream where the exception was taken from, and none afterwards. However, for an instruction executing immediately at the point in the instruction stream that the exception was taken from, the definition of precise also permits any of the following:

- For synchronous Data Abort and Watchpoint exceptions that are taken to AArch64 state generated by an instruction that performs more than one single-copy atomic memory access, the values in registers or memory affected by the instruction can be UNKNOWN, if all of the following apply:
- -The accesses affecting those registers or memory locations do not, themselves, generate exceptions or debug events.
- -The registers are not involved in the calculation of the memory address used by the instruction.
- For synchronous Data Abort and Watchpoint exceptions that are generated from load or store instructions executed in AArch64 state, all the following can occur:
- -If the instruction was a load to either the base address register or the offset register, that register is restored to the original value, and any other destination registers become UNKNOWN.
- -If the instruction was a load that does not load the base address register or the offset register, then the destination registers become UNKNOWN.
- -If the instruction was an atomic that attempted both a load and a store, and the load was to the base address register, a source register or a compare register, that register is restored to the original value. Otherwise, that destination register becomes UNKNOWN.
- For implementations that include synchronous exception generation for floating-point exceptions, when a floating-point exception is taken, it is permitted that the cumulative floating-point exception bits are not restored.
- For a precise exception that is taken from AArch64 state during an instruction that performs more than one single-copy atomic memory access, the values in registers or memory affected by the instruction can be UNKNOWN, if all of the following apply:
- -The instruction is not GCSSS2 .

RTNVSL

- -The accesses affecting those registers or memory locations do not, themselves, generate exceptions or debug events.
- -The registers are not involved in the calculation of the memory address used by the instruction.
- For a synchronous exception or synchronous Debug state entry, generated by a Memory Copy and Memory Set instruction, and for an asynchronous exception or asynchronous Debug state entry part way through the execution of a Memory Copy and Memory Set instruction:
- -The values of PSTATE.{N,Z,C,V} are UNKNOWN on exception entry. The values held in SPSR\_ELx.{N,Z,C,V} on exception entry, and DSPSR\_EL0.{N,Z,C,V} on Debug state entry, are the initial values for the instruction.
- -All memory locations written by the pseudocode at the point at which the exception is taken are updated.
- -If the memory locations that are not written by the pseudocode at the point at which the exception is taken are within the set of locations to be read by the instruction if it is restarted with the X[n], X[d], and X[s] register values presented as part of taking the exception, then those memory locations are not updated.
- -For CPYF*T* and SET{G}*T* instructions, no memory locations that are not written by the pseudocode at the point at which the exception is taken are updated.
- -For Memory Copy and Memory Set instructions other than CPYF*T* and SET{G}*T*, any memory location that does not itself generate a synchronous exception on a write becomes UNKNOWN if all the following apply:
- -The memory location is within the set of locations to be written by the instruction if it is restarted with the X[n], X[d], and X[s] register values presented as part of taking the exception.
- -The memory location is not within the set of locations to be read by the instruction on that restart.
- -Only for a synchronous exception or synchronous Debug state entry, generated by a Memory Copy and Memory Set instruction:
- -On taking the exception, the X[n], X[d], and, as appropriate, X[s] register values hold a self-consistent set of values that correspond to the first element that was not copied or set, such that return to the instruction enables resumption of the memory copy or memory set. That first element does not need to be the element with a watchpoint, but can be an earlier element, including the first element.
- -If a memory location that generates a synchronous exception on a write is within the set of locations to be written by the instruction if it is restarted with the X[n], X[d], and X[s] register values presented as part of taking the exception, and if the memory location is not within the set of locations to be read by the instruction on that restart, then the memory location is unchanged.
- -For a synchronous exception, ELR\_ELx points to the instruction that generated the exception.
- -For a synchronous Debug state entry, DLR\_EL0 points to the instruction that generated the Debug state entry.
- -Only for an asynchronous exception or asynchronous Debug state entry part way through the execution of a Memory Copy and Memory Set instruction:
- -On taking the exception, the values of the registers that are updated by the instruction are presented as a self-consistent set of values that correspond to the first element that was not copied or set.
- If FEAT\_SEBEP is implemented, then for any precise exception, including a PMU exception, the value of all event counters counting at-retirement events and the instruction counter is precise.

| R ZNCXP   | An exception is imprecise if it is not a precise exception.                                                                                                                                                                                                                                                                                                                                                       |
|-----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| R LSGJD   | Except for SError exceptions, all exceptions taken to AArch64 state are precise. For each occurrence of an SError exception, whether the interrupt is precise or imprecise is IMPLEMENTATION DEFINED.                                                                                                                                                                                                             |
| I ZNNNY   | An asynchronous Data Abort exception generated by a load that causes an SError exception to be taken at some point later in the instruction stream than the load that generated the exception, is usually imprecise. The SError exception is usually imprecise because the data returned from the load is UNKNOWN, and so can have corrupted the state that is presented at the time that the exception is taken. |
| I LQPWH   | The preferred exception return address is an address that software might return to after handling an exception in order to resume execution.                                                                                                                                                                                                                                                                      |
| I HBQRX   | The preferred exception return address is determined by the type of the exception.                                                                                                                                                                                                                                                                                                                                |

RDPLYN

RVBQMV

RQYCWH

For an exception taken to an Exception level, ELx, using AArch64, the Exception Link Register for that Exception level, ELR\_ELx, is set to the preferred exception return address.

For asynchronous exceptions, the preferred exception return address is the address of the instruction following the instruction boundary at which the interrupt occurs.

For synchronous exceptions other than exception generating instructions, the preferred exception return address is the address of the instruction that generates the exception.

For an exception generating instruction that is executed, the preferred exception return address is the address of the

RDKWPP instruction that follows the exception generating instruction.

RLBLBR

For an exception generating instruction that is trapped, disabled, or is UNDEFINED because the Exception level has insufficient privilege to execute the instruction, the preferred exception return address is the address of the exception generating instruction.

RXVMNH

When an exception is taken from an Exception level using AArch32 to an Exception level, ELx, using AArch64, ELR\_ELx[63:32] are 0.

## D1.4.1.6 Exception vectors

RFKKHH When an exception is taken to an Exception level that is using AArch64, execution starts at the exception vector .

IQLHPV

The memory at the exception vector for an exception is expected to contain the handler code that corresponds to that exception category.

RBRCKV The vector base address for an Exception level, ELx, is defined by the Vector Base Address Register, VBAR\_ELx.

RPJKRC Each exception category has an exception vector at a fixed offset from the vector base address.

IYCTHH An exception taken to AArch64 is categorized for the purpose of assigning an exception vector based on the following information:

- Whether the exception is one of the following:
- -Asynchronous exception, excluding synchronous External aborts.
- -Asynchronous External abort.
- -An SError exception, including vSError and delegated SError exceptions.
- -An IRQ or vIRQ interrupt.
- -An FIQ or vFIQ interrupt.
- Information about the Exception level that the exception came from.
- Information about the SP in use.
- The state of the register file.

For information on synchronous exceptions, see Synchronous exception types. For information on asynchronous exceptions, see Asynchronous exception types.

The following tables describe the offsets that are added to the vector base address to describe the exception vector:

RRYXCL

| Exception taken from                                                                                         | Offset for exception type Synchronous exceptions, excluding External aborts   | IRQ and vIRQ   | FIQ and vFIQ   |
|--------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------|----------------|----------------|
| Current Exception level with SP_EL0.                                                                         | 0x000                                                                         | 0x080          | 0x100          |
| Current Exception level with SP_ELx, x > 0.                                                                  | 0x200                                                                         | 0x280          | 0x300          |
| Lower Exception level, where the implemented level immediately lower than the target level is using AArch64. | 0x400                                                                         | 0x480          | 0x500          |

| Exception taken from                                                                                         | Offset for exception type Synchronous exceptions, excluding External aborts   | IRQ and vIRQ   | FIQ and vFIQ   |
|--------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------|----------------|----------------|
| Lower Exception level, where the implemented level immediately lower than the target level is using AArch32. | 0x600                                                                         | 0x680          | 0x700          |

| Exception taken from                                                                                         | Offset for exception type   | Synchronous External aborts, == 1   | EASE SError, vSError, and SError   |
|--------------------------------------------------------------------------------------------------------------|-----------------------------|-------------------------------------|------------------------------------|
| Current Exception level with SP_EL0.                                                                         | 0x000                       | 0x180                               | 0x180                              |
| Current Exception level with SP_ELx, x > 0.                                                                  | 0x200                       | 0x380                               | 0x380                              |
| Lower Exception level, where the implemented level immediately lower than the target level is using AArch64. | 0x400                       | 0x580                               | 0x580                              |
| Lower Exception level, where the implemented level immediately lower than the target level is using AArch32. | 0x600                       | 0x780                               | 0x780                              |

The applicable value of EASE is the following:

- For an exception taken to EL1, the Effective value of SCTLR2\_EL1.EASE.
- For an exception taken to EL2, the Effective value of SCTLR2\_EL2.EASE.
- For an exception taken to EL3, the Effective value of SCR\_EL3.EASE.

For the preceding tables, if EL3 is the target Exception level, the implemented Exception level immediately lower than EL3 is either:

- EL2, if EL2 is implemented and enabled for the Security state of the Exception level the exception was taken from.
- EL1, if EL2 is not implemented or not enabled for the Security state of the Exception level the exception was taken from.

## D1.4.2 Exception entry

RDQXFW

When an exception is taken to an Exception level, ELx, that is using AArch64 state, all the following occur:

- Fields in SPSR\_ELx are written according to their description in SPSR\_ELx, based on the values in PSTATE immediately before the exception was taken.
- The preferred exception return address is written to ELR\_ELx.
- The contents of PSTATE immediately after the exception is taken is as described in rule RWTXBY.
- For synchronous exceptions and SError exceptions, exception syndrome information is written to ESR\_ELx.
- Execution starts from the exception vector at the target Exception level.

When an exception is taken to an Exception level, ELx, that is using AArch64 state, after recording the previous values in SPSR\_ELx, the following PSTATE bits are set:

- PSTATE.EL is set to the target Exception level.
- All of PSTATE.{D, A, I, F, SP} are set to 1.
- PSTATE.{IL, nRW} are set to 0.
- PSTATE.SS is set according to the rules in AArch64 Self-hosted Debug.

IFSZTB

RWTXBY

- If FEAT\_PAN is implemented, then for any of the following situations, PSTATE.PAN is set to 1:
- -The target Exception level is EL1 and SCTLR\_EL1.SPAN is 0.
- -The target Exception level is EL2 using AArch64, the Effective value of HCR\_EL2.{TGE, E2H} is {1, 1}, and SCTLR\_EL2.SPAN is 0.
- If FEAT\_UAO is implemented, then PSTATE.UAO is set to 0.
- If FEAT\_BTI is implemented, then PSTATE.BTYPE is set to 0b00 .
- If FEAT\_MTE is implemented, then PSTATE.TCO is set to 1.
- If FEAT\_SSBS is implemented, then PSTATE.SSBS is set to the value of SCTLR\_ELx.DSSBS.
- If FEAT\_NMI is implemented, then PSTATE.ALLINT is set to the inverse value of SCTLR\_ELx.SPINTMASK.
- If FEAT\_EBEP, FEAT\_SPE\_EXC or FEAT\_TRBE\_EXC is implemented, then PSTATE.PM is set to 1.
- If FEAT\_GCS is implemented, PSTATE.EXLOCK is updated based on the following situations:
- -On taking an exception to the same Exception level,PSTATE.EXLOCK is set to the Effective value of GCSCR\_ELx.EXLOCKEN for the current Exception level.
- -On taking an exception to a higher Exception level, PSTATE.EXLOCK is set to 0.
- If FEAT\_SEBEP is implemented, then PSTATE.PPEND is set to 0.
- If FEAT\_PAuth\_LR is implemented, then PSTATE.PACM is set to 0.

RXKSNJ If FEAT\_UINJ is implemented, then when an exception is taken to an Exception level, ELx, that is using AArch64 state, PSTATE.UINJ is set to 0, and the resulting value stored in SPSR\_ELx is 0.

IRFWPH When an exception is taken to an Exception level that is using AArch64 state, the following PSTATE fields are unchanged:

- If FEAT\_DIT is implemented, PSTATE.DIT.
- If FEAT\_SME is implemented, PSTATE.{SM,ZA}.

IHLPGV PSTATE.PACM is set to 0 when executing an SVC , HVC , or SMC instruction that is not trapped, disabled, or UNDEFINED, and the resulting value stored in SPSR\_ELx.PACM is 0.

- RSRXVW If the Effective value of SCTLR\_ELx.IESB is 1 at the target Exception level, an exception taken to AArch64 state is an error synchronization event.
- RBBSRF If SCTLR\_ELx.EIS is 1, exception entry is a Context synchronization event. If SCTLR\_ELx.EIS is 0, exception entry is not a Context synchronization event, but the indirect writes to ESR\_ELx, FAR\_ELx, SPSR\_ELx, ELR\_ELx, and HPFAR\_EL2 due to exception entry are synchronized so that a direct read of the register after exception entry sees the indirectly written value caused by the exception entry.
- IJFWCQ For the purposes of the memory model, some exception entries are Instruction Fetch Barrier effects, regardless of the value of SCTLR\_ELx.EIS. See Basic definitions for the list of exception entries.

IFZTLH The ordering of error synchronization and context synchronization on exception entry is described in the pseudocode.

- IWPBHV Memory copy and memory set operations are guaranteed to function correctly only if the prologue, main, and epilogue Memory Copy and Memory Set instructions are executed in succession and are placed consecutively in memory. Failure to execute the three instructions in succession can result in the instructions causing exceptions. Software exception handlers are expected to require that the three instructions are placed consecutively in memory. If the three instructions are not placed consecutively in memory, exception returns to the wrong instructions might occur.

ILBHFM There are additional behaviors for synchronous External aborts and SError exceptions. See also Taking error exceptions.

## D1.4.2.1 Synchronous exception entry

RPMQBM For any of the following synchronous exceptions taken from an Exception level using AArch64, if FEAT\_BTI is implemented, then PSTATE.BTYPE is copied to SPSR\_ELx.BTYPE and then PSTATE.BTYPE is set to 0:

- Software Step exception.
- PC Alignment Fault exception.
- Instruction Abort exception.
- Breakpoint exception.
- Address Matching Vector Catch exception.

IKVRPF

- Illegal Execution state exception.
- Software Breakpoint exception.
- Branch Target exception.

When taking any other synchronous exception from an Exception level using AArch64, it is CONSTRAINED UNPREDICTABLE whether:

- SPSR\_ELx.BTYPE is set to the value of PSTATE.BTYPE.
- SPSR\_ELx.BTYPE is set to 0.

PSTATE.BTYPE is then set to 0.

For synchronous exceptions that result in the exception handler emulating the instruction and returning to the following instruction, the handler typically completes by ensuring the state of the PE on returning from the exception is consistent with the emulated instruction having been executed. This usually includes ensuring the value of SPSR\_ELx.BTYPE is consistent with the instruction being emulated having executed.

For SVC , HVC , and SMC instructions, when these instructions execute without being trapped, the value of SPSR\_ELx already points to the following instruction. However SPSR\_ELx.BTYPE is not guaranteed to be 0 and so might not be consistent with the SVC , HVC , or SMC instruction having executed. This might subsequently cause a Branch Target exception at the instruction after the SVC , HVC , or SMC instruction. This is unlikely to be encountered in real code since it requires the SVC , HVC , or SMC to be executed in a non-Guarded page with the instruction after the SVC , HVC , or SMC executed in a Guarded page.

RZTSSH For any of the following synchronous exception types, when an exception is taken to an Exception level, ELx, a virtual address (VA) that characterizes the exception is captured in FAR\_ELx:

- An Instruction Abort exception.
- AData Abort exception.
- APCalignment fault exception.
- AWatchpoint exception.

For GPC exceptions, a VA that characterizes the exception is captured in FAR\_EL3. For synchronous External aborts that are not caused by translation table walks, it is CONSTRAINED UNPREDICTABLE whether the FAR\_ELx contains a VA that characterizes the exception. The ESR\_ELx.FnV bit in the ISS encoding for the External abort indicates the validity of the V A in FAR\_ELx:

- If ESR\_ELx.FnV in the ISS encoding for the External abort is 1, the V A in FAR\_ELx is UNKNOWN.
- If ESR\_ELx.FnV in the ISS encoding for the External abort is 0, the V A in FAR\_ELx is valid.

For all other exceptions taken to ELx, FAR\_ELx is UNKNOWN.

RJXPNL When an SME load or store instruction, or an SVE contiguous vector load or store instruction, causes a Data Abort exception that sets ESR\_ELx.ISV to 0:

- If the value written to FAR\_ELx might not be the faulting V A, the PE sets ESR\_ELx.FnP to 1 and sets FAR\_ELx to any address within the naturally-aligned fault granule that contains the faulting V A. The naturally-aligned fault granule is as defined in the FAR\_ELx register descriptions.
- Otherwise, the PE sets ESR\_ELx.FnP to 0.
- RFKLWR For Instruction Abort or Data Abort exceptions caused by any of the following faults, when an exception is taken to EL2, an intermediate physical address (IPA) that characterizes the exception is captured in HPFAR\_EL2:
- ATranslation fault, Access Flag fault, or Address Size fault on a stage 2 translation not on a stage 1 translation table walk.
- ATranslation fault, Access flag fault, Address Size fault, or Permission fault on stage 2 translation of an address accessed in a stage 1 translation table walk.
- AGranule Protection Fault (GPF) on an access for a stage 2 translation table.

For GPC exceptions due to a fault on an access for a stage 2 translation table walk, an IPA that characterizes the exception is captured in HPFAR\_EL2.

For all other exceptions taken to EL2 using AArch64, HPFAR\_EL2 is UNKNOWN.

For GPC exceptions, a PA and physical address space that characterize the exception and a PA are captured in MFAR\_EL3.

For Instruction Abort or Data Abort exceptions caused by an External abort, when FEAT\_PFAR is implemented:

- If all of the following apply, then ESR\_ELx.PFV is set to 0:

RBFJJV

RTGQRC

- -The exception is taken to EL1.
- -EL2 is implemented and enabled in the current Security state.
- -The Effective value of HCR\_EL2.VM is 1.
- Otherwise, ESR\_ELx.PFV is set to an IMPLEMENTATION DEFINED value of 0 or 1.

For all other Instruction Abort and Data Abort exceptions, ESR\_ELx.PFV is set to 0. On taking an Instruction Abort or Data Abort exception:

- If ESR\_ELx.PFV is set to 1 by the PE, then a physical address space that characterizes the exception and a PA are captured in PFAR\_ELx or MFAR\_EL3 as applicable. The fault granule size is defined by DLVGRB.
- If ESR\_ELx.PFV is set to 0 by the PE, then the applicable PFAR\_ELx or MFAR\_EL3 register is set to an UNKNOWN value.

Note

PFAR\_ELxnever records the Intermediate Physical Address (IPA). PFAR\_ELx might reveal a faulting physical addresses to a guest operating system if stage 2 translation is not being used and some other method is used to hide physical addresses from the guest (such as shadow page tables).

| R DHLHF   | For all exceptions other than Instruction Abort, Data Abort, and GPC exceptions, the applicable PFAR_ELx or MFAR_EL3 register is set to an UNKNOWN value.                                                                                                                                                                                                                                                                                    |
|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| R TGRZL   | If an Instruction Abort or Breakpoint exception is generated part way through execution of a Memory Copy and Memory Set instruction, presentation of the exception state is as described inR TNVSL for a synchronous exception or synchronous Debug state entry from a watchpoint, generated by a Memory Copy and Memory Set instruction.                                                                                                    |
| R ZMSLS   | For a CPY* Memory Copy instruction, if both the read and write generate the Data Abort or Watchpoint exception, it is CONSTRAINED UNPREDICTABLE whether the exception on the read or the exception on the write is presented. ESR_ELx.ISS.WnR is set to be consistent with whether the exception was on the read or the write.                                                                                                               |
| R RWVTR   | D1.4.2.1.1 SVE MOVPRFX exception entry behavior When a MOVPRFX instruction pairs legally with another instruction and the execution of the pair generates a synchronous                                                                                                                                                                                                                                                                      |
| R XRWVD   | When a MOVPRFX instruction pairs legally with another instruction and the execution of the pair causes synchronous entry to Debug state: • If the Debug state entry is due to a Halt Instruction debug event from a prefixed HLT instruction then MOVPRFX                                                                                                                                                                                    |
|           | updates the architectural state and DLR_EL0 stores the address of HLT instruction. • Otherwise, the return address that is stored in DLR_EL0 is one of the following: - When the MOVPRFX instruction did not cause a change to the architectural state, the address of the MOVPRFX instruction is stored.                                                                                                                                    |
| R TPRKM   | When a MOVPRFX instruction pairs illegally with another instruction and execution of the pair generates a synchronous exception, the return address recorded in ELR_ELx is a CONSTRAINED UNPREDICTABLE choice one of the following: • The address of the MOVPRFX instruction. • The address of the prefixed instruction. When a MOVPRFX instruction pairs illegally with another instruction and execution of the pair causes entry to Debug |
| R JVNGC   | state, the return address recorded in DLR_EL0 is a CONSTRAINED UNPREDICTABLE choice one of the following: • The address of the MOVPRFX instruction. • The address of the prefixed instruction.                                                                                                                                                                                                                                               |

RCRRPM

RZJYDX

RBWRCL

RJBKRW

RSYZRH

RQXQQX

RNPSDK

RYJTBL

RGZVBJ

RMNGMW

When a prefixed instruction generates an Instruction Abort due to an MMU fault or synchronous External abort and the MOVPRFX does not generate an Instruction Abort, then the address of the prefixed instruction is recorded in the appropriate FAR\_ELx or HPFAR\_EL2 register and the address of the MOVPRFX instruction is recorded in the appropriate ELR\_ELx register.

When a prefixed instruction generates an Instruction Abort due to an MMU fault or synchronous External abort and the MOVPRFX also generates an Instruction Abort, then the address of the MOVPRFX instruction is recorded in the appropriate FAR\_ELx or HPFAR\_EL2 register and the appropriate ELR\_ELx register.

## D1.4.2.2 Asynchronous exception entry

If FEAT\_BTI is implemented, then when an asynchronous exception is taken from an Exception level using AArch64,

PSTATE.BTYPE is copied to SPSR\_ELx.BTYPE and then PSTATE.BTYPE is set to 0.

If any of the following apply, when a physical SError exception is taken to AArch64 state, the pending state of the physical SError is cleared:

- FEAT\_DoubleFault is implemented.
- If FEAT\_RAS is implemented, and on taking the SError exception, the syndrome recorded in ESR\_ELx indicates an SError other than IMPLEMENTATION DEFINED or uncategorized SError exception syndrome. See Taking error exceptions.

Otherwise, it is IMPLEMENTATION DEFINED whether the pending state of the physical SError is cleared. This IMPLEMENTATION DEFINED behavior might vary according to the type of the SError exception.

When a virtual SError exception is taken to AArch64 state, HCR\_EL2.VSE is set to 0.

When a delegated SError exception is taken, SCR\_EL3.DSE is set to 0.

When FEAT\_PFAR is implemented, on taking an SError exception to an Exception level using AArch64:

- If all of the following apply, ESR\_ELx.PFV is set to 0:
- -The exception is taken to EL1.
- -EL2 is implemented and enabled in the current security state.
- -The Effective value of HCR\_EL2.VM is 1.
- Otherwise, ESR\_ELx.PFV is set to an IMPLEMENTATION DEFINED value of 0 or 1.

On taking an SError exception, if ESR\_ELx.PFV is set to 1 by the PE then:

- An address within the same naturally-aligned fault granule as the faulting physical address is written to PFAR\_ELx.PA or MFAR\_EL3.PA as applicable. The fault granule size is defined by DLVGRB.
- The faulting physical address space is written to PFAR\_ELx.{NSE,NS} or MFAR\_EL3.{NSE,NS} as applicable.

Note

PFAR\_ELxnever records the Intermediate Physical Address (IPA). PFAR\_ELx might reveal a faulting physical addresses to a guest operating system if stage 2 translation is not being used and some other method is used to hide physical addresses from the guest (such as shadow page tables).

On taking an SError exception, the following registers is UNKNOWN based on the ESR\_ELx.PFV value:

- If ESR\_EL1.PFV is set to 0, PFAR\_EL1 is UNKNOWN.
- If ESR\_EL2.PFV is set to 0, PFAR\_EL2 is UNKNOWN.
- If ESR\_EL3.PFV is set to 0, MFAR\_EL3 is UNKNOWN.

An asynchronous exception or asynchronous Debug state entry part way through the execution of a Memory Copy and Memory Set instruction is permissible. For an asynchronous exception, ELR\_ELx points to the instruction that the exception was taken on. For an asynchronous Debug state entry, DLR\_EL0 points to the instruction that the Debug state entry was taken on.

For an imprecise asynchronous exception part way through the execution of a Memory Copy and Memory Set instruction, the following are UNKNOWN:

- The state of the X[n], X[d], and X[s] registers.
- The state of memory that was being written to by the instruction.

## D1.4.3 Exception return terminology

## D1.4.3.1 Return, return from, return to

| R MMSFW   | An exception return is caused by the execution of an exception return instruction.                                      |
|-----------|-------------------------------------------------------------------------------------------------------------------------|
| R JDJHH   | The PE state immediately before an exception return instruction is executed is the state the exception returns from .   |
| R HNVMN   | The PE state immediately after the execution of an exception return instruction is the state the exception returns to . |

## D1.4.4 Exception return

RSKNJF

In AArch64 state, the Exception return instructions are ERET, ERETAA, and ERETAB.

RPKJFB The Exception return instructions are UNDEFINED in EL0.

RSVBYH An exception return is either legal or illegal.

## D1.4.4.1 Legal exception returns from AArch64 state

RBWCFK On a legal exception return from an Exception level, ELx, all of the following occur:

- If SCTLR\_ELx.IESB is 1, and the Exception return instruction does not generate an exception, the PE inserts an error synchronization event before the Exception return instruction.
- Fields in PSTATE that have a corresponding field in SPSR\_ELx are written according to their description in SPSR\_ELx.
- The PC is set to the value in ELR\_ELx.
- If returning to an Exception level using AArch32 state, all the following apply:
- -If SPSR\_ELx.T is 0, ELR\_ELx[1:0] are treated as being 0 for setting the PC.
- -If SPSR\_ELx.T is 1, ELR\_ELx[0] is treated as being 0 for setting the PC.
- The contents of PSTATE are set to the values held in SPSR\_ELx.
- If FEAT\_PAuth\_LR is implemented and any of the following apply, PSTATE.PACM is set to 0:
- -The trivial implementation of PSTATE.PACM is used.
- -The effects of PACM instructions are disabled at the target Exception level.
- If the PSTATE.IL bit copied from SPSR\_ELx is 1 and the target Exception level for the return is using AArch32 state, the PSTATE.{IT,T} bits are determined by an IMPLEMENTATION DEFINED choice of one of the following:
- -Set to 0.
- -For returns initiated by an Exception return instruction or DRPS instruction, copied from SPSR\_ELx.
- -For debug exits, copied from DSPSR\_EL0.

The IMPLEMENTATION DEFINED choice might vary dynamically within the implementation. Software must regard the value as being an UNKNOWN choice between the two values.

- The Event Register for the PE executing the Exception return instruction is set.
- The local Exclusives monitor for the PE executing the Exception return instruction is cleared. It is IMPLEMENTATION DEFINED whether clearing the local Exclusives monitor also clears the global Exclusives monitor.
- After the PC is set to the value held in ELR\_ELx and the contents of PSTATE are set to the values held in SPSR\_ELx, ELR\_ELx and SPSR\_ELx become UNKNOWN.
- If the Effective value of SCTLR\_ELx.EOS is 1, the exception return is a Context synchronization event.
- If the Effective value of SCTLR\_ELx.EOS is 0, the exception return is not a Context synchronization event.

If FEAT\_SEBEP is implemented, then unless the exception return instruction causes the PMU to set PSTATE.PPEND to 1, PSTATE.PPEND is set according to RBVBYS.

## D1.4.4.2 Illegal exception returns from AArch64 state

If in AArch64 state, any of the following situations can cause an illegal exception return:

- Areturn is made to an Exception level higher than the current Exception level.
- Areturn is made to an Exception level that is not implemented.

RQWBLS

RTYTWB

RVWJHB

- If FEAT\_RME is implemented, then if SCR\_EL3.{NSE, NS} is {1, 0}, an exception return from EL3 to a lower Exception level.
- If all of the following are true, and a return is made to EL1:
- -EL2 is implemented and enabled in the current Security state
- -HCR\_EL2.TGE is 1.
- If all of the following are true, and a return is made to EL2:
- -EL3 is implemented.
- -SCR\_EL3.NS is 0.
- -FEAT\_SEL2 is not implemented.
- If all of the following are true, and a return is made to EL2:
- -EL3 is implemented.
- -SCR\_EL3.NS is 0.
- -FEAT\_SEL2 is implemented.
- -SCR\_EL3.EEL2 is 0.
- Areturn where the saved PSTATE.M[4] is 0 and at least one of the following is true:
- -M[1] is 1.
- -M[3:0] are 0b0001 .
- -The Exception level being returned to is using AArch32 state, as determined by SCR\_EL3.RW, HCR\_EL2.RW, or as configured from reset.
- Areturn where the saved PSTATE.M[4] bit is 1, indicating a return to AArch32 state, and at least one of the following are true:
- -AArch32 state is not supported at any Exception level.
- -The M field value is not a valid AArch32 state PE mode.
- -The Exception level being returned to is using AArch64 state, as determined by SCR\_EL3.RW, HCR\_EL2.RW, or as configured from reset.
- If the Effective value of GCSCR\_ELx.EXLOCKEN is 1 and PSTATE.EXLOCK is 0, the execution of an exception return instruction to return to the current Exception level ELx.

On an illegal exception return from an Exception level, ELx, all of the following occur:

- If SCTLR\_ELx.IESB is 1, the PE inserts an error synchronization event before the Exception return instruction.
- The PC is set to the value in ELR\_ELx. If the saved PSTATE.M[4] bit is 1, for illegal exception returns to AArch32 state, all of the following are true:
- -The PC bits[31:2] are set to the value in ELR\_ELx.
- -The PC bits[63:32, 1:0] are UNKNOWN.
- PSTATE.IL is set to 1.
- PSTATE.{EL, nRW, SP} are unchanged.
- PSTATE.{N, Z, C, V, D, A, I, F} are set to the associated values in SPSR\_ELx.
- PSTATE.SS is handled as if the return is a legal exception return.
- If PSTATE.nRW is 1, indicating a return to AArch32 state, then the following PSTATE bits are also set:
- -PSTATE.{Q, IT, GE, E} are set to the associated values in SPSR\_ELx.
- -It is CONSTRAINED UNPREDICTABLE whether PSTATE.T is 0 or set to the contents of SPSR\_ELx.
- If FEAT\_PAN is implemented, then PSTATE.PAN is set to the associated value in SPSR\_ELx.
- All of the following are UNKNOWN:
- -If FEAT\_UAO is implemented, then PSTATE.UAO.
- -If FEAT\_DIT is implemented, then PSTATE.DIT.
- -If FEAT\_MTE is implemented, then PSTATE.TCO.
- -If FEAT\_SSBS is implemented, then PSTATE.SSBS.
- -If FEAT\_BTI is implemented, then PSTATE.BTYPE.
- -If FEAT\_PAuth\_LR is implemented, then PSTATE.PACM.
- If FEAT\_NMI is implemented, then PSTATE.ALLINT is set to the associated value in SPSR\_ELx.
- If FEAT\_EBEP, FEAT\_SPE\_EXC or FEAT\_TRBE\_EXC is implemented, then PSTATE.PM is set to the associated value in SPSR\_ELx.
- If FEAT\_GCS is implemented, then PSTATE.EXLOCK is unchanged.
- If FEAT\_SEBEP is implemented, then PSTATE.PPEND is handled as if the return is a legal exception return.
- If FEAT\_UINJ is implemented, then PSTATE.UINJ is set to 0.

- The Event Register for the PE executing the Exception return instruction is set.
- The local Exclusives monitor for the PE executing the Exception return instruction is cleared. It is IMPLEMENTATION DEFINED whether clearing the local Exclusives monitor also clears the global Exclusives monitor.
- After the PC has been set to the value held in ELR\_ELx and the contents of PSTATE have been set to the value held in SPSR\_ELx, the ELR\_ELx and SPSR\_ELx become UNKNOWN.
- If the Effective value of SCTLR\_ELx.EOS is 1, the exception return is a Context synchronization event.
- If the Effective value of SCTLR\_ELx.EOS is 0, the exception return is not a Context synchronization event.

## D1.4.5 Synchronous exception types

RBZGXV

All of the following are synchronous exceptions:

- Any exception generated by attempting to execute an instruction that is UNDEFINED, including:
- -Attempts to execute instructions at an inappropriate Exception level.
- -Attempts to execute instructions when they are disabled.
- -Attempts to execute instruction bit patterns that are not allocated.
- -Any attempt to execute any instruction when PSTATE.UINJ is 1. See Undefined Instruction exceptions injected by PSTATE.UINJ.
- Any exception caused by attempts to execute an instruction when the value of PSTATE.IL is 1. These are called Illegal Execution State exceptions.
- Any exception caused by the use of a misaligned SP. These are called SP Alignment Fault exceptions.
- Any exception caused by attempting to execute an instruction with a misaligned PC. These are called PC Alignment Fault exceptions.
- If FEAT\_BTI is implemented, execution is inside a guarded memory region, and PSTATE.BTYPE does not equal 0, then any exception caused by executing an instruction that is not compatible with the current value of PSTATE.BTYPE. These are called Branch Target exceptions.
- Any exception caused by a pointer authentication instruction authentication failure. These are called PAC Fail exceptions.
- Any exception caused by the exception generating instructions SVC, HVC, or SMC. These are respectively called Supervisor Call (SVC) exceptions, Hypervisor Call (HVC) exceptions, or Secure Monitor Call (SMC) exceptions.
- Traps on attempts to execute instructions that the System registers define as instructions that are trapped to a higher Exception level. These are called Trap exceptions.
- Any exception caused by Instruction Aborts that were generated by the memory address translation system that was associated with attempts to execute instructions from areas of memory that generate faults. These are called Instruction Abort exceptions.
- Any exception caused by Data Aborts that were generated by the memory address translation system that are associated with attempts to read or write memory that generate faults. These are called Data Abort exceptions.
- Any exception caused by Data Aborts because of a misaligned address. These are called Data Abort exceptions.
- If FEAT\_MTE2 is implemented, any exception caused by a Data Abort as a result of a Tag Check Fault. These are called Data Abort exceptions.
- If FEAT\_SEBEP is implemented, a PMU exception that is enabled and unmasked in the current Exception level, and is generated by an event counter in synchronous mode.
- If FEAT\_RME is implemented, any exception that results from a Granule Protection Check (GPC) fault. Depending on the cause of the exception, the GPC fault type, and the value of the routing control SCR\_EL3.GPF, these are called:
- -GPC exceptions.
- -Data Abort exceptions.
- -Instruction Abort exceptions.
- Memory Copy exceptions and Memory Set exceptions. For more information, see Memory Copy and Memory Set exceptions.
- Guarded Control Stack exceptions. For more information, see Guarded Control Stack exceptions.
- All of the debug exceptions:
- -Breakpoint Instruction exceptions.
- -Breakpoint exceptions.
- -Watchpoint exceptions.

- -Vector Catch exceptions.
- -Software Step exceptions.
- In an implementation that supports the trapping of floating-point exceptions, any exception caused by trapped floating-point exceptions. These are called Trapped Floating-point exceptions.
- An IMPLEMENTATION DEFINED set of exceptions caused by External aborts.

IXRFSY The architecture permits, but does not require, synchronous or asynchronous handling of External aborts. However, some situations specified by the architecture must be handled synchronously. For more information, see Taking error exceptions.

## D1.4.5.1 Taking synchronous exceptions from EL0

RDPLSC If EL2 is using AArch64 and the Effective value of HCR\_EL2.TGE is 1, when any of the following exceptions are taken from EL0, they are taken to EL2, unless routed to a higher Exception level. If EL2 is using AArch64 and the Effective value of HCR\_EL2.TGE is 0, when any of the following exceptions are taken from EL0, they are taken to EL1, unless routed to a higher Exception level:

- Stage 1 Data Abort.
- Stage 1 Instruction Abort.
- PC Alignment fault.
- SP Alignment fault.
- Tag Check fault.
- Branch Target exception.
- Illegal Execution State exception.
- Trapped Floating-point exception.
- Supervisor Call.
- Undefined Instruction exception.
- PAC Fail exception.
- WFEtrap.
- WFI trap.
- Advanced SIMD and floating-point Access trap.
- SVE Access trap.
- SMEAccess traps.
- SMEIllegal Instruction exceptions.
- Synchronous External aborts.
- Memory Copy and Memory Set exceptions.
- PMUexceptions.
- Guarded Control Stack exceptions.

If EL2 is using AArch64 and either HCR\_EL2.TGE is 1 or MDCR\_EL2.TDE is 1, when any of the following debug exceptions are taken from EL0, they are taken to EL2. If EL2 is using AArch64 and both HCR\_EL2.TGE is 0 and MDCR\_EL2.TDE is 0, when any of the following debug exceptions are taken from EL0, they are taken to EL1:

- Breakpoint exception.
- Software Breakpoint exception.
- Software Step exception.
- Watchpoint exception.

If EL2 is using AArch64 and either HCR\_EL2.TGE is 1 or MDCR\_EL2.TDE is 1, when a Vector Catch exception is taken from EL0, it is taken to EL2. If EL2 is using AArch64 and both HCR\_EL2.TGE is 0 and MDCR\_EL2.TDE is 0, a Vector Catch exception cannot be taken.

RJNBTN For an exception that is taken from EL0 to EL2 because the value of HCR\_EL2.TGE is 1:

- If the exception would have been reported in ESR\_EL1 using any EC value other than 0x07 , then the EC value and corresponding ISS encoding that would have been used to report the exception in ESR\_EL1 are used to report the exception in ESR\_EL2.
- If the exception would have been reported in ESR\_EL1 using the EC value 0x07 , then the EC value 0x00 and ISS encoding value 0x00 are reported in ESR\_EL2.

RQDLHN

## D1.4.5.2 Exception levels for taking a synchronous External abort

If all of the following are true, then a synchronous External abort is taken to EL3 using AArch64:

- EL3 is implemented and using AArch64.
- Any of the following are true:
- -SCR\_EL3.EA is 1 and the exception is taken from EL2, EL1, or EL0.
- -The exception is taken from EL3.

Otherwise, if all of the following are true, then a synchronous External abort exception is taken to EL2:

- EL2 is implemented and enabled in the current Security state.
- The exception is taken from EL1 or EL0.
- Any of the following are true:
- -The Effective value of HCR\_EL2.TEA or HCR2.TEA is 1.
- -The exception was generated by an External abort on a stage 2 translation table walk.
- -The exception was generated by an External abort on a System register access converted to a memory access by FEAT\_NV2. This can only occur at EL1.
- -The Effective value of HCR\_EL2.TGE or HCR.TGE is 1. This can only occur at EL0.

Otherwise, if FEAT\_DoubleFault2 is implemented and all of the following are true, then a synchronous External abort exception is taken to EL2:

- EL2 is implemented, enabled in the current Security state, and using AArch64.
- The Effective value of HCRX\_EL2.TMEA is 1.
- PSTATE.A is 1.
- The exception is taken from EL1.

Otherwise, if FEAT\_DoubleFault2 is implemented and all of the following are true, then a synchronous External abort exception is taken to EL3:

- EL3 is implemented and using AArch64.
- The Effective value of SCR\_EL3.TMEA is 1.
- PSTATE.A is 1.
- The exception is taken from EL1 or EL2.

Otherwise, all of the following apply:

- Asynchronous External abort exception taken from EL2 is taken to EL2.
- When EL1 is using AArch64, synchronous External abort exception taken from EL1 or EL0 is taken to EL1 using AArch64.

| I MBJFW   | The terms used in the tables in I NDBHM have the following meanings:   | The terms used in the tables in I NDBHM have the following meanings:                                                                                                                                 |
|-----------|------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|           | SCR_EL3                                                                | The Effective value of a field in SCR_EL3.                                                                                                                                                           |
|           | HCR                                                                    | If EL2 is using AArch32, this is the Effective value of a field in HCRor HCR2. If EL2 is using AArch64, this is the Effective value of a field in HCR_EL2.                                           |
|           | HCRX_EL2                                                               | The Effective value of a field in HCRX_EL2.                                                                                                                                                          |
|           | PSTATE                                                                 | The Effective value of a field in PSTATE.                                                                                                                                                            |
|           | EA                                                                     | The Effective value of SCR_EL3.EA. If EL3 is not implemented, the Effective value of SCR_EL3.EA is 0.                                                                                                |
|           | TMEA                                                                   | The Effective value of SCR_EL3.TMEA or HCRX_EL2.TMEA.                                                                                                                                                |
|           |                                                                        | If FEAT_DoubleFault2 is not implemented, the Effective values of SCR_EL3.TMEA and HCRX_EL2.TMEA are 0.                                                                                               |
|           |                                                                        | If EL2 is not implemented or EL2 is disabled in the current Security state, the Effective value of SCR_EL3.HXEn is 0, or EL2 is using AArch32, then the Effective value value of HCRX_EL2.TMEA is 0. |
|           | TGE                                                                    | The Effective value of HCR.TGE. If EL2 is not implemented, or if EL2 is disabled in the current Security state, then the Effective value of HCR.TGE is 0.                                            |
|           | A                                                                      | The Effective value of PSTATE.A.                                                                                                                                                                     |
|           | EL1                                                                    | The exception is taken to EL1. If EL1 is using AArch32, then the exception is taken to the AArch32 Abort mode.                                                                                       |

INDBHM

EL2

The exception is taken to EL2.

If EL2 is using AArch32, then the exception is taken to the AArch32 Hyp mode.

EL3

The exception is taken to EL3 using AArch64.

n/a

Not applicable. The field does not exist in the register in this configuration or the Exception level is not accessible in this configuration.

The following table summarizes the destination Exception level for a synchronous External abort exception taken from ELx, and all of the following applies:

- SCR\_EL3.{NS, EEL2} are not shown. IMBJFW describes Effective values involving Security states.
- The error was generated by a stage 1 fault on an access that is not a System register access. See RQDLHN for details of other cases.

| SCR_EL3   | SCR_EL3   | HCR   | HCR   | HCRX_EL2   | PSTATE   | Exception taken from   | Exception taken from   | Exception taken from   | Exception taken from   |
|-----------|-----------|-------|-------|------------|----------|------------------------|------------------------|------------------------|------------------------|
| EA        | TMEA      | TGE   | TEA   | TMEA       | A        | EL0                    | EL1                    | EL2                    | EL3                    |
| 0b0       | 0b0       | 0b0   | 0b0   | 0b0        | X        | EL1                    | EL1                    | EL2                    | EL3                    |
| 0b0       | 0b0       | 0b0   | 0b0   | 0b1        | 0b0      | EL1                    | EL1                    | EL2                    | EL3                    |
| 0b0       | 0b0       | 0b0   | 0b0   | 0b1        | 0b1      | EL1                    | EL2                    | EL2                    | EL3                    |
| 0b0       | 0b0       | 0b0   | 0b1   | X          | X        | EL2                    | EL2                    | EL2                    | EL3                    |
| 0b0       | 0b0       | 0b1   | X     | X          | X        | EL2                    | n/a                    | EL2                    | EL3                    |
| 0b0       | 0b1       | 0b0   | 0b0   | 0b0        | 0b1      | EL1                    | EL3                    | EL3                    | EL3                    |
| 0b0       | 0b1       | 0b0   | 0b0   | X          | 0b0      | EL1                    | EL1                    | EL2                    | EL3                    |
| 0b0       | 0b1       | 0b0   | 0b0   | 0b1        | 0b1      | EL1                    | EL2                    | EL3                    | EL3                    |
| 0b0       | 0b1       | 0b0   | 0b1   | X          | 0b0      | EL2                    | EL2                    | EL2                    | EL3                    |
| 0b0       | 0b1       | 0b0   | 0b1   | X          | 0b1      | EL2                    | EL2                    | EL3                    | EL3                    |
| 0b0       | 0b1       | 0b1   | X     | X          | 0b0      | EL2                    | n/a                    | EL2                    | EL3                    |
| 0b0       | 0b1       | 0b1   | X     | X          | 0b1      | EL2                    | n/a                    | EL3                    | EL3                    |
| 0b1       | X         | 0b0   | X     | X          | X        | EL3                    | EL3                    | EL3                    | EL3                    |
| 0b1       | X         | 0b1   | X     | X          | X        | EL3                    | n/a                    | EL3                    | EL3                    |

## D1.4.5.3 Granule Protection Check faults

IYRNGX

If FEAT\_RME is implemented, then when GPCCR\_EL3.GPC is 1, Granule Protection Checks (GPCs) on accesses to Physical Address (PA) space are enabled and might result in GPCfaults .

RPYTGX

GPC faults are reported as synchronous exceptions:

| GPC fault                                     | Synchronous exception type                          |
|-----------------------------------------------|-----------------------------------------------------|
| Granule Protection Fault (GPF) at EL3         | Instruction Abort exception or Data Abort exception |
| GPF at EL2, EL1, or EL0 when SCR_EL3.GPF is 0 | Instruction Abort exception or Data Abort exception |
| GPF at EL2, EL1, or EL0 when SCR_EL3.GPF is 1 | GPC exception                                       |
| Granule Protection Table (GPT) walk faults    | GPC exception                                       |
| GPT address size faults                       | GPC exception                                       |
| Synchronous External abort on GPT fetch       | GPC exception                                       |

RFXMGJ

GPC exceptions are taken to EL3.

Instruction Abort exceptions and Data Abort exceptions resulting from GPFs at:

- EL3 are taken to EL3.
- EL2 are taken to EL2.
- EL1 and EL0 are taken to:
- -EL2 when the GPF is on an access for a stage 2 translation table, including for a hardware update of stage 2 tables.
- -Otherwise:
- -EL1 when HCR\_EL2.{TGE, GPF} is {0, 0}.
- -EL2 when HCR\_EL2.{TGE, GPF} is not {0, 0}.

IXWVCY For GPFs at EL2, EL1, or EL0 when SCR\_EL3.GPF is 1, EL3 firmware can choose to delegate the resulting GPC exception to a lower Exception level, as an Instruction Abort exception or Data Abort exception.

RJXSRX

When the PE is in Debug state and EDSCR.SDD is 1, SCR\_EL3.GPF is treated as 0, and the following GPC faults are treated as a GPF for the purposes of causing an exception:

- GPT walk faults.
- GPT address size faults.
- Synchronous External abort on GPT fetch.

IZTKNY GPC exceptions due to a synchronous External abort on GPT fetch are subject to SCR\_EL3.EASE.

IYJLPJ

All GPC faults are reported with a priority consistent with the GPC being performed on any access to PA space. That is, for each existing synchronous External abort, GPC faults are reported with immediately higher priority than the corresponding synchronous External abort for that access. See MMU fault prioritization from a single address translation stage.

IYHXKR

RRWGJH

IZDKBX

RGVSNZ

IRFMWD

When GPCCR\_EL3.GPCP is 1, the PE can omit GPCs on fetches of translation table entries that are Table descriptors for stage 2 translation table walks, for a performance optimization. Enabling this optimization is dependent on the security model of the system.

If GPCCR\_EL3.GPCP is 1 and the PE omits a GPC when fetching a translation table entry that is a Table descriptor for a stage 2 translation table walk, then when the entry is processed:

- If the entry is not a Table descriptor, the PE must complete a GPC on the address of the entry before the translation completes. This is permitted to occur concurrently with a GPC on the entry content, as long as the priority order for fault reporting is maintained.
- Arm strongly recommends that the PE perform a GPC on the address of the entry if the entry generates a fault that would report syndrome information from that entry. If the GPC results in a GPC fault, the fault is reported as though GPCCR.EL3.GPCP is 0.

When a load or store instruction results in accesses to two granules, the access to each granule is subject to a GPC.

If an instruction that stores to memory generates a GPC fault, the value of each memory location that instruction attempted to store to is either:

- Unchanged if access to the location triggered the GPC fault.
- UNKNOWN for any location for which access did not trigger a fault or debug event.

AGPCfault might occur at any point in the translation process that requires access to a PA. For example, to perform a store at EL1, a PE performs:

- Astage 1 translation for the V A.
- Stage 2 translations for:
- -The output IPA from the stage 1 translation.
- -The IPA of each stage 1 descriptor.
- GPCs for all of:
- -The PA that the V A translates to.
- -The PA of each stage 1 descriptor.
- -The PA of each stage 2 descriptor.

## D1.4.5.4 SVE synchronous memory faults

| I YLCFS   | In this section, the term Memory fault refers to the detection of an erroneous condition or debug event as a result of performing a data memory access for an SVE load or store instruction.                                                                                                                                                                                                                                                                                   |
|-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| R SKNTR   | When an SVE load or store instruction results in a data memory access, the detection of any of the following conditions is considered to be a Memory fault : • MMUfault.                                                                                                                                                                                                                                                                                                       |
| I LDTYT   | The detection or generation of a Memory fault by an SVE load or store instruction may or may not cause a synchronous Data Abort or Watchpoint exception to be taken.                                                                                                                                                                                                                                                                                                           |
| R LVCNH   | Unless otherwise specified in this section, SVE vector load and store instructions that detect a Memory fault cause a Data Abort or Watchpoint exception to be taken, as described in SVE Data Abort and Watchpoint exceptions.                                                                                                                                                                                                                                                |
| R FPVTT   | A Memory fault detected for a memory location that can only be accessed by an Inactive element of a predicated SVE vector load or store instruction is ignored and does not cause a Data Abort or Watchpoint exception to be taken by that instruction.                                                                                                                                                                                                                        |
| R KJPTS   | Unless otherwise specified in this section, a Data Abort and Watchpoint exception caused by an SVE load or store instruction follows the behaviors described in Definition of a precise exception and imprecise exception, Exception entry, and Prioritization of Synchronous exceptions taken to AArch64 state.                                                                                                                                                               |
| I DGSNC   | SVE load and store instructions can generate a sequence of single-copy atomic memory accesses that might not be completed due to a Memory fault causing a Data Abort or Watchpoint exception to be taken during the memory access sequence.                                                                                                                                                                                                                                    |
| R ZKBRX   | When the execution of an SVE load or store instruction detects multiple Memory faults caused by different single-copy atomic memory accesses, the Memory faults are not prioritized by the architecture.                                                                                                                                                                                                                                                                       |
| I MSVYK   | When an SVE load or store instruction that has not been architecturally executed is restarted after an exception return, any memory locations that it accessed before taking the exception might be accessed again. Therefore, SVE load or store instructions might perform multiple accesses to memory locations that do not cause a Memory fault but which are sensitive to the number of accesses, or have been modified between the accesses.                              |
| R ZXNXT   | When execution of an SVE load instruction causes a Data Abort or Watchpoint exception to be taken and the destination is not a vector register that is also used as a base or index register by the instruction, then all elements of the destination register become UNKNOWN.                                                                                                                                                                                                 |
| R SNJQR   | When execution of an SVE load instruction causes a Data Abort or Watchpoint exception to be taken and the destination is a vector register that is also used as a base or index register by the instruction, then all elements of the destination vector register are restored to their original value prior to execution of the load instruction.                                                                                                                             |
| R DWYCY   | When execution of an SVE predicated vector store instruction causes a Data Abort or Watchpoint exception to be taken, one or more of the following occurs: • Memory locations that are associated with Active elements and which do not generate a Memory fault become UNKNOWN. • Memory locations that are associated with Active elements and which generate a Memory fault are unchanged. • Memory locations that are only associated with Inactive elements are unchanged. |

## D1.4.5.4.2 SVE First-fault and Non-fault loads

IJZBGW When a memory access performed for the First active element of an SVE First-fault vector load instruction detects a Memory fault , this causes a synchronous exception to be taken as described in SVE Data Abort and Watchpoint exceptions.

- IDXBNG When a memory access performed for the First active element of an SVE First-fault vector load instruction does not detect a Memory fault , the other elements are handled in the same way as the elements of an SVE Non-fault vector load instruction.
- RJKGYJ is detected by a memory access performed

AData Abort or Watchpoint exception is not generated when a Memory fault for any of the following elements:

- Any Active element of an SVE Non-fault vector load.
- Any Active element of an SVE First-fault vector load except for the First active element .
- RMNKNV The PE can choose to suppress a memory access performed for any of the following elements:
- Any Active element of an SVE Non-fault vector load.
- Any Active element of an SVE First-fault vector load except for the First active element .

RYFTRN When a memory access performed for any of the following elements detects a Memory fault , an asynchronous Tag check fault, or is suppressed for any other reason, the FFR predicate elements starting from that element number, up to and including the highest-numbered element, are set to FALSE:

- Any Active element of an SVE Non-fault vector load.
- Any Active element of an SVE First-fault vector load except for the First active element .

Note

An asynchronous Tag check fault setting elements in FFR to FALSE is required to be synchronous with respect to the instruction stream as per RXXMMP.

IBMQVT An FFR predicate element is never set to TRUE by an SVE vector load, therefore the fault indications are cumulative.

IBXNTL Amemory access performed for the First active element of an SVE First-fault vector load instruction is not precisely equivalent to the memory access for an Active element of a regular SVE predicated vector load instruction. When the initial value of the FFR element corresponding to the First active element is FALSE, then even if an access is performed for that element and does not detect a Memory fault , the content of the corresponding destination vector element is still

CONSTRAINED UNPREDICTABLE, as described in rule RNGFTJ.

- RNGFTJ After an SVE Non-fault vector load or First-fault vector load is executed, each destination vector element contains one of the values listed in the following table:

## Table D1-8 Contents of destination vector element after an SVE Non-fault vector load or First-fault vector load

| Corresponding FFR element   | Vector element status   | Content of destination vector element                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|-----------------------------|-------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| FALSE                       | Active                  | Each byte of the element contains an independently CONSTRAINED UNPREDICTABLE choice of one of the following: • 0. • The previous value of that byte in the destination vector register. • If and only if all of the following apply, the value read from memory: - The memory access for that byte was not an access to any type of Device memory, or for a First-fault vector load was an access to Device memory inside the 64-byte window of the First active element. See Device memory for more information. - The memory access for that byte does not return information that cannot be accessed at the current or a lower level of privilege. |
| FALSE                       | Inactive                | ACONSTRAINED UNPREDICTABLE choice of: • 0. • The previous value of that vector element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| TRUE                        | Active                  | The value read from memory.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| TRUE                        | Inactive                | 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |

RWCHSR

In Table D1-8, watchpoints and MTE Tag check faults are not a mechanism for preventing access to memory.

## D1.4.5.5 Undefined Instruction exceptions injected by PSTATE.UINJ

RNKNRG If FEAT\_UINJ is implemented, then any attempt to execute any instruction when PSTATE.UINJ is 1 causes an Undefined Instruction exception with ESR\_ELx.EC 0b000000 .

IHPGHL

RZFGJP

Software can set SPSR\_ELx.UINJ to 1, and on exception return that value is copied to PSTATE.UINJ. Then, when the PE attempts to execute the next instruction, an Undefined Instruction exception occurs.

## D1.4.5.6 Prioritization of Synchronous exceptions taken to AArch64 state

The following list shows the priorities for synchronous exceptions taken to an Exception level using AArch64. The highest priority is 1. The AArch64 priority numbers correlate with the equivalent AArch32 and Debug prioritization lists.

|   Priority | Synchronous exception type                                                                                                                                    |
|------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
|          1 | Reset Catch debug event. See Reset Catch debug events.                                                                                                        |
|          2 | Exception Catch debug event if it has a priority of 2. See Exception Catch debug event.                                                                       |
|          3 | Halting Step debug event. See Halting Step debug events.                                                                                                      |
|          4 | Software Step exception. See Software Step exceptions.                                                                                                        |
|          5 | Synchronous PMUexception. See Synchronous exception-based event profiling.                                                                                    |
|          6 | Exception Catch debug event if it has a priority of 6. See Exception Catch debug event.                                                                       |
|          7 | PC alignment fault exception. See PC alignment checking.                                                                                                      |
|          8 | Illegal Execution state exceptions. It is IMPLEMENTATION DEFINED whether this is prioritized here or at 11. See Illegal exception returns from AArch64 state. |

|   Priority | Synchronous exception type                                                                                                                                                                                                                                                            |
|------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|          9 | Instruction Abort exceptions, including exceptions generated by an MMUfault for the translation of an instruction fetch. If FEAT_RME is implemented, this includes GPC exceptions and Granule Protection Faults. See MMUfault prioritization from a single address translation stage. |
|         10 | Breakpoint exceptions, or AArch32 Address Matching Vector Catch exceptions. See Breakpoint exceptions and Vector Catch exceptions.                                                                                                                                                    |
|         11 | Illegal Execution state exceptions. It is IMPLEMENTATION DEFINED whether this is prioritized here or at 8. See Illegal exception returns from AArch64 state.                                                                                                                          |
|         12 | If FEAT_UINJ is implemented, an Undefined Instruction exception caused by an attempt to execute an instruction when PSTATE.UINJ is 1.                                                                                                                                                 |
|         13 | Software Breakpoint exceptions, caused by execution of a Breakpoint instruction.                                                                                                                                                                                                      |
|         14 | Branch Target exception. See PSTATE.BTYPE.                                                                                                                                                                                                                                            |
|         15 | EXLOCKException. See Guarded Control Stack exceptions.                                                                                                                                                                                                                                |
|         16 | Exceptions taken to EL3 due to the MPAM3_EL3.TRAPLOWER trap control.                                                                                                                                                                                                                  |
|         17 | Exceptions taken to EL3 due to the MPAMBW3_EL3.nTRAPLOWER trap control.                                                                                                                                                                                                               |

Exceptions taken from EL1 to EL2 because of the configuration of one of the following:

- HSTR\_EL2.Tn.
- HCR\_EL2.TIDCP.
- If FEAT\_NV is implemented, the Effective value of HCR\_EL2.{NV1, NV}.

Exceptions taken from EL0 to EL1 or EL2 because of the configuration of the following:

- If FEAT\_TIDCP1 is implemented, SCTLR\_EL1.TIDCP.

Exceptions taken from EL0 to EL2 because of the configuration of the following:

- If FEAT\_TIDCP1 is implemented, SCTLR\_EL2.TIDCP.

18

| Priority   | Synchronous exception type                                                                                                                                                                                                                                                               |
|------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 19         | Exceptions that occur as a result of attempting to execute an instruction that is UNDEFINED for one or more of the following reasons:                                                                                                                                                    |
|            | • Attempting to execute a UDF instruction.                                                                                                                                                                                                                                               |
|            | • Attempting to execute an unallocated instruction encoding, including an encoding for an instruction that is not implemented in the PE implementation.                                                                                                                                  |
|            | • Attempting to execute an instruction that is defined to never be accessible at the current Exception level and Security state, regardless of any enables or traps.                                                                                                                     |
|            | • Debug state execution of an instruction encoding that is not accessible in Debug state.                                                                                                                                                                                                |
|            | • Non-debug state execution of an instruction encoding that is not accessible in Non-debug state.                                                                                                                                                                                        |
|            | • Attempting to execute an HVC instruction, when HVC instructions are disabled by SCR_EL3.HCE or HCR_EL2.HCD.                                                                                                                                                                            |
|            | • Attempting to execute an MSR or MRS instruction to SP_EL0, when SPSel.SP is 0.                                                                                                                                                                                                         |
|            | • Attempting to execute an MSR or MRS instruction using an _EL12 register name, when the Effective value of HCR_EL2.E2H is 0.                                                                                                                                                            |
|            | • If FEAT_FGT and FEAT_PMUv3 are implemented, attempting to execute an MSR or MRS instruction in AArch64 state, or an MCR or MRC instruction in AArch32 state, that accesses a register associated with an unimplementedPMU event counter.                                               |
|            | • If FEAT_SRMASK is implemented, attempting to execute an MSR write access to any of the following: - An EL1 mask register from EL1, when the EL1 mask register is nonzero and the access is not trapped. - An EL2 mask register from EL2, when the EL2 mask register is nonzero.        |
|            | • Attempting to execute an HLT instruction, when HLT instructions are disabled by EDSCR.HDE or halting is prohibited.                                                                                                                                                                    |
|            | • Attempting to execute an SVE instruction that is UNDEFINED because the Maximum implemented SVE vector length in both Streaming SVE mode, and Non-streaming SVE mode, is less than the minimum required vector length for that instruction. See Maximum implemented SVE vector lengths. |
|            | • Attempting to execute an SMEinstruction that is UNDEFINED because the Maximum implemented Streaming SVE vector length is less than the minimum required vector length for that instruction. See Maximum implemented SVE vector lengths.                                                |
|            | • Attempting to execute an SVE MOVPRFX instruction with an immediately following instruction that the MOVPRFX cannot predictably prefix, when the choice of resulting behavior is for either instruction to generate an Undefined Instruction exception. See Move prefix.                |

| Priority   | Synchronous exception type                                                                                                                                                                                                                                    |
|------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 19 cont'd  | • If in Debug state:                                                                                                                                                                                                                                          |
| 20         | If FEAT_SME or FEAT_SVE is implemented, an exception taken to EL1, or to EL2 if HCR_EL2.TGE is 1, due to one of the following trap controls:                                                                                                                  |
| 21         | If all of the following apply, any exception that is generated by a configurable trap or enable: • The exception is not already covered by priorities 4-20. • The exception is taken to EL1, or, if HCR_EL2.TGE is 1, is taken to EL2.                        |
| 22         | As the result of one of the following configuration controls, an exception taken from EL0 to EL2: • When the exception is taken to AArch64 state: - HSTR_EL2.T n . - HCR_EL2.TIDCP. • When the exception is taken to AArch32 state: - HSTR.T n . - HCR.TIDCP. |
|            | If FEAT_SME or FEAT_SVE is implemented, an exception taken to EL2 due to one of the following trap                                                                                                                                                            |
| 23         | controls: • CPTR_EL2.SMEN or CPTR_EL2.ZEN, when the Effective value of HCR_EL2.E2H is 1. • CPTR_EL2.TSM or CPTR_EL2.TZ, when the Effective value of HCR_EL2.E2H is 0.                                                                                         |

| Priority   | Synchronous exception type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 24         | As the result of one of the following configuration controls, an exception taken to EL2: • When the exception is taken to AArch64 state: controls in CPTR_EL2, other than those controls covered in priority                                                                                                                                                                                                                                                                                                                                                   |
| 25         | As the result of a configuration control in one of the following registers, an exception taken to EL2: • When the exception is taken to AArch64 state: - HCR_EL2: Other than a setting made in the {TIDCP, NV} fields, and MRS/MSR instruction using an _EL12 register name when the Effective value of HCR_EL2.E2H is 0. - CNTHCTL_EL2: Any setting. - MDCR_EL2: Any setting. Any of the following fine-grained traps: - HAFGRTR_EL2. - HDFGRTR_EL2. - HDFGRTR2_EL2. - HDFGWTR_EL2. - HDFGWTR2_EL2. - HFGITR_EL2. - HFGITR2_EL2. - HFGRTR_EL2. - HFGRTR2_EL2. |
| 26         | Other than an exception defined by priorities 4-25 inclusive, any exception that is the result of a configurable access to instructions, where the exception is taken to EL2.                                                                                                                                                                                                                                                                                                                                                                                  |
| 27         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|            | An exception caused by the SMCinstruction being UNDEFINED because SCR_EL3.SMD is 1. An exception caused by any of the following Exception generating instructions: • HVC . • SMC . • SVC .                                                                                                                                                                                                                                                                                                                                                                     |
| 28         | For AArch64 State, see Branches, Exception generating, and System instructions.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 29         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|            | If FEAT_SME or FEAT_SVE is implemented, an exception taken to EL3 due to one of the following trap controls: • CPTR_EL3.ESM or CPTR_EL3.EZ.                                                                                                                                                                                                                                                                                                                                                                                                                    |
|            | An exception taken to EL3 as the result of configuration controls in CPTR_EL3, other than those controls covered in 29. It is IMPLEMENTATION DEFINED whether the exception is prioritized as an UNDEFINED instruction or has the priority of                                                                                                                                                                                                                                                                                                                   |
| 30         | priority the original Trap exception.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |

|   Priority | Synchronous exception type                                                                                                                                                                                                                                                                                                                                                                                                           |
|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         31 | Exceptions Trapped to EL3 from Secure EL1 using AArch32.                                                                                                                                                                                                                                                                                                                                                                             |
|         32 | An Exception taken to EL3 from EL0, EL1, or EL2 as a result of configuration controls in MDCR_EL3. It is IMPLEMENTATION DEFINED whether the exception is prioritized as an UNDEFINED instruction or has the priority of the original Trap exception.                                                                                                                                                                                 |
|         33 | Other than an exception defined by priorities 4-32, inclusive, any exception taken to EL3 because of a configurable access to an instruction. If an exception generated by a configurable instruction control is treated as UNDEFINED as a result of EDSCR.SDD configuration, then it is IMPLEMENTATION DEFINED whether the exception is prioritized as an UNDEFINED instruction or has the priority of the original Trap exception. |
|         34 | SME illegal instruction exceptions due to attempting to execute an SMEinstruction when PSTATE.SM is 0, or attempting to execute certain Advanced SIMD or SVE instructions when PSTATE.SM is 1. See Streaming SVE mode.                                                                                                                                                                                                               |
|         35 | SMEillegal instruction exceptions due to attempting to access ZA storage or the ZT0 register when PSTATE.ZA is 0. See ZAstorage and SME2 ZT0 register.                                                                                                                                                                                                                                                                               |
|         36 | SMEillegal instruction exceptions due to attempting to access the ZT0 register when an SMCR_ELx.EZT0 control is 0. See SME2 ZT0 register and SMEtraps and exceptions.                                                                                                                                                                                                                                                                |
|         37 | An exception as a result of attempting to execute an SVE or SMEinstruction that is UNDEFINED because the Effective SVE vector length is less than the minimum required vector length for that instruction. See also Configurable SVE vector lengths.                                                                                                                                                                                 |
|         38 | When FEAT_FPAC is implemented, a PAC Fail exception. See Faulting on pointer authentication.                                                                                                                                                                                                                                                                                                                                         |
|         39 | When SIMD &Floating Point is implemented, any trapped floating-point exception. See Floating-point exceptions and exception traps.                                                                                                                                                                                                                                                                                                   |
|         40 | This priority number is used by debug events.                                                                                                                                                                                                                                                                                                                                                                                        |
|         41 | An SP alignment fault. See SP alignment checking.                                                                                                                                                                                                                                                                                                                                                                                    |
|         42 | When FEAT_MOPS is implemented, Memory Copy and Memory Set exceptions caused by the CPY* or SET* instruction algorithm option of the implementation that an exception is taken from being different from the algorithm option of the implementation that is returned to. See Memory Copy and Memory Set exceptions.                                                                                                                   |
|         43 | When FEAT_MOPS is implemented, Memory Copy and Memory Set exceptions that are not defined by priority 42. See Memory Copy and Memory Set exceptions.                                                                                                                                                                                                                                                                                 |

For priorities 44, 45, 46, 47 or 48: when an instruction results in more than one single-copy atomic memory access, the architecture will not prioritize the individual Synchronous exceptions generated as the result of the multiple memory accesses. When FEAT\_GCS is implemented, a stricter requirement is defined for the GCSSS2 instruction in RXTZVS.

## 44

In descending priority order:

- a) Data Abort exceptions on translation table walks and translation table entry updates.
- b) GPC Exceptions on translation table walks and translation table entry updates, if FEAT\_RME is implemented.
- c) Data Abort exceptions due to synchronous External aborts on translation table walks and translation table entry updates.
- d) Data Abort exceptions arising from an MMU fault not on a translation table walk, that are not covered by priorities 45 or 47.

See also:

- MMUfault prioritization from a single address translation stage.
- External aborts.

| Priority   | Synchronous exception type                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 45         | If prioritized here, then in descending priority order: a) Data Abort exceptions due to a Granule Protection Fault (GPF) on the final physical address access of the address translation process, if FEAT_RME is implemented. b) GPC exceptions on the final physical address access of the address translation process, if FEAT_RME is implemented. c) Any of: i) Data Abort exceptions due to synchronous External aborts on the final physical address access of the |
|            | address translation process. ii) Data Abort exceptions on Tag Check Faults, if FEAT_MTE2 is implemented.                                                                                                                                                                                                                                                                                                                                                                |
| 46         | Watchpoint exception. See Watchpoint exceptions.                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 47         | The exceptions listed for priority 45 if they are prioritized as 47.                                                                                                                                                                                                                                                                                                                                                                                                    |
| 48         | Guarded Control Stack Data Check exceptions. See Guarded Control Stack exceptions.                                                                                                                                                                                                                                                                                                                                                                                      |

## D1.4.5.7 Trapping of floating-point exceptions

| R TSQFJ   | Execution of a floating-point instruction, or execution of an Advanced SIMD or SVE instruction that performs floating-point operations, can generate an exceptional condition, called a floating-point exception.                                                                                                                                                                                 |
|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| R BBSGN   | For each of the following floating-point exceptions, it is IMPLEMENTATION DEFINED whether an implementation includes synchronous exception generation:                                                                                                                                                                                                                                            |
| I YRVSW   | The architecture does not support asynchronous reporting of floating-point exceptions. If an implementation does not support synchronous exception generation from a floating-point exception, then that synchronous exception is never generated and all statements on when that synchronous exception is generated do not apply.                                                                |
| I KJTLV   | For any of the implemented floating-point exceptions listed inR BBSGN , FPCR provides control bits to enable synchronous exception generation.                                                                                                                                                                                                                                                    |
| R VJFJR   | The Exception level that a Trapped Floating-point exception is taken to is defined as follows: • If executing at EL0: - If the Effective value of HCR_EL2.TGE is 0, the exception is taken to EL1. - If the Effective value of HCR_EL2.TGE is 1, the exception is taken to EL2. • If executing at EL1, the exception is taken to EL1.                                                             |
| R TRWMV   | If an implementation includes synchronous exception generation for floating-point exceptions in AArch64 state, when the execution of separate operations in separate SIMD or SVE elements causes multiple floating-point exceptions, the ESR_ELx reports only the exceptions associated with one element that the instruction uses. The architecture does not specify which element is reported.  |
| R         | When a floating-point exception is trapped, all of the following apply: • When the trapped floating-point exception is taken, it is IMPLEMENTATION DEFINED whether the FPSR is                                                                                                                                                                                                                    |
| VJNYH     | restored to the value of the FPSR immediately before the instruction that generated the trapped floating-point exception.When the trapped floating-point exception is taken, if the FPSR is not restored, it is CONSTRAINED UNPREDICTABLE which untrapped floating-point exceptions, if any, are indicated by the corresponding FPSR cumulative floating-point exception bits having the value 1. |
| R FTPRW   | For trapped floating-point exceptions from Advanced SIMD or SVE instructions, the architecture does not define the floating-point exception prioritization between different elements of the instruction. D1.4.5.8 Memory Copy and Memory Set exceptions                                                                                                                                          |
| I TPJXM   | If an exception is taken during the execution of Memory Copy and Memory Set instructions, and execution of these instructions restarts on a physical hardware PE implementation that is different from where the exception was taken from, then a Memory Copy or Memory Set exception can be generated.                                                                                           |
| R JQZHK   | For CPYE*, CPYFE*, CPYFM*, and CPYM*instructions, if the instruction algorithm option indicated by the value                                                                                                                                                                                                                                                                                      |
|           | of PSTATE.C is different from the PSTATE.C value of the implementation, then a Memory Copy exception is generated.                                                                                                                                                                                                                                                                                |

RXQQXB

RPHLLT

RBKCPW

IQJFTK

For SETE*, SETGE*, SETGM*, and SETM* instructions, if the instruction algorithm option indicated by the value of PSTATE.C is different from the PSTATE.C value of the implementation, then a Memory Set exception is generated.

For CPYE*, CPYFE*, CPYFM*, and CPYM* instructions, if the instruction alignment and size requirements of the implementation that an exception is taken from are different from the alignment and size requirements of the implementation that is returned to, then a Memory Copy exception is generated.

For SETE*, SETGE*, SETGM*, and SETM* instructions, if the instruction alignment and size requirements of the implementation that an exception is taken from are different from the alignment and size requirements of the implementation that is returned to, then a Memory Set exception is generated.

The Memory Copy and Memory Set exceptions that are caused by alignment and size requirement differences can be avoided if the following apply:

- The CPYFP*, CPYP*, SETGP*, or SETP* instruction is executed before the appropriate CPYFM*, CPYM*, SETGM*, or SETM* on the same implementation.
- The CPYFM*, CPYM*, SETGM*, or SETM* instruction is executed before the appropriate CPYFE*, CPYE*, SETGE*, or SETE* on the same implementation.

ILNTYW The generic return routine for Memory Copy and Memory Set exceptions is to adjust the register arguments to be consistent with performing a new memory copy or memory set, and then to return to the CPYFP*, CPYP*, SETGP*, or SETP* instruction to restart the memory copy or memory set.

ITTVQX

The generic return routine for Memory Copy and Memory Set exceptions can be used by relying on the Memory Copy and Memory Set instructions being placed consecutively in memory - prologue, then main, and then epilogue.

ICNTMJ

IMWFQH

IPRXVQ

The generic return routine for Memory Copy exceptions is shown in the following pseudocode:

```
if FormatOption == 0b00 || FormatOption == 0b11 then //format is from option B if SPSR_ELx.N=='1' then //backward copy DestReg = DestReg - SizeReg; SrcReg = SrcReg -SizeReg; else // format is from option A; if SizeReg<63>=='1' then // forward copy DestReg = DestReg + SizeReg; SrcReg = SrcReg + SizeReg; SizeReg = -1*SizeReg; if FromEpilogue then ReturnAddress = ELR_ELx - 8; else ReturnAddress = ELR_ELx - 4;
```

The generic return routine for Memory Set exceptions is shown in the following pseudocode:

```
if FormatOption == 0b01 || FormatOption == 0b10 then // format is from Option A // forward set DestReg = DestReg + SizeReg; SizeReg = -1*SizeReg; if FromEpilogue then ReturnAddress = ELR_ELx - 8; else ReturnAddress = ELR_ELx - 4;
```

The information in SPSR\_ELx.C (or, equivalently, the ESR\_ELx.ISS.FormatOption field), SPSR\_ELx.N, and the sign of the value in the Xn register is sufficient to determine the current format of the Xd, Xs, and Xn registers, and perform any required reformatting, before restarting the memory copy or memory set. However, it is not required to use FEAT\_MOPS instructions and the memory copy or memory set could alternatively be restarted using a software implementation.

RZHRJP

INXHPS

IZWLQV

The Exception levels that Memory Copy and Memory Set exceptions are taken to are as follows:

- From EL0, to EL1 if HCR\_EL2.TGE is 0. Otherwise, they are taken to EL2.
- From EL1, to either EL1 or EL2, depending on the value of HCRX\_EL2.MCE2.
- From EL2 or EL3, to the same Exception level.

The HCRX\_EL2.MCE2 control bit allows Memory Copy and Memory Set exceptions to be handled in a system where Memory Copy and Memory Set instructions might be used at EL1 at times when taking an exception to EL1 is not acceptable. This is necessary only if there is a possibility of the migration of EL1 code between different physical hardware PE implementations when EL1 is not tolerant of taking an exception.

Arm expects that software running at EL1 will only enable EL0 use of the Memory Copy and Memory Set instructions with SCTLR\_EL1.MSCEn if it implements the generic return routine for Memory Copy and Memory Set exceptions.

## D1.4.6 Asynchronous exception types

RZNTKG

The Arm architecture Exception model distinguishes the following classes of asynchronous exceptions:

- Physical Interrupts
- Virtual Interrupts
- PMUexceptions, see Exception-based event profiling.

There are the following types of physical interrupt:

- SError (also described as a System Error)
- IRQ
- FIQ

There are the following types of virtual interrupt:

- vSError (also described as a Virtual System Error)
- Delegated SError
- vIRQ
- vFIQ
- Physical interrupt masking.
- Virtual asynchronous exception masking.

RSLLMN

IRQ, FIQ, vIRQ, and vFIQ interrupts are precise asynchronous exceptions.

RGGWMZ

If FEAT\_NMI is implemented, then IRQ, FIQ, vIRQ, and vFIQ interrupts can have Superpriority as an additional attribute.

IPYQBL

When SCTLR\_ELx.NMI is 0, the attribute of Superpriority has no effect on interrupts taken to ELx. See also:

The mechanism by which Superpriority is assigned is IMPLEMENTATION DEFINED.

Each physical interrupt type can be assigned a target Exception level of EL1, EL2, or EL3.

ISR\_EL1 shows the pending status of the physical interrupts, the physical SError exception, the virtual interrupts, and the virtual and delegated SError exceptions, as follows:

- When read from EL1:
- -The pending status of whichever virtual interrupts are enabled, and of the virtual SError exception if enabled. If the virtual SError exception is not enabled and the delegated SError exception is enabled, the pending status of the delegated SError exception.
- When read from EL2:
- -The pending status of the delegated SError exception, if the delegated SError exception is enabled.

Otherwise, when read from EL1, EL2, or EL3, the pending status of the physical interrupts, and of the physical SError exception.

An implementation might support other mechanisms for signaling a virtual interrupt.

RPBKNX

RDXHJZ

IVMWYT

IRWYFW

| I WRGNC   | The following Profiling exceptions can also be asynchronous exceptions: • PMUProfiling exceptions. See Exception-based event profiling. • TRBE Profiling exceptions. See Trace buffer management.                                                                                                                                                         |
|-----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| I XHCGZ   | The mechanism by which physical interrupts are signaled to the PE are IMPLEMENTATION DEFINED and might be either edge or level sensitive. Acommon implementation choice is that the IRQ and FIQ interrupts are level sensitive, and this is supported by the Generic Interrupt Controller (GIC).                                                          |
| I YSKZH   | The physical SError exception is often used, amongst other things, for communicating External aborts from the memory system that are to be taken asynchronously. For more information, see PE error handling.                                                                                                                                             |
| R KTWMT   | For an External abort generated by the memory system that is taken asynchronously using the SError exception, the SError exception always behaves as an edge-triggered interrupt. For any other sources of SError exceptions, it is IMPLEMENTATION DEFINED whether they are edge-triggered or level-sensitive.                                            |
| R HSFRC   | When taking the SError exception to an Exception level using AArch64, ESR_ELx at the target Exception level is updated to describe the SError exception. If FEAT_RAS is implemented, then:                                                                                                                                                                |
| R RKDNV   | When taking an IRQ, vIRQ, FIQ or vFIQ interrupt to an Exception level using AArch64, ESR_ELx at the target Exception level is not updated.                                                                                                                                                                                                                |
| R MLLVN   | Each virtual interrupt type can be independently enabled from EL2. If a virtual interrupt type is enabled from EL2, the target Exception level for the corresponding physical interrupt is not EL1.                                                                                                                                                       |
| R RTLGR   | Pending vIRQ and vFIQ interrupts can be assigned Superpriority by using controls in HCRX_EL2.                                                                                                                                                                                                                                                             |
| R BCXJB   | If HCR_EL2.TGE is 0, then setting an HCR_EL2.{FMO, IMO} routing control bit to 1 enables the corresponding virtual interrupt. If HCR_EL2.TGE is 1, then virtual interrupts are disabled.                                                                                                                                                                  |
| R CDCKC   | If HCR_EL2.TGE is 0, then setting the Effective value of either the HCR_EL2.AMO or HCRX_EL2.TMEA routing control bit to 1 enables the virtual SError exception. If HCR_EL2.TGE is 1, then virtual SError exceptions are disabled.                                                                                                                         |
| R NVFXB   | If a virtual asynchronous exception type is enabled, that type of interrupt can be generated by any one of the following: • Execution at EL0 or EL1 if the corresponding virtual interrupt pending bit, HCR_EL2.{VSE, VI, VF}, is 1. • For a vIRQ or a vFIQ, by an IMPLEMENTATION DEFINED mechanism. This might be a signal from an interrupt controller. |
| R SDVLM   | If a virtual interrupt is disabled, the virtual interrupt cannot be taken.                                                                                                                                                                                                                                                                                |
| I NJPHG   | The following table describes the bits that enable virtual interrupts, the bits that cause virtual asynchronous exceptions to be pending in HCR_EL2, and the bits that enable signaling of pending virtual interrupts with Superpriority in HCRX_EL2:                                                                                                     |

| Virtual asynchronous exception type   | Enable control               | Cause a virtual asynchronous exception to be pending   | Pending virtual interrupt has Superpriority   |
|---------------------------------------|------------------------------|--------------------------------------------------------|-----------------------------------------------|
| vSError                               | HCR_EL2.AMO or HCRX_EL2.TMEA | HCR_EL2.VSE                                            | n/a                                           |
| vIRQ                                  | HCR_EL2.IMO                  | HCR_EL2.VI                                             | HCRX_EL2.VINMI                                |
| vFIQ                                  | HCR_EL2.FMO                  | HCR_EL2.VF                                             | HCRX_EL2.VFNMI                                |

RMZWNH

When taking a vIRQ or a vFIQ interrupt, the corresponding virtual interrupt pending bit in HCR\_EL2 retains its state.

IQVCWH

If the virtual interrupt pending bits are used, the vIRQ or vFIQ exception handler must cause software executing at EL2 or EL3 to set their corresponding virtual interrupt pending bits to 0.

IYPRNB

When taking a vSError exception, HCR\_EL2.VSE is cleared to 0.

ILFSXS

Avirtual SError is never taken to EL2 or EL3, regardless of the values of HCRX\_EL2.TMEA and SCR\_EL3.TMEA.

## D1.4.6.2 Delegated SErrors

INVRSW

If FEAT\_E3DSE is implemented, delegated SError exceptions are defined by SCR\_EL3.EnDSE, SCR\_EL3.DSE, VSESR\_EL3, and VDISR\_EL3.

RTNWJT

If the Effective value of SCR\_EL3.{EA, TMEA} is not {0, 0}, then setting the Effective value of the SCR\_EL3.EnDSE control bit to 1 enables the delegated SError exception.

If the Effective value of SCR\_EL3.{EA, TMEA} is {0, 0}, or the Effective value of SCR\_EL3.EnDSE is 0, then delegated SError exceptions are disabled.

RWLQXL

If delegated SError exceptions are enabled, then setting SCR\_EL3.DSE to 1 pends a delegated SError exception while executing at EL0, EL1, or EL2 .

RRWMSM

If the delegated SError exception is disabled, the delegated SError exception cannot be taken.

IQKSJR

When taking a delegated SError exception, SCR\_EL3.DSE is cleared to 0.

ILVWLF

Adelegated SError is never taken to EL3, regardless of the value of SCR\_EL3.TMEA.

## D1.4.6.3 Establishing the target Exception level of an asynchronous exception

RQZPXL

The RNMMXK table uses the following terms:

| Term    | Meaning                                                                                                                                             |
|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| SCR_EL3 | The Effective value of a field in SCR_EL3.                                                                                                          |
| NS      | If FEAT_RME is implemented, then if Secure state is not implemented, the Effective value of SCR_EL3.NS is 1.                                        |
| EEL2    | If EL3 is not implemented, the Effective value of SCR_EL3.EEL2 is 1.                                                                                |
| IRQ FIQ | If EL3 is not implemented, the Effective value of these fields is 0.                                                                                |
| RW      | If EL3 is not implemented, the Effective value of SCR_EL3.RW is 1.                                                                                  |
| HCR     | If EL2 is using AArch32, this is the Effective value of a field in HCR. If EL2 is using AArch64, this is the Effective value of a field in HCR_EL2. |
| TGE     | If EL2 is not implemented, the Effective value of HCR.TGE or HCR_EL2.TGE is 0.                                                                      |
| IMOFMO  | If EL2 is not implemented, the Effective value of these fields is 0.                                                                                |
| E2H     | If EL2 is not implemented, the Effective value of HCR.E2H or HCR_EL2.E2H is 0.                                                                      |
| RW      | If EL2 is not implemented, the Effective value of HCR_EL2.RW is the same as the Effective value of SCR_EL3.RW.                                      |

| Term     | Meaning                                                                                                                                        |
|----------|------------------------------------------------------------------------------------------------------------------------------------------------|
| EL1      | The exception is taken to EL1 using AArch64.                                                                                                   |
| EL2      | The exception is taken to EL2 using AArch64.                                                                                                   |
| EL3      | The exception is taken to EL3 using AArch64.                                                                                                   |
| C        | The interrupt is not taken and remains pending, regardless of the PSTATE.{I, F, ALLINT} interrupt masks.                                       |
| IRQ, FIQ | The exception is taken to the AArch32 IRQ mode or the AArch32 FIQ mode accordingly.                                                            |
| Hyp      | The exception is taken to AArch32 Hyp mode.                                                                                                    |
| n/a      | Not applicable. The field does not exist in the register in this configuration or the Exception level is not accessible in this configuration. |

RNMMXK

The following table describes the routing of physical FIQ and IRQ interrupts if the highest implemented Exception level is using AArch64 and either EDSCR.INTdis is 0b00 or invasive debug is disabled.

## Table D1-12 FIQ and IRQ interrupt exception targets

| SCR_EL3   | SCR_EL3   |         | HCR   | HCR   | HCR     | HCR   | Target when taken from   | Target when taken from   | Target when taken from   | Target when taken from   | Target when taken from   |
|-----------|-----------|---------|-------|-------|---------|-------|--------------------------|--------------------------|--------------------------|--------------------------|--------------------------|
| NS        | EEL2      | IRQ FIQ | RW    | TGE   | IMO FMO | E2H   | RW                       | EL0                      | EL1                      | EL2                      | EL3                      |
| 0         | 0         | 0       | 0     | x     | x       | x     | x                        | IRQ, FIQ                 | IRQ, FIQ                 | n/a                      | C                        |
| 0         | 0         | 0       | 1     | x     | x       | x     | x                        | EL1                      | EL1                      | n/a                      | C                        |
| 0         | 0         | 1       | x     | x     | x       | x     | x                        | EL3                      | EL3                      | n/a                      | EL3                      |
| 0         | 1         | 0       | x     | 0     | 0       | 0     | 0                        | IRQ, FIQ                 | IRQ, FIQ                 | C                        | C                        |
| 0         | 1         | 0       | x     | 0     | 0       | 0     | 1                        | EL1                      | EL1                      | C                        | C                        |
| 0         | 1         | 0       | x     | 0     | 0       | 1     | x                        | EL1                      | EL1                      | C                        | C                        |
| 0         | 1         | 0       | x     | 0     | 1       | x     | x                        | EL2                      | EL2                      | EL2                      | C                        |
| 0         | 1         | 0       | x     | 1     | x       | x     | x                        | EL2                      | n/a                      | EL2                      | C                        |
| 0         | 1         | 1       | x     | 0     | x       | x     | x                        | EL3                      | EL3                      | EL3                      | EL3                      |
| 0         | 1         | 1       | x     | 1     | x       | x     | x                        | EL3                      | n/a                      | EL3                      | EL3                      |
| 1         | x         | 0       | 0     | 0     | 0       | n/a   | n/a                      | IRQ, FIQ                 | IRQ, FIQ                 | Hyp                      | C                        |
| 1         | x         | 0       | 0     | 0     | 1       | n/a   | n/a                      | Hyp                      | Hyp                      | Hyp                      | C                        |
| 1         | x         | 0       | 0     | 1     | x       | n/a   | n/a                      | Hyp                      | n/a                      | Hyp                      | C                        |
| 1         | x         | 0       | 1     | 0     | 0       | 0     | 0                        | FIQ                      | FIQ                      | C                        | C                        |
| 1         | x         | 0       | 1     | 0     | 0       | 0     | 1                        | EL1                      | EL1                      | C                        | C                        |
| 1         | x         | 0       | 1     | 0     | 0       | 1     | x                        | EL1                      | EL1                      | C                        | C                        |
| 1         | x         | 0       | 1     | 0     | 1       | x     | x                        | EL2                      | EL2                      | EL2                      | C                        |
| 1         | x         | 0       | 1     | 1     | x       | x     | x                        | EL2                      | n/a                      | EL2                      | C                        |
| 1         | x         | 1       | x     | 0     | x       | x     | x                        | EL3                      | EL3                      | EL3                      | EL3                      |
| 1         | x         | 1       | x     | 1     | x       | x     | x                        | EL3                      | n/a                      | EL3                      | EL3                      |

RZZYHK

The RMGNFZ and RVRBFW tables use the following terms:

| Term       | Meaning                                                                                                                                                                                                                                                                 |
|------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SCR_EL3    | The Effective value of a field in SCR_EL3.                                                                                                                                                                                                                              |
| EA         | If EL3 is not implemented, the Effective value of SCR_EL3.EA is 0.                                                                                                                                                                                                      |
| TMEA       | If FEAT_DoubleFault2 is not implemented, the Effective value of SCR_EL3.TMEA is 0.                                                                                                                                                                                      |
| NMEA       | If FEAT_DoubleFault is not implemented, the Effective value of SCR_EL3.NMEA is 0.                                                                                                                                                                                       |
| HCR_EL2    | The Effective value of a field in HCR_EL2.                                                                                                                                                                                                                              |
| HCR        | The Effective value of a field in HCR.                                                                                                                                                                                                                                  |
| TGE        | If EL2 is not implemented, or if EL2 is disabled in the current Security state, then the Effective value of HCR_EL2.TGE or HCR.TGE is 0.                                                                                                                                |
| E2H        | If EL2 is not implemented, or if EL2 is disabled in the current Security state, the Effective value of HCR_EL2.E2H is 0.                                                                                                                                                |
| AMO        | If EL2 is not implemented, or if EL2 is disabled in the current Security state, the Effective value of HCR_EL2.AMO or HCR.AMOis 0.                                                                                                                                      |
| SCTLR2_EL2 | The Effective value of a field in SCTLR2_EL2.                                                                                                                                                                                                                           |
| NMEA       | If FEAT_DoubleFault2 is not implemented, the Effective value of SCTLR2_EL2.NMEA is 0. If EL2 is not implemented or EL2 is disabled in the current Security state, or if the Effective value of SCR_EL3.SCTLR2En is 0, then the Effective value of SCTLR2_EL2.NMEA is 0. |
| HCRX_EL2   | The Effective value of a field in HCRX_EL2.                                                                                                                                                                                                                             |
| TMEA       | If FEAT_DoubleFault2 is not implemented, the Effective value of HCRX_EL2.TMEA is 0. If EL2 is not implemented or EL2 is disabled in the current Security state, or the Effective value of SCR_EL3.HXEn is 0, then the Effective value of HCRX_EL2.TMEA is 0.            |
| SCTLR2_EL1 | The Effective value of a field in SCTLR2_EL1.                                                                                                                                                                                                                           |
| NMEA       | If FEAT_DoubleFault2 is not implemented, the Effective value of SCTLR2_EL1.NMEA is 0. If the Effective value of HCRX_EL2.SCTLR2En is 0 or the Effective value of SCR_EL3.SCTLR2En is 0, then the Effective value of SCTLR2_EL1.NMEA is 0.                               |
| PSTATE     | The value of a field in PSTATE.                                                                                                                                                                                                                                         |
| A          | The value of PSTATE.A.                                                                                                                                                                                                                                                  |
| EL1        | The exception is taken to EL1. If EL1 is using AArch32, then the exception is taken to Abort mode.                                                                                                                                                                      |
| EL2        | The exception is taken to EL2 using AArch64.                                                                                                                                                                                                                            |
| EL3        | The exception is taken to EL3 using AArch64.                                                                                                                                                                                                                            |
| C          | The interrupt is not taken and remains pending, regardless of the PSTATE.A mask.                                                                                                                                                                                        |
| Abt        | The exception is taken to the AArch32 Abort mode.                                                                                                                                                                                                                       |
| Hyp        | The exception is taken to AArch32 Hyp mode.                                                                                                                                                                                                                             |
| n/a        | Not applicable. The field does not exist in the register in this configuration or the Exception level is not accessible in this configuration.                                                                                                                          |

## RMGNFZ

The following tables describe the routing of SError exceptions taken from ELx.

All of the following apply to these tables:

- SCR\_EL3.{NS, EEL2} are not shown because RZZYHK describes Effective values involving Security states.
- Either EDSCR.INTdis is 0b00 or invasive debug is disabled.

| SCR_EL3   | SCR_EL3   | HCR_EL2   | HCR_EL2   | HCR_EL2   | HCR_EL2   | SCTLR2_EL2   | HCRX_EL2   | SCTLR2_EL1   | PSTATE   | Taken from   | Taken from   |     |
|-----------|-----------|-----------|-----------|-----------|-----------|--------------|------------|--------------|----------|--------------|--------------|-----|
| EA        | TMEA      | NMEA      | TGE       | E2H       | AMO       | NMEA         | TMEA       | NMEA         | A        | EL0          | EL1          | EL2 |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b0          | 0b0        | X            | X        | EL1          | EL1          | C   |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b0          | 0b1        | 0b0          | 0b1      | EL2          | EL2          | C   |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b0          | 0b1        | X            | 0b0      | EL1          | EL1          | C   |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b0          | 0b1        | 0b1          | 0b1      | EL1          | EL2          | C   |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b1          | 0b0        | X            | X        | EL1          | EL1          | EL2 |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b1          | 0b1        | 0b0          | 0b1      | EL2          | EL2          | EL2 |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b1          | 0b1        | X            | 0b0      | EL1          | EL1          | EL2 |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b1          | 0b1        | 0b1          | 0b1      | EL1          | EL2          | EL2 |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b1       | X            | X          | X            | X        | EL2          | EL2          | EL2 |
| 0b0       | 0b0       | 0b0       | 0b1       | X         | X         | X            | X          | X            | X        | EL2          | n/a          | EL2 |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b0          | 0b0        | X            | X        | EL1          | EL1          | C   |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b0          | 0b1        | 0b0          | 0b1      | EL2          | EL2          | C   |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b0          | 0b1        | X            | 0b0      | EL1          | EL1          | C   |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b0          | 0b1        | 0b1          | 0b1      | EL1          | EL2          | C   |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b1          | 0b0        | X            | X        | EL1          | EL1          | EL2 |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b1          | 0b1        | 0b0          | 0b1      | EL2          | EL2          | EL2 |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b1          | 0b1        | X            | 0b0      | EL1          | EL1          | EL2 |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b1          | 0b1        | 0b1          | 0b1      | EL1          | EL2          | EL2 |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b1       | X            | X          | X            | X        | EL2          | EL2          | EL2 |
| 0b0       | 0b0       | 0b1       | 0b1       | X         | X         | X            | X          | X            | X        | EL2          | n/a          | EL2 |
| 0b0       | 0b1       | 0b0       | 0b0       | X         | 0b0       | 0b0          | X          | X            | 0b0      | EL1          | EL1          | EL3 |
| 0b0       | 0b1       | 0b0       | 0b0       | X         | 0b0       | X            | 0b0        | 0b0          | 0b1      | EL3          | EL3          | EL3 |
| 0b0       | 0b1       | 0b0       | 0b0       | X         | 0b0       | X            | 0b0        | 0b1          | 0b1      | EL1          | EL3          | EL3 |
| 0b0       | 0b1       | 0b0       | 0b0       | X         | 0b0       | X            | 0b1        | 0b0          | 0b1      | EL2          | EL2          | EL3 |
| 0b0       | 0b1       | 0b0       | 0b0       | X         | 0b0       | X            | 0b1        | 0b1          | 0b1      | EL1          | EL2          | EL3 |
| 0b0       | 0b1       | 0b0       | 0b0       | X         | 0b0       | 0b1          | X          | X            | 0b0      | EL1          | EL1          | EL2 |
| 0b0       | 0b1       | 0b0       | 0b0       | X         | 0b1       | X            | X          | X            | 0b0      | EL2          | EL2          | EL2 |
| 0b0       | 0b1       | 0b0       | 0b0       | X         | 0b1       | X            | X          | X            | 0b1      | EL2          | EL2          | EL3 |
| 0b0       | 0b1       | 0b0       | 0b1       | 0b0       | X         | X            | X          | X            | 0b1      | EL2          | n/a          | EL3 |
| 0b0       | 0b1       | 0b0       | 0b1       | X         | X         | X            | X          | X            | 0b0      | EL2          | n/a          | EL2 |
| 0b0       | 0b1       | 0b0       | 0b1       | 0b1       | X         | 0b0          | X          | X            | 0b1      | EL3          | n/a          | EL3 |
| 0b0       | 0b1       | 0b0       | 0b1       | 0b1       | X         | 0b1          | X          | X            | 0b1      | EL2          | n/a          | EL3 |
| 0b0       | 0b1       | 0b1       | 0b0       | X         | 0b0       | 0b0          | X          | X            | 0b0      | EL1          | EL1          | EL3 |
| 0b0       | 0b1       | 0b1       | 0b0       | X         | 0b0       | X            | 0b0        | 0b0          | 0b1      | EL3          | EL3          | EL3 |
| 0b0       | 0b1       | 0b1       | 0b0       | X         | 0b0       | X            | 0b0        | 0b1          | 0b1      | EL1          | EL3          | EL3 |

| SCR_EL3   | SCR_EL3   | HCR_EL2   | HCR_EL2   | HCR_EL2   |     | SCTLR2_EL2   | HCRX_EL2   | SCTLR2_EL1 NMEA   | PSTATE   | Taken from   | Taken from   | Taken from   |
|-----------|-----------|-----------|-----------|-----------|-----|--------------|------------|-------------------|----------|--------------|--------------|--------------|
| EA        | TMEA      | NMEA      | TGE       | E2H       | AMO | NMEA         | TMEA       |                   | A        | EL0          | EL1          | EL2          |
| 0b0       | 0b1       | 0b1       | 0b0       | X         | 0b0 | X            | 0b1        | 0b0               | 0b1      | EL2          | EL2          | EL3          |
| 0b0       | 0b1       | 0b1       | 0b0       | X         | 0b0 | X            | 0b1        | 0b1               | 0b1      | EL1          | EL2          | EL3          |
| 0b0       | 0b1       | 0b1       | 0b0       | X         | 0b0 | 0b1          | X          | X                 | 0b0      | EL1          | EL1          | EL2          |
| 0b0       | 0b1       | 0b1       | 0b0       | X         | 0b1 | X            | X          | X                 | 0b0      | EL2          | EL2          | EL2          |
| 0b0       | 0b1       | 0b1       | 0b0       | X         | 0b1 | X            | X          | X                 | 0b1      | EL2          | EL2          | EL3          |
| 0b0       | 0b1       | 0b1       | 0b1       | 0b0       | X   | X            | X          | X                 | 0b1      | EL2          | n/a          | EL3          |
| 0b0       | 0b1       | 0b1       | 0b1       | X         | X   | X            | X          | X                 | 0b0      | EL2          | n/a          | EL2          |
| 0b0       | 0b1       | 0b1       | 0b1       | 0b1       | X   | 0b0          | X          | X                 | 0b1      | EL3          | n/a          | EL3          |
| 0b0       | 0b1       | 0b1       | 0b1       | 0b1       | X   | 0b1          | X          | X                 | 0b1      | EL2          | n/a          | EL3          |
| 0b1       | X         | X         | 0b0       | X         | X   | X            | X          | X                 | X        | EL3          | EL3          | EL3          |
| 0b1       | X         | X         | 0b1       | X         | X   | X            | X          | X                 | X        | EL3          | n/a          | EL3          |

## Table D1-15 SError exception target when EL2 is using AArch32

| SCR_EL3   |      | HCR   |     | PSTATE   | Taken from   | Taken from   |     |
|-----------|------|-------|-----|----------|--------------|--------------|-----|
| EA        | TMEA | TGE   | AMO | A        | EL0          | EL1          | EL2 |
| 0b0       | 0b0  | 0b0   | 0b0 | X        | Abt          | Abt          | Hyp |
| 0b0       | 0b0  | 0b0   | 0b1 | X        | Hyp          | Hyp          | Hyp |
| 0b0       | 0b0  | 0b1   | X   | X        | Hyp          | n/a          | Hyp |
| 0b0       | 0b1  | 0b0   | 0b0 | 0b0      | Abt          | Abt          | Hyp |
| 0b0       | 0b1  | 0b0   | 0b0 | 0b1      | EL3          | EL3          | EL3 |
| 0b0       | 0b1  | 0b0   | 0b1 | 0b0      | Hyp          | Hyp          | Hyp |
| 0b0       | 0b1  | 0b0   | 0b1 | 0b1      | Hyp          | Hyp          | EL3 |
| 0b0       | 0b1  | 0b1   | X   | 0b0      | Hyp          | n/a          | Hyp |
| 0b0       | 0b1  | 0b1   | X   | 0b1      | Hyp          | n/a          | EL3 |
| 0b1       | X    | 0b0   | X   | X        | EL3          | EL3          | EL3 |
| 0b1       | X    | 0b1   | X   | X        | EL3          | n/a          | EL3 |

## D1.4.6.3.1 Establishing the target Exception level of a delegated SError exception

The following table describes the routing of delegated SError exceptions taken from ELx. See RZZYHK for the terms used.

All of the following apply to this table:

- SCR\_EL3.{NS, EEL2} are not shown because RZZYHK describes Effective values involving Security states.
- Either EDSCR.INTdis is 0b00 or invasive debug is disabled.

RVRBFW

RHDMYQ

RPVHHQ

RLMWZH

RXZPDT

Table D1-16 Delegated SError exception target when EL2 is using AArch64, in an implementation that includes FEAT\_E3DSE

| HCR_EL2 TGE   | AMO   | HCRX_EL2 TMEA   | PSTATE A   | Taken from EL0   | EL1   | EL2   |
|---------------|-------|-----------------|------------|------------------|-------|-------|
| 0b0           | 0b0   | 0b0             | X          | EL1              | EL1   | C     |
| 0b0           | 0b0   | 0b1             | 0b0        | EL1              | EL1   | C     |
| 0b0           | 0b0   | 0b1             | 0b1        | EL2              | EL2   | C     |
| 0b0           | 0b1   | X               | X          | EL2              | EL2   | EL2   |
| 0b1           | X     | X               | X          | EL2              | n/a   | EL2   |

## D1.4.6.4 Asynchronous exception masking

An interrupt can be masked. A masked interrupt is not taken and remains pending.

Whether an interrupt is masked is determined by all of the following:

- The PSTATE.{A, I, F, ALLINT, SP} bits.
- The value of AllIntMask, as described in RXZPDT.
- Whether an IRQ or FIQ interrupt has Superpriority.
- The implemented Exception levels.
- The configuration of the Hypervisor Configuration Registers.
- For an SError, whether the exception is non-maskable.
- The configuration of the Secure Configuration Register.

If in AArch64 state and the target Exception level of an interrupt is lower than the current Exception level, the interrupt is masked.

If FEAT\_NMI is implemented and SCTLR\_ELx.NMI is 1, all of the following apply:

•

The AllIntMask variable is created and is defined as follows:

AllIntMask

==

PSTATE.ALLINT

|| (PSTATE.SP &amp;&amp; SCTLR\_ELx.SPINTMASK)

- When AllIntMask is 1 and execution is at ELx, an IRQ or FIQ interrupt that is targeted to ELx is masked regardless of Superpriority.
- When AllIntMask is 0 and execution is at ELx:
- -An IRQ or FIQ interrupt with Superpriority that is targeted to ELx is not masked by PSTATE.I or PSTATE.F, respectively.
- -An IRQ or FIQ interrupt without Superpriority that is targeted to ELx is masked by PSTATE.I or PSTATE.F, respectively, in the same way as when the Effective value of SCTLR\_ELx.NMI is 0.

IBXXWT

AllIntMask does not affect the masking or routing of interrupts to a higher Exception level.

RSFMGZ

If FEAT\_NMI is not implemented or SCTLR\_ELx.NMI is 0, the Effective value of AllIntMask is 0.

## D1.4.6.4.1 Physical interrupt masking

RMHWBP

If the target Exception level of a physical IRQ interrupt is the current Exception level, ELx, the following controls determine whether the interrupt is masked:

|   PSTATE.I |   SCTLR_ELx.NMI | AllIntMask   | IRQ        | IRQ with Superpriority   |
|------------|-----------------|--------------|------------|--------------------------|
|          0 |               0 | x            | Not masked | Not masked               |
|          0 |               1 | 0            | Not masked | Not masked               |
|          0 |               1 | 1            | Masked     | Masked                   |

|   PSTATE.I |   SCTLR_ELx.NMI | AllIntMask   | IRQ    | IRQ with Superpriority   |
|------------|-----------------|--------------|--------|--------------------------|
|          1 |               0 | x            | Masked | Masked                   |
|          1 |               1 | 0            | Masked | Not masked               |
|          1 |               1 | 1            | Masked | Masked                   |

RGFXKY

If the target Exception level of a physical FIQ interrupt is the current Exception level, ELx, the following controls determine whether the interrupt is masked:

|   PSTATE.F |   SCTLR_ELx.NMI | AllIntMask   | FIQ        | FIQ with Superpriority   |
|------------|-----------------|--------------|------------|--------------------------|
|          0 |               0 | x            | Not masked | Not masked               |
|          0 |               1 | 0            | Not masked | Not masked               |
|          0 |               1 | 1            | Masked     | Masked                   |
|          1 |               0 | x            | Masked     | Masked                   |
|          1 |               1 | 0            | Masked     | Not masked               |
|          1 |               1 | 1            | Masked     | Masked                   |

|   PSTATE.F | FIQ        |
|------------|------------|
|          0 | Not masked |
|          1 | Masked     |

If the target Exception level of a physical SError is the current Exception level, the PSTATE.A control determines whether the interrupt is masked.

However, if the target Exception level is the current Exception level, and if any of the following are true, the PSTATE.A control is ignored, and the exception is taken:

- The target Exception level is EL3, FEAT\_DoubleFault is implemented and the Effective value of SCR\_EL3.NMEA is 1.
- The target Exception level is EL2, FEAT\_DoubleFault2 is implemented and the Effective value of SCTLR2\_EL2.NMEA is 1.
- The target Exception level is EL1, FEAT\_DoubleFault2 is implemented and the Effective value of SCTLR2\_EL1.NMEA is 1.

If the target Exception level of a physical interrupt is higher than the current Exception level, all of the following apply:

- If the target Exception level is EL3, the interrupt cannot be masked by the PSTATE.{A, I, F} bits.
- If the target Exception level is EL2 and any of the following are true, the interrupt cannot be masked by the PSTATE.{A, I, F} bits.
- -The Effective value of HCR\_EL2.E2H is 0.
- -The Effective value of HCR\_EL2.TGE is 0.
- If the target Exception level is EL2 and all of the following are true, the interrupt can be masked by the PSTATE.{A, I, F} bits:
- -The Effective value of HCR\_EL2.E2H is 1.
- -The Effective value of HCR\_EL2.TGE is 1.
- -The interrupt does not have Superpriority or SCTLR\_EL2.NMI is 0.
- If the target Exception level is EL1 and the interrupt does not have Superpriority or SCTLR\_EL1.NMI is 0, the interrupt can be masked by the PSTATE.{A, I, F} bits.

The ability to execute in EL0 with interrupts taken to EL1 masked is required by some user level driver code.

RGCTZC

RXBYXL

IKDYCN

RHPRNX

The RSXLWJ table uses the following terms:

| Term    | Meaning                                                                                                                                                                                   |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SCR_EL3 | The Effective value of a field in SCR_EL3.                                                                                                                                                |
| NS      | If FEAT_RME is implemented, then if Secure state is not implemented, the Effective value of SCR_EL3.NS is 1.                                                                              |
| EEL2    | If EL3 is not implemented, the Effective value of SCR_EL3.EEL2 is 1. If FEAT_SEL2 is not implemented, the Effective value of SCR_EL3.EEL2 is 0.                                           |
| IRQ FIQ | If EL3 is not implemented, then the Effective value of these fields is 0.                                                                                                                 |
| RW      | If EL3 is not implemented, the Effective value of SCR_EL3.RW is 1.                                                                                                                        |
| HCR     | If EL2 is using AArch32, this is the Effective value of a field in HCR. If EL2 is using AArch64, this is the Effective value of a field in HCR_EL2.                                       |
| TGE     | If EL2 is not implemented, the Effective value of HCR.TGE or HCR_EL2.TGE is 0.                                                                                                            |
| E2H     | If EL2 is not implemented, the Effective value of HCR.E2H or HCR_EL2.E2H is 0.                                                                                                            |
| IMOFMO  | If EL2 is not implemented, the Effective value of these fields is 0.                                                                                                                      |
| A       | When the interrupt is pending, it is taken regardless of the value of the PSTATE.{A, I, F, ALLINT} interrupt masks.                                                                       |
| B       | When the interrupt is pending, it might be subject to masking, as defined inR MHWBP orR GFXKY . If the interrupt is masked, it is not taken. If the interrupt is not masked, it is taken. |
| C       | When the interrupt is pending, it is not taken, regardless of the value of the PSTATE.{A, I, F, ALLINT} interrupt masks.                                                                  |
| n/a     | Not applicable. The PE cannot be executing at this Exception level for the specified state of HCRand SCR_EL3.                                                                             |

RSXLWJ

The following table describes the target and masking of physical FIQ and IRQ interrupts, if the highest implemented Exception level is using AArch64.

## Table D1-21 FIQ and IRQ interrupt exception targets and masking

| SCR_EL3   | SCR_EL3   | SCR_EL3   | HCR   | HCR   | HCR   | Effect of the interrupt mask when executing   | Effect of the interrupt mask when executing   | Effect of the interrupt mask when executing   | Effect of the interrupt mask when executing   | Effect of the interrupt mask when executing   |
|-----------|-----------|-----------|-------|-------|-------|-----------------------------------------------|-----------------------------------------------|-----------------------------------------------|-----------------------------------------------|-----------------------------------------------|
| NS        | EEL2      | IRQ FIQ   | RW    | TGE   | E2H   | IMO FMO                                       | EL0                                           | EL1                                           | EL2                                           | EL3                                           |
| 0         | 0         | 0         | x     | x     | x     | x                                             | B                                             | B                                             | n/a                                           | C                                             |
| 0         | 0         | 1         | x     | x     | x     | x                                             | A                                             | A                                             | n/a                                           | B                                             |
| 0         | 1         | 0         | x     | 0     | x     | 0                                             | B                                             | B                                             | C                                             | C                                             |
| 0         | 1         | 0         | x     | 0     | x     | 1                                             | A                                             | A                                             | B                                             | C                                             |
| 0         | 1         | 0         | x     | 1     | 0     | x                                             | A                                             | n/a                                           | B                                             | C                                             |
| 0         | 1         | 0         | x     | 1     | 1     | x                                             | B                                             | n/a                                           | B                                             | C                                             |
| 0         | 1         | 1         | x     | 0     | x     | x                                             | A                                             | A                                             | A                                             | B                                             |
| 0         | 1         | 1         | x     | 1     | x     | x                                             | A                                             | n/a                                           | A                                             | B                                             |
| 1         | x         | 0         | 0     | 0     | n/a   | 0                                             | B                                             | B                                             | B                                             | C                                             |
| 1         | x         | 0         | 0     | 0     | n/a   | 1                                             | A                                             | A                                             | B                                             | C                                             |
| 1         | x         | 0         | 0     | 1     | n/a   | x                                             | A                                             | n/a                                           | B                                             | C                                             |
| 1         | x         | 0         | 1     | 0     | x     | 0                                             | B                                             | B                                             | C                                             | C                                             |
| 1         | x         | 0         | 1     | 0     | x     | 1                                             | A                                             | A                                             | B                                             | C                                             |

| SCR_EL3   | SCR_EL3   |         | HCR   | HCR   | HCR   | Effect of the interrupt mask when executing at:   | Effect of the interrupt mask when executing at:   | Effect of the interrupt mask when executing at:   | Effect of the interrupt mask when executing at:   | Effect of the interrupt mask when executing at:   |
|-----------|-----------|---------|-------|-------|-------|---------------------------------------------------|---------------------------------------------------|---------------------------------------------------|---------------------------------------------------|---------------------------------------------------|
| NS        | EEL2      | IRQ FIQ | RW    | TGE   | E2H   | IMO FMO                                           | EL0                                               | EL1                                               | EL2                                               | EL3                                               |
| 1         | x         | 0       | 1     | 1     | 0     | x                                                 | A                                                 | n/a                                               | B                                                 | C                                                 |
| 1         | x         | 0       | 1     | 1     | 1     | x                                                 | B                                                 | n/a                                               | B                                                 | C                                                 |
| 1         | x         | 1       | x     | 0     | x     | x                                                 | A                                                 | A                                                 | A                                                 | B                                                 |
| 1         | x         | 1       | x     | 1     | x     | x                                                 | A                                                 | n/a                                               | A                                                 | B                                                 |

RZSRWR

The RJFKMF tables use the following terms:

| Term       | Meaning                                                                                                                                                                                                                                                                 |
|------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SCR_EL3    | The Effective value of a field in SCR_EL3.                                                                                                                                                                                                                              |
| EA         | If EL3 is not implemented, the Effective value of SCR_EL3.EA is 0.                                                                                                                                                                                                      |
| TMEA       | If FEAT_DoubleFault2 is not implemented, the Effective value of SCR_EL3.TMEA is 0.                                                                                                                                                                                      |
| NMEA       | If FEAT_DoubleFault is not implemented, the Effective value of SCR_EL3.NMEA is 0.                                                                                                                                                                                       |
| HCR_EL2    | The Effective value of a field in HCR_EL2.                                                                                                                                                                                                                              |
| HCR        | The Effective value of a field in HCR.                                                                                                                                                                                                                                  |
| TGE        | If EL2 is not implemented or EL2 is disabled in the current Security state, then the Effective value of HCR_EL2.TGE or HCR.TGE is 0.                                                                                                                                    |
| E2H        | If EL2 is not implemented or EL2 is disabled in the current Security state, then the Effective value of HCR_EL2.E2H is 0.                                                                                                                                               |
| AMO        | If EL2 is not implemented or EL2 is disabled in the current Security state, then the Effective value of HCR_EL2.AMO or HCR.AMOis 0.                                                                                                                                     |
| SCTLR2_EL2 | The Effective value of a field in SCTLR2_EL2.                                                                                                                                                                                                                           |
| NMEA       | If FEAT_DoubleFault2 is not implemented, the Effective value of SCTLR2_EL2.NMEA is 0. If EL2 is not implemented or EL2 is disabled in the current Security state, or if the Effective value of SCR_EL3.SCTLR2En is 0, then the Effective value of SCTLR2_EL2.NMEA is 0. |
| HCRX_EL2   | The Effective value of a field in HCRX_EL2.                                                                                                                                                                                                                             |
| TMEA       | If FEAT_DoubleFault2 is not implemented, the Effective value of HCRX_EL2.TMEA is 0. If EL2 is not implemented or EL2 is disabled in the current Security state, or the Effective value of SCR_EL3.HXEn is 0, then the Effective value of HCRX_EL2.TMEA is 0.            |
| SCTLR2_EL1 | The Effective value of a field in SCTLR2_EL1.                                                                                                                                                                                                                           |
| NMEA       | If FEAT_DoubleFault2 is not implemented, the Effective value of SCTLR2_EL1.NMEA is 0. If the Effective value of HCRX_EL2.SCTLR2En is 0 or the Effective value of SCR_EL3.SCTLR2En is 0, then the Effective value of SCTLR2_EL1.NMEA is 0.                               |
| A          | When the exception is pending, it is taken regardless of the value of the PSTATE.A mask.                                                                                                                                                                                |
| B          | When the exception is pending, it might be subject to masking, as defined inR GCTZC . If the interrupt is masked, it is not taken. If the interrupt is not masked, it is taken.                                                                                         |
| C          | The exception is not taken and remains pending, regardless of the PSTATE.A mask.                                                                                                                                                                                        |
| n/a        | Not applicable. The field does not exist in the register in this configuration or the Exception level is not accessible in this configuration.                                                                                                                          |

RJFKMF

The following tables describe the masking of SError exceptions. All of the following apply to these tables:

- SCR\_EL3.{NS, EEL2} are not shown because RZSRWR describes Effective values involving Security states.
- Either EDSCR.INTdis is 0b00 or invasive debug is disabled.

Table D1-23 SError exception masking when EL2 is using AArch64

| SCR_EL3   | SCR_EL3   | HCR_EL2   | HCR_EL2   | HCR_EL2   | HCR_EL2   | SCTLR2_EL2 NMEA   | HCRX_EL2   | SCTLR2_EL1   | Effect of the interrupt mask when executing at   | Effect of the interrupt mask when executing at   | Effect of the interrupt mask when executing at   | Effect of the interrupt mask when executing at   |
|-----------|-----------|-----------|-----------|-----------|-----------|-------------------|------------|--------------|--------------------------------------------------|--------------------------------------------------|--------------------------------------------------|--------------------------------------------------|
| EA        | TMEA      | NMEA      | TGE       | E2H       | AMO       | SCTLR2_EL2 NMEA   | TMEA       | NMEA         | EL0                                              | EL1                                              | EL2                                              | EL3                                              |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b0               | 0b0        | 0b0          | B                                                | B                                                | C                                                | C                                                |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b0               | 0b0        | 0b1          | A                                                | A                                                | C                                                | C                                                |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b0               | 0b1        | X            | A                                                | A                                                | C                                                | C                                                |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b1               | 0b0        | 0b0          | B                                                | B                                                | A                                                | C                                                |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b1               | 0b0        | 0b1          | A                                                | A                                                | A                                                | C                                                |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b0       | 0b1               | 0b1        | X            | A                                                | A                                                | A                                                | C                                                |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b1       | 0b0               | X          | X            | A                                                | A                                                | B                                                | C                                                |
| 0b0       | 0b0       | 0b0       | 0b0       | X         | 0b1       | 0b1               | X          | X            | A                                                | A                                                | A                                                | C                                                |
| 0b0       | 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0               | X          | X            | A                                                | n/a                                              | B                                                | C                                                |
| 0b0       | 0b0       | 0b0       | 0b1       | X         | X         | 0b1               | X          | X            | A                                                | n/a                                              | A                                                | C                                                |
| 0b0       | 0b0       | 0b0       | 0b1       | 0b1       | X         | 0b0               | X          | X            | B                                                | n/a                                              | B                                                | C                                                |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b0               | 0b0        | 0b0          | B                                                | B                                                | C                                                | A                                                |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b0               | 0b0        | 0b1          | A                                                | A                                                | C                                                | A                                                |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b0               | 0b1        | X            | A                                                | A                                                | C                                                | A                                                |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b1               | 0b0        | 0b0          | B                                                | B                                                | A                                                | A                                                |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b1               | 0b0        | 0b1          | A                                                | A                                                | A                                                | A                                                |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b0       | 0b1               | 0b1        | X            | A                                                | A                                                | A                                                | A                                                |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b1       | 0b0               | X          | X            | A                                                | A                                                | B                                                | A                                                |
| 0b0       | 0b0       | 0b1       | 0b0       | X         | 0b1       | 0b1               | X          | X            | A                                                | A                                                | A                                                | A                                                |
| 0b0       | 0b0       | 0b1       | 0b1       | 0b0       | X         | 0b0               | X          | X            | A                                                | n/a                                              | B                                                | A                                                |
| 0b0       | 0b0       | 0b1       | 0b1       | X         | X         | 0b1               | X          | X            | A                                                | n/a                                              | A                                                | A                                                |
| 0b0       | 0b0       | 0b1       | 0b1       | 0b1       | X         | 0b0               | X          | X            | B                                                | n/a                                              | B                                                | A                                                |
| 0b0       | 0b1       | 0b0       | 0b0       | X         | X         | X                 | X          | X            | A                                                | A                                                | A                                                | C                                                |
| 0b0       | 0b1       | 0b0       | 0b1       | X         | X         | X                 | X          | X            | A                                                | n/a                                              | A                                                | C                                                |
| 0b0       | 0b1       | 0b1       | 0b0       | X         | X         | X                 | X          | X            | A                                                | A                                                | A                                                | A                                                |
| 0b0       | 0b1       | 0b1       | 0b1       | X         | X         | X                 | X          | X            | A                                                | n/a                                              | A                                                | A                                                |
| 0b1       | X         | 0b0       | 0b0       | X         | X         | X                 | X          | X            | A                                                | A                                                | A                                                | B                                                |
| 0b1       | X         | 0b0       | 0b1       | X         | X         | X                 | X          | X            | A                                                | n/a                                              | A                                                | B                                                |
| 0b1       | X         | 0b1       | 0b0       | X         | X         | X                 | X          | X            | A                                                | A                                                | A                                                | A                                                |
| 0b1       | X         | 0b1       | 0b1       | X         | X         | X                 | X          | X            | A                                                | n/a                                              | A                                                | A                                                |

RSNLJH

Table D1-24 SError exception masking when EL2 is using AArch32

| SCR_EL3   | SCR_EL3   | HCR   | HCR   | Effect of the interrupt mask when executing at   | Effect of the interrupt mask when executing at   | Effect of the interrupt mask when executing at   |
|-----------|-----------|-------|-------|--------------------------------------------------|--------------------------------------------------|--------------------------------------------------|
| EA        | TMEA      | TGE   | AMO   | EL0                                              | EL1                                              | EL2                                              |
| 0b0       | 0b0       | 0b0   | 0b0   | B                                                | B                                                | B                                                |
| 0b0       | 0b0       | 0b0   | 0b1   | A                                                | A                                                | B                                                |
| 0b0       | 0b0       | 0b1   | X     | A                                                | n/a                                              | B                                                |
| 0b0       | 0b1       | 0b0   | X     | A                                                | A                                                | A                                                |
| 0b0       | 0b1       | 0b1   | X     | A                                                | n/a                                              | A                                                |
| 0b1       | X         | 0b0   | X     | A                                                | A                                                | A                                                |
| 0b1       | X         | 0b1   | X     | A                                                | n/a                                              | A                                                |

## D1.4.6.4.2 Virtual asynchronous exception masking

The following controls determine whether a virtual IRQ interrupt is masked:

|   PSTATE.I |   SCTLR_EL1.NMI | PSTATE.EL   | AllIntMask   | vIRQ       | vIRQ with Superpriority   |
|------------|-----------------|-------------|--------------|------------|---------------------------|
|          0 |               0 | xx          | x            | Not Masked | Not Masked                |
|          0 |               1 | EL0         | x            | Not Masked | Not Masked                |
|          0 |               1 | EL1         | 0            | Not Masked | Not Masked                |
|          0 |               1 | EL1         | 1            | Masked     | Masked                    |
|          1 |               0 | xx          | x            | Masked     | Masked                    |
|          1 |               1 | EL0         | x            | Masked     | Not Masked                |
|          1 |               1 | EL1         | 0            | Masked     | Not Masked                |
|          1 |               1 | EL1         | 1            | Masked     | Masked                    |

RXSPSG

The following controls determine whether a virtual FIQ interrupt is masked:

|   PSTATE.F |   SCTLR_EL1.NMI | PSTATE.EL   | AllIntMask   | vFIQ       | vFIQ with Superpriority   |
|------------|-----------------|-------------|--------------|------------|---------------------------|
|          0 |               0 | xx          | x            | Not Masked | Not Masked                |
|          0 |               1 | EL0         | x            | Not Masked | Not Masked                |
|          0 |               1 | EL1         | 0            | Not Masked | Not Masked                |
|          0 |               1 | EL1         | 1            | Masked     | Masked                    |
|          1 |               0 | xx          | x            | Masked     | Masked                    |
|          1 |               1 | EL0         | x            | Masked     | Not Masked                |
|          1 |               1 | EL1         | 0            | Masked     | Not Masked                |
|          1 |               1 | EL1         | 1            | Masked     | Masked                    |

RGYGBD

Virtual asynchronous exceptions can only be taken from EL0 or EL1 and can only be taken to EL1. If EL2 is not enabled in the current Security state, all types of virtual asynchronous exceptions are always masked. If executing at EL2 or EL3, all types of virtual asynchronous exceptions are always masked.

RMMYBS

The following controls determine whether a virtual SError interrupt is masked:

|   PSTATE.A | PSTATE.EL   | vSError    |
|------------|-------------|------------|
|          0 | xx          | Not Masked |
|          1 | xx          | Masked     |

IBNCCH

The ability to execute at EL0 with virtual interrupts taken to EL1 masked is required by some user level driver code.

RWVZVM

The RBKHXL table uses the following terms:

| Term       | Meaning                                                                                                                                                                                               |
|------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SCR_EL3    | The Effective value of a field in SCR_EL3.                                                                                                                                                            |
| EEL2       | If EL3 is not implemented, the Effective value of SCR_EL3.EEL2 is 1.                                                                                                                                  |
| NS         | If FEAT_RME is implemented, then if Secure state is not implemented, the Effective value of SCR_EL3.NS is 1.                                                                                          |
| EAIRQ FIQ  | If EL3 is not implemented, the Effective value of these fields is 0.                                                                                                                                  |
| HCR        | If EL2 is using AArch32, this is the Effective value of a field in HCR. If EL2 is using AArch64, this is the Effective value of a field in HCR_EL2.                                                   |
| E2H        | If EL2 is using AArch32, the Effective value of HCR.E2H is 0.                                                                                                                                         |
| TGE        | If EL2 is not implemented, the Effective value of HCR.TGE or HCR_EL2.TGE is 0.                                                                                                                        |
| AMOIMO FMO | If EL2 is not implemented, the Effective value of these fields is 0.                                                                                                                                  |
| B          | When the interrupt is pending, it might be subject to masking, as defined inR SNLJH ,R XSPSG , andR MMYBS . If the interrupt is masked, it is not taken. If the interrupt is not masked, it is taken. |
| C          | When the interrupt is pending, it is not taken, regardless of the value of the PSTATE.{A, I, F, ALLINT, SP, PM} interrupt masks.                                                                      |
| n/a        | Not applicable. The PE cannot be executing at this Exception level for the specified state of HCRand SCR_EL3.                                                                                         |

RBKHXL

The following table describes the masking of virtual interrupts when the highest implemented Exception level is using AArch64:

| SCR_EL3   | SCR_EL3   | HCR        | HCR   | HCR   | Effect of the interrupt mask when executing at:   | Effect of the interrupt mask when executing at:   | Effect of the interrupt mask when executing at:   | Effect of the interrupt mask when executing at:   | Effect of the interrupt mask when executing at:   |
|-----------|-----------|------------|-------|-------|---------------------------------------------------|---------------------------------------------------|---------------------------------------------------|---------------------------------------------------|---------------------------------------------------|
| EEL2      | NS        | EA IRQ FIQ | E2H   | TGE   | AMO IMO FMO                                       | EL0                                               | EL1                                               | EL2                                               | EL3                                               |
| 0         | 0         | x          | x     | x     | x                                                 | C                                                 | C                                                 | n/a                                               | C                                                 |
| 1         | 0         | x          | x     | 0     | 0                                                 | C                                                 | C                                                 | C                                                 | C                                                 |
| 1         | 0         | x          | x     | 0     | 1                                                 | B                                                 | B                                                 | C                                                 | C                                                 |
| 1         | 0         | x          | x     | 1     | x                                                 | C                                                 | n/a                                               | C                                                 | C                                                 |
| x         | 1         | x          | x     | 0     | 0                                                 | C                                                 | C                                                 | C                                                 | C                                                 |
| x         | 1         | x          | x     | 0     | 1                                                 | B                                                 | B                                                 | C                                                 | C                                                 |
| x         | 1         | x          | x     | 1     | x                                                 | C                                                 | n/a                                               | C                                                 | C                                                 |

## D1.4.6.4.3 Delegated SError exception masking

RZZXBJ

The RLPCYB table uses the following terms:

| Term     | Meaning                                                                                                                                                                                                                                                                          |
|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HCR_EL2  | The Effective value of a field in HCR_EL2.                                                                                                                                                                                                                                       |
| TGE      | If EL2 is not implemented, or EL2 is disabled in the current Security state, then the Effective value of HCR_EL2.TGE is 0.                                                                                                                                                       |
| E2H      | If FEAT_VHE is implemented and FEAT_E2H0 is not implemented, then the effective value of HCR_EL2.E2H is 1. Otherwise, if FEAT_VHE is not implemented, or EL2 is not implemented, or EL2 is disabled in the current Security state, then the Effective value of HCR_EL2.E2H is 0. |
| AMO      | If EL2 is not implemented, or EL2 is disabled in the current Security state, then the Effective value of HCR_EL2.AMO is 0.                                                                                                                                                       |
| HCRX_EL2 | The Effective value of a field in HCRX_EL2.                                                                                                                                                                                                                                      |
| TMEA     | If FEAT_DoubleFault2 is not implemented, EL2 is not implemented, EL2 is disabled in the current Security state, or the Effective value of SCR_EL3.HXEn is 0, then the Effective value of HCRX_EL2.TMEA is 0.                                                                     |
| A        | When the exception is pending, it is taken regardless of the value of the PSTATE.A mask. However, the target Exception level of the exception might depend on the value of PSTATE.A. SeeR VRBFW .                                                                                |
| B        | When the exception is pending, it might be subject to masking. If PSTATE.A is 1, then the exception is masked and is not taken. If PSTATE.A is 0, then the exception is not masked and is taken.                                                                                 |
| C        | The error exception is not taken and remains pending, regardless of the value of the PSTATE.A mask.                                                                                                                                                                              |
| n/a      | Not applicable. The Exception level is not present in this configuration.                                                                                                                                                                                                        |

RLPCYB

RBKHSW

RRBZYL

The following table describes the masking of delegated SError exceptions. All of the following apply to this table:

- SCR\_EL3.{NS, EEL2} are not shown because RZZXBJ describes Effective values involving Security states.
- Either EDSCR.INTdis is 0b00 or invasive debug is disabled.

Table D1-31 Delegated SError exception masking in an implementation that includes FEAT\_E3DSE

| HCR_EL2   |     | AMO   | HCRX_EL2   | Effect of the interrupt mask when executing at:   | Effect of the interrupt mask when executing at:   | Effect of the interrupt mask when executing at:   |
|-----------|-----|-------|------------|---------------------------------------------------|---------------------------------------------------|---------------------------------------------------|
| TGE       | E2H |       | TMEA       | EL0                                               | EL1                                               | EL2                                               |
| 0b0       | X   | 0b0   | 0b0        | B                                                 | B                                                 | C                                                 |
| 0b0       | X   | 0b0   | 0b1        | A                                                 | A                                                 | C                                                 |
| 0b0       | X   | 0b1   | X          | A                                                 | A                                                 | B                                                 |
| 0b1       | 0b0 | X     | X          | A                                                 | n/a                                               | B                                                 |
| 0b1       | 0b1 | X     | X          | B                                                 | n/a                                               | B                                                 |

## D1.4.6.5 Prioritization of asynchronous exceptions

The virtual SError exception injected using HCR\_EL2.VSE has priority over the delegated SError exception injected using SCR\_EL3.DSE. Otherwise, the prioritization of physical asynchronous exceptions and virtual asynchronous exceptions is IMPLEMENTATION DEFINED.

For all of the following Context synchronization events, if an asynchronous exception is pending before the Context synchronization event, and the asynchronous exception remains pending and is not masked after the Context synchronization event, then the asynchronous exception is taken before the first instruction after the Context synchronization event:

- Execution of an ISB instruction.
- If FEAT\_ExS is not implemented, exception entry.
- If FEAT\_ExS is implemented and the appropriate SCTLR\_ELx.EIS bit is 1, exception entry.
- If FEAT\_ExS is not implemented, exception return.
- If FEAT\_ExS is implemented and the appropriate SCTLR\_ELx.EOS bit is 1, exception exit.
- Exit from Debug state.

If the first instruction after the Context synchronization event generates a synchronous exception, the architecture does not define whether the PE takes the asynchronous exception or the synchronous exception first.

| I RDBWJ   | ARASerror synchronization event defines additional requirements for taking an SError exception. See Error synchronization event.                                                                                                                                                                                                                              |
|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| R QVRHH   | Other than the behaviors described inR RBZYL , an unmasked, pending asynchronous exception must be taken in finite time.                                                                                                                                                                                                                                      |
| R ZQPLL   | If an unmasked asynchronous exception was pending but is changed to not pending before it is taken, it is CONSTRAINED UNPREDICTABLE whether or not the asynchronous exception is taken. If the asynchronous exception is taken, it is taken before the first Context synchronization event after the asynchronous exception was changed to be not pending.    |
|           | D1.4.6.6 Taking an asynchronous exception during a multi-access load or store                                                                                                                                                                                                                                                                                 |
| R ZBFSL   | If in AArch64 state, asynchronous exceptions can be taken during a sequence of memory accesses caused by a single load or store instruction. This is true regardless of the memory type being accessed. In this situation, the behavior is consistent with the requirements described inR TNVSL in Definition of a precise exception and imprecise exception. |
|           | D1.4.6.7 Taking an asynchronous exception during an SVE instruction                                                                                                                                                                                                                                                                                           |
| R TFLTX   | Permitting SVE instructions to be interrupted by asynchronous exceptions is IMPLEMENTATION DEFINED.                                                                                                                                                                                                                                                           |
| R WFMZK   | When returning from an asynchronous exception, an interrupted SVE instruction is restarted and cannot resume at the point the instruction was interrupted.                                                                                                                                                                                                    |
| I QRQJP   | For Data Aborts taken asynchronously, see Definition of a precise exception and imprecise exception.                                                                                                                                                                                                                                                          |

## D1.4.7 UNDEFINED instructions

RZLJDF

An instruction which is UNDEFINED generates a synchronous exception for that instruction unless there is a higher priority exception generated for that instruction.

RSXYZB

The Exception level that the synchronous Undefined Instruction exception is taken to is defined as follows:

- If executing at EL0:
- -If the Effective value of HCR\_EL2.TGE is 0, the exception is taken to EL1.
- -If the Effective value of HCR\_EL2.TGE is 1, the exception is taken to EL2.
- If executing at EL1, the exception is taken to EL1.
- If executing at EL2, the exception is taken to EL2.
- If executing at EL3, the exception is taken to EL3.

## D1.4.8 Configurable instruction controls

RQMWPZ

Configurable instruction controls are control bits held in System registers that determine whether attempting to execute an instruction generates a synchronous exception at the point in the instruction stream of that instruction, and the instruction is not executed.

IZSSHJ

Configurable instruction controls might be referred to by any of the following names:

- Instruction enables.

RVWWGJ

RJTXTF

IBJBMF

ITFGPW

RQQLHG

RSZCKN

ITJPQP

- Instruction disables.
- Trap controls.

The definitions of each type overlap, and in some cases is historical. Describing a register control field as an instruction enable, an instruction disable, or a trap control, gives no indication of how an exception that is generated as a consequence of the value of that field is handled or reported. Each configurable instruction control defines how the exception that is generated as a consequence of the configurable instruction control is handled or reported.

An exception can only be generated as a result of a configurable instruction control if all the following apply:

- The instruction generating the exception does not also generate a higher priority exception.
- The instruction generating the exception is not UNPREDICTABLE or CONSTRAINED UNPREDICTABLE in the PE state in which the instruction is executed.

It is UNPREDICTABLE / CONSTRAINED UNPREDICTABLE whether configurable instruction controls generate an exception when the instruction is UNPREDICTABLE or CONSTRAINED UNPREDICTABLE in the PE state in which the instruction is executed, with all of the following constraints:

- If the instruction description explicitly states that the configurable instruction control is applied with higher priority than the CONSTRAINED UNPREDICTABLE behavior, then the configurable instruction control generates an exception.
- The CONSTRAINED UNPREDICTABLE behaviors cannot lead to any behavior that is prohibited by the general definition of UNPREDICTABLE.

UNPREDICTABLE and CONSTRAINED UNPREDICTABLE instructions can generate exceptions as a result of configurable instruction controls, but the architecture does not require them to do so.

Note: Many CONSTRAINED UNPREDICTABLE behaviors for instructions include an allowance that the CONSTRAINED UNPREDICTABLE instruction behaves the same way as a closely related instruction that is not CONSTRAINED UNPREDICTABLE. In those cases, the instruction enable, disable, or trap control that causes in exception on the closely related instruction will cause the same exception on the CONSTRAINED UNPREDICTABLE instruction.

An implementation might provide more controls, in IMPLEMENTATION DEFINED registers, to provide control of trapping of IMPLEMENTATION DEFINED features.

When a configurable instruction control causes an exception, the exception is taken and the instruction is not executed, and therefore all the following are true:

- The preferred exception return address of the exception is the instruction that generates the exception.
- There are no changes to the registers accessed by the instruction, including as a result of side-effects of a register access.

When a configurable instruction control causes a conditional instruction to generate an exception in AArch32 state, it is IMPLEMENTATION DEFINED whether the exception applies to conditional AArch32 instructions that fail their condition code check.

## D1.4.8.1 EL0 and EL1 configurable instruction controls

The following EL0 and EL1 System registers contain configurable instruction controls:

| Register name   | Register description                          |
|-----------------|-----------------------------------------------|
| AMUSERENR_EL0   | Activity Monitors User Enable Register        |
| CPACR_EL1       | Architectural Feature Access Control Register |
| MDSCR_EL1       | Monitor System Debug Control Register         |
| PMUSERENR_EL0   | Performance Monitors User Enable Register     |
| SCTLR_EL1       | System Control Register (EL1)                 |
| TCR_EL1         | Translation Control Register (EL1)            |

RKYYYZ

An exception caused by configurable instruction controls in EL1 can be taken from either AArch64 state or AArch32 state.

## D1.4.8.2 EL2 configurable instruction controls

IFFLBF

The following EL2 System registers contain configurable instruction controls:

| Register name   | Register description                                         |
|-----------------|--------------------------------------------------------------|
| CPTR_EL2        | Architectural Feature Trap Register, EL2                     |
| HAFGRTR_EL2     | Hypervisor Activity Monitors Fine-Grained Read Trap Register |
| HCR_EL2         | Hypervisor Configuration Register                            |
| HCRX_EL2        | Extended Hypervisor Configuration Register                   |
| HDFGRTR_EL2     | Hypervisor Debug Fine-Grained Read Trap Register             |
| HDFGRTR2_EL2    | Hypervisor Debug Fine-Grained Read Trap Register 2           |
| HDFGWTR_EL2     | Hypervisor Debug Fine-Grained Write Trap Register            |
| HDFGWTR2_EL2    | Hypervisor Debug Fine-Grained Write Trap Register 2          |
| HFGITR_EL2      | Hypervisor Fine-Grained Instruction Trap Register            |
| HFGITR2_EL2     | Hypervisor Fine-Grained Instruction Trap Register 2          |
| HFGRTR_EL2      | Hypervisor Fine-Grained Read Trap Register                   |
| HFGRTR2_EL2     | Hypervisor Fine-Grained Read Trap Register 2                 |
| HFGWTR_EL2      | Hypervisor Fine-Grained Write Trap Register                  |
| HFGWTR2_EL2     | Hypervisor Fine-Grained Write Trap Register 2                |
| HSTR_EL2        | Hypervisor System Trap Register                              |
| MDCR_EL2        | Monitor Debug Configuration Register, EL2                    |
| SCTLR_EL2       | System Control Register, EL2                                 |
| TCR_EL2         | Translation Control Register, EL2                            |

RJZJRG

An exception caused by configurable instruction controls in EL2 can be taken from either AArch64 state or AArch32 state.

RSNLNY

EL2 configurable instruction controls are ignored in Secure state if Secure EL2 is not implemented or not enabled.

## D1.4.8.3 EL3 configurable instruction controls

RLTKXZ

The following EL3 System registers contain configurable instruction controls:

| Register name   | Register description                      |
|-----------------|-------------------------------------------|
| CPTR_EL3        | Architectural Feature Trap Register, EL3  |
| FGWTE3_EL3      | Fine-Grained Write Traps EL3              |
| MDCR_EL3        | Monitor Debug Configuration Register, EL3 |
| SCTLR_EL3       | System Control Register, EL3              |
| SCR_EL3         | Secure Configuration Register             |
| TCR_EL3         | Translation Control Register, EL3         |

RNMCCJ

An exception caused by configurable instruction controls in EL3 can be taken from either AArch64 state or AArch32 state.

## D1.4.9 Exception generating instructions

IYRYNQ

RBRCQB

RTNSNV

The exception generating instructions are commonly called system calls and refer to the instructions that generate any of the following synchronous exception types:

- Supervisor Call exception.
- Hypervisor Call exception.
- Secure Monitor Call exception.

ASupervisor Call is generated by executing an SVC instruction.

ASupervisor Call exception is taken to the following Exception levels:

- If executing at EL0:
- -If the Effective value of HCR\_EL2.TGE is 0, the exception is taken to EL1.
- -If the Effective value of HCR\_EL2.TGE is 1, the exception is taken to EL2.
- If executing at EL1, the exception is taken to EL1.
- If executing at EL2, the exception is taken to EL2.
- If executing at EL3, the exception is taken to EL3.

INCTDB ASupervisor Call enables software executing at EL0 to make a call to an operating system or other software executing at EL1.

RLLLGJ If EL2 is implemented and the HVC instruction is not UNDEFINED, a Hypervisor Call is generated by executing an HVC instruction.

RRWKMY AHypervisor Call exception is taken to the following Exception levels:

- If EL2 is implemented and enabled in the current Security state, when taken from EL1, the exception is taken to EL2.
- When taken from EL2, the exception is taken to EL2.
- When taken from EL3, the exception is taken to EL3.

If any of the following is true, the HVC instruction is UNDEFINED:

- The PE is executing at EL0.
- If EL2 is not enabled in the current Security state, and the PE is executing at EL1.
- The Effective value of SCR\_EL3.HCE is 0.
- EL2 is not implemented.

If EL3 is implemented and the SMC instruction is not UNDEFINED or trapped, a Secure Monitor Call is generated by executing an SMC instruction. A Secure Monitor Call is a synchronous exception that is taken to EL3.

RZVTPR

RNDGTC

RHMXQS If any of the following are true, the SMC instruction is UNDEFINED:

- The PE is executing at EL0.
- EL3 is not implemented and the SMC instruction is not trapped to EL2 by HCR\_EL2.TSC.
- SCR\_EL3.SMD is 1 and the SMC instruction is not trapped to EL2 by HCR\_EL2.TSC.

## D1.4.10 Program Counter and stack pointer alignment

## D1.4.10.1 PC alignment checking

RQCCWG

If bits [1:0] of the PC are not 0b00 , there is a misaligned PC.

RSJLDM

The execution of an instruction with a misaligned PC generates a synchronous PC Alignment exception on that instruction.

RJKZZX

APCAlignment exception is taken to the following Exception levels:

- If executing at EL0:

- If HCR\_EL2.TGE is 0, the exception is taken to EL1.

RMVTQT

IVFXPV

RRDMXG

RTFVSM

RJQXVP

RSTDYJ

RNCGYQ

- -If HCR\_EL2.TGE is 1, the exception it taken to EL2.
- If executing at EL1, the exception is taken to EL1.
- If executing at EL2, the exception is taken to EL2.
- If executing at EL3, the exception is taken to EL3.

When a PC Alignment Fault exception is taken to an Exception level, ELx, using AArch64, the ELR\_ELx and the FAR\_ELx both hold the entire PC in its misaligned form.

Amisalignment of the PC is an indication of a serious error, for example software corruption of an address.

## D1.4.10.2 SP alignment checking

When the SP is used as the base address of a calculation, regardless of any offset applied by the instruction, if bits [3:0] of the SP are not 0b0000 , there is a misaligned SP.

If SP alignment checking is enabled, then the execution of a load or store using the SP with a misaligned SP generates a synchronous SP Alignment exception on that load or store.

PRFMinstructions that use the SP do not perform stack alignment checking.

The following bits enable SP alignment checking at each Exception level when that Exception level is using AArch64.

- If the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}, SCTLR\_EL2.SA0 controls EL0. Otherwise, SCTLR\_EL1.SA0 controls EL0.
- SCTLR\_EL1.SA controls EL1.
- SCTLR\_EL2.SA controls EL2.
- SCTLR\_EL3.SA controls EL3.

An SP Alignment exception is taken to the following Exception levels:

- If executing at EL0:
- -If HCR\_EL2.TGE is 0, the exception is taken to EL1
- -If HCR\_EL2.TGE is 1, the exception it taken to EL2.
- If executing at EL1, the exception is taken to EL1.
- If executing at EL2, the exception is taken to EL2.
- If executing at EL3, the exception is taken to EL3.

RDLDVL If SP alignment checking is enabled and an SVE predicated load or store instruction with any Active elements uses the current SP as the base address, then the SP register is checked for 16-byte alignment.

RFNCJX

If SP alignment checking is enabled and an SVE predicated load or store instruction with no Active elements uses the current SP as the base address, then it is CONSTRAINED UNPREDICTABLE whether the SP register is checked for 16-byte alignment.