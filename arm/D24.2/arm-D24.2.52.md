## D24.2.52 FPEXC32\_EL2, Floating-Point Exception Control Register

The FPEXC32\_EL2 characteristics are:

## Purpose

Allows access to the AArch32 register FPEXC from AArch64 state only. Its value has no effect on execution in AArch64 state.

## Configuration

If EL2 is not implemented but EL3 is implemented, and EL1 is capable of using AArch32, then this register is not RES0.

Implemented only if the implementation includes the Advanced SIMD and floating-point functionality.

AArch64 System register FPEXC32\_EL2 bits [31:0] are architecturally mapped to AArch32 System register FPEXC[31:0].

This register is present only when FEAT\_AA32EL1 is implemented and FEAT\_AA64 is implemented. Otherwise, direct accesses to FPEXC32\_EL2 are UNDEFINED.

## Attributes

FPEXC32\_EL2 is a 64-bit register.

## Field descriptions

<!-- image -->

## Bits [63:32]

Reserved, RES0.

## EX, bit [31]

Exception bit.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

Access to this field is RAZ/WI.

## EN, bit [30]

Enables access to the Advanced SIMD and floating-point functionality from all Exception levels, except that setting this field to 0 does not disable the following:

- VMSRaccesses to the FPEXC or FPSID.
- VMRSaccesses from the FPEXC, FPSID, MVFR0, MVFR1, or MVFR2.

| EN   | Meaning                                                                                                                                                                               |
|------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b0  | Accesses to the FPSCR, and any of the SIMD and floating-point registers Q0-Q15, including their views as D0-D31 registers or S0-S31 registers, are UNDEFINED at all Exception levels. |
| 0b1  | This control permits access to the Advanced SIMD and floating-point functionality at all Exception levels.                                                                            |

Execution of Advanced SIMD and floating-point instructions in AArch32 state can be disabled or trapped by the following controls:

- CPACR.cp10, or, if executing at EL0, CPACR\_EL1.FPEN.
- FPEXC.EN.
- If executing in Non-secure state:
- HCPTR.TCP10, or if EL2 is using AArch64, CPTR\_EL2.TFP.
- NSACR.cp10, or if EL3 is using AArch64, CPTR\_EL3.TFP.
- For Advanced SIMD instructions only:
- CPACR.ASEDIS.
- If executing in Non-secure state, HCPTR.TASE and NSACR.NSASEDIS.

See the descriptions of the controls for more information.

## Note

When executing at EL0 using AArch32:

- If EL1 is using AArch64, then the Effective value of FPEXC.EN is 1.
- If EL2 is using AArch64 and is enabled in the current Security state, HCR\_EL2.TGE is 1, and the Effective value of HCR\_EL2.RW is 1, then the Effective value of FPEXC.EN is 1. However, Arm deprecates using the value of FPEXC32\_EL2.EN to determine behavior.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## DEX, bit [29]

Defined synchronous exception on floating-point execution.

This field identifies whether a synchronous exception generated by the attempted execution of an instruction was generated by an unallocated encoding. The instruction must be in the encoding space that is identified by the pseudocode function ExecutingCP10or11Instr() returning TRUE. This field also indicates whether the FPEXC32\_EL2.TFV field is valid.

The meaning of this bit is:

| DEX   | Meaning                                                                                                                                                                                                                                                                                                                           |
|-------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b0   | The exception was generated by the attempted execution of an unallocated instruction in the encoding space that is identified by the pseudocode function ExecutingCP10or11Instr(). If FPEXC32_EL2.TFV is RWthen it is invalid and UNKNOWN. If FPEXC32_EL2.{IDF, IXF, UFF, OFF, DZF, IOF} are RWthen they are invalid and UNKNOWN. |
| 0b1   | The exception was generated during the execution of an allocated encoding. FPEXC32_EL2.TFV is valid and indicates the cause of the exception.                                                                                                                                                                                     |

On an exception that sets this bit to 1 the exception-handling routine must clear this bit to 0.

On an implementation that both does not support trapping of floating-point exceptions and implements the AArch32 FPSCR.{Stride, Len} fields as RAZ, this bit is RES0.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## FP2V, bit [28]

FPINST2 instruction Valid bit. From Armv8.0, this bit is RES0.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

Access to this field is RES0.

## VV, bit [27]

VECITR valid bit. From Armv8, this bit is RES0.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

Access to this field is RES0.

## TFV, bit [26]

Trapped Fault Valid bit. Valid only when the value of FPEXC32\_EL2.DEX is 1. When valid, it indicates the cause of the exception and therefore whether FPEXC32\_EL2.{IDF, IXF, UFF, OFF, DZF, IOF} are valid.

| TFV   | Meaning                                                                                                                                                                                                                                                                                                                            |
|-------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b0   | The exception was caused by the execution of a floating-point VABS, VADD, VDIV, VFMA, VFMS, VFNMA, VFNMS, VMLA, VMLS, VMOV, VMUL, VNEG, VNMLA, VNMLS, VNMUL, VSQRT, or VSUBinstruction when one or both of FPSCR.{Stride, Len} was nonzero. If FPEXC32_EL2.{IDF, IXF, UFF, OFF, DZF, IOF} are RWthen they are invalid and UNKNOWN. |
| 0b1   | FPEXC32_EL2.{IDF, IXF, UFF, OFF, DZF, IOF} indicate the presence of trapped floating-point exceptions that had occurred at the time of the exception. Bits are set for all trapped exceptions that had occurred at the time of the exception.                                                                                      |

This bit returns a status value and ignores writes.

When the value of FPEXC32\_EL2.DEX is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

Accessing this field has the following behavior:

- When an implementation does not implement trapping of floating-point exceptions, access to this field is RAZ/WI.
- When an implementation implements FPSCR.LEN,STRIDE as RAZ, access to this field is RAO/WI.

## Bits [25:11]

Reserved, RES0.

## VECITR, bits [10:8]

Vector iteration count. From Armv8, this field is RES1.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

Access to this field is RES1.

## IDF, bit [7]

Input Denormal trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Input Denormal exception occurred while FPSCR.IDE was 1:

| IDF   | Meaning                                    |
|-------|--------------------------------------------|
| 0b0   | Input Denormal exception has not occurred. |
| 0b1   | Input Denormal exception has occurred.     |

Input Denormal exceptions can occur only when FPSCR.FZ is 1.

Note

Ahalf-precision floating-point value that is flushed to zero because the value of FPSCR.FZ16 is 1 does not generate an Input Denormal exception.

This bit must be cleared to 0 by the exception-handling routine.

When the value of FPEXC32\_EL2.TFV is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

When an implementation does not implement trapping of Input Denormal floating-point exceptions, access to this field is RAZ/WI.

## Bits [6:5]

Reserved, RES0.

## IXF, bit [4]

Inexact trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Inexact exception occurred while FPSCR.IXE was 1:

| IXF   | Meaning                             |
|-------|-------------------------------------|
| 0b0   | Inexact exception has not occurred. |
| 0b1   | Inexact exception has occurred.     |

This bit must be cleared to 0 by the exception-handling routine.

When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

When an implementation does not implement trapping of Inexact floating-point exceptions, access to this field is RAZ/WI.

## UFF, bit [3]

Underflow trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Underflow exception occurred while FPSCR.UFE was 1:

Underflow trapped exceptions can occur:

- On half-precision data-processing instructions only when FPSCR.FZ16 is 0.
- Otherwise only when FPSCR.FZ is 0.

This bit must be cleared to 0 by the exception-handling routine.

When the value of FPEXC32\_EL2.TFV is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

When an implementation does not implement trapping of Underflow floating-point exceptions, access to this field is RAZ/WI.

## OFF, bit [2]

Overflow trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Overflow exception occurred while FPSCR.OFE was 1:

| OFF   | Meaning                              |
|-------|--------------------------------------|
| 0b0   | Overflow exception has not occurred. |
| 0b1   | Overflow exception has occurred.     |

This bit must be cleared to 0 by the exception-handling routine.

When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

When an implementation does not implement trapping of Overflow floating-point exceptions, access to this field is RAZ/WI.

## DZF, bit [1]

Divide by Zero trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether a Divide by Zero exception occurred while FPSCR.DZE was 1:

| DZF   | Meaning                                    |
|-------|--------------------------------------------|
| 0b0   | Divide by Zero exception has not occurred. |
| 0b1   | Divide by Zero exception has occurred.     |

This bit must be cleared to 0 by the exception-handling routine.

| UFF   | Meaning                               |
|-------|---------------------------------------|
| 0b0   | Underflow exception has not occurred. |
| 0b1   | Underflow exception has occurred.     |

When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

When an implementation does not implement trapping of Divide by Zero floating-point exceptions, access to this field is RAZ/WI.

## IOF, bit [0]

Invalid Operation trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Invalid Operation exception occurred while FPSCR.IOE was 1:

| IOF   | Meaning                                       |
|-------|-----------------------------------------------|
| 0b0   | Invalid Operation exception has not occurred. |
| 0b1   | Invalid Operation exception has occurred.     |

This bit must be cleared to 0 by the exception-handling routine.

When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

When an implementation does not implement trapping of Invalid Operation floating-point exceptions, access to this field is RAZ/WI.

## Accessing FPEXC32\_EL2

Accesses to this register use the following encodings in the System register encoding space:

MRS &lt;Xt&gt;, FPEXC32\_EL2

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b100 | 0b0101 | 0b0011 | 0b000 |

```
if !(IsFeatureImplemented(FEAT_AA32EL1) && IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif !IsFeatureImplemented(FEAT_AA32EL1) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EffectiveHCR_EL2_NVx() IN {'xx1'} then AArch64.SystemAccessTrap(EL2, 0x18); else UNDEFINED; elsif PSTATE.EL == EL2 then if HaveEL(EL3) && EL3SDDUndefPriority() && CPTR_EL3.TFP == '1' then UNDEFINED; elsif !ELIsInHost(EL2) && CPTR_EL2.TFP == '1' then AArch64.SystemAccessTrap(EL2, 0x07); elsif ELIsInHost(EL2) && CPTR_EL2.FPEN IN {'x0'} then AArch64.SystemAccessTrap(EL2, 0x07);
```

```
elsif HaveEL(EL3) && CPTR_EL3.TFP == '1' then if EL3SDDUndef() then UNDEFINED; else AArch64.SystemAccessTrap(EL3, 0x07); else X[t, 64] = FPEXC32_EL2; elsif PSTATE.EL == EL3 then if CPTR_EL3.TFP == '1' then AArch64.SystemAccessTrap(EL3, 0x07); else X[t, 64] = FPEXC32_EL2;
```

MSR FPEXC32\_EL2, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b100 | 0b0101 | 0b0011 | 0b000 |

```
if !(IsFeatureImplemented(FEAT_AA32EL1) && IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif !IsFeatureImplemented(FEAT_AA32EL1) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EffectiveHCR_EL2_NVx() IN {'xx1'} then AArch64.SystemAccessTrap(EL2, 0x18); else UNDEFINED; elsif PSTATE.EL == EL2 then if HaveEL(EL3) && EL3SDDUndefPriority() && CPTR_EL3.TFP == '1' then UNDEFINED; elsif !ELIsInHost(EL2) && CPTR_EL2.TFP == '1' then AArch64.SystemAccessTrap(EL2, 0x07); elsif ELIsInHost(EL2) && CPTR_EL2.FPEN IN {'x0'} then AArch64.SystemAccessTrap(EL2, 0x07); elsif HaveEL(EL3) && CPTR_EL3.TFP == '1' then if EL3SDDUndef() then UNDEFINED; else AArch64.SystemAccessTrap(EL3, 0x07); else FPEXC32_EL2 = X[t, 64]; elsif PSTATE.EL == EL3 then if CPTR_EL3.TFP == '1' then AArch64.SystemAccessTrap(EL3, 0x07); else FPEXC32_EL2 = X[t, 64];
```