## D24.2.49 FAR\_EL2, Fault Address Register (EL2)

The FAR\_EL2 characteristics are:

## Purpose

Holds the faulting Virtual Address for all synchronous Instruction Abort exceptions, Data Abort exceptions, PC alignment fault exceptions and Watchpoint exceptions that are taken to EL2.

## Configuration

If EL2 is not implemented, this register is RES0 from EL3.

This register has no effect if EL2 is not enabled in the current Security state.

AArch64 System register FAR\_EL2 bits [31:0] are architecturally mapped to AArch32 System register HDFAR[31:0].

AArch64 System register FAR\_EL2 bits [63:32] are architecturally mapped to AArch32 System register HIFAR[31:0].

This register is present only when FEAT\_AA64 is implemented. Otherwise, direct accesses to FAR\_EL2 are UNDEFINED.

## Attributes

FAR\_EL2 is a 64-bit register.

## Field descriptions

```
Faulting Virtual Address for synchronous exceptions taken to EL2 63 32 Faulting Virtual Address for synchronous exceptions taken to EL2 31 0
```

## VA, bits [63:0]

Faulting Virtual Address for synchronous exceptions taken to EL2. Exceptions that set the FAR\_EL2 are Instruction Aborts (EC 0x20 or 0x21 ), Data Aborts (EC 0x24 or 0x25 ), PC alignment faults (EC 0x22 ), and Watchpoints (EC 0x34 or 0x35 ). ESR\_EL2.EC holds the EC syndrome value for the exception.

For a synchronous External abort:

- If the V A that generated the abort was from an address range for which Address tagging is enabled for the translation regime in use when the abort was generated, then bits[63:56] of FAR\_EL2 are UNKNOWN.
- If the V A that generated the abort was from an address range for which Address tagging is disabled and Logical Address Tagging is enabled for the translation regime in use when the abort was generated, then bits[59:56] of FAR\_EL2 are UNKNOWN.

For a synchronous External abort other than a synchronous External abort on a translation table walk, this field is valid only if ESR\_EL2.FnV is 0, and FAR\_EL2 is UNKNOWN if ESR\_EL2.FnV is 1.

On an exception due to a Tag Check Fault caused by a data cache maintenance or other DC instruction, the address held in FAR\_EL2 is IMPLEMENTATION DEFINED as one of the following:

- The lowest address that gave rise to the fault.
- The address specified in the register argument of the instruction as generated by MMU faults caused by DC ZVA.

If a memory fault that sets FAR\_EL2 is generated from an STZGM instruction, the address held in FAR\_EL2 is IMPLEMENTATION DEFINED as one of the following:

- The lowest address that gave rise to the fault.
- The address specified in the register argument.

If a memory fault that sets FAR\_EL2, other than a Tag Check Fault, is generated from a data cache maintenance or other DC instruction, this field holds the address specified in the register argument of the instruction.

If the exception that updates FAR\_EL2 is taken from an Exception level using AArch32, the top 32 bits are all zero, unless both of the following apply, in which case the top 32 bits of FAR\_ELx are 0x00000001 :

- The faulting address was generated by a load or store instruction that sequentially incremented from address 0xFFFFFFFF . Such a load or store instruction is CONSTRAINED UNPREDICTABLE.
- The implementation treats such incrementing as setting bit[32] of the virtual address to 1.

When the PE sets ESR\_EL2.{ISV,FnP} to {0,1} on taking a Data Abort exception, the PE sets FAR\_EL2 to any address within the naturally-aligned fault granule that contains the virtual address of the memory access that generated the Data Abort exception.

When the PE sets ESR\_EL2.{FnV,FnP} to {0,1} on taking a Watchpoint exception, the PE sets FAR\_EL2 to any address within the naturally-aligned fault granule that contains the virtual address of the memory access that generated the Watchpoint exception.

The naturally-aligned fault granule is one of:

- When ESR\_EL2.DFSC is 0b010001 , indicating a Synchronous Tag Check fault, it is a 16-byte tag granule.
- When ESR\_EL2.DFSC is 0b11010x , indicating an IMPLEMENTATION DEFINED fault, it is an IMPLEMENTATION DEFINED granule.
- Otherwise, it is the smallest implemented translation granule.

When FEAT\_MOPS is implemented, the value in FAR\_EL2 on a synchronous exception from any of the Memory Copy and Memory Set instructions represents the first element that has not been copied or set, and is determined as follows:

- For an MMU fault reported as a Data Abort, the value is within the address range of the relevant translation granule, aligned to the size of the relevant translation granule of the address that generated the Data Abort. Bits[(n-1):0] of the value are UNKNOWN, where 2 n is the relevant translation granule size in bytes. For the purpose of calculating the relevant translation granule, if the MMU is disabled for a stage of translation, then the current translation granule size is equal to 2 64 for stage 1, and the PARange for stage 2. The relevant translation granule is:
- For MMU faults generated at stage 1, the current stage 1 translation granule.
- For MMU faults generated at stage 2, the smaller of the current stage 1 translation granule and the current stage 2 translation granule.
- If FEAT\_RME is implemented, for a synchronous Data Abort generated as the result of a GPF, the smallest of the current stage 1 translation granule, the current stage 2 translation granule and the configured granule size in GPCCR\_EL3.PGS.
- For a Data Abort generated by a Tag Check Fault, the value is any address that caused a Tag Check Fault within the block size of the load or store.
- For a Watchpoint exception, the value is an address range of the size defined by the DCZID\_EL0.BS field. This address does not need to be the element with a watchpoint, but can be some earlier element.
- Otherwise, the value is the lowest address in the block size of the load or store.

For a Data Abort exception or Watchpoint exception, if address tagging is enabled for the address accessed by the data access that caused the exception, then this field includes the tag. For more information about address tagging, see 'Address tagging'.

For a synchronous Tag Check Fault:

- If FEAT\_MTE\_TAGGED\_FAR is implemented or Address tagging is disabled for the translation regime in use when the abort was generated, all bits of FAR\_EL2 are not UNKNOWN.
- If FEAT\_MTE\_TAGGED\_FAR is not implemented and Address tagging is enabled for the translation regime in use when the abort was generated, bits[63:60] of FAR\_EL2 are UNKNOWN.

Execution at EL1 or EL0 makes FAR\_EL2 become UNKNOWN.

Note

The address held in this field is an address accessed by the instruction fetch or data access that caused the exception that actually gave rise to the instruction or Data Abort. It is the lower address that gave rise to the fault that is reported. Where different faults from different addresses arise from the same instruction, such as for an instruction that loads or stores an unaligned address that crosses a page boundary, the architecture does not prioritize which fault is reported.

For all other exceptions taken to EL2, FAR\_EL2 is UNKNOWN.

FAR\_EL2 is made UNKNOWN on an exception return from EL2.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Accessing FAR\_EL2

When the Effective value of HCR\_EL2.E2H is 1, without explicit synchronization, accesses from EL2 using the accessor name FAR\_EL2 or FAR\_EL1 are not guaranteed to be ordered with respect to accesses using the other accessor name.

Accesses to this register use the following encodings in the System register encoding space:

```
MRS <Xt>, FAR_EL2
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b100 | 0b0110 | 0b0000 | 0b000 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EffectiveHCR_EL2_NVx() IN {'1x1'} then X[t, 64] = FAR_EL1; elsif EffectiveHCR_EL2_NVx() IN {'xx1'} then AArch64.SystemAccessTrap(EL2, 0x18); else UNDEFINED; elsif PSTATE.EL == EL2 then X[t, 64] = FAR_EL2; elsif PSTATE.EL == EL3 then X[t, 64] = FAR_EL2;
```

```
MSR FAR_EL2, <Xt>
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b100 | 0b0110 | 0b0000 | 0b000 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then
```

```
if EffectiveHCR_EL2_NVx() IN {'1x1'} then FAR_EL1 = X[t, 64]; elsif EffectiveHCR_EL2_NVx() IN {'xx1'} then AArch64.SystemAccessTrap(EL2, 0x18); else UNDEFINED; elsif PSTATE.EL == EL2 then FAR_EL2 = X[t, 64]; elsif PSTATE.EL == EL3 then FAR_EL2 = X[t, 64];
```

When FEAT\_VHE is implemented MRS &lt;Xt&gt;, FAR\_EL1

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b000 | 0b0110 | 0b0000 | 0b000 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TRVM == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') ↪ → && HFGRTR_EL2.FAR_EL1 == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EffectiveHCR_EL2_NVx() IN {'111'} then X[t, 64] = NVMem[0x220]; else X[t, 64] = FAR_EL1; elsif PSTATE.EL == EL2 then if ELIsInHost(EL2) then X[t, 64] = FAR_EL2; else X[t, 64] = FAR_EL1; elsif PSTATE.EL == EL3 then X[t, 64] = FAR_EL1;
```

When FEAT\_VHE is implemented MSR FAR\_EL1, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b000 | 0b0110 | 0b0000 | 0b000 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TVM == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') ↪ → && HFGWTR_EL2.FAR_EL1 == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EffectiveHCR_EL2_NVx() IN {'111'} then
```

```
NVMem[0x220] = X[t, 64]; else FAR_EL1 = X[t, 64]; elsif PSTATE.EL == EL2 then if ELIsInHost(EL2) then FAR_EL2 = X[t, 64]; else FAR_EL1 = X[t, 64]; elsif PSTATE.EL == EL3 then FAR_EL1 = X[t, 64];
```