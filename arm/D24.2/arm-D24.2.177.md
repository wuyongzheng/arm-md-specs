## D24.2.177 SCTLR\_EL3, System Control Register (EL3)

The SCTLR\_EL3 characteristics are:

## Purpose

Provides top-level control of the system, including its memory system, at EL3.

## Configuration

This register is present only when EL3 is implemented and FEAT\_AA64 is implemented. Otherwise, direct accesses to SCTLR\_EL3 are UNDEFINED.

## Attributes

SCTLR\_EL3 is a 64-bit register.

## Field descriptions

<!-- image -->

## Bit [63]

Reserved, RES0.

## SPINTMASK, bit [62]

## When FEAT\_NMI is implemented:

SP Interrupt Mask enable. When SCTLR\_EL3.NMI is 1, controls whether PSTATE.SP acts as an interrupt mask, and controls the value of PSTATE.ALLINT on taking an exception to EL3.

| SPINTMASK   | Meaning                                                                                                                                                                                                        |
|-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b0         | Does not cause PSTATE.SP to mask interrupts. PSTATE.ALLINT is set to 1 on taking an exception to EL3.                                                                                                          |
| 0b1         | When PSTATE.SP is 1 and execution is at EL3, an IRQ or FIQ interrupt that is targeted to EL3 is masked regardless of any indication of Superpriority. PSTATE.ALLINT is set to 0 on taking an exception to EL3. |

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

NMI, bit [61]

## When FEAT\_NMI is implemented:

Non-maskable Interrupt enable.

| NMI   | Meaning                                                  |
|-------|----------------------------------------------------------|
| 0b0   | This control does not affect interrupt masking behavior. |
| 0b1   | This control enables all of the following:               |

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL3, this field resets to '0' .

## Otherwise:

Reserved, RES0.

Bit [60]

Reserved, RES0.

TCSO, bit [59]

## When FEAT\_MTE\_STORE\_ONLY is implemented:

Tag Checking Store Only.

| TCSO   | Meaning                                                                                   |
|--------|-------------------------------------------------------------------------------------------|
| 0b0    | This field has no effect on Tag checking.                                                 |
| 0b1    | Explicit Memory Read Effects generated by instructions executed in EL3 are Tag Unchecked. |

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

Bits [58:45]

Reserved, RES0.

DSSBS, bit [44]

## When FEAT\_SSBS is implemented:

Default PSTATE.SSBS value on Exception Entry.

| DSSBS   | Meaning                                         |
|---------|-------------------------------------------------|
| 0b0     | PSTATE.SSBS is set to 0 on an exception to EL3. |
| 0b1     | PSTATE.SSBS is set to 1 on an exception to EL3. |

The reset behavior of this field is:

- On a Warm reset, this field resets to an IMPLEMENTATION DEFINED value.

## Otherwise:

Reserved, RES0.

## ATA, bit [43]

## When FEAT\_MTE2 is implemented:

Allocation Tag Access in EL3.

Controls use of Memory tagging in EL3.

| ATA   | Meaning                                   |
|-------|-------------------------------------------|
| 0b0   | Use of Memory tagging is disabled at EL3. |
| 0b1   | Use of Memory tagging is enabled at EL3.  |

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## Bit [42]

Reserved, RES0.

TCF, bits [41:40]

## When FEAT\_MTE2 is implemented:

Tag Check Fault in EL3. Controls the effect of Tag Check Faults due to Loads and Stores in EL3.

| TCF   | Meaning                                         | Applies when   |
|-------|-------------------------------------------------|----------------|
| 0b00  | Tag Check Faults have no effect on the PE.      |                |
| 0b01  | Tag Check Faults cause a synchronous exception. |                |

| TCF   | Meaning                                                                                                | Applies when                       |
|-------|--------------------------------------------------------------------------------------------------------|------------------------------------|
| 0b10  | Tag Check Faults are asynchronously accumulated.                                                       |                                    |
| 0b11  | Tag Check Faults cause a synchronous exception on reads, and are asynchronously accumulated on writes. | FEAT_MTE_ASYM_FAULT is implemented |

If FEAT\_MTE3 is not implemented, the value 0b11 is reserved.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## Bits [39:38]

Reserved, RES0.

## ITFSB, bit [37]

## When FEAT\_MTE\_ASYNC is implemented:

When synchronous exceptions are not being generated by Tag Check Faults, this field controls whether on exception entry into EL3, all Tag Check Faults due to instructions executed before exception entry, that are reported asynchronously, are synchronized into TFSRE0\_EL1 and TFSR\_ELx registers.

| ITFSB   | Meaning                                                |
|---------|--------------------------------------------------------|
| 0b0     | Tag Check Faults are not synchronized on entry to EL3. |
| 0b1     | Tag Check Faults are synchronized on entry to EL3.     |

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## BT, bit [36]

## When FEAT\_BTI is implemented:

Indicates the Branch Type compatibility of the implicit BTI behavior for the following instructions at EL3:

- PACIASP .
- PACIBSP .
- If FEAT\_PAuth\_LR is implemented, PACIASPPC .
- If FEAT\_PAuth\_LR is implemented, PACIBSPPC .

| BT   | Meaning                                                                                                                                                   |
|------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b0  | When the PE is executing at EL3, when the specified instructions have an implicit BTI behavior, they are compatible with the same BTYPE values as BTI.jc. |
| 0b1  | When the PE is executing at EL3, when the specified instructions have an implicit BTI behavior, they are compatible with the same BTYPE values as BTI.c.  |

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## Bits [35:32]

Reserved, RES0.

## EnIA, bit [31]

## When FEAT\_PAuth is implemented:

Controls enabling of pointer authentication of instruction addresses, using the APIAKey\_EL1 key, in the EL3 translation regime.

Possible values of this bit are:

| EnIA   | Meaning                                                                                     |
|--------|---------------------------------------------------------------------------------------------|
| 0b0    | Pointer authentication of instruction addresses, using the APIAKey_EL1 key, is not enabled. |
| 0b1    | Pointer authentication of instruction addresses, using the APIAKey_EL1 key, is enabled.     |

## Note

This field controls the behavior of the AddPACIA and AuthIA pseudocode functions. Specifically, when the field is 1, AddPACIA returns a copy of a pointer to which a pointer authentication code has been added, and AuthIA returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## EnIB, bit [30]

## When FEAT\_PAuth is implemented:

Controls enabling of pointer authentication of instruction addresses, using the APIBKey\_EL1 key, in the EL3 translation regime.

Possible values of this bit are:

| EnIB   | Meaning                                                                                     |
|--------|---------------------------------------------------------------------------------------------|
| 0b0    | Pointer authentication of instruction addresses, using the APIBKey_EL1 key, is not enabled. |
| 0b1    | Pointer authentication of instruction addresses, using the APIBKey_EL1 key, is enabled.     |

## Note

This field controls the behavior of the AddPACIB and AuthIB pseudocode functions. Specifically, when the field is 1, AddPACIB returns a copy of a pointer to which a pointer authentication code has been added, and AuthIB returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## Bits [29:28]

Reserved, RES1.

## EnDA, bit [27]

## When FEAT\_PAuth is implemented:

Controls enabling of pointer authentication of instruction addresses, using the APDAKey\_EL1 key, in the EL3 translation regime.

| EnDA   | Meaning                                                                              |
|--------|--------------------------------------------------------------------------------------|
| 0b0    | Pointer authentication of data addresses, using the APDAKey_EL1 key, is not enabled. |
| 0b1    | Pointer authentication of data addresses, using the APDAKey_EL1 key, is enabled.     |

## Note

This field controls the behavior of the AddPACDA and AuthDA pseudocode functions. Specifically, when the field is 1, AddPACDA returns a copy of a pointer to which a pointer authentication code has been added, and AuthDA returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## Bit [26]

Reserved, RES0.

## EE, bit [25]

## When FEAT\_MixedEnd is implemented:

Endianness of data accesses at EL3, and stage 1 translation table walks in the EL3 translation regime.

| EE   | Meaning                                                                                                             |
|------|---------------------------------------------------------------------------------------------------------------------|
| 0b0  | Explicit data accesses at EL3, and stage 1 translation table walks in the EL3 translation regime are little-endian. |
| 0b1  | Explicit data accesses at EL3, and stage 1 translation table walks in the EL3 translation regime are big-endian.    |

The EE bit is permitted to be cached in a TLB.

The reset behavior of this field is:

- On a Warm reset, this field resets to an IMPLEMENTATION DEFINED value.

## When FEAT\_BigEnd is implemented:

Explicit data accesses at EL1, and stage 1 translation table walks in the EL1&amp;0 translation regime are big-endian.

Reserved, RES1.

## Otherwise:

Explicit data accesses at EL1, and stage 1 translation table walks in the EL1&amp;0 translation regime are little-endian.

Reserved, RES0.

## Bit [24]

Reserved, RES0.

## Bit [23]

Reserved, RES1.

## EIS, bit [22]

## When FEAT\_ExS is implemented:

Exception Entry is a context synchronization event.

| EIS   | Meaning                                                                   |
|-------|---------------------------------------------------------------------------|
| 0b0   | The taking of an exception to EL3 is not a context synchronization event. |
| 0b1   | The taking of an exception to EL3 is a context synchronization event.     |

## If SCTLR\_EL3.EIS is set to 0b0 :

- Indirect writes to ESR\_EL3, FAR\_EL3, SPSR\_EL3, ELR\_EL3 are synchronized on exception entry to EL3, so that a direct read of the register after exception entry sees the indirectly written value caused by the exception entry.
- Memory transactions, including instruction fetches, from an Exception level always use the translation resources associated with that translation regime.
- Exception Catch debug events are synchronous debug events.
- DCPS* and DRPS instructions are context synchronization events.
- Some exception entries reported are not considered IFBEs per the memory model.

The following are not affected by the value of SCTLR\_EL3.EIS:

- Changes to the PSTATE information on entry to EL3.

- Behavior of accessing the banked copies of the stack pointer using the SP register name for loads, stores and data processing instructions.
- The memory model requirement for exception entry to generate an Instruction Fetch Barrier Effect for some exception entries. See Basic definitions for the list of exception entries.
- Exit from Debug state.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES1.

## IESB, bit [21]

## When FEAT\_IESB is implemented:

Implicit Error Synchronization event enable.

| IESB   | Meaning                                                                             |
|--------|-------------------------------------------------------------------------------------|
| 0b0    | Disabled.                                                                           |
| 0b1    | An implicit error synchronization event is added: • At each exception taken to EL3. |

When the PE is in Debug state, the effect of this field is CONSTRAINED UNPREDICTABLE, and its Effective value might be 0 or 1 regardless of the value of the field and, if implemented, SCR\_EL3.NMEA. If the Effective value of the field is 1, then an implicit error synchronization event is added after each DCPSx instruction taken to EL3 and before each DRPS instruction executed at EL3, in addition to the other cases where it is added.

When FEAT\_DoubleFault is implemented, the PE is in Non-debug state, and the Effective value of SCR\_EL3.NMEA is 1, this field is ignored and its Effective value is 1.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## Bit [20]

Reserved, RES0.

## WXN,bit [19]

Write permission implies XN (Execute-never). For the EL3 translation regime, this bit can force all memory regions that are writable to be treated as XN.

| WXN   | Meaning                                                                                                               |
|-------|-----------------------------------------------------------------------------------------------------------------------|
| 0b0   | This control has no effect on memory access permissions.                                                              |
| 0b1   | Any region that is writable in the EL3 translation regime is forced to XNfor accesses from software executing at EL3. |

This bit applies only when SCTLR\_EL3.M bit is set.

The WXN bit is permitted to be cached in a TLB.

This field is RES0 if TCR\_EL3.PIE is 1.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Bit [18]

Reserved, RES1.

## Bit [17]

Reserved, RES0.

## Bit [16]

Reserved, RES1.

## Bits [15:14]

Reserved, RES0.

## EnDB, bit [13]

## When FEAT\_PAuth is implemented:

Controls enabling of pointer authentication of instruction addresses, using the APDBKey\_EL1 key, in the EL3 translation regime.

| EnDB   | Meaning                                                                              |
|--------|--------------------------------------------------------------------------------------|
| 0b0    | Pointer authentication of data addresses, using the APDBKey_EL1 key, is not enabled. |
| 0b1    | Pointer authentication of data addresses, using the APDBKey_EL1 key, is enabled.     |

Note

This field controls the behavior of the AddPACDB and AuthDB pseudocode functions. Specifically, when the field is 1, AddPACDB returns a copy of a pointer to which a pointer authentication code has been added, and AuthDB returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## I, bit [12]

Instruction access Cacheability control, for accesses at EL3:

| I   | Meaning                                                                                                                                                                                                                                                                                                |
|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b0 | All instruction access to Normal memory from EL3 are Non-cacheable for all levels of instruction and unified cache. If the value of SCTLR_EL3.M is 0, instruction accesses from stage 1 of the EL3 translation regime are to Normal, Outer Shareable, Inner Non-cacheable, Outer Non-cacheable memory. |
| 0b1 | This control has no effect on the Cacheability of instruction access to Normal memory from EL3. If the value of SCTLR_EL3.M is 0, instruction accesses from stage 1 of the EL3 translation regime are to Normal, Outer Shareable, Inner Write-Through, Outer Write-Through memory.                     |

This bit has no effect on the EL1&amp;0, EL2, or EL2&amp;0 translation regimes.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL3, this field resets to '0' .

## EOS, bit [11]

## When FEAT\_ExS is implemented:

Exception Exit is a context synchronization event.

| EOS   | Meaning                                                             |
|-------|---------------------------------------------------------------------|
| 0b0   | An exception return from EL3 is not a context synchronization event |
| 0b1   | An exception return from EL3 is a context synchronization event     |

## If SCTLR\_EL3.EOS is set to 0b0 :

- Memory transactions, including instruction fetches, from an Exception level always use the translation resources associated with that translation regime.
- Exception Catch debug events are synchronous debug events.
- DCPS* and DRPS instructions are context synchronization events.

The following are not affected by the value of SCTLR\_EL3.EOS:

- The indirect write of the PSTATE and PC values from SPSR\_EL3 and ELR\_EL3 on exception return is synchronized.
- If the PE enters Debug state before the first instruction after an Exception return from EL3 to Non-secure state, any pending Halting debug event completes execution.
- The GIC behavior that allocates interrupts to FIQ or IRQ changes simultaneously with leaving the EL3 Exception level.
- Behavior of accessing the banked copies of the stack pointer using the SP register name for loads, stores and data processing instructions.
- Exit from Debug state.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES1.

## Bits [10:7]

Reserved, RES0.

## nAA, bit [6]

## When FEAT\_LSE2 is implemented:

Non-aligned access. This bit controls generation of Alignment faults at EL3 under certain conditions.

The following instructions generate an Alignment fault if all bytes being accessed are not within a single naturally aligned 16-byte quantity, for access:

- LDAPR, LDAPRH, LDAPUR, LDAPURH, LDAPURSH, LDAPURSW, LDAR, LDARH, LDLAR, LDLARH.
- STLLR, STLLRH, STLR, STLRH, STLUR, and STLURH.
- If FEAT\_LRCPC3 is implemented, the post index versions of LDAPR and the pre index versions of STLR.
- If FEAT\_LRCPC3 and Advanced SIMD and floating-point instructions are implemented, LDAPUR (SIMD&amp;FP), LDAP1 (SIMD&amp;FP), STLUR (SIMD&amp;FP), and STL1 (SIMD&amp;FP).

If FEAT\_LRCPC3 is implemented, the following instructions generate an Alignment fault if all bytes being accessed for a single register are not within a single naturally aligned 16-byte quantity, for access:

- LDIAPP, STILP.

| nAA   | Meaning                                                                              |
|-------|--------------------------------------------------------------------------------------|
| 0b0   | Unaligned accesses by the specified instructions generate an Alignment fault.        |
| 0b1   | Unaligned accesses by the specified instructions do not generate an Alignment fault. |

For a load-acquire instruction that does not have acquire semantics as the result of the destination register, or registers, being ZR, it is IMPLEMENTATION SPECIFIC whether this field behaves as 1 or the programmed value.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## Bits [5:4]

Reserved, RES1.

## SA, bit [3]

SP Alignment check enable. When set to 1, if a load or store instruction executed at EL3 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see 'SP alignment checking'.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## C, bit [2]

Cacheability control, for data accesses.

| C   | Meaning                                                                                                                                                              |
|-----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b0 | All data access to Normal memory from EL3, and all Normal memory accesses to the EL3 translation tables, are Non-cacheable for all levels of data and unified cache. |
| 0b1 | This control has no effect on the Cacheability of: • Data access to Normal memory from EL3. • Normal memory accesses to the EL3 translation tables.                  |

This bit has no effect on the EL1&amp;0, EL2, or EL2&amp;0 translation regimes.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL3, this field resets to '0' .

## A, bit [1]

Alignment check enable. This is the enable bit for Alignment fault checking at EL3.

| A   | Meaning                                                                                                                                                                                                                                                                                                                                |
|-----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b0 | Alignment fault checking is disabled when executing at EL3. Alignment checks on some instructions are not disabled by this control. For more information, see 'Alignment of data accesses'.                                                                                                                                            |
| 0b1 | Alignment fault checking is enabled when executing at EL3. All instructions that load or store one or more registers have an alignment check that the address being accessed is aligned to the size of the data element(s) being accessed. If this check fails it causes an Alignment fault, which is taken as a Data Abort exception. |

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## M, bit [0]

MMUenable for EL3 stage 1 address translation. Possible values of this bit are:

| M   | Meaning                                                                                                                        |
|-----|--------------------------------------------------------------------------------------------------------------------------------|
| 0b0 | EL3 stage 1 address translation disabled. See the SCTLR_EL3.I field for the behavior of instruction accesses to Normal memory. |
| 0b1 | EL3 stage 1 address translation enabled.                                                                                       |

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL3, this field resets to '0' .

## Accessing SCTLR\_EL3

Accesses to this register use the following encodings in the System register encoding space:

MRS &lt;Xt&gt;, SCTLR\_EL3

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b110 | 0b0001 | 0b0000 | 0b000 |

if !(HaveEL(EL3) &amp;&amp; IsFeatureImplemented(FEAT\_AA64)) then

UNDEFINED;

elsif PSTATE.EL == EL0 then

UNDEFINED;

elsif PSTATE.EL == EL1 then

UNDEFINED;

elsif PSTATE.EL == EL2 then

UNDEFINED;

elsif PSTATE.EL == EL3 then

X[t, 64] = SCTLR\_EL3;

MSR SCTLR\_EL3, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b110 | 0b0001 | 0b0000 | 0b000 |

```
if !(HaveEL(EL3) && IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then UNDEFINED; elsif PSTATE.EL == EL2 then UNDEFINED; elsif PSTATE.EL == EL3 then if IsFeatureImplemented(FEAT_FGWTE3) && FGWTE3_EL3.SCTLR_EL3 == '1' AArch64.SystemAccessTrap(EL3, 0x18); else SCTLR_EL3 = X[t, 64];
```

then