## D8.15 Memory aborts

| R SQLMR   | For a VMSAv8-64 implementation, all of the following abort mechanisms can cause the PE to take an exception due to a failed memory access: • A Debug exception generated by the self-hosted debug system. For more information, see AArch64 Self-hosted Debug. • An Alignment fault generated by a memory access that is not aligned as required by the operation. For more information, see Alignment support. • An MMUfault generated by the fault checking sequence in the appropriate translation regime. For more information, see MMUfault types. • An External abort generated by the memory system and not by self-hosted debug, alignment checking,orMMU   |
|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| R XXMXW   | For AArch64 state, MMUfaults are synchronous exceptions that are reported as one of the following: • Data Aborts due to data memory access faults. • Instruction Aborts due to instruction fetch faults. For more information, see Synchronous exception types.                                                                                                                                                                                                                                                                                                                                                                                                     |
| I WFYSR   | In some cases, an MMUfault generated as part of AT instruction execution is reported in PAR_EL1 rather than as a synchronous abort.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| I YMZWZ   | When an MMUfault is generated and reported as an Instruction Abort or Data Abort, the Exception level that the exception is taken to depends on the translation regime and translation stage that caused the fault.                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| I DHWPX   | When a memory access abort generates an exception, all of the following registers are used to record context information:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| I XLTCG   | When an MMUfault is generated, the fault context saved in the ESR_ELx at the Exception level that the fault is taken to depends on all of the following: • Whether the fault is reported as an Instruction Abort or as a Data Abort. • Whether the exception is taken from the same or a lower Exception level.                                                                                                                                                                                                                                                                                                                                                     |
| I FVNYG   | For an Instruction Abort, only the following two exceptions have a higher priority in the exception priority hierarchy: • Software Step exception.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|           | • PC alignment fault exception.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |

## D8.15.1 MMU fault types

RYLSQG

All of the following MMU fault types are supported, and there are no other MMU fault types:

- Alignment fault on a data access. For more information, see Alignment support.
- Translation fault.
- Address size fault.
- Synchronous External abort on a translation table walk.
- Access flag fault.
- Permission fault.
- TLB conflict abort.
- Granule Protection Check fault (GPC fault). For more information, see GPC faults.

RGKZPW

When an attempt to access Device memory generates an MMU fault, no memory access occurs.

RTQDJS

If the memory attributes cannot be determined and the resultant memory region could be Device memory, then when an attempt to access that region generates an MMU fault, no memory access occurs.

## D8.15.1.1 Translation fault

| R DYNYQ   | If descriptor bit[0] is 0 in any translation table entry, the descriptor is invalid. When a translation table lookup returns an invalid descriptor, a Translation fault is generated and descriptor bits[63:1] are ignored.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| R KRMJZ   | If descriptor bit[1] is 0 at a lookup level that does not support Block descriptors, then the descriptor encoding is reserved. When a translation table lookup returns that descriptor, a Translation fault is generated.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| R FDQJL   | If FEAT_BBML1 is implemented, and the Block descriptor has the nT bit set, then the implementation is permitted to generate a Translation fault.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| I RRSLQ   | For any translation lookup level, when a Translation fault is generated, the reported fault code indicates the lookup level.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| R VZZSZ   | When one or more of the following apply, a level 0 Translation fault is generated on the relevant translation stage: • The IA does not map onto a TTBR_ELx address range. • If the IA maps onto the TTBR0_ELx address range and the IA contains any one bits above the configured IA size as determined by TCR_ELx.T0SZ. • If the IA maps onto the TTBR1_ELx address range and the IA contains any zero bits above the configured IA size as determined by TCR_ELx.T1SZ. • When a TLB miss occurs, the corresponding TCR_ELx.EPD n field prevents a translation table walk using TTBR n _ELx. • When FEAT_E0PD is implemented, the corresponding TCR_ELx.E0PD n field prevents unprivileged access to an address translated by TTBR n _ELx. |
| R MLNTS   | Atranslation table entry that generates a Translation fault is not cached in a TLB.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| I XFTPJ   | When a Translation fault is generated, the fault handler does not have to perform TLB maintenance to remove the faulting entry.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| I PXJFV   | For more information, see MMUfaults generated by cache maintenance operations.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| R CVSBH   | For a translation stage, if an address in one of the following has nonzero address bits above the configured OAsize, then an Address size fault is generated: • The TTBR_ELx used in the translation. • Atranslation table entry.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| R FTZHB   | An Address size fault can be generated at any translation lookup level.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| R WDZFC   | For the 64KB translation granule, if the implementation does not support 52-bit PAs, then all of the following apply: • It is IMPLEMENTATION DEFINED whether descriptor bits[15:12] being nonzero generates an Address size fault. • For this case, it is deprecated to not generate an Address size fault.                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| R BFHQH   | When an Address size fault is generated, the reported fault code indicates one of the following: • If the fault was generated due to the TTBR_ELx used in the translation having nonzero address bits above the OAsize, then a fault at level 0. • If the fault was not generated due to the TTBR_ELx used in the translation, then the lookup level at which the fault occurred.                                                                                                                                                                                                                                                                                                                                                           |
| R GGQPR   | When an Address size fault is generated, the translation table entry causing the fault is not cached in a TLB.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| I PBYZQ   | When an Address size fault is generated, the fault handler does not have to perform TLB maintenance to remove the faulting entry.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| I WWYQH   | An implementation is required to ensure that the Contiguous bit does not prevent generation of Address size faults. For more information, see Architectural guarantees when the Contiguous bit is misprogrammed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| I JTTDF   | For more information, see: • MMUfaults generated by cache maintenance operations. • Output address size configuration.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

IJVVQN

## D8.15.1.3 External abort on a translation table walk

RYLGBV If an External abort on a translation table walk is generated, then it is reported in one of the following ways:

- If the External abort is synchronous, then it is reported as one of the following:
- -If the translation table walk is due to an instruction fetch, then a synchronous Instruction Abort exception.
- -If the translation table walk is due to a data access, an address translation instruction, or a cache maintenance instruction operating by V A, then a synchronous Data Abort exception.
- If the External abort is asynchronous, then it is reported using the SError exception.

ATLBor intermediate TLB caching structure might support:

- An arbitrary number of translation table lookup levels.
- One or more translation stages that might not correspond to an address translation lookup stage.

RBGPQR If a synchronous External abort is generated due to a TLB or intermediate TLB caching structure, including parity or ECC errors, then all of the following are permitted:

- If the PE cannot precisely determine the translation stage at which the error occurred, then it is reported and prioritized as a stage 1 fault.
- If the PE cannot precisely determine the lookup level at which the error occurred, then the lookup level is reported and prioritized as one of the following:
- -The lowest-numbered lookup level that could have caused the error.
- -If the PE cannot determine any information about the lookup level, then level 0.

## D8.15.1.4 Access flag fault

IBMSDD For an implementation that does not manage the AF in hardware, when and only when a non-speculative access is made to an address and an attempt is made to translate that address using a descriptor with an AF of 0, an Access flag fault is generated.

RLFGXS For a translation lookup of a Block descriptor or Page descriptor, when an Access flag fault is generated, the reported fault code indicates the lookup level.

IPNQBP When an Access flag fault is generated, the translation table entry causing the fault is not cached in a TLB.

ITQXPT When an Access flag fault is generated, the fault handler does not have to perform TLB maintenance to remove the faulting entry.

IRGFRF For more information, see:

- MMUfaults generated by cache maintenance operations.
- Software management of the Access flag.

## D8.15.1.5 Permission fault

RCSRQR When a Permission fault is generated, the reported fault code indicates the lookup level of the Block or Page descriptor used in the translation, even if the lack of permission was caused by hierarchical permission controls.

RJVXRH Atranslation table entry that generates a Permission fault is permitted to be cached in a TLB.

IWJLXV If software updates a stage 1 or stage 2 translation table due to a Permission fault, then the software is required to invalidate the appropriate TLB entry to prevent stale information in a TLB from being used by a subsequent memory access.

IWHWDD For more information, see:

- Prioritization of Permission faults.
- MMUfaults generated by cache maintenance operations.
- Memory access control.
- Stage 2 fault on a stage 1 translation table walk.

## D8.15.1.6 TLB conflict abort

| I CNNYQ   | When a TLB has not been properly invalidated, such as when architecturally required TLB invalidation is not done, an address lookup might hit multiple TLB entries.                                                                                                                                                                                                                                   |
|-----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| R ZQNWZ   | When a lookup address hits multiple TLB entries, it is IMPLEMENTATION DEFINED whether a TLB conflict abort is generated.                                                                                                                                                                                                                                                                              |
| R WJMZJ   | When a TLB conflict abort is generated, it is reported as one of the following: • On an instruction fetch it is reported as an Instruction Abort. • On a data access or a cache management instruction, it is reported as a Data Abort. • For an AT S1E0* or AT S1E1* instruction executed from EL1, when a TLB conflict abort is generated on a stage 2 translation, it is reported as a Data Abort. |
| I DHRWD   | For an AT instruction other than an AT S1E0* or AT S1E1* instruction executed from EL1, a TLB conflict does not generate an abort.                                                                                                                                                                                                                                                                    |
| R QWTKL   | For the EL1&0 regime, when a TLB conflict abort is generated and both stages of translation are enabled, then one of following applies: • If FEAT_BBML1 is implemented and the TLB conflict abort is generated due to changing the table or block or Contiguous bit, then the abort is reported to EL2. • Otherwise, it is IMPLEMENTATION DEFINED whether it is reported to EL1 or EL2.               |
| R ZMVZT   | ATLBConflict abort cannot be generated for a disabled stage of translation.                                                                                                                                                                                                                                                                                                                           |
| I JYDXJ   | When a TLB conflict abort is generated, all of the following are reported: • A 0b110000 Fault status code. • The lookup address that caused the fault.                                                                                                                                                                                                                                                |

## D8.15.2 MMU faults generated by address translation instructions

RXGWVV

INPRRQ

RNHWXL

An address translation instruction uses the translation system and can generate all of the following faults:

- Translation fault.
- Address size fault.
- Synchronous External abort on a translation table walk.
- Access flag fault.
- Permission fault.
- TLB conflict abort.
- When translating using the AArch32 translation systems, a domain fault.

If FEAT\_RME is implemented, the following faults are added to the list of faults that can be generated by an address translation instruction:

- GPF.
- GPT address size fault.
- GPT walk fault.
- Synchronous External abort on GPT fetch.

These are collectively called Granule Protection Check faults (GPC faults). For more information, see GPC faults.

When an address translation instruction generates a fault and when none of the following generated the fault, the fault is not taken as a synchronous exception, and PAR\_EL1 is populated with PAR\_EL1.F == 1 and the fault syndrome information:

- Asynchronous External abort during a translation table walk.
- An AT S1E0* or AT S1E1* instruction executed from EL1 generates a stage 2 fault on a memory access during a translation table walk.

For more information, see Exceptions to reporting the fault in PAR\_EL1.

| I ZCTWS   | If an address translation instruction requires two address translation stages, then a fault can be generated from either stage 1 or stage 2.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|-----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| I CLHMP   | If an address translation instruction requires two address translation stages in the EL1&0 translation regime, then a fault can be generated on the stage 2 translation of an address accessed as part of the stage 1 translation table walk. For more information, see Stage 2 fault on a stage 1 translation table walk.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| I MXTJT   | When populating PAR_EL1 with the result of an address translation instruction, granule protection checks are not performed on the final output address of a successful translation. However, granule protection checks are performed on fetches of stage 1 or stage 2 descriptors and these checks could result in a GPC fault.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| I KKHBS   | If FEAT_PAN2 is implemented, then the <pan> component of the AT instruction <operation> determines whether the PSTATE.PAN value is considered when determining permissions.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| R QBSVM   | For an address translation instruction executed at a particular Exception level, ELx, if a synchronous External abort is generated on a stage 1 translation table walk, then the Data Abort exception is taken to the Exception level to which a synchronous External abort on a stage 1 translation table walk for a memory access from ELx would be taken.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| R QCVQK   | When an address translation instruction executed at EL3 generates a synchronous External abort on a stage 2 translation table walk, a Data Abort exception is taken to EL3.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| R YWCRL   | For an address translation instruction executed at the EL2 or EL1 Exception level, if a synchronous External abort is generated on a stage 2 translation table walk, then the Data Abort exception is taken to the Exception level to which a synchronous External abort on a stage 2 translation table walk for a memory access from that same EL2 or EL1 Exception level would be taken.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| R FDJKZ   | When an address translation instruction causes a synchronous External abort that is reported as an exception, all of the following apply:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| R ZWKYB   | When an AT S1E0* or AT S1E1* instruction is executed, all of the following can generate a stage 2 fault on a memory access during a translation table walk:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| R VMRFQ   | • Stage 2 Translation fault. • Stage 2 Address size fault. • Synchronous External abort on a stage 2 translation table walk. • Stage 2 Access fault. • Stage 2 Permission fault. • ATLBconflict abort that takes an IMPLEMENTATION DEFINED choice of reporting as a stage 2 abort.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|           | When an AT S1E0* or AT S1E1* instruction executed from EL1 generates a stage 2 fault on a memory access during a translation table walk, one of the following occurs: • If the fault is a synchronous External abort on a stage 2 translation table walk and SCR_EL3.EA is 1, then a synchronous External abort on a stage 2 translation table walk is taken to EL3. • The fault is taken as an exception to EL2 and all of the following apply: - PAR_EL1 is UNKNOWN. - ESR_EL2 indicates that a cache maintenance instruction faulted during a translation table walk. - HPFAR_EL2 holds the IPA that faulted. - FAR_EL2 holds the VA supplied to the address translation instruction. In addition to the cases listed in Address translation instructions in the Arm architecture, the following faults as a result of an address translation instruction are reported as an exception: • GPC faults that would result in a GPC exception. |
| R ZTRDD   | • GPC faults on fetches of stage 2 descriptors from AT S1E0* and AT S1E1* instructions executed from EL1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |

IVKPJB

- When HCR\_EL2.GPF is 1, GPFs on fetches of stage 1 descriptors from AT S1E0* and AT S1E1* instructions executed from EL1.

Otherwise, faults as a result of an address translation instruction are reported using PAR\_EL1.FST.

For more information, see Stage 2 fault on a stage 1 translation table walk.

## D8.15.3 MMU faults generated by cache maintenance operations

IQZTRG There are no alignment requirements in cache maintenance instructions and execution of these instructions cannot generate an Alignment fault.

IBDCCY Cache maintenance instructions treated as a NOP cannot generate MMU faults.

RTRTWX It is IMPLEMENTATION DEFINED whether execution of any cache maintenance instruction by V A that is not treated as a NOP can generate an Access flag fault.

- RMXZPX If SCTLR\_ELx.UCI is 1, enabling EL0 execution of the data cache maintenance instructions that operate by V A, then when the instruction is executed at EL0 to a location that does not have read permission at EL0, a Permission fault can be generated.
- RXJRNW If SCTLR\_ELx.UCI is 1, enabling EL0 execution of the IC IVAU instruction, and if the instruction is executed at EL0 to a location that does not have read permission at EL0, then it is IMPLEMENTATION DEFINED whether a Permission fault is generated.

If the Effective value of SCTLR\_ELx.CMOW is 1, execution of any of the following at EL0 without stage 1 write

- RFTXTG permission generates a stage 1 Permission fault:
- Any DC instruction that operates by V A and performs clean and invalidate.
- Any IC instruction that operates by V A.

RBBLTJ If the Effective value of HCRX\_EL2.CMOW is 1, execution of any of the following at EL1 or EL0 without stage 2 write permission generates a stage 2 Permission fault:

- Any DC instruction that operates by V A and performs clean and invalidate.
- Any IC instruction that operates by V A.
- IZNSBH When an implementation can generate MMU faults on execution of cache maintenance operations, Permission faults are generated according to the type of cache maintenance operation and system register configuration.

RJQCHQ If a stage 2 translation of a stage 1 translation table walk is done as part of a cache maintenance instruction, then a stage 2 Permission fault can be generated.

RJYWZL If a DC Invalidate by address instruction, for example, DC IV AC, DC IGV AC, or DC IGDV AC is not treated as a NOP and does not have write permission to the location it invalidates, then a Permission fault is generated.

IXQZJB DCZVAis not a cache maintenance instruction.

ILJLSP For more information, see:

- Data and unified caches.
- Instruction caches.
- Memory aborts.
- Permission fault.
- A64 Cache maintenance instructions.

## D8.15.4 MMU fault-checking sequence

IPTYRT

IJFVPZ

For a translation stage, when an IA is translated to an OA, the fault checking sequence is done using all of the following steps:

1. If the IA is subject to an alignment check, then check the alignment and do one of the following:
- If the IA is not aligned, then an Alignment fault is generated.
- If the IA is aligned, then continue to the next step.
2. Check that the IA maps to a translation table base address register, TTBR, and do one of the following:
- If the IA does not map to a TTBR, then a Translation fault is generated.
- If the IA maps to a TTBR and translation using that TTBR is disabled, then a Translation fault is generated.
- If the IA maps to a TTBR, then get the translation table base address and continue to the next step.
3. Check that the translation table base address size is valid and do one of the following:
- If the translation table base address size is not valid, then an Address size fault is generated.
- If the translation table base address size is valid, then continue to the next step.
4. Fetch the descriptor, using all of the following steps:
- If the descriptor address is an IPA from a stage 1 translation, then all of the following are done:
13. -The fault checking sequence is done on the stage 2 translation, using the IPA as an IA to the stage 2 translation.
14. -The OA from the stage 2 translation is the descriptor PA.
- If the descriptor address is not an IPA from a stage 1 translation, then the descriptor address is the descriptor PA.
- The descriptor fetch is initiated using the descriptor PA, and one of the following occurs:
17. -ASynchronous External abort is generated.
18. -The descriptor is returned.
5. Check that the descriptor is valid and do one of the following:
- If the descriptor is not valid, then a Translation fault is generated.
- If the descriptor is valid, then continue to the next step.
6. Check that the descriptor address size is valid and do one of the following:
- If the descriptor address size is not valid, then an Address size fault is generated.
- If the descriptor address size is valid, then continue to the next step.
7. Check the descriptor type and do one of the following:
- For a Table descriptor, get the descriptor address, get the hierarchical permissions and attributes that apply to subsequent lookup levels, and go back to step 4 to fetch the next descriptor.
- For a Block descriptor or Page descriptor, continue to the next step.
8. If FEAT\_BBML1 is implemented, and the fetched descriptor is a block descriptor with the nT bit set, then the implementation can generate a Translation fault.
9. If AF hardware management is disabled or not implemented, check the descriptor AF bit and do one of the following:
- If AF is 0, then an Access flag fault is generated.
- If AF is 1, then continue to the next step.
10. If AF hardware management is enabled, then the hardware attempts to update the AF and that might result in a Permission fault at stage 2, or a Synchronous External abort.
11. Get the OA and OA space from the Block descriptor or Page descriptor returned by the translation table walk.
12. Check the alignment required for the output memory type and do one of the following:
- If the OA alignment is not valid, then an Alignment fault is generated.
- If the OA alignment is valid, then continue to the next step.
13. Check the OA space access permissions and do one of the following:
- If the OA space access is not permitted, then a Permission fault is generated.
- If the OA space access is permitted, then continue to the next step.
14. If dirty state hardware management is enabled, then the hardware attempts to update the dirty state and that might result in a Permission fault at stage 2, or a Synchronous External abort.
15. The translation stage returns the OA and region attributes.

For a translation stage, the following figure illustrates the MMU fault checking sequence.

IHZZMB

Figure D8-22 MMU fault checking sequence

<!-- image -->

For a translation stage, the following figure illustrates the steps taken to fetch a descriptor during a translation table walk.

IMQXNK

INGFYK

Figure D8-23 Fetching a descriptor during a translation table walk

<!-- image -->

IGLRRS For more information, see Permission fault.

## D8.15.4.1 Stage 2 fault on a stage 1 translation table walk

For a translation regime that uses two translation stages, the memory access made as part of a stage 1 translation table lookup can generate one or more of the following during a stage 2 translation:

- ATranslation fault, Address size fault, Access flag fault, or Permission fault.
- AGPCfault on the stage 2 descriptor access.
- Asynchronous External abort on the stage 2 descriptor access.
- Asynchronous External abort on the memory access.

If an Address size fault, Translation fault, Access flag fault, or Permission fault is generated on a stage 2 translation of a stage 1 translation table walk, then all of the following apply:

- The exception is taken to EL2.
- ESR\_EL2.ISS[7] is 1 to indicate a stage 2 fault during a stage 1 translation table walk.
- The part of the ISS field that might contain details of the instruction is invalid.

IMRJLZ

IZGDHT

If a synchronous External abort is generated on a stage 2 translation of a stage 1 translation table walk, then all of the following apply:

- If SCR\_EL3.EA is 0, then all of the following apply:
- -The exception is taken to EL2.
- -ESR\_EL2.ISS[7] is 1 to indicate a stage 2 fault during a stage 1 translation table walk.
- If SCR\_EL3.EA is 1, then all of the following apply:
- -The exception is taken to EL3.
- -ESR\_EL3.ISS[7] is 1 to indicate a stage 2 fault during a stage 1 translation table walk.
- The part of the ISS field that might contain details of the instruction is invalid.

If the stage 2 translation of a stage 1 translation table walk returns a Device memory type, then the value of HCR\_EL2.PTW determines all of the following:

- If the value is 0, the translation table walk access is permitted and treated as an access to Normal, Non-cacheable memory.
- If the value is 1, the translation table walk access generates a stage 2 Permission fault.

IVXKVL If the stage 2 translation of a stage 1 translation table lookup maps to Device memory, it likely indicates a Guest OS error where the stage 1 translation table is corrupted, and it is appropriate to trap this access to the hypervisor.

ILWGSL If software updates HCR\_EL2.PTW without changing the current VMID, then the software is required to invalidate the TLBs because they might hold entries that depend on the effect of HCR\_EL2.PTW.

IHPGQN

IXCCCM

ICRKPZ

For more information, see Permission fault.

## D8.15.4.2 The lookup level associated with MMU faults

For MMU faults, the Data Fault Status Code (DFSC) and Instruction Fault Status Code (IFSC) in the ESR\_ELx report the translation lookup level associated with a given MMU fault type.

When an MMU fault is generated, all of the following determine the lookup level associated with the fault:

- For a fault generated by a translation table walk, the lookup level at which the fault occurred.
- For a Translation fault, one of the following:
- -The lookup level at which the fault occurred.
- -If a fault is generated because translation table walks are disabled by TCR\_ELx.EPD n , the IA is outside the range specified by the associated TTBR\_ELx, or FEAT\_E0PD is enabled and prevents access to addresses translated by TTBRn\_ELx, then the fault is reported as a level 0 fault.
- For an Access flag fault, the lookup level at which the fault occurred.
- For a Permission fault, including a Permission fault generated by hierarchical permissions, the final lookup level that returned the Block descriptor or Page descriptor.

ICJZVP For more information, see Permission fault.

## D8.15.5 MMU fault prioritization from a single address translation stage

RXCHFJ

For a single translation stage in a VMSAv8-64 translation regime, the following list shows the possible MMU faults on a memory access, from highest priority to lowest priority, and includes where stage 2 faults that are generated within a stage 1 translation table walk are prioritized:

1. For a stage 1 translation, an Alignment fault not caused by memory type.
2. If one or more of the following is true, then a Translation fault:
- The IA out of the translated address range.
- For a stage 1 translation, the IA requiring a TTBR\_ELx that is disabled.
- For a stage 2 translation, VTCR\_EL2.SL0 is inconsistent with VTCR\_EL2.T0SZ.
- For a stage 2 translation, VSTCR\_EL2.SL0 is inconsistent with VSTCR\_EL2.T0SZ.
- For a stage 2 translation, SL0 is programmed to a reserved value.
- For a stage 2 translation, the Effective value of VTCR\_EL2.DS is 1 and VTCR\_EL2.{SL2, SL0} is inconsistent with VTCR\_EL2.T0SZ.

- For a stage 2 translation, the Effective value of VTCR\_EL2.DS is 1 and VSTCR\_EL2.{SL2, SL0} is inconsistent with VSTCR\_EL2.T0SZ.
- For a stage 2 translation, the Effective value of VTCR\_EL2.DS is 1 and {SL2, SL0} is programmed to a reserved value.
3. If one or more of the following is true, an Address size fault on the address in TTBR\_ELx:
- The address size check on TCR\_EL1.IPS, TCR\_EL2.{I}PS, TCR\_EL3.PS, or VTCR\_EL2.PS fails.
- The programmed address is outside the implemented range.
4. If stage 2 address translation is enabled, then a stage 2 MMU fault on a level -1 memory access during a stage 1 table walk, including an Address size fault caused by a PA outside the implemented range.
5. Asynchronous parity or ECC error on a level -1 lookup of a translation table walk.
6. AGPCfault on a level -1 lookup of a translation table walk.
7. Asynchronous External abort on a level -1 lookup of a translation table walk.
8. Translation fault on a level -1 translation table entry.
9. If one or more of the following is true, an Address size fault on the address in a level -1 lookup translation table entry:
- The address size check on TCR\_EL1.IPS, TCR\_EL2.{I}PS, TCR\_EL3.PS, or VTCR\_EL2.PS fails.
- The OA is out of the implemented range.
10. If stage 2 address translation is enabled, then a stage 2 MMU fault on a level 0 memory access during a stage 1 table walk, including an Address size fault caused by a PA outside the implemented range.
11. Asynchronous parity or ECC error on a level 0 lookup of a translation table walk.
12. AGPCfault on a level 0 lookup of a translation table walk.
13. Asynchronous External abort on a level 0 lookup of a translation table walk.
14. Translation fault on a level 0 translation table entry.
15. If one or more of the following is true, an Address size fault on the address in a level 0 lookup translation table entry:
- The address size check on TCR\_EL1.IPS, TCR\_EL2.{I}PS, TCR\_EL3.PS, or VTCR\_EL2.PS fails.
- The OA is out of the implemented range.
16. If stage 2 address translation is enabled, then a stage 2 MMU fault on a level 1 memory access during a stage 1 table walk, including an Address size fault caused by a PA outside the implemented range.
17. Asynchronous parity or ECC error on a level 1 lookup of a translation table walk.
18. AGPCfault on a level 1 lookup of a translation table walk.
19. Asynchronous External abort on a level 1 lookup of a translation table walk.
20. Translation fault on a level 1 translation table entry.
21. If one or more of the following is true, an Address size fault on the address in a level 1 lookup translation table entry:
- The address size check on TCR\_EL1.IPS, TCR\_EL2.{I}PS, TCR\_EL3.PS, or VTCR\_EL2.PS fails.
- The OA is out of the implemented range.
22. If stage 2 address translation is enabled, then a stage 2 MMU fault on a level 2 memory access during a stage 1 table walk, including an Address size fault caused by a PA outside the implemented range.
23. Asynchronous parity or ECC error on a level 2 lookup of a translation table walk.
24. AGPCfault on a level 2 lookup of a translation table walk.
25. Asynchronous External abort on a level 2 lookup of a translation table walk.
26. Translation fault on a level 2 translation table entry.
27. If one or more of the following is true, an Address size fault on the address in a level 2 lookup translation table entry:
- The address size check on TCR\_EL1.IPS, TCR\_EL2.{I}PS, TCR\_EL3.PS, or VTCR\_EL2.PS fails.
- The OA is out of the implemented range.
28. If stage 2 address translation is enabled, then a stage 2 MMU fault on a level 3 memory access during a stage 1 table walk, including an Address size fault caused by a PA outside the implemented range.
29. Asynchronous parity or ECC error on a level 3 lookup of a translation table walk.
30. AGPCfault on a level 3 lookup of a translation table walk.
31. Asynchronous External abort on a level 3 lookup of a translation table walk.
32. Translation fault on a level 3 translation table entry.
33. If one or more of the following is true, an Address size fault on the address in a level 3 lookup translation table entry:
- The address size check on TCR\_EL1.IPS, TCR\_EL2.{I}PS, TCR\_EL3.PS, or VTCR\_EL2.PS fails.
- The OA is out of the implemented range.

RDFGCF

RTLHDK

34. Access flag fault.
35. Alignment fault caused by the memory type. For an Alignment fault generated as a result of the conditions specified in Crossing a page boundary with different memory types or Shareability attributes or Crossing a peripheral boundary with a Device access, the prioritization of the Alignment fault is IMPLEMENTATION DEFINED, at a point between here and above Synchronous External abort on the memory access.
36. Permission fault. For more information, see Prioritization of Permission faults.
37. If stage 2 address translation is enabled, then a stage 2 fault on the memory access, including an Address size fault caused by a PA outside the implemented range.
38. Synchronous parity or ECC error on the memory access.
39. AGPCfault on the memory access.
40. Synchronous External abort on the memory access.

RMJLPH If all the following apply, the prioritization between the stage 2 fault on the stage 1 translation table walk and the stage 1 fault caused by the stage 1 Block descriptor or Page descriptor is IMPLEMENTATION DEFINED:

- Hardware management of the stage 1 access flag or dirty state is enabled.
- The access flag or dirty state in a stage 1 descriptor needs to be updated.
- For the location of the stage 1 Block descriptor or Page descriptor, the stage 2 translation generates one of the following:
- -APermission fault because the descriptor grants read permission but not write permission.
- -An unsupported atomic hardware update fault.
- The stage 1 Block descriptor or Page descriptor generates an MMU fault, which can be due to an Address size fault, an Alignment fault caused by memory type, or a Permission fault.

For more information, see Hardware management of the dirty state.

- RWLLHL When the use of a stage 1 Table descriptor generates a stage 1 Translation fault or Address Size fault, it is reported with higher priority than any stage 2 MMU faults generated as part of hardware updates for that descriptor, except in the following case:
- Asynchronous External abort or an IMPLEMENTATION DEFINED abort caused by a memory type not supporting an atomic read-modify-write at stage 2 is permitted to be reported to EL2 with higher priority than a stage 1 Translation fault or Address Size fault.

RWLJCM For a TLB conflict abort, all of the following apply:

- The priority of the abort is IMPLEMENTATION DEFINED.
- The priority of the abort is required to be higher than any abort that depends on a value held in a TLB.

IHGZXP The cause of a TLB conflict abort depends on the TLB implementation.

ISYVYF For more information on GPC fault priority, see Table D9-2.

- RCSFKV For an IMPLEMENTATION DEFINED MMU fault caused by an unsupported combination of memory access type and memory type and reported with ESR\_ELx.DFSC value 0b110101 , the priority is IMPLEMENTATION DEFINED.
- RKYXHT For an MMU fault at a translation stage caused by an unsupported atomic hardware update, the priority of this fault lies at an IMPLEMENTATION DEFINED point between all of the following:
- Apriority immediately higher than an Access flag fault generated by the same translation stage as this MMU fault.
- Apriority immediately lower than a Permission fault generated by the same translation stage as this MMU fault.

## D8.15.5.1 Prioritization of Permission faults

The following list shows the priority order of stage 1 Permission faults, from highest priority to lowest priority:

1. Fault due to Overlay permissions.
2. Fault due to stage 1 Base permissions.
3. Fault due to write of an Allocation Tag to a Canonically Tagged memory location.
4. Fault due to the dirty state.

The following list shows the priority order of stage 2 Permission faults, from highest priority to lowest priority:

RLTQNW

1. Fault due to TopLevel checks, causing a stage 2 abort during a stage 1 translation table walk.
2. Fault due to AssuredOnly check, including due to VTCR\_EL2.GCSH, causing a stage 2 abort.
3. Fault due to stage 2 Overlay permissions.
4. Fault due to stage 2 Base permissions.
5. Fault due to NoTagAccess attribute, causing a stage 2 abort on the final access.
6. Fault due to the dirty state.

For priority checking at each translation stage, when an access requires both read and write permission, both permissions are evaluated together at each step of the fault priority.

Note

Accesses that require both read and write permission include atomic, RCW , and RCWS instructions.

For example, if the Effective value of TCR\_ELx.HD is 0 and the computed privileged stage 1 permissions are as shown in the following table, an access will generate a stage 1 Permission fault with {Overlay, WnR, DirtyBit} fields in the syndrome register updated to {1,1,0}:

## Table D8-121 Example condition that generate a stage 1 Permission fault

| Permission type             | PrivRead   | PrivWrite   |
|-----------------------------|------------|-------------|
| Stage 1 Overlay permissions | 1          | 0           |
| Stage 1 Base permissions    | 0          | 0           |
| TTD.nDirty                  |            | Clean       |