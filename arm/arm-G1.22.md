## G1.22 Configurable instruction controls

This section describes the Configurable instruction controls provided by the AArch32 state. For information about the configurable instruction controls provided by the AArch64 state, see Configurable instruction controls.

Each control is categorized as an instruction enable , an instruction disable , or a trap control . The definitions of each type overlap, and in some cases are historical. Each configurable instruction control defines how an exception that is generated as a consequence of the configurable instruction control is handled or reported.

## Instruction enables and instruction disables

Enable or disable the use of one or more particular instructions at a particular Privilege level and Security state.

When an instruction is disabled as a result of an instruction enable or disable, it is UNDEFINED.

The exception generated by attempting to execute an UNDEFINED instruction is:

- Taken to EL1 if the UNDEFINED instruction was executed at EL0, unless the instruction was executed at Non-secure EL0 and is routed to EL2 by the control described in Routing exceptions from Non-secure EL0 to EL2.

When the exception is taken to EL1, it is taken to Undefined mode.

- Otherwise, taken to the Exception level at which the UNDEFINED instruction was executed:
- -If the instruction was executed in Hyp mode the exception is taken to Hyp mode.
- -Otherwise, the exception is taken to Undefined mode.

Control whether one or more instructions, when executed at a particular Privilege level, are trapped .

Note AArch32 trap controls are described in terms of Privilege levels, rather than Exception levels, because the PL1 traps apply at and are controlled from:

EL1

EL3

In Secure state when EL3 is using AArch32.

For more information, see Security state, Exception levels, and AArch32 execution privilege.

Trap controls are grouped as:

## PL1, excluding Monitor mode

Trapped instructions generate Undefined Instruction exceptions that are taken to Undefined mode, unless the instruction was executed at Non-secure EL0 and is routed to EL2 by the control described in Routing exceptions from Non-secure EL0 to EL2.

For more information about these traps, see PL1 configurable controls.

These traps apply only to execution in Non-secure state. This section only describes the traps that apply when EL2 is using AArch32.

Trapped instructions generate:

- Hyp Trap exceptions, taken to Hyp mode, if trapped from a mode other than Hyp mode.
- Undefined Instruction exceptions taken to Hyp mode, if trapped from Hyp mode.

For more information about these traps, see EL2 configurable controls.

See also Routing exceptions from Non-secure EL0 to EL2.

## Trap controls

## Hyp mode (PL2)

In Non-secure state, and in Secure state when EL3 is using AArch64.

## Monitor mode (Secure PL1)

This section describes only the traps that apply when EL3 is using AArch32.

Trapped instructions generate Monitor Trap exceptions, which are taken to Monitor mode.

For more information about these traps, see EL3 configurable controls.

An exception generated as a result of an instruction enable or disable, or a trap control, is only taken if the instruction does not also generate a higher priority exception. Exception prioritization for exceptions taken to AArch32 state defines the prioritization of different exceptions on the same instruction.

Exceptions generated as a result of these controls are synchronous exceptions.

For exceptions taken to an Exception level that is using AArch32, only exceptions that are taken to Hyp mode are reported in a syndrome register, the HSR.

An implementation might provide additional controls, in IMPLEMENTATION DEFINED registers, to provide control of trapping of IMPLEMENTATION DEFINED features.

When a configurable instruction control causes an exception, the exception is taken and the instruction is not executed, and therefore all the following are true:

- The preferred exception return address of the exception is the instruction that generates the exception.
- There are no changes to the registers accessed by the instruction, including as a result of side-effects of a register access.

This section is organized as follows:

- Instructions that fail their Condition code check.
- Instructions that are UNPREDICTABLE.
- Register access instructions.
- PL1 configurable controls.
- EL2 configurable controls.
- EL3 configurable controls.
- Pseudocode description of configurable instruction enables, disables, and traps.

## G1.22.1 Instructions that fail their Condition code check

When a configurable instruction control causes a conditional instruction to generate an exception in AArch32 state, it is IMPLEMENTATION DEFINED whether the exception applies to conditional AArch32 instructions that fail their condition code check.

For instructions that fail their Condition code check, see Conditional execution of undefined instructions.

For an instruction that has a Hyp trap or Monitor trap set that fails its Condition code check:

- Unless the trap description states otherwise, it is IMPLEMENTATION DEFINED whether the instruction:
- -Generates a Hyp Trap or Monitor Trap exception.
- -Executes as a NOP .

Any implementation must be consistent in its handling of instructions that fail their Condition code check. This means that:

- Whenever a Hyp trap or Monitor trap is set on an instruction it must either:
- -Always generate a Hyp Trap or Monitor Trap exception.
- -Always treat the instruction as a NOP .

- The IMPLEMENTATION DEFINED part of the requirements of Conditional execution of undefined instructions must be consistent with the handling of Hyp traps or Monitor traps on instructions that fail their Condition code check. Table G1-22 shows this:

Table G1-22 Consistent handling of instructions that fail their Condition code check

| Behavior of conditional undefined instruction a   | Hyp trap or Monitor trap on instruction that fails its Condition code check b   |
|---------------------------------------------------|---------------------------------------------------------------------------------|
| Executes as a NOP                                 | Executes as a NOP                                                               |
| Generates an Undefined Instruction exception      | Generates a Hyp Trap or Monitor Trap exception                                  |

## G1.22.2 Instructions that are UNPREDICTABLE

It is UNPREDICTABLE / CONSTRAINED UNPREDICTABLE whether configurable instruction controls generate an exception when the instruction is UNPREDICTABLE or CONSTRAINED UNPREDICTABLE in the PE state in which the instruction is executed, except in the following cases:

- If the instruction description explicitly states that the configurable instruction control is applied with higher priority than the CONSTRAINED UNPREDICTABLE behavior, then the configurable instruction control generates an exception.
- For an instruction where one of the CONSTRAINED UNPREDICTABLE behaviors is that a register value becomes UNKNOWN, then either:
- -The configurable instruction controls generate an exception.
- -The instruction executes with one of the CONSTRAINED UNPREDICTABLE behaviors that does not cause a register value to become UNKNOWN.

UNPREDICTABLE and CONSTRAINED UNPREDICTABLE instructions can generate exceptions as a result of configurable instruction controls, but the architecture does not require them to do so.

Note

UNPREDICTABLE and CONSTRAINED UNPREDICTABLE behavior must not perform any function that cannot be performed at the current or lower Exception level using instructions that are not UNPREDICTABLE and are not CONSTRAINED UNPREDICTABLE. This means that disabling or trapping an instruction changes the set of instructions that might be executed in:

- Non-secure state at EL1 or EL0.
- Modes other than Monitor Mode.

This indirectly affects the permitted behavior of UNPREDICTABLE and CONSTRAINED UNPREDICTABLE instructions. Many CONSTRAINED UNPREDICTABLE behaviors for instructions include an allowance that the CONSTRAINED UNPREDICTABLE instruction behaves the same way as a closely related instruction that is not CONSTRAINED UNPREDICTABLE. In those cases, the instruction enable, disable, or trap control that causes an exception on the closely related instruction will cause the same exception on the CONSTRAINED UNPREDICTABLE instruction.

If no instructions are trapped, the attempted execution of an UNPREDICTABLE instruction in a Non-secure EL1 or EL0 mode must not generate a Hyp Trap exception or Monitor Trap exception.

## G1.22.3 Register access instructions

When an instruction is disabled or trapped, the exception is taken before execution of the instruction. This means that if the instruction is a register access instruction:

- No access is made before the exception is taken.
- Side-effects that are normally associated with the access do not occur before the exception is taken.

## G1.22.4 PL1 configurable controls

In AArch32 state, each control is associated with a particular System register field that is accessible:

- When EL3 is using AArch64, or when an implementation does not include EL3, from EL1.
- When EL3 is using AArch32:
- -In Non-secure state, from EL1.
- -In Secure state, from EL3.

This means that the controls are described as PL1 controls, because PL1 is defined as being the Privilege level of software that is executing:

- At EL3, if the PE is executing in EL3 and EL3 is using AArch32.
- At EL1 under all other conditions.

Where there is an AArch64 control that is equivalent to an AArch32 PL1 control, the AArch64 control is an EL1 control. Any exception that is generated because of an AArch32 PL1 control is taken to a PL1 mode.

Note

Any exception generated because of an AArch32 PL1 control is taken to AArch32 state.

Table G1-23 shows the AArch32 System registers that contain these controls.

Table G1-23 PL1 System registers that contain configurable instruction controls

| Register name   | Register description                          |
|-----------------|-----------------------------------------------|
| SCTLR           | System Control Register                       |
| FPEXC           | Floating-point Exception Control Register     |
| CPACR           | Architectural Feature Access Control Register |
| DBGDSCRext      | Monitor System Debug Control Register         |
| PMUSERENR       | Performance Monitors User Enable Register     |
| AMUSERENR       | Activity Monitors User Enable Register        |
| CNTKCTL         | Counter-timer Kernel Control Register         |

When generated in Non-secure User mode, exceptions generated by these controls can be routed to EL2, as described in Routing exceptions from Non-secure EL0 to EL2.

## G1.22.5 EL2 configurable controls

These controls are ignored in Secure state when using AArch32.

Table G1-24 shows the System registers that contain these controls.

## Table G1-24 EL2 System registers that contain configurable instruction controls

| Register name   | Register description                      |
|-----------------|-------------------------------------------|
| FPEXC           | Floating-point Exception Control Register |
| HCR             | Hypervisor Configuration Register         |
| HSTR            | Hypervisor System Trap Register           |
| HCPTR           | Hyp Architectural Feature Trap Register   |
| HDCR            | Hyp Debug Control Register                |
| HSCTLR          | Hyp System Control Register               |
| HCR2            | Hypervisor Configuration Register 2       |
| CNTHCTL         | Counter-timer Hyp Control Register        |

## G1.22.6 EL3 configurable controls

Table G1-25 shows the System registers that contain these controls.

## Table G1-25 EL3 System registers that contain configurable instruction controls

| Register name   | Register description               |
|-----------------|------------------------------------|
| SCR             | Secure Configuration Register      |
| NSACR           | Non-secure Access Control Register |
| SDCR            | Secure Debug Control Register      |

## G1.22.7 Pseudocode description of configurable instruction enables, disables, and traps

The pseudocode function AArch32.CheckITEnabled() checks whether the T32 IT instruction is enabled.

The pseudocode function AArch32.CheckSETENDEnabled() checks whether the SETEND instruction is disabled.

The pseudocode function for AArch32.CheckForSMCUndefOrTrap() checks for traps on an SMC instruction.

The AArch32.CheckForWFxTrap() pseudocode function checks for traps on WFE and WFI instructions:

## G1.22.7.1 Pseudocode description of enabling SIMD and floating-point functionality

The AArch32.CheckAdvSIMDOrFPEnabled() and AArch32.CheckFPAdvSIMDTrap() pseudocode functions take appropriate action if an SIMD or floating-point instruction is used when the SIMD and floating-point functionality is not enabled or is trapped.

The CheckAdvSIMDOrVFPEnabled() , CheckAdvSIMDEnabled() , and CheckVFPEnabled() wrapper functions support the AArch32.CheckAdvSIMDOrFPEnabled() and AArch32.CheckFPAdvSIMDTrap() functions.

The AArch32.CheckAdvSIMDOrFPEnabled() , AArch32.CheckFPAdvSIMDTrap() , CheckAdvSIMDOrVFPEnabled() , CheckAdvSIMDEnabled() , and CheckVFPEnabled() functions are described in A-profile Architecture Pseudocode.

## Chapter G2 AArch32 Self-hosted Debug

When the PE is using self-hosted debug, it generates debug exceptions . This chapter describes the AArch32 self-hosted debug Exception model. It is organized as follows:

## Introductory information

- About self-hosted debug.
- The debug exception enable controls.

## The debug Exception model

- Routing debug exceptions.
- Enabling debug exceptions.
- The effect of powerdown on debug exceptions.
- Summary of permitted routing and enabling of debug exceptions.
- Pseudocode description of debug exceptions.

## The debug exceptions

- Breakpoint Instruction exceptions.
- Breakpoint exceptions.
- Watchpoint exceptions.
- Vector Catch exceptions.

## Synchronization requirements

The behavior of self-hosted debug after changes to System registers, or after changes to the authentication interface, but before a Context Synchronization event guarantees the effects of the changes:

- Synchronization and debug exceptions.