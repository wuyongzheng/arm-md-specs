## D17.6 The profiling data

Unless otherwise stated, all sample records that are generated by a profiling operation contain:

- Atimestamp, if enabled. This is one of:
- -Physical time.
- -Offset physical time.
- -Virtual time.

It is IMPLEMENTATION DEFINED how this timestamp relates to the sampled operation. It might be the time when the sampled operation was taken or any later time during the lifetime of the sampled operation, that is, up to the time when the sampled operation finishes execution.

If the Generic Timer system counter is disabled and timestamps are enabled, then it is IMPLEMENTATION DEFINED whether:

- -The SPU behaves as if timestamps are disabled.
- -The timestamp that is collected in the sample record is UNKNOWN.

Note

This behavior describes when CNTCR.EN is 0, the Generic Timer system counter is disabled. This behavior does not apply when the Generic Timer system counter is enabled but not accessible at the current Exception level.

- The context, if enabled, which is one or more of:
- -CONTEXTIDR\_EL1.
- -CONTEXTIDR\_EL2.
- -The Exception level.
- -The Security state.
- Information about whether the sampled operation generated an exception:
- -The target address for an exception generating operation is not collected.
- Information about whether the sampled operation was Architecturally executed.

If the sampled operation is Architecturally executed and does not generate an exception, the sample record also contains:

- The PC virtual address for the sampled operation.
- Information about whether the sampled operation is a branch, a load, a load atomic, a store, or other.
- Information about whether the sampled operation is conditional, conditional select, or not.
- The total latency, a cycle count from the start of the sampled operation up to the point where the operation has finished execution and is no longer capable of stalling any instruction that consumes its output.
- The issue latency, a count of cycles when the operation is waiting to be issued. A sampled operation might be delayed, for example, because the input operands were not available.

If the sampled operation is not Architecturally executed or generates an exception, it is UNPREDICTABLE whether the record contains all or any of this information and the other information about the operation listed in this section and the following subsections. For information on exceptions being taken in sampled operations, see Exceptions.

The architecture defines a set of additional data that is collected in the sample record for each sampled operation. This is described in the following subsections, and comprises:

- Events, which are required to be implemented consistently with PMU Events. For more information, see Statistical Profiling Extension Sample Record Specification and The Performance Monitors Extension.
- Cycle counters. Cycle count values as described in this architecture, which, for a particular implementation, are fixed with an IMPLEMENTATION DEFINED value, might be omitted from the sample record.
- Addresses.

In addition, the architecture permits IMPLEMENTATION DEFINED events, counters, and addresses to be collected.

## D17.6.1 Asynchronous operation

IPXWXV

If an operation executes asynchronously to the main PE, such that the cycles are not main CPU cycles, then the PE might count the cycles recorded in a Counter packet in one of the following ways:

- The Counter packet counts elapsed cycles in the main CPU clock domain. For example, the asynchronous execution unit signals start and stop events to the CPU clock domain and the cycles are counted in the CPU clock domain.
- When FEAT\_SPE\_SME is implemented, for operations executed in Streaming SVE mode, the Counter packet counts elapsed cycles in the SMCU clock domain. Counter packet.INDEX and PMSIDR\_EL1.ALTCLK indicate that the Streaming Mode Compute Unit clock value is recorded. This option is not supported for the Total latency Counter packet.
- The Counter packet counts elapsed cycles in a clock domain other than an architecturally defined clock domain. Counter packet.INDEX indicates an IMPLEMENTATION DEFINED counter value. This option is not supported for the Total latency Counter packet.

For example, an operation is executed by a separate Streaming Mode Compute Unit.

## D17.6.2 Information collected for micro-ops

Because architectural instructions might create zero, one, or more micro-ops, micro-ops might have different characteristics from the architectural instructions they are created from. The data collected for each micro-op is IMPLEMENTATION DEFINED. Implementations should collect the subset of data appropriate to the micro-op.

Example D17-2 Sampling of micro-ops

If an architectural load instruction is split into an address generation micro-op and a load micro-op, then when generating the sample record and filtering based on operation type:

- If the address generation micro-op is sampled, the sampled operation is treated as other .
- If the load micro-op is sampled, the sampled operation is treated as a load.

## D17.6.3 Additional information for each profiled branch or exception return

For an Architecturally executed sampled branch or exception return operation, the profiling operation records:

- The sampled operation type as an unconditional branch or a conditional branch. Sampled exception returns are treated as unconditional branches by the Statistical Profiling Extension.
- If the branch is taken, the target virtual address of the branch. The target virtual address includes the Exception level and Security state of the target. If the sampled operation is an illegal exception return, it is CONSTRAINED UNPREDICTABLE whether the context information recorded in the target virtual address is the actual target context, or the target context that is described by the SPSR.
- If the PE implements branch prediction, whether the branch was correctly predicted or mispredicted.
- Whether the branch was taken or not taken.
- Whether the branch was direct or indirect.
- If the branch is not taken, a target virtual address might be recorded. Software must treat this value if present as UNKNOWN.
- If FEAT\_SPE\_PBT is implemented, the target address of the most recently executed branch that was taken and retired in program order before the sampled operation.
- If FEAT\_SPE\_CRR is implemented, whether the branch was a branch with link, a procedure return, or neither of these.

If an operation executes both a Branch and a Guarded Control Stack data access, then all of the following apply:

- The Operation Type packet for the operation is Branch.

- The information for both the branch and the load or store is collected.
- The operation is treated as both a branch and a load or store for the purposes of filtering. See Filtering sample records.

Note

Asampled operation that generates an exception is not treated as a branch.

It is IMPLEMENTATION DEFINED whether an ISB instruction is treated as a branch to the next instruction.

## D17.6.3.1 Previous branch target

FEAT\_SPE\_PBT adds the capability to record a packet for each event that provides the target address of the previous taken branch. PMSIDR\_EL1.PBT describes whether this feature is implemented.

When implemented, the profiling operation records the target address of the most recent branch that was taken and retired in program order before the sampled operation.

It is IMPLEMENTATION DEFINED whether or not the profiling operation records the target address of the most recently taken branch instruction in the following cases:

- The sampled operation is not a sampled retired taken branch operation.
- The most recently taken branch instruction was a Context synchronization operation, exception-generating instruction, or exception return.
- No branch instruction has been retired, prior to the sampled operation, since the most recent Context synchronization operation or taken exception.

The profiling operation does not record the target address of the most recently taken branch instruction in the following cases:

- The most recently taken branch instruction was executed when profiling was disabled or prohibited.
- Either the most recently taken branch instruction or the sampled operation is still speculative.

## D17.6.4 Additional information for each profiled memory access operation

For an Architecturally executed sampled load, store, or atomic operation that does not generate an exception, the profiling operation records:

- The data virtual and, if enabled, physical addresses being accessed.
- -If the applicable Top Byte Ignore (TBI) bit is set to one, the virtual address includes any top-byte tag.
- -The physical address is the address the PE accesses in the physical address space, and so includes the Secure address space identifier.
- The sampled operation type, which includes:
- -Whether the sampled operation is a load, store, or atomic.
- -When FEAT\_SPEv1p3 and FEAT\_MTE are implemented, whether the sampled operation is a Tag load or store.
- -When FEAT\_NV2 is implemented, whether the sampled operation is a System register access transformed into a memory access.
- -When FEAT\_SPEv1p3 and FEAT\_MOPS are implemented, whether the sampled operation is a Memory Copy or Memory Set load or store.
- -Whether the sampled operation is Load-Exclusive, Store-Exclusive or Load-acquire, Store-release.
- -Whether the sampled operation accesses the general-purpose or SIMD&amp;FP registers.
- The translation latency. The count of cycles when at least one part of the operation is waiting for the MMU to complete an address translation. It is IMPLEMENTATION DEFINED whether a cycle is counted if a part of the operation is accessing memory, having completed an address translation for that part of the operation. For more information, see Additional infomation for each profiled memory access operation.
- Whether the sampled operation accessed the Level 1 data cache and the result.

- Whether the sampled operation accessed the data TLB and the result.
- An optional record of whether the sampled operation accessed Last Level data cache and the result.
- An optional record of whether the sampled operation accessed another socket in a multi-socket system.
- An optional, IMPLEMENTATION DEFINED, indicator of the data source for a load. If the sampled operation makes multiple accesses, it is IMPLEMENTATION DEFINED whether this indicator combines information for all parts of the load or applies only for a chosen part of the load.
- If FEAT\_SPEv1p1 is implemented, an optional indication that the sampled memory operation is non-optimal for the access size. For more information, see Data Alignment Flag.
- If FEAT\_SPEv1p2 is implemented, all of the following:
- -An optional record of whether the sampled operation accessed the Level 2 data cache, and the result.
- -An optional record of whether the sampled operation accessed the modified data in a cache, and whether the sampled operation accessed a recently fetched cache line.
- -An optional record of whether the sampled operation snooped data from a cache outside of the cache hierarchy of this PE.
- If FEAT\_GCS is implemented, whether the operation includes a Guarded Control Stack data access.

For each of the cache and another socket indicators, it is IMPLEMENTATION DEFINED and might be UNPREDICTABLE whether this information is present for store accesses.

For more information, see Events packet.

Note

Astore might be marked as not accessing a cache or another socket because it microarchitecturally finished before doing so. For example, the write was placed into a write buffer. This behavior is IMPLEMENTATION DEFINED and might change from time to time, and such events must be interpreted with care.

It is IMPLEMENTATION DEFINED whether a sampled DC ZVA , DC GVA , DC GZVA operation is recorded as a store operation targeting unspecified registers or a cache maintenance operation. The behavior if the sampled operation is recorded as a data cache maintenance operation is described in Additional information for other operations. Arm recommends that these operations are recorded as store operations.

If the sampled load, store, or atomic operation performs multiple accesses, it is IMPLEMENTATION DEFINED whether the implementation chooses to profile all or a chosen part of the access.

If the implementation profiles part of the access:

- It is IMPLEMENTATION DEFINED how the PE chooses the part of the access, while avoiding introducing systematic bias.

Note

For an example of inadvertent systematic bias, consider an implementation where a multiple-register load operation is split into multiple accesses. If the PE systematically chooses the first operation at the lower address for sampling translation latency and data source indicator, and the operation is executed in a loop with an incrementing address, then the first access has better spatial locality with preceding accesses than later accesses and is more likely to both:

- Hit in the TLB, giving a shorter translation latency.

- Return data from the Level 1 data cache.

In this case, or if the PE systematically chooses the last access at the higher address, then sampling would be biased.

- If the accesses are architecturally contiguous, it is further IMPLEMENTATION DEFINED whether the recorded data virtual address is the lowest virtual address that is accessed by the sampled operation or applies to the chosen part of the access.

- If the accesses are not architecturally contiguous, the recorded data virtual address applies for the chosen part of the access.

- It is IMPLEMENTATION DEFINED whether the events and total operation latency apply to the whole operation or the chosen part of the operation.

- The translation latency applies to the chosen part of the operation, and is the count of cycles for which the chosen part of the operation is waiting for the MMU to complete an address translation.

Arm recommends that if the implementation chooses to profile a chosen part of the access, then the recorded addresses, events, and total operation latency apply to the chosen access. That is, the PE behaves as if the chosen part of the access is the sampled operation.

If the sampled load, store, or atomic operation performs a single access, or the implementation chooses to profile all parts of a multiple access:

- If the accesses are architecturally contiguous, the recorded data virtual addresses is the lowest virtual address that is accessed by the sampled operation.
- If the accesses are not architecturally contiguous, the recorded data virtual addresses apply for the chosen part of the access.
- The events and total operation latency apply to the whole operation. For example, when recording whether the sampled operation accessed the Level 1 data cache, the PE records whether any part of the access accessed the Level 1 data cache, and the result, and the total operation latency applies from the issue of the operation to the completion of all parts of the operation.
- The translation latency is an IMPLEMENTATION DEFINED choice between:
- -The count of cycles for which at least one part of the operation is waiting for the MMU to complete an address translation, and no part of the operation is accessing memory.
- -The count of cycles for which at least one part of the operation is waiting for the MMU to complete an address translation.

The sampled data physical address packet is not output if any of the following are true:

- The sampled operation operates on a virtual address and any of the following are true:
- -The PE does not translate the address, for example because it does not perform the access.
- -The sampled data virtual address packet is not output.
- Sampling of physical addresses is prohibited by System register controls.

If AArch64.ExclusiveMonitorsPass() or AArch32.ExclusiveMonitorsPass() returns FALSE for a Store-Exclusive instruction, it is IMPLEMENTATION DEFINED whether or not the physical address packet is output when permitted by the above rules.

If a sampled virtual address packet is not output, or the PE does not perform the access, then all of the following apply:

- It is IMPLEMENTATION DEFINED whether the Translation latency Counter packet for the load or store is either not recorded, or recorded with a value of zero. If the access does not occur and the address is not translated, the packet is not recorded.
- It is IMPLEMENTATION DEFINED whether the bits corresponding to the access in the Events packet are recorded or always zero. If the access does not occur, these bits are zero.

## D17.6.4.1 Additional effects when FEAT\_MTE is implemented

If profiling is enabled, each Allocation Tag covers multiple locations in a Tag Granule. It is IMPLEMENTATION DEFINED whether the implementation treats each Allocation Tag access as an access to the data location addressed in the operation, or the whole Tag Granule. That is, whether the data virtual address associated with the sampled access or chosen part of the access is the address of the location being accessed, or the lowest address covered by the same Allocation Tag or Allocation Tags.

An instruction that loads or stores an Allocation Tag is treated as a load or store for the purpose of Statistical Profiling.

When a sampled data access virtual address is from a context using Memory Tagging with Address tagging disabled, the TAG byte in the Address packet payload holds bits[63:56] of the address.

If the operation is an access to an Allocation Tag or multiple Allocation Tags, the sampled data physical address has two possibilities:

- The address generated from translating the sampled data virtual address.

- The address generated from translating the lowest address covered by the same Allocation Tag or Allocation Tags.

If the two possibilities have different values, it is IMPLEMENTATION DEFINED which one is used as the sampled data physical address. Otherwise, the sampled data physical address is the address generated from translating the sampled data virtual address.

If FEAT\_SPEv1p3 is implemented, instructions that load or store Allocation Tags are sampled using a dedicated Operation Type packet subclass, (Tags load/store). See Operation Type packet payload (Load/store, general).

Note

Operations that store both Tags and data are recorded as store operations targeting the general-purpose registers or targeting an unspecified registers subclass.

For more information, see The Memory Tagging Extension.

## D17.6.4.2 Additional effects when FEAT\_NV2 is implemented

When the sampled operation is a System register access transformed into a memory access by the mechanism described in Enhanced support for nested virtualization, the operation is recorded as an MRS or MSR operation at EL1 transformed into a load/store. If Statistical Profiling is disabled at EL2, the virtual address for the memory access is not recorded.

## D17.6.4.3 Additional effects when FEAT\_MOPS is implemented

Memory Copy and Memory Set instructions are sampled as retired if they have started processing. This is true even if the execution is not completed at the time of sampling, for example, due to an interrupt.

Memory Copy operations CPY and CPYF are sampled using Operation Type packet subclass (Memory Copy load/store), and Memory Set operations SET and SETG are sampled using Operation Type packet subclass (Memory Set load/store).

If a sampled Memory Copy operation performs both a load and a store, then the following are true:

- The sampled data virtual address is:
- -The corresponding one of load and store addresses if the filter controls are set to sample only one of load and store operations, respectively.
- -An unbiased sampling of one of load and store addresses if the filter controls are set to sample both load and store operations.
- The value of the LDST bit in the Operation Type packet is 0 if the source address is sampled, and 1 if the destination address is sampled.

## D17.6.4.4 Additional effects when FEAT\_LS64, FEAT\_LS64\_V, and FEAT\_LS64\_ACCDATA are implemented

FEAT\_LS64, FEAT\_LS64\_V, and FEAT\_LS64\_ACCDATA add the LD64B , ST64B , ST64BV , and ST64BV0 instructions. For SPE:

- LD64B is treated as a load.

- ST64B , ST64BV , and ST64BV0 are treated as stores. ST64BV and ST64BV0 are store with status result instructions and might have performance properties similar to a Device memory load. Sampled ST64BV and ST64BV0 instructions might have the following additional behaviors normally associated with sampled loads:

- AData Source packet is generated. This is optional for these instructions. For example, if the Data Source packet can only describe Normal memory sources, then they are not relevant for these instructions.

- The total latency counter for the sampled operation preferably includes cycles to the point where the return value is returned to the PE.

Note

These behaviors are optional. The information in these packets might not be available or relevant for all implementations.

## D17.6.4.5 Additional effects when FEAT\_GCS is implemented

If a sampled operation from GCSSS2 instruction performs both a load and a store, then the following is true:

- The sampled data virtual address is:
- -The corresponding one of load and store addresses if the filter controls are set to sample only one of load and store operations, respectively.
- -An unbiased sampling of one of load and store addresses if the filter controls are set to sample both load and store operations.
- The value of the LDST bit in the Operation Type packet payload depends on the address sampled:
- -If the source address is sampled, the value is 0.
- -If the destination address is sampled, the value is 1.

For an operation executing both a Branch and the Guarded Control Stack data access, if one of the branch and load or store is filtered out, the sampled operation will continue to record the information for both operations. For example, the Total latency packet or Issue latency packet includes the latencies of both the branch and the load or store operations.

## D17.6.4.6 Data Alignment Flag

If FEAT\_SPEv1p1 is implemented Events packet.E[11] is set to 1 for a sampled memory operation if the address alignment is non-optimal for the access size.

Address alignment is defined as non-optimal if that access incurs an additional performance penalty only because of the address alignment, and is unrelated to whether the access is architecturally misaligned for the access size.

## Example D17-3 Data Alignment Flag operation

- A 32-bit word access that is not word aligned is architecturally misaligned, but (if Alignment faults are disabled) might not incur an additional penalty because of this alignment unless the word also happens to span a cache-line boundary.
- Acontiguous load operation that loads a vector that is the length of two cache lines is optimally aligned if it has cache-line alignment, even though the operation makes two cache line accesses.
- A non-contiguous SVE load operation that makes a sequence of access is optimal only if all of the access are optimal.

The definition of non-optimal is IMPLEMENTATION DEFINED and support for the Alignment Flag is OPTIONAL.

## D17.6.5 Additional information for each profiled conditional instruction

For an Architecturally executed sampled conditional operation that finishes execution, the profiling operation records:

- That the sampled operation was conditional.
- Whether the condition passed or failed.

Only operations where the conditionality is controlled by PSTATE.{N, Z, C, V} are treated as conditional operations. Predicated SVE and SME operations are not treated as conditional operations, because the conditionality of the operation is controlled by a predicate

For each of the following operations, it is IMPLEMENTATION DEFINED whether it is treated as a conditional operation:

- Conditional select, both integer and floating-point.
- Conditional select increment.
- Conditional select negation.
- Conditional select inversion.
- Conditional compare, both integer and floating-point.
- Conditional compare negative.

Arm recommends that all operations where the conditionality is controlled by PSTATE.{N, Z, C, V} are treated as conditional operations.

Micro-ops might have different characteristics from the architectural instructions they are created from. See Information collected for micro-ops for more information.

Note

If the implementation samples architectural instructions, for some alias instructions, the alias specifies the opposite condition to the machine instruction that they alias. For example, CSET and CSETM. The event as captured by SPE always captures the result of the machine instruction, not the alias.

For conditional branches, see Additional information for each profiled branch or exception return.

## D17.6.6 Additional information for each profiled SVE and SME operation

ICKWPL

When FEAT\_SPEv1p1 is implemented, SVE and SME operations are sampled as described in this section.

DWRNLK

This section uses the following terms:

## Maximum implemented SVE vector length

- The Maximum implemented Streaming SVE vector length means the implemented width of the SVE scalable vector registers in Streaming SVE mode.
- The Maximum implemented Non-streaming SVE vector length means the implemented width of the SVE scalable vector registers in Non-streaming SVE mode.

See Maximum implemented SVE vector lengths.

## Effective SVE vector length (VL)

Means the current SVE vector length, SVL or NSVL :

- The Effective Streaming SVE vector length (SVL) is less than or equal to the Maximum implemented Streaming SVE vector length.
- The Effective Non-streaming SVE vector length (NSVL) is less than or equal to the Maximum implemented Non-streaming SVE vector length.

See Configurable SVE vector lengths.

## Effective tile size

Means the tile size of the current instruction, determined by SVL and the element size used by the instruction. The Effective tile size is less than or equal to the square of the Maximum implemented Streaming SVE vector length, divided by the element size.

## Sampled SVE SIMD operation

Means a sampled instruction or micro-operation that reads from or writes to the SVE vector or predicate registers but not the SME ZA storage. This includes instructions with scalar outputs, but excludes non-SIMD instructions or operations. For example, the following instructions are in this category:

- ADD Z0.S, P7/M, Z0.S, Z1.S .
- FMLALB Z2.S, Z3.H, Z4.H .
- TBL Z5.H, { Z6.H }, Z7.H .
- LASTA W0, P6, Z8.S .
- LUTI4 {Z8.H-Z9.H}, ZT0, Z10[2] .
- FMAX {Z0.H-Z1.H}, {Z2.H-Z3.H}, {Z4.H-Z5.H} .

## Sampled SME vector SIMD operation

Means a sampled instruction or micro-operation reading from or writing to SME ZA array vectors or tile slices, which is not reading from or writing to a 2D ZA tile. For example, the following instructions are in this category:

- ADD ZA.S[W8, 3, VGx2], {Z0.S-Z1.S}, {Z2.S-Z3.S} .
- FMLAL ZA.S[W9, 4:5, VGx4], {Z4.H-Z7.H}, {Z8.H-Z11.H} .
- MOVA Z11.S, P3/M, ZA0H.S[W12,1] .
- LD1W {ZA1V.S[W13,0]}, P4/Z, [X1,X2,LSL 2] .

IXYGNN

## Sampled SME tile SIMD operation

Means a sampled instruction or micro-operation reading from or writing to a 2D ZA tile or multiple ZA tiles. For example, the following instructions are in this category:

- SMOPA ZA0.S, P0/M, P1/M, Z2.B, Z3.B .
- ZERO {ZA1.H} .

## Sampled effective vector length

Means the length in bits of the vector or vectors operated on by a Sampled SVE SIMD operation or a Sampled SME vector SIMD operation. That is, the number of elements in the vector multiplied by the element size.

In cases where the Sampled effective vector length for the input operands of the sampled operation and the Sampled effective vector length for the output operand of the sampled operation differ, the Sampled effective vector length of the output operand is used.

For a Sampled SVE SIMD operation or a Sampled SME vector SIMD operation which reads or writes only SVE predicate registers, the Sampled effective vector length is:

- The length in bits of the predicate operated on multiplied by 8, when predicate-as-mask encoding is used.
- The VL, when predicate-as-counter encoding is used.

## Sampled effective tile size

Means the size in bits of the ZA tile or tiles operated on by a Sampled SME tile SIMD operation. That is, the number of elements in the ZA tile or tiles multiplied by the element size.

## Sampled predicated operation

Means a Sampled SVE SIMD operation, Sampled SME vector SIMD operation, or Sampled SME tile SIMD operation that is one of:

- An operation that writes to one or more SVE scalable vector registers or ZA tile slices under a Governing predicate or predicates using either zeroing or merging predication.
- Apredicated store of a one or more SVE scalable vector registers or ZA tile slices.

For an implementation that samples micro-operations, an SVE or SME instruction might be split up into one or more micro-operations, some of which are predicated and some of which are not predicated.

Note

Sampled predicated operation excludes operations that do not write a vector register, or do so but not using zeroing or merging predication, and applies to machine instructions rather than aliases. For example, the following instructions are not predicated SVE instructions under this definition:

- CNTP , LASTA , and PTRUE do not write to vector registers.
- FADDV and SMAXV write scalar values to SIMD&amp;FP registers.
- COMPACT and SEL (vectors) write to vector registers, and have a predicate operand, but do not use that predicate as a Governing predicate for zeroing or merging predication.
- MOV (vector, predicated) appears to be a predicated SVE instruction because it specifies merging predication through the &lt;PG&gt;/M operand, but it is actually an alias for the SEL (vectors) instruction.

In some implementations, a SIMD instruction might be split into one or more micro-operations, each operating on only a part of the vector or tile specified by the instruction. When such an operation is sampled by the Statistical Profiling Unit (SPU), the Sampled effective vector length or Sampled effective tile size might be smaller than the Effective vector length or Effective tile size specified by SVL or NSVL .

Furthermore, some instructions might not affect the whole vector or tile specified by the instruction. For example, a predicated operation or an instruction such as ZERO (tiles) that specifies a mask in the instruction. This might affect how an individual micro-operation functions, and, for an implementation that samples operations, how the micro-operation is described by the SPU when sampled.

## Example D17-4 Vector length

To support a vector length of 1024 bits, an implementation might split all instructions into four micro-operations on 256-bit vector paths. The implementation must, however, implement 1024-bit wide vector registers.

This behavior might vary based on operation type. For example, an implementation that has a full-width data-path for most operations might choose to break certain complex operations, such as non-contiguous load or stores, into shorter vectors.

RDDCQB

- RMZJMH

RCYBGV

RLQXZR

## Example D17-5 Effective SVE vector length less-than the Maximum implemented

To support an Effective SVE vector length less-than the Maximum implemented SVE vector length, an implementation might choose to execute all operations at the Maximum implemented SVE vector length and discard the results above the Effective SVE vector length. Discarded results, arising from difference between Maximum implemented SVE vector length and Effective vector length, do not form part of the sampled operation and the Sampled effective SVE vector length does not include any discarded portions of the vector.

Results discarded because of predication are part of the sampled operation.

If an implementation samples micro-operations, then it is IMPLEMENTATION DEFINED, and might vary between operation types, whether a SIMD SVE or SME operation for which all the following are true is treated as a Sampled SVE SIMD operation or Sampled SME vector SIMD operation respectively, or the equivalent Advanced SIMD operation:

- The Sampled effective vector length is 128 bits.
- The operation is unpredicated, and does not have a predicate register as an input or output.
- The operation has an equivalent Advanced SIMD operation.

This includes SVE or SME load and store operations where an equivalent Advanced SIMD operation is defined.

- RLMHHC The division of instructions into micro-operations must be fixed prior to sampling to guarantee consistently accurate statistical sampling.
- RMDBYZ ASampled SVE SIMD data-processing operation generates a Data processing, SVE vector format Operation Type packet, and:
- If FEAT\_SPE\_SME is implemented, then the Operation Type packet.EVL field records the upper bound of the Sampled effective vector length multiplied by the number of vectors operated on by the sampled operation. If the result is greater than 2048 bits, then the Operation Type packet.EVL field is set to 0b111 .
- If FEAT\_SPE\_SME is not implemented, then the Operation Type packet.EVL field records the upper bound of the Sampled effective vector length.

If FEAT\_SPE\_SME is not implemented, then it is IMPLEMENTATION DEFINED whether any of the following Sampled SVE SIMD data-processing operations generate an Other or a Data processing, SVE vector format Operation Type packet:

- Adata-processing operation which involves the ZT registers.
- Adata-processing operation with a multi-vector operand which accesses only SVE scalable vector registers.

If FEAT\_SPE\_SME is implemented, then a Sampled SME tile SIMD operation generates a Data processing, SME array format Operation Type packet, and:

- If the operation operates on the whole ZA array at once, then the Operation Type packet.ETS field is set to 0b1111 .
- Otherwise, the Operation Type packet.ETS field records an upper bound of the Sampled effective tile size for the sampled operation.

If FEAT\_SPE\_SME is not implemented, then a Sampled SME tile SIMD operation generates an Other format Operation Type packet.

Note

The Data processing, SME array format does not record whether the Sampled SME tile SIMD operation was predicated, or not.

If FEAT\_SPE\_SME is implemented, then a Sampled SME vector data-processing operation generates a Data processing, SMEarray format Operation Type packet, and the Operation Type packet.ETS field records an upper bound of the Sampled effective vector length multiplied by the number of vectors operated on by the sampled operation. If FEAT\_SPE\_SME is not implemented, then a Sampled SME vector data-processing operation generates an Other format Operation Type packet.

Note

The Data processing, SME array format does not record whether the Sampled SME vector data-processing operation was predicated, or not.

ASampled SVE vector load/store operation generates a Load/store, SVE or SME format Operation Type packet.

RMJQCL

RJCLMP

## RBHKSC

If FEAT\_SPE\_SME is implemented, then a Sampled SME vector load/store operation generates a Load/store, SVE or SMEformat Operation Type packet.

If FEAT\_SPE\_SME is not implemented, then it is IMPLEMENTATION DEFINED whether a Sampled SME vector load/store operation generates a Load/store, SVE or SME format or an Unspecified load/store format Operation Type packet.

If FEAT\_SPE\_SME is implemented and a Sampled SME vector load/store operation or Sampled SVE SIMD load/store operation generates a Load/store, SVE or SME format Operation Type packet, then the Operation Type packet.EVL field records the upper bound of the Sampled effective vector length multiplied by the number of vectors loaded or stored by the sampled operation. If this product is greater than 2048 bits, then the Operation Type packet.EVL field is set to 0b111 .

If FEAT\_SPE\_SME is not implemented and a Sampled SME vector load/store operation or Sampled SVE SIMD load/store operation generates a Load/store, SVE or SME format Operation Type packet, then the Operation Type packet.EVL field records the upper bound of the Sampled effective vector length.

For a sampled SVE cache prefetch operation:

- The profiling operation captures an IMPLEMENTATION DEFINED subset of the information captured for an SVE load instruction.
- The profiling operation treats the operation type as Other when generating the sample records and filtering based on operation.
- It is IMPLEMENTATION DEFINED whether the operation is treated as a Sampled SVE SIMD operation:
- -If treated as a Sampled SVE SIMD operation, then the Operation Type packet format is Data processing, SVE vector payload.
- -If not treated as a Sampled SVE SIMD operation, then the Operation Type packet format is Other payload.
- RMYPFF For a sampled non-contiguous SVE load or store operation that makes multiple memory accesses, the sampled data virtual address is the address accessed by a random one of the load or store operations chosen from the Sampled predicated operation. If the chosen load or store operation is for an Inactive element, the data virtual address packet is not output.

For more information, see Additional information for each profiled memory access operation.

- RNHSYR For a sampled contiguous SVE load or store operation that makes multiple memory accesses, the sampled data virtual address is an IMPLEMENTATION DEFINED choice of:
- The address accessed for the lowest element in the Sampled predicated operation.
- The address used for the access containing the lowest Active element in the Sampled predicated operation.

If the corresponding element is an Inactive element, it is IMPLEMENTATION DEFINED whether the data virtual address packet is output.

## D17.6.7 Sample operation records for misspeculated and non-architectural operations

It is IMPLEMENTATION DEFINED whether each of the following operations is part of the sample population:

- Operations on misspeculated paths.
- Operations that do not relate to any architecture instruction.

If the operation is part of the sample population, it is further IMPLEMENTATION DEFINED whether the sample record for the sampled operation is captured in the Profiling Buffer. For more information, see Operations that might be excluded from the sample population.

If such an operation is part of the sample population and the sample record is captured in the Profiling Buffer, then some information for the operation might not be present. However, the Events packet and either the End packet or the Timestamp packet is always output. Neither event 0 (generated exception) nor event 1 (architecturally retired) will be set in the Events packet.

The record must not contain or infer values that cannot be accessed or used by the sampled operation, as defined by Restrictions on the effects of speculation.

For example:

- An address that is not permitted to be used by the sampled operation, such as might be recorded in an Address packet.
- Acondition code or predicate value that is not permitted to be used by the sampled operation, such as might be
- inferred from the Mispredicted, Partial or empty predicate, or Empty predicate bits in the Events packet.
- Abranch target address predicted in a way that is prohibited, such as might be recorded in an Address packet.

## D17.6.8 Additional information for other operations

For a sampled operation that does not use any of the Operation Type packet formats defined in the previous sections, it will use the Other format Operation Type packet. This indicates:

- Whether the instruction was conditional or not. See Additional information for each profiled conditional instruction.
- If FEAT\_SPE\_FPF is implemented, whether the operation is Advanced SIMD or scalar.
- If FEAT\_SPE\_FPF is implemented, whether the operation is floating-point or not floating-point.

For cache maintenance operations by virtual address, cache prefetch other than SVE cache prefetch, or address translation instructions, the profiling operation:

- Generates an Other format Operation Type packet.
- Captures an IMPLEMENTATION DEFINED subset of the information captured for a load instruction. See Additional information for each profiled memory access operation.
- Is not treated as a load or a store when filtering based on operation type. See Filtering sample records.

## D17.6.9 Controlling the data that is collected

Certain data in sample records is collected only if permitted by one or both of EL1 and EL2. This is to restrict exposure of data to a lower Exception level or to Non-secure state.

CONTEXTIDR\_EL1 is collected only if PMSCR\_EL1.CX is set to 1, the PE is executing at EL1 or EL0 and any of the following are true when an operation is sampled:

- EL2 is not implemented.
- FEAT\_SEL2 is implemented and EL2 is disabled for the current Security state.
- The Effective value of HCR\_EL2.TGE is 0.

CONTEXTIDR\_EL2 is collected only if the Effective value of PMSCR\_EL2.CX is 1 and EL2 is implemented and enabled for the current Security state.

This is described in the pseudocode functions CollectContextIDR1() and CollectContextIDR2() .

Timestamps are collected only if one of the following is true:

- PMSCR\_EL1.TS is set to 1 and the Profiling Buffer is owned by EL1.
- PMSCR\_EL2.TS is set to 1 and the Profiling Buffer is owned by EL2.

The timestamp is a choice between:

- Physical time, which is defined by the physical count value returned by PhysicalCountInt ().
- If FEAT\_ECV is implemented, offset physical time, which is defined as the value of PhysicalCountInt () minus a physical offset.
- Virtual time, which is defined as the value of PhysicalCountInt () minus a virtual offset.

Table D17-3 summarizes the choice of value for the Timestamp packet when FEAT\_ECV is implemented and StatisticalProfilingEnabled() is TRUE. In Table D17-3:

Owning EL This is the Exception level that owns the Profiling Buffer. This is returned by the function ProfilingBufferOwner() . If EL2 is disabled in the current Security state, this is always EL1.

EL2 enabled

## Virtual offset

This is TRUE when EL2 is enabled in the current Security state. When EL2 is disabled in the current Security state, this is FALSE.

The virtual offset is treated as zero if a read of CNTVCT\_EL0 at the current Exception level would treat the virtual offset as zero. Therefore if any of the following are true, the virtual offset is zero:

- EL2 is not implemented.
- The Effective value of HCR\_EL2.E2H is 1, and the sampled operation was executed at EL2.
- The Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}, and the sampled operation was executed at EL0.

Otherwise the virtual offset is the value of CNTVOFF\_EL2.

Physical offset

If any of the following are true, the physical offset is zero:

- EL2 is not implemented.
- FEAT\_ECV\_POFF is not implemented.
- CNTHCTL\_EL2.ECV is 0.
- EL3 is implemented and SCR\_EL3.ECVEn is 0.

Otherwise the physical offset is the value of CNTPOFF\_EL2.

Table D17-3 Recorded timestamp when FEAT\_ECV is implemented

| EL2 enabled   | Owning EL   | PMSCR_EL2   |    | PMSCR_EL1   | PMSCR_EL1   | Recorded timestamp                    |
|---------------|-------------|-------------|----|-------------|-------------|---------------------------------------|
| EL2 enabled   | Owning EL   | PCT[1:0]    | TS | PCT[1:0]    | TS          | Recorded timestamp                    |
| x             | EL1         | xx          | x  | xx          | 0           | None                                  |
| x             | EL1         |             |    | 0b00        | 1           | PhysicalCountInt () - virtual offset  |
| FALSE         | EL1         | xx          | x  | 0b01        | 1           | PhysicalCountInt ()                   |
| FALSE         | EL1         |             |    | 0b11        | 1           | PhysicalCountInt () - physical offset |
| TRUE          | EL1         | 0b00        | x  | xx          | 1           | PhysicalCountInt () - virtual offset  |
| TRUE          | EL1         | 0b01        | x  | 0b01        | 1           | PhysicalCountInt ()                   |
| TRUE          | EL1         |             |    | 0b11        | 1           | PhysicalCountInt () - physical offset |
| TRUE          | EL1         | 0b11        | x  | 0b01        | 1           | PhysicalCountInt () - physical offset |
| TRUE          | EL1         |             |    | 0b11        | 1           | PhysicalCountInt () - physical offset |
| TRUE          | EL2         | xx          | 0  | xx          | x           | None                                  |
| TRUE          | EL2         | 0b00        | 1  | xx          | x           | PhysicalCountInt () - virtual offset  |
| TRUE          | EL2         | 0b01        | 1  | xx          | x           | PhysicalCountInt ()                   |
| TRUE          | EL2         | 0b11        | 1  | xx          | x           | PhysicalCountInt () - physical offset |

If EL2 is not implemented, see the register descriptions of PMSCR\_EL1.PCT and PMSCR\_EL2.PCT for details of their behavior. This behavior is described by the pseudocode function CollectTimeStamp() .

Physical data addresses are collected only if one of the following is true:

- The Effective value of PMSCR\_EL1.PA is 1, the Effective value of PMSCR\_EL2.PA is 1, and the Profiling Buffer is owned by EL1.
- The Effective value of PMSCR\_EL2.PA is 1 and the Profiling Buffer is owned by EL2.

If EL2 is not implemented or is disabled for the owning Security state, then the Effective value of PMSCR\_EL2.PA is 1.

Physical data address collection is described by the pseudocode function CollectPhysicalAddress() .

Enabling collection of the physical data addresses has an IMPLEMENTATION DEFINED impact on the sampled operation.

## D17.6.10 Exceptions

All sample records written to the Profiling Buffer contain the Events packet and either the End packet or the Timestamp packet.

If the sampled operation generates an exception condition, it is UNPREDICTABLE whether the sample record contains any other information. This includes operations that generate faults or other exception conditions but do not generate exceptions. For example:

- An instruction on a misspeculated path.
- Aload operation that is part of a Non-fault load instruction or is not the First active element of a First-fault load instruction that generates an MMU fault or watchpoint.
- An address translation operation or prefetch instruction that generates an MMU fault.

Where a sampled operation generates an exception and the type of exception means that a particular item is not computed by the sampled operation, that information is not collected by the profiling operation. For more information, see Synchronization and Statistical Profiling.

## Example D17-6 Translation Faults

If a sampled operation generates a Translation Fault, the physical address for the sampled operation was not generated by the MMU and cannot be recorded.

## D17.6.10.1 Non-architectural exceptions

It is IMPLEMENTATION DEFINED whether operations that generate non-architectural exceptions are part of the sample population. If such an operation is part of the sample population, it is further IMPLEMENTATION DEFINED whether the sample record for a sampled operation that generates a non-architectural exception is captured in the Profiling Buffer. For more information, see Operations that might be excluded from the sample population.

If such an operation is part of the sample population and the sample record is captured in the Profiling Buffer, then the sample might record handling of the non-architectural exception. If the sample record does not record handling of the non-architectural exception, then the sampled operation is not Architecturally executed because of the non-architectural exception and it is recorded using E[1] == 0 (operation is not architecturally executed) in the Events packet. Bit E[0] (operation generated an exception) might be used to indicate the operation did not complete because of the non-architectural exception.