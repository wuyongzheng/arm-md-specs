## C8.2.400 LDFF1SW (vector plus immediate)

Gather load first-fault signed words to vector (immediate index)

This instruction performs a gather load with first-faulting behavior of signed words to Active elements of a vector register from memory addresses generated by a vector base plus immediate index. The index is a multiple of 4 in the range 0 to 124. Inactive elements will not cause a read from Device memory or signal faults, and are set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless FEAT\_SME\_FA64 is implemented and enabled.

## SVE

(FEAT\_SVE)

<!-- image -->

## Encoding

```
LDFF1SW { <Zt>.D },
```

```
<Pg>/Z, [<Zn>.D{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Zt); constant integer n = UInt(Zn); constant integer g = UInt(Pg); constant integer esize = 64; constant integer msize = 32; constant boolean unsigned = FALSE; constant integer offset = UInt(imm5);
```

## Assembler Symbols

&lt;Zt&gt;

Is the name of the scalable vector register to be transferred, encoded in the 'Zt' field.

Is the name of the governing scalable predicate register P0-P7, encoded in the 'Pg' field.

&lt;Pg&gt;

&lt;Zn&gt;

Is the name of the base scalable vector register, encoded in the 'Zn' field.

## &lt;imm&gt;

Is the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 124, defaulting to 0, encoded in the 'imm5' field.

## Operation

```
CheckNonStreamingSVEEnabled(); constant integer VL = CurrentVL; constant integer PL = VL DIV 8; constant integer elements = VL DIV esize; constant bits(PL) mask = P[g, PL]; bits(VL) base; bits(VL) result; constant bits(VL) orig = Z[t, VL]; bits(msize) data; constant integer mbytes = msize DIV 8; boolean fault = FALSE; boolean faulted = FALSE; boolean unknown = FALSE; constant boolean contiguous = FALSE; constant boolean tagchecked = TRUE; AccessDescriptor accdesc = CreateAccDescSVEFF(contiguous, tagchecked); if AnyActiveElement(mask, esize) then base = Z[n, VL]; assert accdesc.first; for e = 0 to elements-1 if ActivePredicateElement(mask, e, esize) then constant bits(64) baddr = ZeroExtend(Elem[base, e, esize], 64); constant bits(64) addr = AddressAdd(baddr, offset * mbytes, accdesc); if accdesc.first then // Mem[] will not return if a fault is detected for the First active element data = Mem[addr, mbytes, accdesc]; accdesc.first = FALSE; else // MemNF[] will return fault=TRUE if access is not performed for any reason (data, fault) = MemNF[addr, mbytes, accdesc]; faulted = faulted || ConstrainUnpredictableBool(Unpredictable_NONFAULT); else (data, fault) = (Zeros(msize), FALSE); // FFR elements set to FALSE following a suppressed access/fault faulted = faulted || fault; if faulted then ElemFFR[e, esize] = '0'; // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE unknown = unknown || ElemFFR[e, esize] == '0'; if unknown then if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then Elem[result, e, esize] = Extend(data, esize, unsigned); elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then Elem[result, e, esize] = Zeros(esize); else // merge Elem[result, e, esize] = Elem[orig, e, esize]; else Elem[result, e, esize] = Extend(data, esize, unsigned); Z[t, VL] = result;
```