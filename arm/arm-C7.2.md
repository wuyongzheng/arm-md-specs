## C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

This section lists every section in the Advanced SIMD and floating-point categories of the A64 instruction set. For details of the format used, see Structure of the A64 assembler language.

## C7.2.1 ABS

Absolute value (vector)

This instruction calculates the absolute value of each vector element in the source SIMD&amp;FP register, puts the result into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ABS D<d>, D<n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ABS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Vd&gt; Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.
- &lt;T&gt;

&lt;Vn&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 element = SInt(Elem[operand, e, esize]); element = Abs(element); Elem[result, e, esize] = element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.2 ADD (vector)

Add (vector)

This instruction adds corresponding elements in the two source SIMD&amp;FP registers, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ADD D<d>, D<n>, D<m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ADD
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;n&gt;

&lt;m&gt;

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

- &lt;Vd&gt; Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.
- &lt;T&gt;

&lt;Vn&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = element1 + element2; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.3 ADDHN, ADDHN2

Add returning high narrow

This instruction adds each vector element in the first source SIMD&amp;FP register to the corresponding vector element in the second source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register.

The results are truncated. For rounded results, see RADDHN.

The ADDHN instruction writes the vector to the lower half of the destination register and clears the upper half. The ADDHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

Three registers, not all the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ADDHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant boolean round = FALSE;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Tb&gt;

## &lt;Vn&gt;

&lt;Ta&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand1 = V[n, 2*datasize]; constant bits(2*datasize) operand2 = V[m, 2*datasize]; bits(datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, 2*esize]); element2 = UInt(Elem[operand2, e, 2*esize]); sum = element1 + element2; sum = RShr(sum, esize, round); Elem[result, e, esize] = sum<esize-1:0>; Vpart[d, part, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

## C7.2.4 ADDP (scalar)

Add pair of elements (scalar)

This instruction adds two vector elements in the source SIMD&amp;FP register and writes the scalar result into the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ADDP D<d>, <Vn>.2D
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 64; constant integer datasize = 128;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; V[d, esize] = IntReduce(ReduceOp_ADD, operand, esize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.5 ADDP (vector)

Add pairwise (vector)

This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ADDP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |
|     10 |   1 | 4S    |

<!-- image -->

&lt;Vn&gt;

|   size |   Q | <T>      |
|--------|-----|----------|
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; constant bits(2*datasize) concat = operand2:operand1; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[concat, 2*e, esize]; element2 = Elem[concat, (2*e)+1, esize]; Elem[result, e, esize] = element1 + element2; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.6 ADDV

Add across vector

This instruction adds every vector element in the source SIMD&amp;FP register together, and writes the scalar result to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ADDV <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '100' then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q);
```

## Assembler Symbols

<!-- image -->

&lt;V&gt;

Is the destination width specifier, encoded in 'size':

&lt;d&gt;

&lt;Vn&gt;

|   size | <V>      |
|--------|----------|
|     00 | B        |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;T&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | RESERVED |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; V[d, esize] = IntReduce(ReduceOp_ADD, operand, esize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.7 AESD

AES single round decryption.

## Advanced SIMD

(FEAT\_AES)

<!-- image -->

## Encoding

```
AESD <Vd>.16B, <Vn>.16B
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AES) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[d, 128]; constant bits(128) operand2 = V[n, 128]; bits(128) result = operand1 EOR operand2; result = AESInvShiftRows(result); V[d, 128] = AESInvSubBytes(result);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.8 AESE

AES single round encryption.

## Advanced SIMD

(FEAT\_AES)

<!-- image -->

## Encoding

```
AESE <Vd>.16B, <Vn>.16B
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AES) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[d, 128]; constant bits(128) operand2 = V[n, 128]; bits(128) result = operand1 EOR operand2; result = AESShiftRows(result); V[d, 128] = AESSubBytes(result);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.9 AESIMC

AES inverse mix columns.

## Advanced SIMD

(FEAT\_AES)

<!-- image -->

## Encoding

```
AESIMC <Vd>.16B, <Vn>.16B
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AES) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand = V[n, 128]; V[d, 128] = AESInvMixColumns(operand);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.10 AESMC

AES mix columns.

## Advanced SIMD

(FEAT\_AES)

<!-- image -->

## Encoding

```
AESMC <Vd>.16B, <Vn>.16B
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AES) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand = V[d, 128] = AESMixColumns(operand);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
V[n, 128];
```

## C7.2.11 AND (vector)

Bitwise AND (vector)

This instruction performs a bitwise AND between the two source SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
AND <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q);
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;T&gt;

## &lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = V[d, datasize] = operand1 AND operand2;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
V[n, datasize]; V[m, datasize];
```

## C7.2.12 BCAX

Bit clear and exclusive-OR

This instruction performs a bitwise AND of the 128-bit vector in a source SIMD&amp;FP register and the complement of the vector in another source SIMD&amp;FP register, then performs a bitwise exclusive-OR of the resulting vector and the vector in a third source SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP register.

## Advanced SIMD

(FEAT\_SHA3)

<!-- image -->

## Encoding

```
BCAX <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA3) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer a = UInt(Ra);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Va&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Ra' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[m, 128]; constant bits(128) operand2 = V[n, 128]; constant bits(128) operand3 = V[a, 128]; V[d, 128] = operand2 EOR (operand1 AND NOT(operand3));
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.13 BF1CVTL, BF1CVTL2, BF2CVTL, BF2CVTL2

8-bit floating-point convert to BFloat16 (vector)

This instruction converts each 8-bit floating-point element from the lower or upper half of the source vector to BFloat16 while downscaling the value, and places the results in the 16-bit elements of the destination vector. BF1CVTL and BF2CVTL convert the elements from the lower half of the source vector while scaling the values by 2 -UInt(FPMR.LSCALE[5:0]) and 2 -UInt(FPMR.LSCALE2[5:0]) , respectively. BF1CVTL2 and BF2CVTL2 convert the elements from the upper half of the source vector while scaling the values by 2 -UInt(FPMR.LSCALE[5:0]) and 2 -UInt(FPMR.LSCALE2[5:0]) , respectively.

The 8-bit floating-point encoding format for BF1CVTL and BF1CVTL2 is selected by FPMR.F8S1. The 8-bit floating-point encoding format for BF2CVTL and BF2CVTL2 is selected by FPMR.F8S2.

## Advanced SIMD

(FEAT\_FP8)

<!-- image -->

## Encoding for the BF1CVTL{2} variant

```
Applies when (size == 10) BF1CVTL{2} <Vd>.8H, <Vn>.<Ta>
```

## Encoding for the BF2CVTL{2} variant

Applies when

```
(size == 11) BF2CVTL{2} <Vd>.8H, <Vn>.<Ta>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP8) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer part = UInt(Q); constant integer elements = 64 DIV 8; constant boolean issrc2 = size == '11';
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Vn&gt;

&lt;Ta&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(64) operand = Vpart[n, part, 64]; bits(128) result; for e = 0 to elements-1 Elem[result, e, 16] = FP8ConvertBF(Elem[operand, e, 8], V[d, 128] = result;
```

|   Q | <Ta>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

```
issrc2, FPCR, FPMR);
```

## C7.2.14 BFCVT

Single-precision convert to BFloat16 (scalar)

This instruction converts the single-precision floating-point value in the 32-bit SIMD&amp;FP source register to BFloat16 format and writes the result in the 16-bit SIMD&amp;FP destination register.

ID\_AA64ISAR1\_EL1.BF16 indicates whether this instruction is supported.

## Single-precision to BFloat16

(FEAT\_BF16)

<!-- image -->

## Encoding

```
BFCVT <Hd>, <Sn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_BF16) then constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

<!-- image -->

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(32) operand = V[n, 32]; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); Elem[result, 0, 16] = FPConvertBF(operand, FPCR); V[d, 128] = result;
```

```
EndOfDecode(Decode_UNDEF);
```

## C7.2.15 BFCVTN, BFCVTN2

Single-precision convert to BFloat16 (vector)

This instruction reads each single-precision element in the SIMD&amp;FP source vector, converts each value to BFloat16 format, and writes the results in the lower or upper half of the SIMD&amp;FP destination vector. The result elements are half the width of the source elements.

The BFCVTN instruction writes the half-width results to the lower half of the destination vector and clears the upper half to zero. The BFCVTN2 instruction writes the results to the upper half of the destination vector without affecting the other bits in the register.

## Vector single-precision to BFloat16

(FEAT\_BF16)

<!-- image -->

## Encoding

```
BFCVTN{2} <Vd>.<Ta>, <Vn>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_BF16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer part = UInt(Q); constant integer elements = 64 DIV 16;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Vd&gt;

<!-- image -->

&lt;Vn&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 4H     |
|   1 | 8H     |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand = V[n, 128]; bits(64) result; for e = 0 to elements-1 Elem[result, e, 16] = FPConvertBF(Elem[operand, e, 32], FPCR); Vpart[d, part, 64] = result;
```

## C7.2.16 BFDOT (by element)

BFloat16 dot product to single-precision (vector, by element)

This instruction delimits the source vectors into pairs of BFloat16 elements. The BFloat16 pair within the second source vector is specified using an immediate index. The index range is from 0 to 3 inclusive.

If FEAT\_EBF16 is not implemented or FPCR.EBF is 0, this instruction:

- Performs an unfused sum-of-products of each pair of adjacent BFloat16 elements in the first source vector with the specified pair of elements in the second source vector. The intermediate single-precision products are rounded before they are summed, and the intermediate sum is rounded before accumulation into the single-precision destination element that overlaps with the corresponding pair of BFloat16 elements in the first source vector.
- Uses the non-IEEE 754 Round-to-Odd rounding mode, which forces bit 0 of an inexact result to 1, and rounds an overflow to an appropriately signed Infinity.
- Flushes denormalized inputs and results to zero, as if FPCR.{FZ, FIZ} is {1, 1}.
- Honors FPCR.AH when generating a default NaN result, otherwise disables alternative floating point behaviors, as if FPCR.AH is 0.

If FEAT\_EBF16 is implemented and FPCR.EBF is 1, then this instruction:

- Performs a fused sum-of-products of each pair of adjacent BFloat16 elements in the first source vector with the specified pair of elements in the second source vector. The intermediate single-precision products are not rounded before they are summed, but the intermediate sum is rounded before accumulation into the single-precision destination element that overlaps with the corresponding pair of BFloat16 elements in the first source vector.
- Follows all other floating-point behaviors that apply to single-precision arithmetic, as governed by FPCR.RMode, FPCR.FZ, FPCR.AH, and FPCR.FIZ.

Irrespective of FEAT\_EBF16 and FPCR.EBF, this instruction:

- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.
- Generates only the default NaN, as if FPCR.DN is 1.

ID\_AA64ISAR1\_EL1.BF16 indicates whether this instruction is supported.

## Advanced SIMD

(FEAT\_BF16)

<!-- image -->

## Encoding

```
BFDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.2H[<index>]
```

## Decode for this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_BF16) then constant integer n = UInt(Rn); constant integer m = UInt(M:Rm); constant integer d = UInt(Rd); constant integer i = UInt(H:L); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV 32;
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

## &lt;Vn&gt;

&lt;Tb&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'M:Rm' fields.

## &lt;index&gt;

Is the immediate index of a pair of 16-bit elements in the range 0 to 3, encoded in the 'H:L' fields.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(128) operand2 = V[m, 128]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; for e = 0 to elements-1 constant bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16]; constant bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16]; constant bits(16) elt2_a = Elem[operand2, 2 * i + 0, 16]; constant bits(16) elt2_b = Elem[operand2, 2 * i + 1, 16]; constant bits(32) sum = Elem[operand3, e, 32]; Elem[result, e, 32] = BFDotAdd(sum, elt1_a, elt1_b, elt2_a, elt2_b, FPCR); V[d, datasize] = result;
```

|   Q | <Tb>   |
|-----|--------|
|   0 | 4H     |
|   1 | 8H     |

## C7.2.17 BFDOT (vector)

BFloat16 dot product to single-precision (vector)

This instruction delimits the source vectors into pairs of BFloat16 elements.

If FEAT\_EBF16 is not implemented or FPCR.EBF is 0, this instruction:

- Performs an unfused sum-of-products of each pair of adjacent BFloat16 elements in the source vectors. The intermediate single-precision products are rounded before they are summed, and the intermediate sum is rounded before accumulation into the single-precision destination element that overlaps with the corresponding pair of BFloat16 elements in the source vectors.
- Uses the non-IEEE 754 Round-to-Odd rounding mode, which forces bit 0 of an inexact result to 1, and rounds an overflow to an appropriately signed Infinity.
- Flushes denormalized inputs and results to zero, as if FPCR.{FZ, FIZ} is {1, 1}.
- Honors FPCR.AH when generating a default NaN result, otherwise disables alternative floating point behaviors, as if FPCR.AH is 0.

If FEAT\_EBF16 is implemented and FPCR.EBF is 1, then this instruction:

- Performs a fused sum-of-products of each pair of adjacent BFloat16 elements in the source vectors. The intermediate single-precision products are not rounded before they are summed, but the intermediate sum is rounded before accumulation into the single-precision destination element that overlaps with the corresponding pair of BFloat16 elements in the source vectors.
- Follows all other floating-point behaviors that apply to single-precision arithmetic, as governed by FPCR.RMode, FPCR.FZ, FPCR.AH, and FPCR.FIZ.

Irrespective of FEAT\_EBF16 and FPCR.EBF, this instruction:

- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.
- Generates only the default NaN, as if FPCR.DN is 1.

ID\_AA64ISAR1\_EL1.BF16 indicates whether this instruction is supported.

## Advanced SIMD

(FEAT\_BF16)

<!-- image -->

## Encoding

```
BFDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_BF16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV 32;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

&lt;Vn&gt;

&lt;Tb&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; for e = 0 to elements-1 constant bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16]; constant bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16]; constant bits(16) elt2_a = Elem[operand2, 2 * e + 0, 16]; constant bits(16) elt2_b = Elem[operand2, 2 * e + 1, 16]; constant bits(32) sum = Elem[operand3, e, 32]; Elem[result, e, 32] = BFDotAdd(sum, elt1_a, elt1_b, elt2_a, elt2_b, FPCR); V[d, datasize] = result;
```

|   Q | <Tb>   |
|-----|--------|
|   0 | 4H     |
|   1 | 8H     |

## C7.2.18 BFMLALB, BFMLALT (by element)

BFloat16 multiply-add to single-precision (by element)

This instruction widens the even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first source vector, and the indexed element in the second source vector from Bfloat16 to single-precision format. The instruction then multiplies and adds these values without intermediate rounding to single-precision elements of the destination vector that overlap with the corresponding BFloat16 elements in the first source vector.

ID\_AA64ISAR1\_EL1.BF16 indicates whether this instruction is supported.

## Vector

(FEAT\_BF16)

<!-- image -->

## Encoding

```
BFMLAL<bt> <Vd>.4S, <Vn>.8H, <Vm>.H[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_BF16) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer m = UInt('0':Rm); constant integer d = UInt(Rd); constant integer index = UInt(H:L:M); constant integer elements = 128 DIV 32; constant integer sel = UInt(Q);
```

## Assembler Symbols

&lt;bt&gt;

Is the bottom or top element specifier, encoded in 'Q':

|   Q | <bt>   |
|-----|--------|
|   0 | B      |
|   1 | T      |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, in the range V0 to V15, encoded in the 'Rm' field.

## &lt;index&gt;

Is the element index, in the range 0 to 7, encoded in the 'H:L:M' fields.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(128) result; constant bits(128) operand1 = V[n, 128]; constant bits(128) operand2 = V[m, 128]; constant bits(128) operand3 = V[d, 128]; constant bits(16) element2 = Elem[operand2, index, 16]; for e = 0 to elements-1 constant bits(16) element1 = Elem[operand1, 2 * e + sel, 16]; constant bits(32) addend = Elem[operand3, e, 32]; Elem[result, e, 32] = BFMulAddH(addend, element1, element2, FPCR); V[d, 128] = result;
```

## C7.2.19 BFMLALB, BFMLALT (vector)

BFloat16 multiply-add to single-precision (vector)

This instruction widens the even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first and second source vectors from Bfloat16 to single-precision format. The instruction then multiplies and adds these values without intermediate rounding to the single-precision elements of the destination vector that overlap with the corresponding BFloat16 elements in the source vectors.

ID\_AA64ISAR1\_EL1.BF16 indicates whether this instruction is supported.

## Vector

(FEAT\_BF16)

<!-- image -->

## Encoding

```
BFMLAL<bt> <Vd>.4S, <Vn>.8H, <Vm>.8H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_BF16) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer elements = 128 DIV 32; constant integer sel = UInt(Q);
```

## Assembler Symbols

&lt;bt&gt;

Is the bottom or top element specifier, encoded in 'Q':

|   Q | <bt>   |
|-----|--------|
|   0 | B      |
|   1 | T      |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

```
EndOfDecode(Decode_UNDEF);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[n, 128]; constant bits(128) operand2 = V[m, 128]; constant bits(128) operand3 = V[d, 128]; bits(128) result; for e = 0 to elements-1 constant bits(16) element1 = Elem[operand1, 2 * e + sel, 16]; constant bits(16) element2 = Elem[operand2, 2 * e + sel, 16]; constant bits(32) addend = Elem[operand3, e, 32]; Elem[result, e, 32] = BFMulAddH(addend, element1, element2, FPCR); V[d, 128] = result;
```

## C7.2.20 BFMMLA (widening)

BFloat16 matrix multiply-accumulate to single-precision

If FEAT\_EBF16 is not implemented or FPCR.EBF is 0, this instruction:

- Performs two unfused sums-of-products within each two pairs of adjacent BFloat16 elements while multiplying the 2x4 matrix of BFloat16 values in the first source vector with the 4x2 matrix of BFloat16 values in the second source vector. The intermediate single-precision products are rounded before they are summed and the intermediate sum is rounded before accumulation into the 2x2 single-precision matrix in the destination vector. This is equivalent to accumulating two 2-way unfused dot products per destination element.
- Uses the non-IEEE 754 Round-to-Odd rounding mode, which forces bit 0 of an inexact result to 1, and rounds an overflow to an appropriately signed Infinity.
- Flushes denormalized inputs and results to zero, as if FPCR.{FZ, FIZ} is {1, 1}.
- Honors FPCR.AH when generating a default NaN result, otherwise disables alternative floating point behaviors, as if FPCR.AH is 0.

If FEAT\_EBF16 is implemented and FPCR.EBF is 1, then this instruction:

- Performs two fused sums-of-products within each two pairs of adjacent BFloat16 elements while multiplying the 2x4 matrix of BFloat16 values in the first source vector with the 4x2 matrix of BFloat16 values in the second source vector. The intermediate single-precision products are not rounded before they are summed, but the intermediate sum is rounded before accumulation into the 2x2 single-precision matrix in the destination vector. This is equivalent to accumulating two 2-way fused dot products per destination element.
- Follows all other floating-point behaviors that apply to single-precision arithmetic, as governed by FPCR.RMode, FPCR.FZ, FPCR.AH, and FPCR.FIZ.

Irrespective of FEAT\_EBF16 and FPCR.EBF, this instruction:

- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.
- Generates only the default NaN, as if FPCR.DN is 1.

ID\_AA64ISAR1\_EL1.BF16 indicates whether this instruction is supported.

```
Advanced SIMD (FEAT_BF16)
```

<!-- image -->

## Encoding

```
BFMMLA <Vd>.4S, <Vn>.8H, <Vm>.8H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_BF16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP third source and destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) op1 = V[n, 128]; constant bits(128) op2 = V[m, 128]; constant bits(128) acc = V[d, 128]; V[d, 128] = BFMatMulAddH(acc, op1, op2, FPCR);
```

## Operational Information

Arm expects that the BFMMLA instruction will deliver a peak BFloat16 multiply throughput that is at least as high as can be achieved using two BFDOT (vector) instructions, with a goal that it should have significantly higher throughput.

## C7.2.21 BIC (vector, immediate)

Bitwise bit clear (vector, immediate)

This instruction reads each vector element from the destination SIMD&amp;FP register, performs a bitwise AND between each result and the complement of an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Shifted immediate

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 16-bit variant

Applies when (cmode == 10x1) BIC &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}

## Encoding for the 32-bit variant

Applies when (cmode ==

```
0xx1) BIC <Vd>.<T>, #<imm8>{, LSL #<amount>}
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer rd = UInt(Rd); constant integer datasize = 64 << UInt(Q); constant bits(64) imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h); constant bits(datasize) imm = Replicate(imm64, datasize DIV 64);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP register, encoded in the 'Rd' field.

For the '16-bit' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |

<!-- image -->

&lt;T&gt;

## &lt;imm8&gt;

Is an 8-bit immediate encoded in 'a:b:c:d:e:f:g:h'.

## &lt;amount&gt;

For the '16-bit' variant: is the shift amount encoded in 'cmode&lt;1&gt;':

|   cmode<1> |   <amount> |
|------------|------------|
|          0 |          0 |
|          1 |          8 |

defaulting to 0 if LSL is omitted.

For the '32-bit' variant: is the shift amount encoded in 'cmode&lt;2:1&gt;':

|   cmode<2:1> |   <amount> |
|--------------|------------|
|           00 |          0 |
|           01 |          8 |
|           10 |         16 |
|           11 |         24 |

defaulting to 0 if LSL is omitted.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[rd, datasize]; V[rd, datasize] = operand AND NOT(imm);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| 1   | 8H   |
|-----|------|

For the '32-bit' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 2S    |
|   1 | 4S    |

## C7.2.22 BIC (vector, register)

Bitwise bit clear (vector, register)

This instruction performs a bitwise AND between the first source SIMD&amp;FP register and the complement of the second source SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
BIC <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;T&gt;

## &lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[d, datasize] = operand1 AND operand2;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
NOT(V[m, datasize]);
```

## C7.2.23 BIF

Bitwise insert if false

This instruction inserts each bit from the first source SIMD&amp;FP register into the destination SIMD&amp;FP register if the corresponding bit of the second source SIMD&amp;FP register is 0, otherwise leaves the bit in the destination register unchanged.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
BIF <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;T&gt;

&lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[d, datasize]; constant bits(datasize) operand2 = NOT(V[m, datasize]); constant bits(datasize) operand3 = V[n, datasize]; V[d, datasize] = operand1 EOR ((operand1 EOR operand3)
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
AND operand2);
```

## C7.2.24 BIT

Bitwise insert if true

This instruction inserts each bit from the first source SIMD&amp;FP register into the SIMD&amp;FP destination register if the corresponding bit of the second source SIMD&amp;FP register is 1, otherwise leaves the bit in the destination register unchanged.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
BIT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;T&gt;

&lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[d, datasize]; constant bits(datasize) operand2 = V[m, datasize]; constant bits(datasize) operand3 = V[n, datasize]; V[d, datasize] = operand1 EOR ((operand1 EOR operand3)
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
AND operand2);
```

## C7.2.25 BSL

Bitwise select

This instruction sets each bit in the destination SIMD&amp;FP register to the corresponding bit from the first source SIMD&amp;FP register when the original destination bit was 1, otherwise from the second source SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
BSL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q);
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;T&gt;

## &lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[m, datasize]; constant bits(datasize) operand2 = V[d, datasize]; constant bits(datasize) operand3 = V[n, datasize]; V[d, datasize] = operand1 EOR ((operand1 EOR operand3)
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
AND operand2);
```

## C7.2.26 CLS (vector)

Count leading sign bits (vector)

This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The count does not include the most significant bit itself.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CLS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

<!-- image -->

&lt;Vn&gt;

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; for e = 0 to elements-1 constant integer count = CountLeadingSignBits(Elem[operand, e, esize]); Elem[result, e, esize] = count<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.27 CLZ (vector)

Count leading zero bits (vector)

This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CLZ <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

<!-- image -->

&lt;Vn&gt;

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; for e = 0 to elements-1 constant integer count = CountLeadingZeroBits(Elem[operand, e, esize]); Elem[result, e, esize] = count<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.28 CMEQ (register)

Compare bitwise equal (vector)

This instruction compares each vector element from the first source SIMD&amp;FP register with the corresponding vector element from the second source SIMD&amp;FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMEQ D<d>, D<n>, D<m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMEQ <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = if element1 == element2 then Ones(esize) else Zeros(esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

## C7.2.29 CMEQ (zero)

Compare bitwise equal to zero (vector)

This instruction reads each vector element in the source SIMD&amp;FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMEQ D<d>, D<n>, #0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMEQ <Vd>.<T>, <Vn>.<T>, #0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Vd&gt; Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;T&gt;

&lt;Vn&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 element = SInt(Elem[operand, e, esize]); Elem[result, e, esize] = if element == 0 then Ones(esize) else Zeros(esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.30 CMGE (register)

Compare signed greater than or equal (vector)

This instruction compares each vector element in the first source SIMD&amp;FP register with the corresponding vector element in the second source SIMD&amp;FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMGE D<d>, D<n>,
```

```
D<m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMGE
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = bits(datasize) result; integer element1;
```

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

```
V[n, datasize]; V[m, datasize];
```

```
integer element2; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); Elem[result, e, esize] = if element1 >= element2 then Ones(esize) else Zeros(esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.31 CMGE (zero)

Compare signed greater than or equal to zero (vector)

This instruction reads each vector element in the source SIMD&amp;FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMGE D<d>, D<n>, #0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMGE <Vd>.<T>, <Vn>.<T>, #0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Vd&gt; Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;T&gt;

&lt;Vn&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 element = SInt(Elem[operand, e, esize]); Elem[result, e, esize] = if element >= 0 then Ones(esize) else Zeros(esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.32 CMGT (register)

Compare signed greater than (vector)

This instruction compares each vector element in the first source SIMD&amp;FP register with the corresponding vector element in the second source SIMD&amp;FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMGT D<d>, D<n>,
```

```
D<m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMGT
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = bits(datasize) result; integer element1;
```

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

```
V[n, datasize]; V[m, datasize];
```

```
integer element2; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); Elem[result, e, esize] = if element1 > element2 then Ones(esize) else Zeros(esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.33 CMGT (zero)

Compare signed greater than zero (vector)

This instruction reads each vector element in the source SIMD&amp;FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMGT D<d>, D<n>, #0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMGT <Vd>.<T>, <Vn>.<T>, #0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Vd&gt; Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;T&gt;

&lt;Vn&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 element = SInt(Elem[operand, e, esize]); Elem[result, e, esize] = if element > 0 then Ones(esize) else Zeros(esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.34 CMHI (register)

Compare unsigned higher (vector)

This instruction compares each vector element in the first source SIMD&amp;FP register with the corresponding vector element in the second source SIMD&amp;FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMHI D<d>, D<n>, D<m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMHI
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = bits(datasize) result; integer element1;
```

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

```
V[n, datasize]; V[m, datasize];
```

```
integer element2; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); Elem[result, e, esize] = if element1 > element2 then Ones(esize) else Zeros(esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.35 CMHS (register)

Compare unsigned higher or same (vector)

This instruction compares each vector element in the first source SIMD&amp;FP register with the corresponding vector element in the second source SIMD&amp;FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMHS D<d>, D<n>, D<m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMHS
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1;
```

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

```
integer element2; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); Elem[result, e, esize] = if element1 >= element2 then Ones(esize) else Zeros(esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.36 CMLE (zero)

Compare signed less than or equal to zero (vector)

This instruction reads each vector element in the source SIMD&amp;FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMLE D<d>, D<n>, #0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMLE <Vd>.<T>, <Vn>.<T>, #0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Vd&gt; Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;T&gt;

&lt;Vn&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 element = SInt(Elem[operand, e, esize]); Elem[result, e, esize] = if element <= 0 then Ones(esize) else Zeros(esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.37 CMLT (zero)

Compare signed less than zero (vector)

This instruction reads each vector element in the source SIMD&amp;FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMLT D<d>, D<n>, #0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMLT <Vd>.<T>, <Vn>.<T>, #0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Vd&gt; Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;T&gt;

&lt;Vn&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 element = SInt(Elem[operand, e, esize]); Elem[result, e, esize] = if element < 0 then Ones(esize) else Zeros(esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.38 CMTST

Compare bitwise test bits nonzero (vector)

This instruction reads each vector element in the first source SIMD&amp;FP register, performs an AND with the corresponding vector element in the second source SIMD&amp;FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMTST D<d>, D<n>, D<m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CMTST <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = if !IsZero(element1 AND element2) then Ones(esize) else Zeros(esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

## C7.2.39 CNT

Population count per byte

This instruction counts the number of bits that have a value of one in each vector element in the source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
CNT <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size != '00' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV 8;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

| size   | Q   | <T>      |
|--------|-----|----------|
| 00     | 0   | 8B       |
| 00     | 1   | 16B      |
| 01     | x   | RESERVED |
| 1x     | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; for e = 0 to elements-1 constant integer count = Elem[result, e, esize] = count<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
BitCount(Elem[operand, e, esize]);
```

## C7.2.40 DUP (element)

Duplicate vector element to vector or scalar

This instruction duplicates the vector element at the specified element index in the source SIMD&amp;FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This instruction is used by the alias MOV (scalar).

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
DUP <V><d>, <Vn>.<T>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if imm5 == 'x0000' then EndOfDecode(Decode_UNDEF); constant integer size = LowestSetBitNZ(imm5<3:0>); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer index = UInt(imm5<4:size+1>); constant integer idxdsize = 64 << UInt(imm5<4>); constant integer esize = 8 << size; constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
DUP <Vd>.<T>, <Vn>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if imm5 == 'x0000' then EndOfDecode(Decode_UNDEF); if imm5 == 'x1000' && Q == '0' then EndOfDecode(Decode_UNDEF); constant integer size = LowestSetBitNZ(imm5<3:0>); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer index = UInt(imm5<4:size+1>); constant integer idxdsize = 64 << UInt(imm5<4>); constant integer esize = 8 << size; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;V&gt;

Is the destination width specifier, encoded in 'imm5':

| imm5   | <V>      |
|--------|----------|
| x0000  | RESERVED |
| xxxx1  | B        |
| xxx10  | H        |
| xx100  | S        |
| x1000  | D        |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

For the 'Scalar' variant: is the element width specifier, encoded in 'imm5':

| imm5   | <T>      |
|--------|----------|
| x0000  | RESERVED |
| xxxx1  | B        |
| xxx10  | H        |
| xx100  | S        |
| x1000  | D        |

For the 'Vector' variant: is an arrangement specifier, encoded in 'imm5:Q':

&lt;d&gt;

&lt;Vn&gt;

&lt;T&gt;

## &lt;index&gt;

Is the element index encoded in 'imm5':

## &lt;Vd&gt;

## &lt;Ts&gt;

| imm5   | Q   | <T>      |
|--------|-----|----------|
| x0000  | x   | RESERVED |
| xxxx1  | 0   | 8B       |
| xxxx1  | 1   | 16B      |
| xxx10  | 0   | 4H       |
| xxx10  | 1   | 8H       |
| xx100  | 0   | 2S       |
| xx100  | 1   | 4S       |
| x1000  | 0   | RESERVED |
| x1000  | 1   | 2D       |

| imm5   | <index>         |
|--------|-----------------|
| x0000  | RESERVED        |
| xxxx1  | UInt(imm5<4:1>) |
| xxx10  | UInt(imm5<4:2>) |
| xx100  | UInt(imm5<4:3>) |
| x1000  | UInt(imm5<4>)   |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an element size specifier, encoded in 'imm5':

Alias Conditions

| imm5   | <Ts>     |
|--------|----------|
| x0000  | RESERVED |
| xxxx1  | B        |
| xxx10  | H        |
| xx100  | S        |
| x1000  | D        |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(idxdsize) operand = bits(datasize) result; bits(esize) element; element = Elem[operand, index, esize]; for e = 0 to elements-1 Elem[result, e, esize] = element; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
V[n, idxdsize];
```

| Alias        | Is preferred when   |
|--------------|---------------------|
| MOV (scalar) | Unconditionally     |

## C7.2.41 DUP (general)

Duplicate general-purpose register to vector

This instruction duplicates the contents of the source general-purpose register into a scalar or each element in a vector, and writes the result to the SIMD&amp;FP destination register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
DUP <Vd>.<T>, <R><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if imm5 == 'x0000' then EndOfDecode(Decode_UNDEF); if imm5 == 'x1000' && Q == '0' then EndOfDecode(Decode_UNDEF); constant integer size = LowestSetBitNZ(imm5<3:0>); constant integer d = UInt(Rd); constant integer n = UInt(Rn); // imm5<4:size+1> is IGNORED constant integer esize = 8 << size; constant integer datasize = 64 << UInt(Q);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'imm5:Q':

| imm5   | Q   | <T>      |
|--------|-----|----------|
| x0000  | x   | RESERVED |
| xxxx1  | 0   | 8B       |
| xxxx1  | 1   | 16B      |
| xxx10  | 0   | 4H       |
| xxx10  | 1   | 8H       |
| xx100  | 0   | 2S       |
| xx100  | 1   | 4S       |

<!-- image -->

&lt;T&gt;

<!-- image -->

&lt;R&gt;

<!-- image -->

Is the number [0-30] of the general-purpose source register or ZR (31), encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(esize) element = X[n, esize]; constant integer elements = datasize bits(datasize) result; for e = 0 to elements-1 Elem[result, e, esize] = element; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| imm5   |   Q | <T>      |
|--------|-----|----------|
| x1000  |   0 | RESERVED |
| x1000  |   1 | 2D       |

Is the width specifier for the general-purpose source register, encoded in 'imm5':

| imm5   | <R>      |
|--------|----------|
| x0000  | RESERVED |
| xxxx1  | W        |
| xxx10  | W        |
| xx100  | W        |
| x1000  | X        |

Unspecified bits in 'imm5' are ignored but should be set to zero by an assembler.

```
DIV esize;
```

## C7.2.42 EOR3

Three-way exclusive-OR

This instruction performs a three-way exclusive-OR of the values in the three source SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP register.

## Advanced SIMD

(FEAT\_SHA3)

<!-- image -->

## Encoding

```
EOR3 <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA3) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer a = UInt(Ra);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

```
EndOfDecode(Decode_UNDEF);
```

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Va&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Ra' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[m, 128]; constant bits(128) operand2 = V[n, 128]; constant bits(128) operand3 = V[a, 128]; V[d, 128] = operand2 EOR operand1 EOR operand3;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

Op0

## C7.2.43 EOR (vector)

Bitwise exclusive-OR (vector)

This instruction performs a bitwise exclusive-OR operation between the two source SIMD&amp;FP registers, and places the result in the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
EOR <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q);
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;T&gt;

## &lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[m, datasize]; constant bits(datasize) operand2 = Zeros(datasize); constant bits(datasize) operand3 = Ones(datasize); constant bits(datasize) operand4 = V[n, datasize]; V[d, datasize] = operand1 EOR ((operand2 EOR operand4) AND operand3);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.44 EXT

Extract vector from pair of vectors

This instruction extracts the lowest vector elements from the second source SIMD&amp;FP register and the highest vector elements from the first source SIMD&amp;FP register, concatenates the results into a vector, and writes the vector to the destination SIMD&amp;FP register vector. The index value specifies the lowest vector element to extract from the first source register, and consecutive elements are extracted from the first, then second, source registers until the destination vector is filled.

Figure C7-1 EXT doubleword operation for Q = 0 and imm4&lt;2:0&gt; = 3

<!-- image -->

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
EXT
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<index>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if Q == '0' && imm4<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q); constant integer position = 8 * UInt(imm4);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;T&gt;

## &lt;Vn&gt;

Is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;index&gt;

Is the lowest numbered byte element to be extracted, encoded in 'Q:imm4':

|   Q | imm4<3>   | <index>         |
|-----|-----------|-----------------|
|   0 | 0         | UInt(imm4<2:0>) |
|   0 | 1         | RESERVED        |
|   1 | x         | UInt(imm4)      |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) hi = V[m, datasize]; constant bits(datasize) lo = V[n, datasize]; constant bits(datasize*2) concat = hi : lo; V[d, datasize] = concat<(position+datasize)-1:position>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.45 F1CVTL, F1CVTL2, F2CVTL, F2CVTL2

8-bit floating-point convert to half-precision (vector)

This instruction converts each 8-bit floating-point element from the lower or upper half of the source vector to half-precision while downscaling the value, and places the results in the 16-bit elements of the destination vector. F1CVTL and F2CVTL convert the elements from the lower half of the source vector while scaling the values by 2 -UInt(FPMR.LSCALE[3:0]) and 2 -UInt(FPMR.LSCALE2[3:0]) , respectively. F1CVTL2 and F2CVTL2 convert the elements from the upper half of the source vector while scaling the values by 2 -UInt(FPMR.LSCALE[3:0]) and 2 -UInt(FPMR.LSCALE2[3:0]) , respectively.

The 8-bit floating-point encoding format for F1CVTL and F1CVTL2 is selected by FPMR.F8S1. The 8-bit floating-point encoding format for F2CVTL and F2CVTL2 is selected by FPMR.F8S2.

## Advanced SIMD

(FEAT\_FP8)

<!-- image -->

## Encoding for the F1CVTL{2} variant

```
Applies when (size == 00) F1CVTL{2} <Vd>.8H,
```

```
<Vn>.<Ta>
```

## Encoding for the F2CVTL{2} variant

```
Applies when (size == 01) F2CVTL{2} <Vd>.8H,
```

```
<Vn>.<Ta>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP8) then EndOfDecode(Decode_UNDEF);
```

```
constant integer n = UInt(Rn); constant integer d = UInt(Rd); constant integer part = UInt(Q); constant integer elements = 64 DIV 8; constant boolean issrc2 = size == '01';
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Vn&gt;

&lt;Ta&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(64) operand = Vpart[n, part, 64]; bits(128) result; for e = 0 to elements-1 Elem[result, e, 16] = FP8ConvertFP(Elem[operand, e, 8], V[d, 128] = result;
```

|   Q | <Ta>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

```
issrc2, FPCR, FPMR);
```

## C7.2.46 FABD

Floating-point absolute difference (vector)

This instruction subtracts the floating-point values in the elements of the second source SIMD&amp;FP register, from the corresponding floating-point values in the elements of the first source SIMD&amp;FP register, places the absolute value of each result in a vector, and writes the vector to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FABD <Hd>, <Hn>, <Hm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FABD <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

- &lt;V&gt;

Is a width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

- &lt;d&gt; Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.
- &lt;n&gt;

&lt;m&gt;

- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz | Q <T>   |
|------|---------|
|    0 | 0 2S    |

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(esize) element1; bits(esize) element2; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[n, 128] else Zeros(128); for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; constant bits(esize) diff = FPSub(element1, element2, Elem[result, e, esize] = FPAbs(diff, FPCR); V[d, 128] = result;
```

```
FPCR);
```

## C7.2.47 FABS (vector)

Floating-point absolute value (vector)

This instruction calculates the absolute value of each vector element in the source SIMD&amp;FP register, writes the result to a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FABS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FABS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; for e = 0 to elements-1 constant bits(esize) element = Elem[operand, e, esize]; Elem[result, e, esize] = FPAbs(element, FPCR); V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

## C7.2.48 FABS (scalar)

Floating-point absolute value (scalar)

This instruction calculates the absolute value in the SIMD&amp;FP source register and writes the result to the SIMD&amp;FP destination register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

(FEAT\_FP16) Applies when (ftype == 11)

```
FABS <Hd>, <Hn>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FABS <Sd>, <Sn>
```

## Encoding for the Double-precision variant

(FEAT\_FP) Applies when (ftype == 01)

```
FABS <Dd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

## &lt;Sd&gt;

<!-- image -->

## &lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPAbs(operand, FPCR); V[d, 128] = result;
```

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.49 FACGE

Floating-point absolute compare greater than or equal (vector)

This instruction compares the absolute value of each floating-point value in the first source SIMD&amp;FP register with the absolute value of the corresponding floating-point value in the second source SIMD&amp;FP register and if the first value is greater than or equal to the second value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FACGE <Hd>, <Hn>, <Hm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FACGE <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FACGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FACGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;V&gt;

- &lt;d&gt;
- &lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |

Is a width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(esize) element1; bits(esize) element2; boolean test_passed; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[m, 128] else Zeros(128); for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; element1 = FPAbs(element1, FPCR); element2 = FPAbs(element2, FPCR); test_passed = FPCompareGE(element1, element2, FPCR); Elem[result, e, esize] = if test_passed then Ones(esize) else Zeros(esize); V[d, 128] = result;
```

## C7.2.50 FACGT

Floating-point absolute compare greater than (vector)

This instruction compares the absolute value of each vector element in the first source SIMD&amp;FP register with the absolute value of the corresponding vector element in the second source SIMD&amp;FP register and if the first value is greater than the second value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FACGT <Hd>, <Hn>, <Hm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FACGT <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FACGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FACGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;V&gt;

- &lt;d&gt;
- &lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |

Is a width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(esize) element1; bits(esize) element2; boolean test_passed; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[m, 128] else Zeros(128); for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; element1 = FPAbs(element1, FPCR); element2 = FPAbs(element2, FPCR); test_passed = FPCompareGT(element1, element2, FPCR); Elem[result, e, esize] = if test_passed then Ones(esize) else Zeros(esize); V[d, 128] = result;
```

## C7.2.51 FADD (vector)

Floating-point add (vector)

This instruction adds corresponding vector elements in the two source SIMD&amp;FP registers, writes the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FADD
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FADD
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = FPAdd(element1, element2,
```

&lt;T&gt;

&lt;Vn&gt;

```
FPCR);
```

V[d, datasize] = result;

## C7.2.52 FADD (scalar)

Floating-point add (scalar)

This instruction adds the floating-point values of the two source SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

(FEAT\_FP16) Applies when (ftype == 11)

```
FADD <Hd>, <Hn>, <Hm>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FADD <Sd>, <Sn>, <Sm>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FADD <Dd>, <Dn>, <Dm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Sd&gt;

&lt;Sn&gt;

Is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand1 = V[n, esize]; constant bits(esize) operand2 = V[m, esize]; bits(128) result = if IsMerging(FPCR) then V[n, 128] else Zeros(128); Elem[result, 0, esize] = FPAdd(operand1, operand2, FPCR); V[d, 128] = result;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.53 FADDP (scalar)

Floating-point add pair of elements (scalar)

This instruction adds two floating-point vector elements in the source SIMD&amp;FP register and writes the scalar result into the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FADDP H<d>, <Vn>.2H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 32;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FADDP <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize * 2;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the destination width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

&lt;Vn&gt;

&lt;V&gt;

&lt;T&gt;

Is the source arrangement specifier, encoded in 'sz':

|   sz | <T>   |
|------|-------|
|    0 | 2S    |
|    1 | 2D    |

```
esize]; esize];
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant bits(esize) element1 = Elem[operand, 0, constant bits(esize) element2 = Elem[operand, 1, V[d, esize] = FPAdd(element1, element2, FPCR);
```

## C7.2.54 FADDP (vector)

Floating-point add pairwise (vector)

This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FADDP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FADDP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; constant bits(2*datasize) concat = operand2:operand1; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[concat, 2*e, esize]; element2 = Elem[concat, (2*e)+1, esize];
```

&lt;T&gt;

&lt;Vn&gt;

```
Elem[result, e, esize] = FPAdd(element1, element2, FPCR); V[d, datasize] = result;
```

## C7.2.55 FAMAX

Floating-point absolute maximum

This instruction determines the maximum absolute value from floating-point elements of the first source vector and the corresponding floating-point elements of the second source vector, and places the results in the corresponding elements of the destination vector.

Regardless of the value of FPCR.AH, the behavior is as follows:

- When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a NaN, the result is the Default NaN, with the sign bit set to 0.
- Denormalized inputs and results are never flushed to zero, as if FPCR.{FZ, FZ16, FIZ} are all 0.
- Denormalized inputs never generate an Input Denormal floating-point exception.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FAMINMAX)

<!-- image -->

## Encoding

```
FAMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FAMINMAX) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = if Q == '1' then 128 else 64; constant integer elements = datasize DIV esize;
```

Single-precision and double-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FAMINMAX)

<!-- image -->

## Encoding

```
FAMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FAMINMAX) then EndOfDecode(Decode_UNDEF); if Q == '0' && size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = if Q == '1' then 128 else 64; constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'size&lt;0&gt;:Q':

|   size<0> |   Q | <T>      |
|-----------|-----|----------|
|         0 |   0 | 2S       |
|         0 |   1 | 4S       |
|         1 |   0 | RESERVED |
|         1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; for e = 0 to elements-1 constant bits(esize) op1 = Elem[operand1, e, esize]; constant bits(esize) op2 = Elem[operand2, e, esize]; Elem[result, e, esize] = FPAbsMax(op1, op2, FPCR); V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

## C7.2.56 FAMIN

Floating-point absolute minimum

This instruction determines the minimum absolute value from floating-point elements of the first source vector and the corresponding floating-point elements of the second source vector, and places the results in the corresponding elements of the destination vector.

Regardless of the value of FPCR.AH, the behavior is as follows:

- When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a NaN, the result is the Default NaN, with the sign bit set to 0.
- Denormalized inputs and results are never flushed to zero, as if FPCR.{FZ, FZ16, FIZ} are all 0.
- Denormalized inputs never generate an Input Denormal floating-point exception.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FAMINMAX)

<!-- image -->

## Encoding

```
FAMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FAMINMAX) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = if Q == '1' then 128 else 64; constant integer elements = datasize DIV esize;
```

Single-precision and double-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FAMINMAX)

<!-- image -->

## Encoding

```
FAMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FAMINMAX) then EndOfDecode(Decode_UNDEF); if Q == '0' && size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = if Q == '1' then 128 else 64; constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'size&lt;0&gt;:Q':

|   size<0> |   Q | <T>      |
|-----------|-----|----------|
|         0 |   0 | 2S       |
|         0 |   1 | 4S       |
|         1 |   0 | RESERVED |
|         1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; for e = 0 to elements-1 constant bits(esize) op1 = Elem[operand1, e, esize]; constant bits(esize) op2 = Elem[operand2, e, esize]; Elem[result, e, esize] = FPAbsMin(op1, op2, FPCR); V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

## C7.2.57 FCADD

Floating-point complex add

This instruction operates on complex numbers that are represented in SIMD&amp;FP registers as pairs of elements, with the more significant element holding the imaginary part of the number and the less significant element holding the real part of the number. Each element holds a floating-point value. It performs the following computation on the corresponding complex number element pairs from the two source registers:

- Considering the complex number from the second source register on an Argand diagram, the number is rotated counterclockwise by 90 or 270 degrees.
- The rotated complex number is added to the complex number from the first source register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_FCMA)

<!-- image -->

## Encoding

```
FCADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FCMA) then EndOfDecode(Decode_UNDEF); if size == '00' then EndOfDecode(Decode_UNDEF); if size == '01' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); if Q == '0' && size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

<!-- image -->

## &lt;Vn&gt;

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | 0   | RESERVED |
|     11 | 1   | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;rotate&gt;

Is the rotation, encoded in 'rot':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element3; for e = 0 to (elements DIV 2)-1 case rot of when '0' element1 = FPNeg(Elem[operand2, e*2+1, esize], FPCR); element3 = Elem[operand2, e*2, esize]; when '1' element1 = Elem[operand2, e*2+1, esize]; element3 = FPNeg(Elem[operand2, e*2, esize], FPCR); Elem[result, e*2, esize] = FPAdd(Elem[operand1, e*2, esize], element1, FPCR); Elem[result, e*2+1, esize] = FPAdd(Elem[operand1, e*2+1, esize], element3, FPCR); V[d, datasize] = result;
```

|   rot |   <rotate> |
|-------|------------|
|     0 |         90 |
|     1 |        270 |

## C7.2.58 FCCMP

Floating-point conditional quiet compare (scalar)

This instruction compares the two SIMD&amp;FP source register values and writes the result to the PSTATE.{N, Z, C, V} flags. If the condition does not pass, then the PSTATE.{N, Z, C, V} flags are set to the flag bit specifier.

This instruction raises an Invalid Operation floating-point exception if either or both of the operands is a signaling NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype
```

```
FCCMP <Hn>, <Hm>, #<nzcv>,
```

```
== 11) <cond>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when
```

```
(ftype == 00)
```

```
FCCMP <Sn>, <Sm>, #<nzcv>, <cond>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FCCMP <Dn>, <Dm>, #<nzcv>, <cond>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 8 << UInt(ftype EOR '10'); constant bits(4) condition = cond; bits(4) flags = nzcv;
```

## Assembler Symbols

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;nzcv&gt;

Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the 'nzcv' field.

## &lt;cond&gt;

Is one of the standard conditions, encoded in the standard way, and encoded in 'cond':

|   cond | <cond>   |
|--------|----------|
|   0000 | EQ       |
|   0001 | NE       |
|   0010 | CS       |
|   0011 | CC       |
|   0100 | MI       |
|   0101 | PL       |
|   0110 | VS       |
|   0111 | VC       |
|   1000 | HI       |
|   1001 | LS       |
|   1010 | GE       |
|   1011 | LT       |
|   1100 | GT       |
|   1101 | LE       |
|   1110 | AL       |
|   1111 | NV       |

Is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; if ConditionHolds(condition) then constant boolean signal_all_nans = FALSE; flags = FPCompare(operand1, operand2, signal_all_nans,
```

## &lt;Sn&gt;

```
FPCR);
```

PSTATE.&lt;N,Z,C,V&gt; = flags;

## Operational Information

The IEEE 754 standard specifies that the result of a comparison is precisely one of &lt;, ==, &gt; or unordered. If either or both of the operands is a NaN, they are unordered, and all three of (Operand1 &lt; Operand2), (Operand1 == Operand2) and (Operand1 &gt; Operand2) are false. An unordered comparison sets the PSTATE condition flags to N=0, Z=0, C=1, and V=1.

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the NZCV condition flags written by this instruction might be significantly delayed.

## C7.2.59 FCCMPE

Floating-point conditional signaling compare (scalar)

This instruction compares the two SIMD&amp;FP source register values and writes the result to the PSTATE.{N, Z, C, V} flags. If the condition does not pass, then the PSTATE.{N, Z, C, V} flags are set to the flag bit specifier.

This instruction raises an Invalid Operation floating-point exception if either or both of the operands is any type of NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11)
```

```
FCCMPE <Hn>, <Hm>, #<nzcv>, <cond>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00) FCCMPE <Sn>, <Sm>, #<nzcv>, <cond>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FCCMPE <Dn>, <Dm>, #<nzcv>, <cond>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 8 << UInt(ftype EOR '10'); constant bits(4) condition = cond; bits(4) flags = nzcv;
```

## Assembler Symbols

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;nzcv&gt;

Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the 'nzcv' field.

## &lt;cond&gt;

Is one of the standard conditions, encoded in the standard way, and encoded in 'cond':

|   cond | <cond>   |
|--------|----------|
|   0000 | EQ       |
|   0001 | NE       |
|   0010 | CS       |
|   0011 | CC       |
|   0100 | MI       |
|   0101 | PL       |
|   0110 | VS       |
|   0111 | VC       |
|   1000 | HI       |
|   1001 | LS       |
|   1010 | GE       |
|   1011 | LT       |
|   1100 | GT       |
|   1101 | LE       |
|   1110 | AL       |
|   1111 | NV       |

Is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; if ConditionHolds(condition) then constant boolean signal_all_nans = TRUE; flags = FPCompare(operand1, operand2, signal_all_nans,
```

## &lt;Sn&gt;

```
FPCR);
```

PSTATE.&lt;N,Z,C,V&gt; = flags;

## Operational Information

The IEEE 754 standard specifies that the result of a comparison is precisely one of &lt;, ==, &gt; or unordered. If either or both of the operands is a NaN, they are unordered, and all three of (Operand1 &lt; Operand2), (Operand1 == Operand2) and (Operand1 &gt; Operand2) are false. An unordered comparison sets the PSTATE condition flags to N=0, Z=0, C=1, and V=1.

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the NZCV condition flags written by this instruction might be significantly delayed.

## C7.2.60 FCMEQ (register)

Floating-point compare equal (vector)

This instruction compares each floating-point value from the first source SIMD&amp;FP register, with the corresponding floating-point value from the second source SIMD&amp;FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMEQ <Hd>, <Hn>, <Hm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMEQ <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMEQ <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMEQ <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;V&gt;

- &lt;d&gt;
- &lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |

Is a width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(esize) element1; bits(esize) element2; boolean test_passed; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[m, 128] else Zeros(128); for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; test_passed = FPCompareEQ(element1, element2, FPCR); Elem[result, e, esize] = if test_passed then Ones(esize) else Zeros(esize); V[d, 128] = result;
```

## C7.2.61 FCMEQ (zero)

Floating-point compare equal to zero (vector)

This instruction reads each floating-point value in the source SIMD&amp;FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMEQ <Hd>, <Hn>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMEQ <V><d>, <V><n>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMEQ <Vd>.<T>, <Vn>.<T>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMEQ <Vd>.<T>, <Vn>.<T>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

&lt;V&gt;

- &lt;d&gt;

&lt;n&gt;

- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vn&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; constant bits(esize) zero = FPZero('0', esize); bits(esize) element; boolean test_passed; for e = 0 to elements-1 element = Elem[operand, e, esize]; test_passed = FPCompareEQ(element, zero, FPCR); Elem[result, e, esize] = if test_passed then Ones(esize) V[d, datasize] = result;
```

```
else Zeros(esize);
```

## C7.2.62 FCMGE (register)

Floating-point compare greater than or equal (vector)

This instruction reads each floating-point value in the first source SIMD&amp;FP register and if the value is greater than or equal to the corresponding floating-point value in the second source SIMD&amp;FP register sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMGE <Hd>, <Hn>, <Hm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMGE <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;V&gt;

- &lt;d&gt;
- &lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |

Is a width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(esize) element1; bits(esize) element2; boolean test_passed; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[m, 128] else Zeros(128); for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; test_passed = FPCompareGE(element1, element2, FPCR); Elem[result, e, esize] = if test_passed then Ones(esize) else Zeros(esize); V[d, 128] = result;
```

## C7.2.63 FCMGE (zero)

Floating-point compare greater than or equal to zero (vector)

This instruction reads each floating-point value in the source SIMD&amp;FP register and if the value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMGE <Hd>, <Hn>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMGE <V><d>, <V><n>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMGE <Vd>.<T>, <Vn>.<T>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMGE <Vd>.<T>, <Vn>.<T>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

&lt;V&gt;

- &lt;d&gt;

&lt;n&gt;

- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vn&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; constant bits(esize) zero = FPZero('0', esize); bits(esize) element; boolean test_passed; for e = 0 to elements-1 element = Elem[operand, e, esize]; test_passed = FPCompareGE(element, zero, FPCR); Elem[result, e, esize] = if test_passed then Ones(esize) V[d, datasize] = result;
```

```
else Zeros(esize);
```

## C7.2.64 FCMGT (register)

Floating-point compare greater than (vector)

This instruction reads each floating-point value in the first source SIMD&amp;FP register and if the value is greater than the corresponding floating-point value in the second source SIMD&amp;FP register sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMGT <Hd>, <Hn>, <Hm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMGT <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;V&gt;

- &lt;d&gt;
- &lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |

Is a width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(esize) element1; bits(esize) element2; boolean test_passed; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[m, 128] else Zeros(128); for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; test_passed = FPCompareGT(element1, element2, FPCR); Elem[result, e, esize] = if test_passed then Ones(esize) else Zeros(esize); V[d, 128] = result;
```

## C7.2.65 FCMGT (zero)

Floating-point compare greater than zero (vector)

This instruction reads each floating-point value in the source SIMD&amp;FP register and if the value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMGT <Hd>, <Hn>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMGT <V><d>, <V><n>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMGT <Vd>.<T>, <Vn>.<T>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMGT <Vd>.<T>, <Vn>.<T>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

&lt;V&gt;

&lt;Vn&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

- &lt;d&gt; Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; constant bits(esize) zero = FPZero('0', esize); bits(esize) element; boolean test_passed; for e = 0 to elements-1 element = Elem[operand, e, esize]; test_passed = FPCompareGT(element, zero, FPCR); Elem[result, e, esize] = if test_passed then Ones(esize) V[d, datasize] = result;
```

```
else Zeros(esize);
```

## C7.2.66 FCMLA (by element)

Floating-point complex multiply accumulate (by element)

This instruction operates on complex numbers that are represented in SIMD&amp;FP registers as pairs of elements, with the more significant element holding the imaginary part of the number and the less significant element holding the real part of the number. Each element holds a floating-point value. It performs the following computation on complex numbers from the first source register and the destination register with the specified complex number from the second source register:

- Considering the complex number from the second source register on an Argand diagram, the number is rotated counterclockwise by 0, 90, 180, or 270 degrees.
- The two elements of the transformed complex number are multiplied by:
- The real element of the complex number from the first source register, if the transformation was a rotation by 0 or 180 degrees.
- The imaginary element of the complex number from the first source register, if the transformation was a rotation by 90 or 270 degrees.
- The complex number resulting from that multiplication is added to the complex number from the destination register.

The multiplication and addition operations are performed as a fused multiply-add, without any intermediate rounding.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_FCMA)

<!-- image -->

## Encoding

```
FCMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FCMA) then EndOfDecode(Decode_UNDEF); if size == '00' || size == '11' then EndOfDecode(Decode_UNDEF); if !IsFeatureImplemented(FEAT_FP16) && size == '01' then EndOfDecode(Decode_UNDEF); if size == '10' && (L == '1' || Q == '0') then EndOfDecode(Decode_UNDEF); if size == '01' && H == '1' && Q == '0' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(M:Rm); integer index; if size == '01' then index = UInt(H:L); if size == '10' then index = UInt(H); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | RESERVED |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'M:Rm' fields.

## &lt;Ts&gt;

&lt;T&gt;

## &lt;Vn&gt;

Is an element size specifier, encoded in 'size':

## &lt;index&gt;

Is the element index, encoded in 'size:H:L':

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>   |
|--------|-----------|
|     00 | RESERVED  |
|     01 | UInt(H:L) |
|     10 | UInt(H)   |
|     11 | RESERVED  |

## &lt;rotate&gt;

Is the rotation, encoded in 'rot':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; for e = 0 to (elements DIV 2)-1 bits(esize) element1; bits(esize) element2; bits(esize) element3; bits(esize) element4; case rot of when '00' element1 = Elem[operand2, index*2, esize]; element2 = Elem[operand1, e*2, esize]; element3 = Elem[operand2, index*2+1, esize]; element4 = Elem[operand1, e*2, esize]; when '01' element1 = FPNeg(Elem[operand2, index*2+1, esize], FPCR); element2 = Elem[operand1, e*2+1, esize]; element3 = Elem[operand2, index*2, esize]; element4 = Elem[operand1, e*2+1, esize]; when '10' element1 = FPNeg(Elem[operand2, index*2, esize], FPCR); element2 = Elem[operand1, e*2, esize]; element3 = FPNeg(Elem[operand2, index*2+1, esize], FPCR); element4 = Elem[operand1, e*2, esize]; when '11' element1 = Elem[operand2, index*2+1, esize]; element2 = Elem[operand1, e*2+1, esize]; element3 = FPNeg(Elem[operand2, index*2, esize], FPCR); element4 = Elem[operand1, e*2+1, esize]; Elem[result, e*2, esize] = FPMulAdd(Elem[operand3, e*2, esize], element2, element1, FPCR); Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR); V[d, datasize] = result;
```

|   rot |   <rotate> |
|-------|------------|
|    00 |          0 |
|    01 |         90 |
|    10 |        180 |
|    11 |        270 |

## C7.2.67 FCMLA

Floating-point complex multiply accumulate

This instruction operates on complex numbers that are represented in SIMD&amp;FP registers as pairs of elements, with the more significant element holding the imaginary part of the number and the less significant element holding the real part of the number. Each element holds a floating-point value. It performs the following computation on the corresponding complex number element pairs from the two source registers and the destination register:

- Considering the complex number from the second source register on an Argand diagram, the number is rotated counterclockwise by 0, 90, 180, or 270 degrees.
- The two elements of the transformed complex number are multiplied by:
- The real element of the complex number from the first source register, if the transformation was a rotation by 0 or 180 degrees.
- The imaginary element of the complex number from the first source register, if the transformation was a rotation by 90 or 270 degrees.
- The complex number resulting from that multiplication is added to the complex number from the destination register.

The multiplication and addition operations are performed as a fused multiply-add, without any intermediate rounding.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_FCMA)

<!-- image -->

## Encoding

```
FCMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FCMA) then EndOfDecode(Decode_UNDEF); if size == '00' then EndOfDecode(Decode_UNDEF); if !IsFeatureImplemented(FEAT_FP16) && size == '01' then EndOfDecode(Decode_UNDEF); if Q == '0' && size == '11' then EndOfDecode(Decode_UNDEF); constant integer esize = 8 << UInt(size); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | 0   | RESERVED |
|     11 | 1   | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;rotate&gt;

Is the rotation, encoded in 'rot':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; bits(esize) element3; bits(esize) element4; for e = 0 to (elements DIV 2)-1 case rot of when '00'
```

&lt;T&gt;

## &lt;Vn&gt;

|   rot |   <rotate> |
|-------|------------|
|    00 |          0 |
|    01 |         90 |
|    10 |        180 |
|    11 |        270 |

```
element1 = Elem[operand2, e*2, esize]; element2 = Elem[operand1, e*2, esize]; element3 = Elem[operand2, e*2+1, esize]; element4 = Elem[operand1, e*2, esize]; when '01' element1 = FPNeg(Elem[operand2, e*2+1, esize], FPCR); element2 = Elem[operand1, e*2+1, esize]; element3 = Elem[operand2, e*2, esize]; element4 = Elem[operand1, e*2+1, esize]; when '10' element1 = FPNeg(Elem[operand2, e*2, esize], FPCR); element2 = Elem[operand1, e*2, esize]; element3 = FPNeg(Elem[operand2, e*2+1, esize], FPCR); element4 = Elem[operand1, e*2, esize]; when '11' element1 = Elem[operand2, e*2+1, esize]; element2 = Elem[operand1, e*2+1, esize]; element3 = FPNeg(Elem[operand2, e*2, esize], FPCR); element4 = Elem[operand1, e*2+1, esize]; Elem[result, e*2, esize] = FPMulAdd(Elem[operand3, e*2, esize], element2, element1, FPCR); Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR); V[d, datasize] = result;
```

## C7.2.68 FCMLE (zero)

Floating-point compare less than or equal to zero (vector)

This instruction reads each floating-point value in the source SIMD&amp;FP register and if the value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMLE <Hd>, <Hn>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMLE <V><d>, <V><n>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMLE <Vd>.<T>, <Vn>.<T>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMLE <Vd>.<T>, <Vn>.<T>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

&lt;V&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

- &lt;d&gt; Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

- &lt;Vd&gt;
- &lt;T&gt;

&lt;Vn&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; constant bits(esize) zero = FPZero('0', esize); bits(esize) element; boolean test_passed; for e = 0 to elements-1 element = Elem[operand, e, esize]; test_passed = FPCompareGE(zero, element, FPCR); Elem[result, e, esize] = if test_passed then Ones(esize) V[d, datasize] = result;
```

```
else Zeros(esize);
```

## C7.2.69 FCMLT (zero)

Floating-point compare less than zero (vector)

This instruction reads each floating-point value in the source SIMD&amp;FP register and if the value is less than zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMLT <Hd>, <Hn>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMLT <V><d>, <V><n>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCMLT <Vd>.<T>, <Vn>.<T>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCMLT <Vd>.<T>, <Vn>.<T>, #0.0
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

- &lt;V&gt;

&lt;Vn&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

- &lt;d&gt; Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; constant bits(esize) zero = FPZero('0', esize); bits(esize) element; boolean test_passed; for e = 0 to elements-1 element = Elem[operand, e, esize]; test_passed = FPCompareGT(zero, element, FPCR); Elem[result, e, esize] = if test_passed then Ones(esize) V[d, datasize] = result;
```

```
else Zeros(esize);
```

## C7.2.70 FCMP

Floating-point quiet compare (scalar)

This instruction compares the two SIMD&amp;FP source register values, or the first SIMD&amp;FP source register value and zero. It writes the result to the PSTATE.{N, Z, C, V} flags.

This instruction raises an Invalid Operation floating-point exception if either or both of the operands is a signaling NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11 && opc == 00)
```

```
FCMP <Hn>, <Hm>
```

## Encoding for the Half-precision, zero variant

```
(FEAT_FP16) Applies when (ftype == 11 && Rm == (00000) && opc == 01)
```

```
FCMP <Hn>, #0.0
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00 && opc == 00)
```

```
FCMP <Sn>, <Sm>
```

## Encoding for the Single-precision, zero variant

```
(FEAT_FP) Applies when (ftype == 00 && Rm == (00000) && opc == 01)
```

```
FCMP <Sn>, #0.0
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01 && opc == 00)
```

```
FCMP <Dn>, <Dm>
```

## Encoding for the Double-precision, zero variant

```
(FEAT_FP) Applies when (ftype == 01 && Rm == (00000) && opc == 01)
```

```
FCMP <Dn>, #0.0
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer m = UInt(Rm); // ignored when opc<0> == '1' constant integer datasize = 8 << UInt(ftype EOR '10'); constant boolean signal_all_nans = FALSE; constant boolean cmp_with_zero = (opc<0> == '1');
```

## Assembler Symbols

## &lt;Hn&gt;

For the 'Half-precision' variant: is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

For the 'Half-precision, zero' variant: is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

For the 'Single-precision' variant: is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

For the 'Single-precision, zero' variant: is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

For the 'Double-precision' variant: is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

For the 'Double-precision, zero' variant: is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = if cmp_with_zero then FPZero('0', datasize) else V[m, datasize]; PSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);
```

## &lt;Sn&gt;

## &lt;Dn&gt;

## Operational Information

The IEEE 754 standard specifies that the result of a comparison is precisely one of &lt;, ==, &gt; or unordered. If either or both of the operands is a NaN, they are unordered, and all three of (Operand1 &lt; Operand2), (Operand1 == Operand2) and (Operand1 &gt; Operand2) are false. An unordered comparison sets the PSTATE condition flags to N=0, Z=0, C=1, and V=1.

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the NZCV condition flags written by this instruction might be significantly delayed.

## C7.2.71 FCMPE

Floating-point signaling compare (scalar)

This instruction compares the two SIMD&amp;FP source register values, or the first SIMD&amp;FP source register value and zero. It writes the result to the PSTATE.{N, Z, C, V} flags.

This instruction raises an Invalid Operation floating-point exception if either or both of the operands is any type of NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11 && opc == 10)
```

```
FCMPE <Hn>, <Hm>
```

## Encoding for the Half-precision, zero variant

```
(FEAT_FP16) Applies when (ftype == 11 && Rm == (00000) && opc == 11)
```

```
FCMPE <Hn>, #0.0
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00 && opc == 10)
```

```
FCMPE <Sn>, <Sm>
```

## Encoding for the Single-precision, zero variant

```
(FEAT_FP) Applies when (ftype == 00 && Rm == (00000) && opc == 11)
```

```
FCMPE <Sn>, #0.0
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01 && opc == 10)
```

```
FCMPE <Dn>, <Dm>
```

## Encoding for the Double-precision, zero variant

```
(FEAT_FP) Applies when (ftype == 01 && Rm == (00000) && opc == 11)
```

```
FCMPE <Dn>, #0.0
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer m = UInt(Rm); // ignored when opc<0> == '1' constant integer datasize = 8 << UInt(ftype EOR '10'); constant boolean signal_all_nans = TRUE; constant boolean cmp_with_zero = (opc<0> == '1');
```

## Assembler Symbols

## &lt;Hn&gt;

For the 'Half-precision' variant: is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

For the 'Half-precision, zero' variant: is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

For the 'Single-precision' variant: is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

For the 'Single-precision, zero' variant: is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

For the 'Double-precision' variant: is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

For the 'Double-precision, zero' variant: is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = if cmp_with_zero then FPZero('0', datasize) else V[m, datasize]; PSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);
```

## &lt;Sn&gt;

## &lt;Dn&gt;

## Operational Information

The IEEE 754 standard specifies that the result of a comparison is precisely one of &lt;, ==, &gt; or unordered. If either or both of the operands is a NaN, they are unordered, and all three of (Operand1 &lt; Operand2), (Operand1 == Operand2) and (Operand1 &gt; Operand2) are false. An unordered comparison sets the PSTATE condition flags to N=0, Z=0, C=1, and V=1.

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the NZCV condition flags written by this instruction might be significantly delayed.

## C7.2.72 FCSEL

Floating-point conditional select (scalar)

This instruction allows the SIMD&amp;FP destination register to take the value from either one or the other of two SIMD&amp;FP source registers. If the condition passes, the first SIMD&amp;FP source register value is taken, otherwise the second SIMD&amp;FP source register value is taken.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype
```

```
FCSEL <Hd>, <Hn>, <Hm>,
```

```
== 11) <cond>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00) FCSEL <Sd>, <Sn>, <Sm>, <cond>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FCSEL <Dd>, <Dn>, <Dm>, <cond>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 8 << UInt(ftype EOR '10'); constant bits(4) condition = cond;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;cond&gt;

Is one of the standard conditions, encoded in the standard way, and encoded in 'cond':

|   cond | <cond>   |
|--------|----------|
|   0000 | EQ       |
|   0001 | NE       |
|   0010 | CS       |
|   0011 | CC       |
|   0100 | MI       |
|   0101 | PL       |
|   0110 | VS       |
|   0111 | VC       |
|   1000 | HI       |
|   1001 | LS       |
|   1010 | GE       |
|   1011 | LT       |
|   1100 | GT       |
|   1101 | LE       |
|   1110 | AL       |
|   1111 | NV       |

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;Sn&gt; Is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(datasize) result; constant boolean condition_holds = ConditionHolds(condition); result = if condition_holds then V[n, datasize] else V[m, datasize];
```

## &lt;Sd&gt;

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

```
V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.73 FCVT

Floating-point convert precision (scalar)

This instruction converts the floating-point value in the SIMD&amp;FP source register to the precision for the destination register data type using the rounding mode that is determined by the FPCR and writes the result to the SIMD&amp;FP destination register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FP)

<!-- image -->

## Encoding for the Half-precision to single-precision variant

```
Applies when (ftype == 11 && opc
```

```
== 00) FCVT <Sd>, <Hn>
```

## Encoding for the Half-precision to double-precision variant

```
Applies when (ftype == 11 && opc
```

```
== 01) FCVT <Dd>, <Hn>
```

## Encoding for the Single-precision to half-precision variant

```
Applies when (ftype == 00 && opc == 11)
```

```
FCVT <Hd>, <Sn>
```

## Encoding for the Single-precision to double-precision variant

```
Applies when (ftype == 00 && opc
```

```
== 01) FCVT <Dd>, <Sn>
```

## Encoding for the Double-precision to half-precision variant

```
Applies when (ftype == 01 && opc == 11)
```

FCVT

&lt;Hd&gt;, &lt;Dn&gt;

## Encoding for the Double-precision to single-precision variant

Applies when (ftype == 01 &amp;&amp; opc == 00)

FCVT

&lt;Sd&gt;, &lt;Dn&gt;

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == opc || ftype == '10' || opc == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer srcsize = 8 << UInt(ftype EOR '10'); constant integer dstsize = 8 << UInt(opc EOR '10');
```

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

## &lt;Dd&gt;

## &lt;Hd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(srcsize) operand = V[n, srcsize]; bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, dstsize] = FPConvert(operand, FPCR, dstsize); V[d, 128] = result;
```

## C7.2.74 FCVTAS (vector)

Floating-point convert to signed integer, rounding to nearest with ties to away (vector)

This instruction converts each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTAS <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPRounding_TIEAWAY; constant boolean unsigned = FALSE;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTAS <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPRounding_TIEAWAY; constant boolean unsigned = FALSE;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTAS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPRounding_TIEAWAY; constant boolean unsigned = FALSE;
```

Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTAS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPRounding_TIEAWAY; constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

- &lt;V&gt;
- &lt;d&gt;
- &lt;n&gt;
- &lt;Vd&gt;
- &lt;T&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 && IsFeatureImplemented(FEAT_FPRCVT) then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); constant integer fracbits = 0; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.75 FCVTAS (scalar)

Floating-point convert to signed integer, rounding to nearest with ties to away (scalar)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit signed integer using the Round to Nearest with Ties to Away rounding mode, and writes the result to the general-purpose destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
FCVTAS <Wd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
FCVTAS <Xd>, <Hn>
```

## Encoding for the Single-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

```
FCVTAS <Wd>, <Sn>
```

## Encoding for the Single-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
FCVTAS <Xd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

```
FCVTAS <Wd>, <Dn>
```

## Encoding for the Double-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype ==
```

```
FCVTAS <Xd>,
```

```
01) <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10'); constant FPRounding rounding = FPRounding_TIEAWAY; constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Xd&gt;

&lt;Sn&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(fltsize) fltval = V[n, fltsize]; constant integer fracbits = 0; X[d, intsize] =
```

```
FPToFixed(fltval, fracbits, unsigned, FPCR, rounding, intsize);
```

## Operational Information

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the general-purpose register written by this instruction might be significantly delayed.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.76 FCVTAS (scalar SIMD&amp;FP)

Floating-point convert to signed integer, rounding to nearest with ties to away (scalar SIMD&amp;FP)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit signed integer using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FPRCVT)

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

Applies when

FCVTAS

(sf

&lt;Sd&gt;,

==

&lt;Hn&gt;

## Encoding for the Half-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
FCVTAS <Dd>,
```

```
11) <Hn>
```

## Encoding for the Single-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
00) FCVTAS <Dd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 01)
```

```
FCVTAS <Sd>, <Dn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_FPRCVT) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10');
```

0

&amp;&amp;

ftype ==

11)

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

## &lt;Dd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(fltsize) fltval; bits(intsize) intval; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); fltval = V[n, fltsize]; intval = FPToFixed(fltval, 0, FALSE, FPCR, Elem[result, 0, intsize] = intval; V[d, 128] = result;
```

```
FPRounding_TIEAWAY, intsize);
```

## C7.2.77 FCVTAU (vector)

Floating-point convert to unsigned integer, rounding to nearest with ties to away (vector)

This instruction converts each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTAU <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPRounding_TIEAWAY; constant boolean unsigned = TRUE;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTAU <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPRounding_TIEAWAY; constant boolean unsigned = TRUE;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTAU <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPRounding_TIEAWAY; constant boolean unsigned = TRUE;
```

Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTAU <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPRounding_TIEAWAY; constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

- &lt;V&gt;
- &lt;d&gt;
- &lt;n&gt;
- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 && IsFeatureImplemented(FEAT_FPRCVT) then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); constant integer fracbits = 0; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.78 FCVTAU (scalar)

Floating-point convert to unsigned integer, rounding to nearest with ties to away (scalar)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit unsigned integer using the Round to Nearest with Ties to Away rounding mode, and writes the result to the general-purpose destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
FCVTAU <Wd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
FCVTAU <Xd>, <Hn>
```

## Encoding for the Single-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

```
FCVTAU <Wd>, <Sn>
```

## Encoding for the Single-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
FCVTAU <Xd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

```
FCVTAU <Wd>, <Dn>
```

## Encoding for the Double-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
FCVTAU <Xd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10'); constant FPRounding rounding = FPRounding_TIEAWAY; constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Xd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(fltsize) fltval = V[n, fltsize]; constant integer fracbits = 0; X[d, intsize] =
```

```
FPToFixed(fltval, fracbits, unsigned, FPCR, rounding, intsize);
```

## Operational Information

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the general-purpose register written by this instruction might be significantly delayed.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.79 FCVTAU (scalar SIMD&amp;FP)

Floating-point convert to unsigned integer, rounding to nearest with ties to away (scalar SIMD&amp;FP)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit unsigned integer using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FPRCVT)

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 11)
```

```
FCVTAU <Sd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
11) FCVTAU <Dd>, <Hn>
```

## Encoding for the Single-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
00) FCVTAU <Dd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 01)
```

```
FCVTAU <Sd>, <Dn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_FPRCVT) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

&lt;Dd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(fltsize) fltval; bits(intsize) intval; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); fltval = V[n, fltsize]; intval = FPToFixed(fltval, 0, TRUE, FPCR, Elem[result, 0, intsize] = intval; V[d, 128] = result;
```

```
FPRounding_TIEAWAY, intsize);
```

## C7.2.80 FCVTL, FCVTL2

Floating-point convert to higher precision long (vector)

This instruction reads each element in a vector in the SIMD&amp;FP source register, converts each value to double the precision of the source element using the rounding mode that is determined by the FPCR, and writes each result to the equivalent element of the vector in the SIMD&amp;FP destination register.

Where the operation lengthens a 64-bit vector to a 128-bit vector, the FCVTL2 variant operates on the elements in the top 64 bits of the source register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTL{2} <Vd>.<Ta>, <Vn>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16 << UInt(sz); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

## &lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'sz':

|   sz | <Ta>   |
|------|--------|
|    0 | 4S     |
|    1 | 2D     |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <Tb>   |
|------|-----|--------|
|    0 |   0 | 4H     |
|    0 |   1 | 8H     |
|    1 |   0 | 2S     |
|    1 |   1 | 4S     |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = Vpart[n, part, datasize]; bits(2*datasize) result; for e = 0 to elements-1 Elem[result, e, 2*esize] = FPConvert(Elem[operand, e, esize], FPCR, 2 * esize); V[d, 2*datasize] = result;
```

## C7.2.81 FCVTMS (vector)

Floating-point convert to signed integer, rounding toward minus infinity (vector)

This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTMS <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTMS <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTMS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTMS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

- &lt;V&gt;
- &lt;d&gt;
- &lt;n&gt;
- &lt;Vd&gt;
- &lt;T&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 && IsFeatureImplemented(FEAT_FPRCVT) then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); constant integer fracbits = 0; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.82 FCVTMS (scalar)

Floating-point convert to signed integer, rounding toward minus infinity (scalar)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit signed integer using the Round towards Minus Infinity rounding mode, and writes the result to the general-purpose destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
FCVTMS <Wd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
FCVTMS <Xd>, <Hn>
```

## Encoding for the Single-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

FCVTMS

&lt;Wd&gt;,

&lt;Sn&gt;

## Encoding for the Single-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
FCVTMS <Xd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

```
FCVTMS <Wd>, <Dn>
```

## Encoding for the Double-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
FCVTMS <Xd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10'); constant FPRounding rounding = FPRounding_NEGINF; constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Xd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(fltsize) fltval = V[n, fltsize]; constant integer fracbits = 0; X[d, intsize] =
```

```
FPToFixed(fltval, fracbits, unsigned, FPCR, rounding, intsize);
```

## Operational Information

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the general-purpose register written by this instruction might be significantly delayed.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.83 FCVTMS (scalar SIMD&amp;FP)

Floating-point convert to signed integer, rounding toward minus infinity (scalar SIMD&amp;FP)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit signed integer using the Round toward Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FPRCVT)

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

Applies when

FCVTMS

(sf

&lt;Sd&gt;,

==

&lt;Hn&gt;

## Encoding for the Half-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
11) FCVTMS <Dd>, <Hn>
```

## Encoding for the Single-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
00) FCVTMS <Dd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 01)
```

```
FCVTMS <Sd>, <Dn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_FPRCVT) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10');
```

0

&amp;&amp;

ftype ==

11)

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

&lt;Dd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); FPRounding_NEGINF, intsize);
```

```
bits(fltsize) fltval; bits(intsize) intval; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); fltval = V[n, fltsize]; intval = FPToFixed(fltval, 0, FALSE, FPCR, Elem[result, 0, intsize] = intval; V[d, 128] = result;
```

## C7.2.84 FCVTMU (vector)

Floating-point convert to unsigned integer, rounding toward minus infinity (vector)

This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTMU <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTMU <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTMU <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTMU <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

&lt;V&gt;

- &lt;d&gt;
- &lt;n&gt;
- &lt;Vd&gt;

&lt;T&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 && IsFeatureImplemented(FEAT_FPRCVT) then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); constant integer fracbits = 0; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.85 FCVTMU (scalar)

Floating-point convert to unsigned integer, rounding toward minus infinity (scalar)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Minus Infinity rounding mode, and writes the result to the general-purpose destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
FCVTMU <Wd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
FCVTMU <Xd>, <Hn>
```

## Encoding for the Single-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

```
FCVTMU <Wd>, <Sn>
```

## Encoding for the Single-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
FCVTMU <Xd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

```
FCVTMU <Wd>, <Dn>
```

## Encoding for the Double-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
FCVTMU <Xd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10'); constant FPRounding rounding = FPRounding_NEGINF; constant boolean unsigned = TRUE;
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Xd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(fltsize) fltval = V[n, fltsize]; constant integer fracbits = 0; X[d, intsize] =
```

```
FPToFixed(fltval, fracbits, unsigned, FPCR, rounding, intsize);
```

## Operational Information

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the general-purpose register written by this instruction might be significantly delayed.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.86 FCVTMU (scalar SIMD&amp;FP)

Floating-point convert to unsigned integer, rounding toward minus infinity (scalar SIMD&amp;FP)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit unsigned integer using the Round toward Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FPRCVT)

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

Applies when

FCVTMU

(sf

&lt;Sd&gt;,

==

&lt;Hn&gt;

## Encoding for the Half-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
FCVTMU <Dd>,
```

```
11) <Hn>
```

## Encoding for the Single-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
00) FCVTMU <Dd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 01)
```

```
FCVTMU <Sd>, <Dn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_FPRCVT) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10');
```

0

&amp;&amp;

ftype ==

11)

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

&lt;Dd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(fltsize) fltval; bits(intsize) intval; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); fltval = V[n, fltsize]; intval = FPToFixed(fltval, 0, TRUE, FPCR, Elem[result, 0, intsize] = intval; V[d, 128] = result;
```

```
FPRounding_NEGINF, intsize);
```

## C7.2.87 FCVTN, FCVTN2 (double to single-precision, single to half-precision)

Floating-point convert to lower precision narrow (vector)

This instruction reads each vector element in the SIMD&amp;FP source register, converts each result to half the precision of the source element, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. The rounding mode is determined by the FPCR.

FCVTN writes the vector to the lower half of the destination register and clears the upper half. FCVTN2 writes the vector to the upper half of the destination register without affecting the other bits of the register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTN{2} <Vd>.<Tb>, <Vn>.<Ta>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16 << UInt(sz); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

<!-- image -->

&lt;Tb&gt;

## &lt;Vn&gt;

&lt;Ta&gt;

Is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <Tb>   |
|------|-----|--------|
|    0 |   0 | 4H     |
|    0 |   1 | 8H     |
|    1 |   0 | 2S     |
|    1 |   1 | 4S     |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'sz':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand = V[n, 2*datasize]; bits(datasize) result; for e = 0 to elements-1 Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR, esize); Vpart[d, part, datasize] = result;
```

|   sz | <Ta>   |
|------|--------|
|    0 | 4S     |
|    1 | 2D     |

## C7.2.88 FCVTN (half-precision to 8-bit floating-point)

Half-precision convert to 8-bit floating-point (vector)

This instruction converts half-precision elements of the two source vectors to 8-bit floating-point while scaling the values by 2 SInt(FPMR.NSCALE[4:0]) , and places the in-order results in the 8-bit elements of the destination vector.

The 8-bit floating-point encoding format is selected by FPMR.F8D.

## Advanced SIMD

(FEAT\_FP8)

<!-- image -->

## Encoding

```
FCVTN <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP8) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = if Q == '1' then 128 else 64; constant integer elements = datasize DIV 16;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

## &lt;Vn&gt;

&lt;Tb&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; for e = 0 to elements-1 Elem[result, 0*elements + e, 8] = FPConvertFP8(Elem[operand1, e, 16], FPCR, FPMR, 8); Elem[result, 1*elements + e, 8] = FPConvertFP8(Elem[operand2, e, 16], FPCR, FPMR, 8); V[d, datasize] = result;
```

|   Q | <Tb>   |
|-----|--------|
|   0 | 4H     |
|   1 | 8H     |

## C7.2.89 FCVTN, FCVTN2 (single-precision to 8-bit floating-point)

Single-precision convert to 8-bit floating-point (vector)

This instruction converts each single-precision element of the two source vectors to 8-bit floating-point while scaling the value by 2 SInt(FPMR.NSCALE) , and places the in-order results in the 8-bit elements of the lower or upper half of the destination vector. FCVTN writes the results to the lower half of the destination vector and clears the upper half. FCVTN2 writes the results to the upper half of the destination vector without affecting the other bits of the vector.

The 8-bit floating-point encoding format is selected by FPMR.F8D.

## Advanced SIMD

(FEAT\_FP8)

<!-- image -->

## Encoding

```
FCVTN{2} <Vd>.<Ta>, <Vn>.4S, <Vm>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP8) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer part = UInt(Q); constant integer elements = 128 DIV 32;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Vd&gt;

<!-- image -->

&lt;Ta&gt;

&lt;Vn&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[n, 128]; constant bits(128) operand2 = V[m, 128]; bits(64) result; for e = 0 to elements-1 Elem[result, 0*elements + e, 8] = FPConvertFP8(Elem[operand1, e, 32], FPCR, FPMR, 8); Elem[result, 1*elements + e, 8] = FPConvertFP8(Elem[operand2, e, 32], FPCR, FPMR, 8); Vpart[d, part, 64] = result;
```

## C7.2.90 FCVTNS (vector)

Floating-point convert to signed integer, rounding to nearest with ties to even (vector)

This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTNS <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTNS <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTNS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTNS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

- &lt;V&gt;
- &lt;d&gt;
- &lt;n&gt;
- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 && IsFeatureImplemented(FEAT_FPRCVT) then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); constant integer fracbits = 0; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.91 FCVTNS (scalar)

Floating-point convert to signed integer, rounding to nearest with ties to even (scalar)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit signed integer using the Round to Nearest rounding mode, and writes the result to the general-purpose destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
FCVTNS <Wd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
FCVTNS <Xd>, <Hn>
```

## Encoding for the Single-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

```
FCVTNS <Wd>, <Sn>
```

## Encoding for the Single-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
FCVTNS <Xd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

```
FCVTNS <Wd>,
```

```
<Dn>
```

## Encoding for the Double-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
FCVTNS <Xd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10'); constant FPRounding rounding = FPRounding_TIEEVEN; constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Xd&gt;

&lt;Sn&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(fltsize) fltval = V[n, fltsize]; constant integer fracbits = 0; X[d, intsize] =
```

```
FPToFixed(fltval, fracbits, unsigned, FPCR, rounding, intsize);
```

## Operational Information

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the general-purpose register written by this instruction might be significantly delayed.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.92 FCVTNS (scalar SIMD&amp;FP)

Floating-point convert to signed integer, rounding to nearest with ties to even (scalar SIMD&amp;FP)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit signed integer using the Round to Nearest with Ties to Even rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FPRCVT)

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

Applies when

FCVTNS

(sf

&lt;Sd&gt;,

==

&lt;Hn&gt;

## Encoding for the Half-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
FCVTNS <Dd>,
```

```
11) <Hn>
```

## Encoding for the Single-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
00) FCVTNS <Dd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 01)
```

```
FCVTNS <Sd>, <Dn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_FPRCVT) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10');
```

0

&amp;&amp;

ftype ==

11)

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

&lt;Dd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); FPRounding_TIEEVEN, intsize);
```

```
bits(fltsize) fltval; bits(intsize) intval; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); fltval = V[n, fltsize]; intval = FPToFixed(fltval, 0, FALSE, FPCR, Elem[result, 0, intsize] = intval; V[d, 128] = result;
```

## C7.2.93 FCVTNU (vector)

Floating-point convert to unsigned integer, rounding to nearest with ties to even (vector)

This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTNU <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTNU <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTNU <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTNU <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

- &lt;V&gt;
- &lt;d&gt;
- &lt;n&gt;
- &lt;Vd&gt;
- &lt;T&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 && IsFeatureImplemented(FEAT_FPRCVT) then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); constant integer fracbits = 0; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.94 FCVTNU (scalar)

Floating-point convert to unsigned integer, rounding to nearest with ties to even (scalar)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit unsigned integer using the Round to Nearest rounding mode, and writes the result to the general-purpose destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
FCVTNU <Wd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
FCVTNU <Xd>, <Hn>
```

## Encoding for the Single-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

FCVTNU

&lt;Wd&gt;,

&lt;Sn&gt;

## Encoding for the Single-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
FCVTNU <Xd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

```
FCVTNU <Wd>, <Dn>
```

## Encoding for the Double-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
FCVTNU <Xd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10'); constant FPRounding rounding = FPRounding_TIEEVEN; constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Xd&gt;

&lt;Sn&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(fltsize) fltval = V[n, fltsize]; constant integer fracbits = 0; X[d, intsize] =
```

```
FPToFixed(fltval, fracbits, unsigned, FPCR, rounding, intsize);
```

## Operational Information

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the general-purpose register written by this instruction might be significantly delayed.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.95 FCVTNU (scalar SIMD&amp;FP)

Floating-point convert to unsigned integer, rounding to nearest with ties to even (scalar SIMD&amp;FP)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit unsigned integer using the Round to Nearest with Ties to Even rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FPRCVT)

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 11)
```

FCVTNU

&lt;Sd&gt;,

&lt;Hn&gt;

## Encoding for the Half-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
11) FCVTNU <Dd>, <Hn>
```

## Encoding for the Single-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
00) FCVTNU <Dd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 01)
```

```
FCVTNU <Sd>, <Dn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_FPRCVT) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

&lt;Dd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); FPRounding_TIEEVEN, intsize);
```

```
bits(fltsize) fltval; bits(intsize) intval; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); fltval = V[n, fltsize]; intval = FPToFixed(fltval, 0, TRUE, FPCR, Elem[result, 0, intsize] = intval; V[d, 128] = result;
```

## C7.2.96 FCVTPS (vector)

Floating-point convert to signed integer, rounding toward plus infinity (vector)

This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTPS <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTPS <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTPS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTPS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

- &lt;V&gt;
- &lt;d&gt;
- &lt;n&gt;
- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 && IsFeatureImplemented(FEAT_FPRCVT) then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); constant integer fracbits = 0; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.97 FCVTPS (scalar)

Floating-point convert to signed integer, rounding toward plus infinity (scalar)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit signed integer using the Round towards Plus Infinity rounding mode, and writes the result to the general-purpose destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
FCVTPS <Wd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
FCVTPS <Xd>, <Hn>
```

## Encoding for the Single-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

```
FCVTPS <Wd>, <Sn>
```

## Encoding for the Single-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
FCVTPS <Xd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

```
FCVTPS <Wd>, <Dn>
```

## Encoding for the Double-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
FCVTPS <Xd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10'); constant FPRounding rounding = FPRounding_POSINF; constant boolean unsigned = FALSE;
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Xd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(fltsize) fltval = V[n, fltsize]; constant integer fracbits = 0; X[d, intsize] =
```

```
FPToFixed(fltval, fracbits, unsigned, FPCR, rounding, intsize);
```

## Operational Information

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the general-purpose register written by this instruction might be significantly delayed.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.98 FCVTPS (scalar SIMD&amp;FP)

Floating-point convert to signed integer, rounding toward plus infinity (scalar SIMD&amp;FP)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit signed integer using the Round toward Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FPRCVT)

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 11)
```

```
FCVTPS <Sd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
FCVTPS <Dd>,
```

```
11) <Hn>
```

## Encoding for the Single-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
00) FCVTPS <Dd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 01)
```

```
FCVTPS <Sd>, <Dn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_FPRCVT) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

&lt;Dd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); FPRounding_POSINF, intsize);
```

```
bits(fltsize) fltval; bits(intsize) intval; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); fltval = V[n, fltsize]; intval = FPToFixed(fltval, 0, FALSE, FPCR, Elem[result, 0, intsize] = intval; V[d, 128] = result;
```

## C7.2.99 FCVTPU (vector)

Floating-point convert to unsigned integer, rounding toward plus infinity (vector)

This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTPU <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTPU <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTPU <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTPU <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

- &lt;V&gt;
- &lt;d&gt;
- &lt;n&gt;
- &lt;Vd&gt;

&lt;T&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 && IsFeatureImplemented(FEAT_FPRCVT) then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); constant integer fracbits = 0; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.100 FCVTPU (scalar)

Floating-point convert to unsigned integer, rounding toward plus infinity (scalar)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Plus Infinity rounding mode, and writes the result to the general-purpose destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
FCVTPU <Wd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
FCVTPU <Xd>, <Hn>
```

## Encoding for the Single-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

```
FCVTPU <Wd>, <Sn>
```

## Encoding for the Single-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
FCVTPU <Xd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

```
FCVTPU <Wd>, <Dn>
```

## Encoding for the Double-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
FCVTPU <Xd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10'); constant FPRounding rounding = FPRounding_POSINF; constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Xd&gt;

&lt;Sn&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(fltsize) fltval = V[n, fltsize]; constant integer fracbits = 0; X[d, intsize] =
```

```
FPToFixed(fltval, fracbits, unsigned, FPCR, rounding, intsize);
```

## Operational Information

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the general-purpose register written by this instruction might be significantly delayed.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.101 FCVTPU (scalar SIMD&amp;FP)

Floating-point convert to unsigned integer, rounding toward plus infinity (scalar SIMD&amp;FP)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit unsigned integer using the Round toward Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FPRCVT)

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 11)
```

```
FCVTPU <Sd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
Applies when (sf == 1 && ftype == 11)
```

```
FCVTPU <Dd>, <Hn>
```

## Encoding for the Single-precision to 64-bit variant

```
Applies when (sf == 1 && ftype == 00)
```

```
FCVTPU <Dd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 01)
```

```
FCVTPU <Sd>, <Dn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_FPRCVT) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

&lt;Dd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); FPRounding_POSINF, intsize);
```

```
bits(fltsize) fltval; bits(intsize) intval; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); fltval = V[n, fltsize]; intval = FPToFixed(fltval, 0, TRUE, FPCR, Elem[result, 0, intsize] = intval; V[d, 128] = result;
```

## C7.2.102 FCVTXN, FCVTXN2

Floating-point convert to lower precision narrow, rounding to odd (vector)

This instruction reads each double-precision element in the source SIMD&amp;FP register, converts each value to single-precision format using the Round to Odd rounding mode, and writes the results to the destination SIMD&amp;FP register.

Note

This instruction uses the Round to Odd rounding mode, which is not defined by the IEEE 754-2008 standard. This rounding mode ensures that if the result of the conversion is inexact, the least significant bit of the mantissa is forced to 1. This rounding mode enables a floating-point value to be converted to a lower precision format via an intermediate precision format while avoiding double rounding errors. For example, a 64-bit floating-point value can be converted to a correctly rounded 16-bit floating-point value by first using this instruction to produce a 32-bit value and then using another instruction with the wanted rounding mode to convert the 32-bit value to the final 16-bit floating-point value.

The Vector variant of FCVTXN writes the half-width results to the lower half of the destination register and clears the upper half to 0. FCVTXN2 writes the half-width results to the upper half of the destination register without affecting the other bits of the register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTXN S<d>, D<n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32; constant integer datasize = esize; constant integer elements = 1; constant integer part = 0;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTXN{2} <Vd>.<Tb>, <Vn>.2D
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32; constant integer datasize = 64; constant integer elements = 2; constant integer part = UInt(Q);
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;n&gt;

2

&lt;Vd&gt;

&lt;Tb&gt;

&lt;Vn&gt;

|   Q | <Tb>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand = V[n, 2*datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); for e = 0 to elements-1 Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR, FPRounding_ODD, esize); if merge then V[d, 128] = result; else Vpart[d, part, datasize] = Elem[result, 0, datasize];
```

## C7.2.103 FCVTZS (vector, fixed-point)

Floating-point convert to signed fixed-point, rounding toward zero (vector)

This instruction converts a scalar or each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTZS <V><d>, <V><n>, #<fbits>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh IN {'000x'} || (immh IN {'001x'} && !IsFeatureImplemented(FEAT_FP16)) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = if immh IN {'1xxx'} then 64 else if immh IN {'01xx'} then 32 else 16; constant integer datasize = esize; constant integer elements = 1; constant integer fracbits = (esize * 2) UInt(immh:immb); constant boolean unsigned = FALSE; constant FPRounding rounding = FPRounding_ZERO;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTZS <Vd>.<T>, <Vn>.<T>, #<fbits>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh IN {'000x'} || (immh IN {'001x'} && !IsFeatureImplemented(FEAT_FP16)) then EndOfDecode(Decode_UNDEF); if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = if immh IN {'1xxx'} then 64 else if immh IN {'01xx'} then 32 else 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer fracbits = (esize * 2) UInt(immh:immb); constant boolean unsigned = FALSE; constant FPRounding rounding = FPRounding_ZERO;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'immh':

| immh   | <V>      | Architectural Feature   |
|--------|----------|-------------------------|
| 0001   | RESERVED | -                       |
| 001x   | H        | FEAT_FP16               |
| 01xx   | S        | -                       |
| 1xxx   | D        | -                       |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;d&gt;

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;fbits&gt;

For the 'Scalar' variant: is the number of fractional bits, in the range 1 to the operand width, encoded in 'immh:immb':

| immh   | <fbits>               |
|--------|-----------------------|
| 0001   | RESERVED              |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

For the 'Vector' variant: is the number of fractional bits, in the range 1 to the element width, encoded in 'immh:immb':

## &lt;Vd&gt;

&lt;T&gt;

| immh   | <fbits>               |
|--------|-----------------------|
| 0001   | RESERVED              |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   | Q   | <T>      | Architectural Feature   |
|--------|-----|----------|-------------------------|
| 0001   | x   | RESERVED | -                       |
| 001x   | 0   | 4H       | FEAT_FP16               |
| 001x   | 1   | 8H       | FEAT_FP16               |
| 01xx   | 0   | 2S       | -                       |
| 01xx   | 1   | 4S       | -                       |
| 1xxx   | 0   | RESERVED | -                       |
| 1xxx   | 1   | 2D       | -                       |

## &lt;Vn&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.104 FCVTZS (vector, integer)

Floating-point convert to signed integer, rounding toward zero (vector)

This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTZS <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTZS <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTZS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTZS <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

- &lt;V&gt;
- &lt;d&gt;
- &lt;n&gt;
- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 && IsFeatureImplemented(FEAT_FPRCVT) then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); constant integer fracbits = 0; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.105 FCVTZS (scalar, fixed-point)

Floating-point convert to signed fixed-point, rounding toward zero (scalar)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
FCVTZS <Wd>, <Hn>, #<fbits>
```

## Encoding for the Half-precision to 64-bit variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
FCVTZS <Xd>, <Hn>, #<fbits>
```

## Encoding for the Single-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

```
FCVTZS <Wd>, <Sn>, #<fbits>
```

## Encoding for the Single-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
FCVTZS <Xd>, <Sn>, #<fbits>
```

## Encoding for the Double-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

```
FCVTZS <Wd>, <Dn>, #<fbits>
```

## Encoding for the Double-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
FCVTZS <Xd>, <Dn>, #<fbits>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); if sf == '0' && scale<5> == '0' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer decode_fltsize = 8 << UInt(ftype EOR '10'); constant integer fracbits = 64 -UInt(scale); constant FPRounding rounding = FPRounding_ZERO; constant boolean unsigned = FALSE;
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;fbits&gt;

For the 'Double-precision to 32-bit', 'Half-precision to 32-bit', and 'Single-precision to 32-bit' variants: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 32, encoded as 64 minus 'scale'.

For the 'Double-precision to 64-bit', 'Half-precision to 64-bit', and 'Single-precision to 64-bit' variants: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 64, encoded as 64 minus 'scale'.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

## &lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(decode_fltsize) fltval = V[n, decode_fltsize]; X[d, intsize] =
```

```
FPToFixed(fltval, fracbits, unsigned, FPCR, rounding, intsize);
```

## Operational Information

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the general-purpose register written by this instruction might be significantly delayed.

## C7.2.106 FCVTZS (scalar, integer)

Floating-point convert to signed integer, rounding toward zero (scalar)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
FCVTZS <Wd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
FCVTZS <Xd>, <Hn>
```

## Encoding for the Single-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

FCVTZS

&lt;Wd&gt;,

&lt;Sn&gt;

## Encoding for the Single-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
FCVTZS <Xd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

```
FCVTZS <Wd>,
```

```
<Dn>
```

## Encoding for the Double-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
FCVTZS <Xd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10'); constant FPRounding rounding = FPRounding_ZERO; constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Xd&gt;

&lt;Sn&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(fltsize) fltval = V[n, fltsize]; constant integer fracbits = 0; X[d, intsize] =
```

```
FPToFixed(fltval, fracbits, unsigned, FPCR, rounding, intsize);
```

## Operational Information

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the general-purpose register written by this instruction might be significantly delayed.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.107 FCVTZS (scalar SIMD&amp;FP)

Floating-point convert to signed integer, rounding toward zero (scalar SIMD&amp;FP)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit signed integer using the Round toward Zero rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FPRCVT)

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 11)
```

FCVTZS

&lt;Sd&gt;,

&lt;Hn&gt;

## Encoding for the Half-precision to 64-bit variant

```
Applies when (sf == 1 && ftype == 11)
```

```
FCVTZS <Dd>, <Hn>
```

## Encoding for the Single-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
00) FCVTZS <Dd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 01)
```

```
FCVTZS <Sd>, <Dn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_FPRCVT) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

## &lt;Dd&gt;

## &lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(fltsize) fltval; bits(intsize) intval; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); fltval = V[n, fltsize]; intval = FPToFixed(fltval, 0, FALSE, FPCR, Elem[result, 0, intsize] = intval; V[d, 128] = result;
```

```
FPRounding_ZERO, intsize);
```

## C7.2.108 FCVTZU (vector, fixed-point)

Floating-point convert to unsigned fixed-point, rounding toward zero (vector)

This instruction converts a scalar or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTZU <V><d>, <V><n>, #<fbits>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh IN {'000x'} || (immh IN {'001x'} && !IsFeatureImplemented(FEAT_FP16)) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = if immh IN {'1xxx'} then 64 else if immh IN {'01xx'} then 32 else 16; constant integer datasize = esize; constant integer elements = 1; constant integer fracbits = (esize * 2) UInt(immh:immb); constant boolean unsigned = TRUE; constant FPRounding rounding = FPRounding_ZERO;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTZU <Vd>.<T>, <Vn>.<T>, #<fbits>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh IN {'000x'} || (immh IN {'001x'} && !IsFeatureImplemented(FEAT_FP16)) then EndOfDecode(Decode_UNDEF); if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = if immh IN {'1xxx'} then 64 else if immh IN {'01xx'} then 32 else 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer fracbits = (esize * 2) UInt(immh:immb); constant boolean unsigned = TRUE; constant FPRounding rounding = FPRounding_ZERO;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'immh':

| immh   | <V>      | Architectural Feature   |
|--------|----------|-------------------------|
| 0001   | RESERVED | -                       |
| 001x   | H        | FEAT_FP16               |
| 01xx   | S        | -                       |
| 1xxx   | D        | -                       |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;d&gt;

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;fbits&gt;

For the 'Scalar' variant: is the number of fractional bits, in the range 1 to the operand width, encoded in 'immh:immb':

| immh   | <fbits>               |
|--------|-----------------------|
| 0001   | RESERVED              |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

For the 'Vector' variant: is the number of fractional bits, in the range 1 to the element width, encoded in 'immh:immb':

## &lt;Vd&gt;

&lt;T&gt;

| immh   | <fbits>               |
|--------|-----------------------|
| 0001   | RESERVED              |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   | Q   | <T>      | Architectural Feature   |
|--------|-----|----------|-------------------------|
| 0001   | x   | RESERVED | -                       |
| 001x   | 0   | 4H       | FEAT_FP16               |
| 001x   | 1   | 8H       | FEAT_FP16               |
| 01xx   | 0   | 2S       | -                       |
| 01xx   | 1   | 4S       | -                       |
| 1xxx   | 0   | RESERVED | -                       |
| 1xxx   | 1   | 2D       | -                       |

## &lt;Vn&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.109 FCVTZU (vector, integer)

Floating-point convert to unsigned integer, rounding toward zero (vector)

This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTZU <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTZU <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FCVTZU <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FCVTZU <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant FPRounding rounding = FPDecodeRounding(o1:o2); constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

&lt;V&gt;

- &lt;d&gt;
- &lt;n&gt;
- &lt;Vd&gt;

&lt;T&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 && IsFeatureImplemented(FEAT_FPRCVT) then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); constant integer fracbits = 0; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.110 FCVTZU (scalar, fixed-point)

Floating-point convert to unsigned fixed-point, rounding toward zero (scalar)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
FCVTZU <Wd>, <Hn>, #<fbits>
```

## Encoding for the Half-precision to 64-bit variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
FCVTZU <Xd>, <Hn>, #<fbits>
```

## Encoding for the Single-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

```
FCVTZU <Wd>, <Sn>, #<fbits>
```

## Encoding for the Single-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
FCVTZU <Xd>, <Sn>, #<fbits>
```

## Encoding for the Double-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

```
FCVTZU <Wd>, <Dn>, #<fbits>
```

## Encoding for the Double-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
FCVTZU <Xd>, <Dn>, #<fbits>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); if sf == '0' && scale<5> == '0' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer decode_fltsize = 8 << UInt(ftype EOR '10'); constant integer fracbits = 64 -UInt(scale); constant FPRounding rounding = FPRounding_ZERO; constant boolean unsigned = TRUE;
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;fbits&gt;

For the 'Double-precision to 32-bit', 'Half-precision to 32-bit', and 'Single-precision to 32-bit' variants: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 32, encoded as 64 minus 'scale'.

For the 'Double-precision to 64-bit', 'Half-precision to 64-bit', and 'Single-precision to 64-bit' variants: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 64, encoded as 64 minus 'scale'.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

## &lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(decode_fltsize) fltval = V[n, decode_fltsize]; X[d, intsize] = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding, intsize);
```

## Operational Information

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the general-purpose register written by this instruction might be significantly delayed.

## C7.2.111 FCVTZU (scalar, integer)

Floating-point convert to unsigned integer, rounding toward zero (scalar)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
FCVTZU <Wd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
FCVTZU <Xd>, <Hn>
```

## Encoding for the Single-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

```
FCVTZU <Wd>, <Sn>
```

## Encoding for the Single-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
FCVTZU <Xd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

```
FCVTZU <Wd>, <Dn>
```

## Encoding for the Double-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
FCVTZU <Xd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10'); constant FPRounding rounding = FPRounding_ZERO; constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Xd&gt;

&lt;Sn&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(fltsize) fltval = V[n, fltsize]; constant integer fracbits = 0; X[d, intsize] =
```

```
FPToFixed(fltval, fracbits, unsigned, FPCR, rounding, intsize);
```

## Operational Information

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the general-purpose register written by this instruction might be significantly delayed.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.112 FCVTZU (scalar SIMD&amp;FP)

Floating-point convert to unsigned integer, rounding toward zero (scalar SIMD&amp;FP)

This instruction converts the floating-point value in the SIMD&amp;FP source register to a 32-bit or 64-bit unsigned integer using the Round toward Zero rounding mode, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FPRCVT)

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 11)
```

FCVTZU

&lt;Sd&gt;,

&lt;Hn&gt;

## Encoding for the Half-precision to 64-bit variant

```
Applies when (sf == 1 && ftype == 11)
```

```
FCVTZU <Dd>, <Hn>
```

## Encoding for the Single-precision to 64-bit variant

```
Applies when (sf == 1 && ftype ==
```

```
00) FCVTZU <Dd>, <Sn>
```

## Encoding for the Double-precision to 32-bit variant

```
Applies when (sf == 0 && ftype == 01)
```

```
FCVTZU <Sd>, <Dn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_FPRCVT) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

&lt;Dd&gt;

&lt;Sn&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(fltsize) fltval; bits(intsize) intval; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); fltval = V[n, fltsize]; intval = FPToFixed(fltval, 0, TRUE, FPCR, Elem[result, 0, intsize] = intval; V[d, 128] = result;
```

```
FPRounding_ZERO, intsize);
```

## C7.2.113 FDIV (vector)

Floating-point divide (vector)

This instruction divides the floating-point values in the elements in the first source SIMD&amp;FP register, by the floating-point values in the corresponding elements in the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FDIV
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FDIV
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = FPDiv(element1, element2,
```

&lt;T&gt;

&lt;Vn&gt;

```
FPCR);
```

V[d, datasize] = result;

## C7.2.114 FDIV (scalar)

Floating-point divide (scalar)

This instruction divides the floating-point value of the first source SIMD&amp;FP register by the floating-point value of the second source SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

(FEAT\_FP16) Applies when (ftype == 11)

```
FDIV <Hd>, <Hn>, <Hm>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FDIV <Sd>, <Sn>, <Sm>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FDIV <Dd>, <Dn>, <Dm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Sd&gt;

&lt;Sn&gt;

Is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand1 = V[n, esize]; constant bits(esize) operand2 = V[m, esize]; bits(128) result = if IsMerging(FPCR) then V[n, 128] Elem[result, 0, esize] = FPDiv(operand1, operand2, FPCR); V[d, 128] = result;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

```
else Zeros(128);
```

## C7.2.115 FDOT (8-bit floating-point to half-precision, by element)

8-bit floating-point dot product to half-precision (vector, by element)

This instruction computes the fused sum-of-products of a pair of 8-bit floating-point values held in each 16-bit element of the first source vector and a pair of 8-bit floating-point values in an indexed 16-bit element of the second source vector. The half-precision sum-of-products are scaled by 2 -UInt(FPMR.LSCALE[3:0]) , before being destructively added without intermediate rounding to the corresponding half-precision elements of the destination vector.

The 8-bit floating-point groups within the second source vector are specified using an immediate index.

The 8-bit floating-point encoding format for the elements of the first source vector is selected by FPMR.F8S1. The 8-bit floating-point encoding format for the elements of the second source vector is selected by FPMR.F8S2.

## Advanced SIMD

(FEAT\_FP8DOT2)

<!-- image -->

## Encoding

```
FDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.2B[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP8DOT2) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer d = UInt(Rd); constant integer m = UInt('0':Rm); constant integer i = UInt(H:L:M); constant integer datasize = if Q == '1' then 128 else constant integer esize = 16; constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

<!-- image -->

&lt;Vn&gt;

```
64;
```

|   Q | <Ta>   |
|-----|--------|
|   0 | 4H     |
|   1 | 8H     |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'Q':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, in the range V0 to V15, encoded in the 'Rm' field.

## &lt;index&gt;

Is the immediate index of a pair of 8-bit elements, in the range 0 to 7, encoded in the 'H:L:M' fields.

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(128) operand2 = V[m, 128]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; for e = 0 to elements-1 constant bits(esize) op1 = Elem[operand1, e, esize]; constant bits(esize) op2 = Elem[operand2, i, esize]; constant bits(esize) sum = Elem[operand3, e, esize]; Elem[result, e, esize] = FP8DotAddFP(sum, op1, op2, FPCR, FPMR); V[d, datasize] = result;
```

|   Q | <Tb>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

## C7.2.116 FDOT (8-bit floating-point to half-precision, vector)

8-bit floating-point dot product to half-precision (vector)

This instruction computes the fused sum-of-products of a pair of 8-bit floating-point values held in each 16-bit element of the first and second source vectors. The half-precision sum-of-products are scaled by 2 -UInt(FPMR.LSCALE[3:0]) , before being destructively added without intermediate rounding to the corresponding half-precision elements of the destination vector.

The 8-bit floating-point encoding format for the elements of the first source vector is selected by FPMR.F8S1. The 8-bit floating-point encoding format for the elements of the second source vector is selected by FPMR.F8S2.

## Advanced SIMD (FEAT\_FP8DOT2)

<!-- image -->

## Encoding

```
FDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP8DOT2) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = if Q == '1' then 128 else 64; constant integer esize = 16; constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

<!-- image -->

&lt;Ta&gt;

&lt;Vn&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 4H     |
|   1 | 8H     |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'Q':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; for e = 0 to elements-1 constant bits(esize) op1 = Elem[operand1, e, esize]; constant bits(esize) op2 = Elem[operand2, e, esize]; bits(esize) sum = Elem[operand3, e, esize]; sum = FP8DotAddFP(sum, op1, op2, FPCR, FPMR); Elem[result, e, esize] = sum; V[d, datasize] = result;
```

|   Q | <Tb>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

## C7.2.117 FDOT (8-bit floating-point to single-precision, by element)

8-bit floating-point dot product to single-precision (vector, by element)

This instruction computes the fused sum-of-products of a group of four 8-bit floating-point values held in each 32-bit element of the first source vector and a group of four 8-bit floating-point values in an indexed 32-bit element of the second source vector. The single-precision sum-of-products are scaled by 2 -UInt(FPMR.LSCALE) , before being destructively added without intermediate rounding to the corresponding single-precision elements of the destination vector.

The 8-bit floating-point groups within the second source vector are specified using an immediate index.

The 8-bit floating-point encoding format for the elements of the first source vector is selected by FPMR.F8S1. The 8-bit floating-point encoding format for the elements of the second source vector is selected by FPMR.F8S2.

## Advanced SIMD

(FEAT\_FP8DOT4)

<!-- image -->

## Encoding

```
FDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP8DOT4) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer d = UInt(Rd); constant integer m = UInt(M:Rm); constant integer i = UInt(H:L); constant integer datasize = if Q == '1' then 128 else constant integer esize = 32; constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

<!-- image -->

&lt;Vn&gt;

```
64;
```

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'Q':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'M:Rm' fields.

## &lt;index&gt;

Is the immediate index of a 32-bit group of four 8-bit values, in the range 0 to 3, encoded in the 'H:L' fields.

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(128) operand2 = V[m, 128]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; for e = 0 to elements-1 constant bits(esize) op1 = Elem[operand1, e, esize]; constant bits(esize) op2 = Elem[operand2, i, esize]; constant bits(esize) sum = Elem[operand3, e, esize]; Elem[result, e, esize] = FP8DotAddFP(sum, op1, op2, FPCR, FPMR); V[d, datasize] = result;
```

|   Q | <Tb>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

## C7.2.118 FDOT (8-bit floating-point to single-precision, vector)

8-bit floating-point dot product to single-precision (vector)

This instruction computes the fused sum-of-products of a group of four 8-bit floating-point values held in each 32-bit element of the first and second source vectors. The single-precision sum-of-products are scaled by 2 -UInt(FPMR.LSCALE) , before being destructively added without intermediate rounding to the corresponding single-precision elements of the destination vector.

The 8-bit floating-point encoding format for the elements of the first source vector is selected by FPMR.F8S1. The 8-bit floating-point encoding format for the elements of the second source vector is selected by FPMR.F8S2.

## Advanced SIMD

(FEAT\_FP8DOT4)

<!-- image -->

## Encoding

```
FDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP8DOT4) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = if Q == '1' then 128 else 64; constant integer esize = 32; constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

<!-- image -->

&lt;Ta&gt;

&lt;Vn&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'Q':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; for e = 0 to elements-1 constant bits(esize) op1 = Elem[operand1, e, esize]; constant bits(esize) op2 = Elem[operand2, e, esize]; bits(esize) sum = Elem[operand3, e, esize]; sum = FP8DotAddFP(sum, op1, op2, FPCR, FPMR); Elem[result, e, esize] = sum; V[d, datasize] = result;
```

|   Q | <Tb>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

## C7.2.119 FJCVTZS

Floating-point Javascript convert to signed fixed-point, rounding toward zero

This instruction converts the double-precision floating-point value in the SIMD&amp;FP source register to a 32-bit signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register. If the result is too large to be represented as a signed 32-bit integer, then the result is the integer modulo 2 32 , as held in a 32-bit signed integer.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Double-precision to 32-bit

(FEAT\_JSCVT)

<!-- image -->

## Encoding

```
FJCVTZS <Wd>, <Dn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_JSCVT) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(64) fltval = V[n, 64]; bits(32) intval; bit z; (intval, z) = FPToFixedJS(fltval, FPCR); X[d, 32] = intval; PSTATE.<N,Z,C,V> = '0':z:'00';
```

## C7.2.120 FMADD

Floating-point fused multiply-add (scalar)

This instruction multiplies the values of the first two SIMD&amp;FP source registers, adds the product to the value of the third SIMD&amp;FP source register, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

(FEAT\_FP16) Applies when (ftype == 11)

```
FMADD <Hd>, <Hn>, <Hm>, <Ha>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FMADD <Sd>, <Sn>, <Sm>, <Sa>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when
```

```
FMADD <Dd>, <Dn>, <Dm>,
```

```
(ftype == 01) <Da>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer a = UInt(Ra); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Ha&gt;

&lt;Sd&gt;

&lt;Sn&gt;

Is the 32-bit name of the first SIMD&amp;FP source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register holding the multiplier, encoded in the 'Rm' field.

&lt;Sa&gt;

&lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Da&gt;

Is the 64-bit name of the third SIMD&amp;FP source register holding the addend, encoded in the 'Ra' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) addend = V[a, esize]; constant bits(esize) operand1 = V[n, esize]; constant bits(esize) operand2 = V[m, esize]; bits(128) result = if IsMerging(FPCR) then V[a, 128] else Zeros(128); Elem[result, 0, esize] = FPMulAdd(addend, operand1, operand2, FPCR); V[d, 128] = result;
```

Is the 16-bit name of the third SIMD&amp;FP source register holding the addend, encoded in the 'Ra' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the third SIMD&amp;FP source register holding the addend, encoded in the 'Ra' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.121 FMAX (vector)

Floating-point maximum (vector)

This instruction compares corresponding vector elements in the two source SIMD&amp;FP registers, places the larger of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&amp;FP register.

When FPCR.AH is 0, the behavior is as follows:

- Negative zero compares less than positive zero.
- When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows:

- If both elements are zeros, regardless of the sign of either zero, the result is the second element.
- If either element is a NaN, regardless of the value of FPCR.DN, the result is the second element.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

## (FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = bits(datasize) result; bits(esize) element1;
```

```
V[n, datasize]; V[m, datasize]; bits(esize) element2;
```

<!-- image -->

&lt;Vn&gt;

```
for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = FPMax(element1, element2, FPCR); V[d, datasize] = result;
```

## C7.2.122 FMAX (scalar)

Floating-point maximum (scalar)

This instruction compares the two source SIMD&amp;FP registers, and writes the larger of the two floating-point values to the destination SIMD&amp;FP register.

When FPCR.AH is 0, the behavior is as follows:

- Negative zero compares less than positive zero.
- When FPCR.DN is 0, if either value is a NaN, the result is a quiet NaN.
- When FPCR.DN is 1, if either value is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows:

- If both values are zeros, regardless of the sign of either zero, the result is the second value.
- If either value is a NaN, regardless of the value of FPCR.DN, the result is the second value.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11)
```

```
FMAX <Hd>, <Hn>, <Hm>
```

## Encoding for the Single-precision variant

(FEAT\_FP) Applies when (ftype == 00)

```
FMAX <Sd>, <Sn>, <Sm>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FMAX <Dd>, <Dn>, <Dm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Sd&gt;

&lt;Sn&gt;

Is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand1 = V[n, esize]; constant bits(esize) operand2 = V[m, esize]; bits(128) result = if IsMerging(FPCR) then V[n, 128] Elem[result, 0, esize] = FPMax(operand1, operand2, FPCR); V[d, 128] = result;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

```
else Zeros(128);
```

## C7.2.123 FMAXNM (vector)

Floating-point maximum number (vector)

This instruction compares corresponding vector elements in the two source SIMD&amp;FP registers, writes the larger of the two floating-point values into a vector, and writes the vector to the destination SIMD&amp;FP register.

Regardless of the value of FPCR.AH, the behavior is as follows:

- Negative zero compares less than positive zero.
- If one element is numeric and the other is a quiet NaN, the result is the numeric value.
- When FPCR.DN is 0, if either element is a signaling NaN or if both elements are NaNs, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a signaling NaN or if both elements are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMAXNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMAXNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = FPMaxNum(element1, element2, V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

```
FPCR);
```

## C7.2.124 FMAXNM (scalar)

Floating-point maximum number (scalar)

This instruction compares the first and second source SIMD&amp;FP register values, and writes the larger of the two floating-point values to the destination SIMD&amp;FP register.

Regardless of the value of FPCR.AH, the behavior is as follows:

- Negative zero compares less than positive zero.
- If one value is numeric and the other is a quiet NaN, the result is the numeric value.
- When FPCR.DN is 0, if either value is a signaling NaN or if both values are NaNs, the result is a quiet NaN.
- When FPCR.DN is 1, if either value is a signaling NaN or if both values are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11)
```

```
FMAXNM <Hd>, <Hn>, <Hm>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FMAXNM <Sd>, <Sn>, <Sm>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when
```

```
FMAXNM <Dd>,
```

```
(ftype == 01) <Dn>, <Dm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Sd&gt;

&lt;Sn&gt;

Is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand1 = V[n, esize]; constant bits(esize) operand2 = V[m, esize]; bits(128) result = if IsMerging(FPCR) then V[n, 128] else Zeros(128); Elem[result, 0, esize] = FPMaxNum(operand1, operand2, FPCR); V[d, 128] = result;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.125 FMAXNMP (scalar)

Floating-point maximum number of pair of elements (scalar)

This instruction compares two vector elements in the source SIMD&amp;FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&amp;FP register.

Regardless of the value of FPCR.AH, the behavior is as follows for each pairwise operation:

- Negative zero compares less than positive zero.
- If one element is numeric and the other is a quiet NaN, the result is the numeric value.
- When FPCR.DN is 0, if either element is a signaling NaN or if both elements are NaNs, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a signaling NaN or if both elements are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMAXNMP H<d>, <Vn>.2H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 32;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMAXNMP <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize * 2;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the destination width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

&lt;Vn&gt;

&lt;V&gt;

&lt;T&gt;

Is the source arrangement specifier, encoded in 'sz':

|   sz | <T>   |
|------|-------|
|    0 | 2S    |
|    1 | 2D    |

```
esize]; esize];
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant bits(esize) element1 = Elem[operand, 0, constant bits(esize) element2 = Elem[operand, 1, V[d, esize] = FPMaxNum(element1, element2, FPCR);
```

## C7.2.126 FMAXNMP (vector)

Floating-point maximum number pairwise (vector)

This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements in the two source SIMD&amp;FP registers, writes the largest of each pair of values into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values.

Regardless of the value of FPCR.AH, the behavior is as follows for each pairwise operation:

- Negative zero compares less than positive zero.
- If one element is numeric and the other is a quiet NaN, the result is the numeric value.
- When FPCR.DN is 0, if either element is a signaling NaN or if both elements are NaNs, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a signaling NaN or if both elements are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMAXNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMAXNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; constant bits(2*datasize) concat bits(esize) element1;
```

```
= operand2:operand1; bits(esize) element2;
```

<!-- image -->

&lt;Vn&gt;

```
for e = 0 to elements-1 element1 = Elem[concat, 2*e, esize]; element2 = Elem[concat, (2*e)+1, esize]; Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR); V[d, datasize] = result;
```

## C7.2.127 FMAXNMV

Floating-point maximum number across vector

This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the largest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values.

Regardless of the value of FPCR.AH, the behavior is as follows:

- Negative zero compares less than positive zero.
- If one value is numeric and the other is a quiet NaN, the result is the numeric value.
- When FPCR.DN is 0, if either value is a signaling NaN or if both values are NaNs, the result is a quiet NaN.
- When FPCR.DN is 1, if either value is a signaling NaN or if both values are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMAXNMV <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q);
```

## Single-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

FMAXNMV

S&lt;d&gt;,

&lt;Vn&gt;.4S

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); end if sz:Q != '01' then EndOfDecode(Decode_UNDEF); end // .4S only constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer{} esize = 32; constant integer{} datasize = 64 << UInt(Q);
```

## Assembler Symbols

&lt;V&gt;

Is the destination width specifier, H.

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; V[d, esize] =
```

<!-- image -->

&lt;Vn&gt;

&lt;T&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

```
FPReduce(ReduceOp_FMAXNUM, operand, esize, FPCR);
```

## C7.2.128 FMAXP (scalar)

Floating-point maximum of pair of elements (scalar)

This instruction compares two vector elements in the source SIMD&amp;FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&amp;FP register.

When FPCR.AH is 0, the behavior is as follows for each pairwise operation:

- Negative zero compares less than positive zero.
- When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows for each pairwise operation:

- If both elements are zeros, regardless of the sign of either zero, the result is the second element.
- If either element is a NaN, regardless of the value of FPCR.DN, the result is the second element.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMAXP H<d>, <Vn>.2H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 32;
```

Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMAXP <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize * 2;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the destination width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

&lt;Vn&gt;

&lt;V&gt;

&lt;T&gt;

Is the source arrangement specifier, encoded in 'sz':

|   sz | <T>   |
|------|-------|
|    0 | 2S    |
|    1 | 2D    |

```
esize]; esize];
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant bits(esize) element1 = Elem[operand, 0, constant bits(esize) element2 = Elem[operand, 1, V[d, esize] = FPMax(element1, element2, FPCR);
```

## C7.2.129 FMAXP (vector)

Floating-point maximum pairwise (vector)

This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the larger of each pair of values into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values.

When FPCR.AH is 0, the behavior is as follows for each pairwise operation:

- Negative zero compares less than positive zero.
- When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows for each pairwise operation:

- If both elements are zeros, regardless of the sign of either zero, the result is the second element.
- If either element is a NaN, regardless of the value of FPCR.DN, the result is the second element.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

## (FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

<!-- image -->

&lt;Vn&gt;

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; constant bits(2*datasize) concat = operand2:operand1; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[concat, 2*e, esize]; element2 = Elem[concat, (2*e)+1, esize]; Elem[result, e, esize] = FPMax(element1, element2, V[d, datasize] = result;
```

```
FPCR);
```

## C7.2.130 FMAXV

Floating-point maximum across vector

This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the largest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values.

When FPCR.AH is 0, the behavior is as follows:

- Negative zero compares less than positive zero.
- When FPCR.DN is 0, if either value is a NaN, the result is a quiet NaN.
- When FPCR.DN is 1, if either value is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows:

- If both values are zeros, regardless of the sign of either zero, the result is the second value.
- If either value is a NaN, regardless of the value of FPCR.DN, the result is the second value.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMAXV
```

```
<V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q);
```

## Single-precision (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMAXV S<d>, <Vn>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if sz:Q != '01' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32; constant integer datasize = 64 << UInt(Q);
```

## Assembler Symbols

&lt;V&gt;

Is the destination width specifier, H.

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; V[d, esize] = FPReduce(ReduceOp_FMAX, operand, esize, FPCR);
```

<!-- image -->

&lt;Vn&gt;

&lt;T&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

## C7.2.131 FMIN (vector)

Floating-point minimum (vector)

This instruction compares corresponding elements in the vectors in the two source SIMD&amp;FP registers, places the smaller of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&amp;FP register.

When FPCR.AH is 0, the behavior is as follows:

- Negative zero compares less than positive zero.
- When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows:

- If both elements are zeros, regardless of the sign of either zero, the result is the second element.
- If either element is a NaN, regardless of the value of FPCR.DN, the result is the second element.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

## (FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = bits(datasize) result; bits(esize) element1;
```

```
V[n, datasize]; V[m, datasize]; bits(esize) element2;
```

<!-- image -->

&lt;Vn&gt;

```
for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = FPMin(element1, element2, FPCR); V[d, datasize] = result;
```

## C7.2.132 FMIN (scalar)

Floating-point minimum (scalar)

This instruction compares the first and second source SIMD&amp;FP register values, and writes the smaller of the two floating-point values to the destination SIMD&amp;FP register.

When FPCR.AH is 0, the behavior is as follows:

- Negative zero compares less than positive zero.
- When FPCR.DN is 0, if either value is a NaN, the result is a quiet NaN.
- When FPCR.DN is 1, if either value is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows:

- If both values are zeros, regardless of the sign of either zero, the result is the second value.
- If either value is a NaN, regardless of the value of FPCR.DN, the result is the second value.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11)
```

```
FMIN <Hd>, <Hn>, <Hm>
```

## Encoding for the Single-precision variant

(FEAT\_FP) Applies when (ftype == 00)

```
FMIN <Sd>, <Sn>, <Sm>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FMIN
```

```
<Dd>, <Dn>, <Dm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Sd&gt;

&lt;Sn&gt;

Is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand1 = V[n, esize]; constant bits(esize) operand2 = V[m, esize]; bits(128) result = if IsMerging(FPCR) then V[n, 128] Elem[result, 0, esize] = FPMin(operand1, operand2, FPCR); V[d, 128] = result;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

```
else Zeros(128);
```

## C7.2.133 FMINNM (vector)

Floating-point minimum number (vector)

This instruction compares corresponding vector elements in the two source SIMD&amp;FP registers, writes the smaller of the two floating-point values into a vector, and writes the vector to the destination SIMD&amp;FP register.

Regardless of the value of FPCR.AH, the behavior is as follows:

- Negative zero compares less than positive zero.
- If one element is numeric and the other is a quiet NaN, the result is the numeric value.
- When FPCR.DN is 0, if either element is a signaling NaN or if both elements are NaNs, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a signaling NaN or if both elements are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMINNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMINNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = FPMinNum(element1, element2, V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

```
FPCR);
```

## C7.2.134 FMINNM (scalar)

Floating-point minimum number (scalar)

This instruction compares the first and second source SIMD&amp;FP register values, and writes the smaller of the two floating-point values to the destination SIMD&amp;FP register.

Regardless of the value of FPCR.AH, the behavior is as follows:

- Negative zero compares less than positive zero.
- If one value is numeric and the other is a quiet NaN, the result is the numeric value.
- When FPCR.DN is 0, if either value is a signaling NaN or if both values are NaNs, the result is a quiet NaN.
- When FPCR.DN is 1, if either value is a signaling NaN or if both values are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11)
```

```
FMINNM <Hd>, <Hn>, <Hm>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when
```

```
FMINNM <Sd>,
```

```
(ftype == 00) <Sn>, <Sm>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when
```

```
FMINNM <Dd>,
```

```
(ftype == 01) <Dn>, <Dm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Sd&gt;

&lt;Sn&gt;

Is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand1 = V[n, esize]; constant bits(esize) operand2 = V[m, esize]; bits(128) result = if IsMerging(FPCR) then V[n, 128] else Zeros(128); Elem[result, 0, esize] = FPMinNum(operand1, operand2, FPCR); V[d, 128] = result;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.135 FMINNMP (scalar)

Floating-point minimum number of pair of elements (scalar)

This instruction compares two vector elements in the source SIMD&amp;FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&amp;FP register.

Regardless of the value of FPCR.AH, the behavior is as follows for each pairwise operation:

- Negative zero compares less than positive zero.
- If one element is numeric and the other is a quiet NaN, the result is the numeric value.
- When FPCR.DN is 0, if either element is a signaling NaN or if both elements are NaNs, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a signaling NaN or if both elements are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMINNMP H<d>, <Vn>.2H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 32;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMINNMP <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize * 2;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the destination width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

&lt;Vn&gt;

&lt;V&gt;

&lt;T&gt;

Is the source arrangement specifier, encoded in 'sz':

|   sz | <T>   |
|------|-------|
|    0 | 2S    |
|    1 | 2D    |

```
esize]; esize];
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant bits(esize) element1 = Elem[operand, 0, constant bits(esize) element2 = Elem[operand, 1, V[d, esize] = FPMinNum(element1, element2, FPCR);
```

## C7.2.136 FMINNMP (vector)

Floating-point minimum number pairwise (vector)

This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements in the two source SIMD&amp;FP registers, writes the smallest of each pair of floating-point values into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values.

Regardless of the value of FPCR.AH, the behavior is as follows for each pairwise operation:

- Negative zero compares less than positive zero.
- If one element is numeric and the other is a quiet NaN, the result is the numeric value.
- When FPCR.DN is 0, if either element is a signaling NaN or if both elements are NaNs, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a signaling NaN or if both elements are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMINNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMINNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; constant bits(2*datasize) concat bits(esize) element1;
```

```
= operand2:operand1; bits(esize) element2;
```

<!-- image -->

&lt;Vn&gt;

```
for e = 0 to elements-1 element1 = Elem[concat, 2*e, esize]; element2 = Elem[concat, (2*e)+1, esize]; Elem[result, e, esize] = FPMinNum(element1, element2, FPCR); V[d, datasize] = result;
```

## C7.2.137 FMINNMV

Floating-point minimum number across vector

This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the smallest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values.

Regardless of the value of FPCR.AH, the behavior is as follows:

- Negative zero compares less than positive zero.
- If one value is numeric and the other is a quiet NaN, the result is the numeric value.
- When FPCR.DN is 0, if either value is a signaling NaN or if both values are NaNs, the result is a quiet NaN.
- When FPCR.DN is 1, if either value is a signaling NaN or if both values are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMINNMV <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q);
```

## Single-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

FMINNMV

S&lt;d&gt;,

&lt;Vn&gt;.4S

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); end if sz:Q != '01' then EndOfDecode(Decode_UNDEF); end // .4S only constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer{} esize = 32; constant integer{} datasize = 64 << UInt(Q);
```

## Assembler Symbols

&lt;V&gt;

Is the destination width specifier, H.

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; V[d, esize] =
```

<!-- image -->

&lt;Vn&gt;

&lt;T&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

```
FPReduce(ReduceOp_FMINNUM, operand, esize, FPCR);
```

## C7.2.138 FMINP (scalar)

Floating-point minimum of pair of elements (scalar)

This instruction compares two vector elements in the source SIMD&amp;FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&amp;FP register.

When FPCR.AH is 0, the behavior is as follows for each pairwise operation:

- Negative zero compares less than positive zero.
- When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows for each pairwise operation:

- If both elements are zeros, regardless of the sign of either zero, the result is the second element.
- If either element is a NaN, regardless of the value of FPCR.DN, the result is the second element.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMINP H<d>, <Vn>.2H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 32;
```

Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMINP <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize * 2;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the destination width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

&lt;Vn&gt;

&lt;V&gt;

&lt;T&gt;

Is the source arrangement specifier, encoded in 'sz':

|   sz | <T>   |
|------|-------|
|    0 | 2S    |
|    1 | 2D    |

```
esize]; esize];
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant bits(esize) element1 = Elem[operand, 0, constant bits(esize) element2 = Elem[operand, 1, V[d, esize] = FPMin(element1, element2, FPCR);
```

## C7.2.139 FMINP (vector)

Floating-point minimum pairwise (vector)

This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the smaller of each pair of values into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values.

When FPCR.AH is 0, the behavior is as follows for each pairwise operation:

- Negative zero compares less than positive zero.
- When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN.
- When FPCR.DN is 1, if either element is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows for each pairwise operation:

- If both elements are zeros, regardless of the sign of either zero, the result is the second element.
- If either element is a NaN, regardless of the value of FPCR.DN, the result is the second element.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

## (FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

<!-- image -->

&lt;Vn&gt;

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; constant bits(2*datasize) concat = operand2:operand1; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[concat, 2*e, esize]; element2 = Elem[concat, (2*e)+1, esize]; Elem[result, e, esize] = FPMin(element1, element2, FPCR); V[d, datasize] = result;
```

## C7.2.140 FMINV

Floating-point minimum across vector

This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the smallest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values.

When FPCR.AH is 0, the behavior is as follows:

- Negative zero compares less than positive zero.
- When FPCR.DN is 0, if either value is a NaN, the result is a quiet NaN.
- When FPCR.DN is 1, if either value is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows:

- If both values are zeros, regardless of the sign of either zero, the result is the second value.
- If either value is a NaN, regardless of the value of FPCR.DN, the result is the second value.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMINV
```

```
<V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q);
```

## Single-precision (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMINV S<d>, <Vn>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if sz:Q != '01' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32; constant integer datasize = 64 << UInt(Q);
```

## Assembler Symbols

&lt;V&gt;

Is the destination width specifier, H.

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; V[d, esize] = FPReduce(ReduceOp_FMIN, operand, esize, FPCR);
```

<!-- image -->

&lt;Vn&gt;

&lt;T&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

## C7.2.141 FMLA (by element)

Floating-point fused multiply-add to accumulator (by element)

This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and accumulates the results in the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are floating-point values.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar, half-precision, Scalar, single-precision and double-precision, Vector, half-precision, and Vector, single-precision and double-precision

## Scalar, half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMLA <Hd>, <Hn>, <Vm>.H[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer d = UInt(Rd); constant integer index = UInt(H:L:M); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar, single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMLA <V><d>, <V><n>, <Vm>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; constant bit Rmhi = M; case sz:L of when '0x' index = UInt(H:L); when '10' index = UInt(H); when '11' EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector, half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMLA <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer d = UInt(Rd); constant integer index = UInt(H:L:M); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

Vector, single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); integer index; constant bit Rmhi = M; case sz:L of when '0x' index = UInt(H:L); when '10' index = UInt(H); when '11' EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

For the 'Scalar, half-precision' and 'Vector, half-precision' variants: is the name of the second SIMD&amp;FP source register, in the range V0 to V15, encoded in the 'Rm' field.

For the 'Scalar, single-precision and double-precision' and 'Vector, single-precision and double-precision' variants: is the name of the second SIMD&amp;FP source register, encoded in the 'M:Rm' fields.

## &lt;index&gt;

For the 'Scalar, half-precision' and 'Vector, half-precision' variants: is the element index, in the range 0 to 7, encoded in the 'H:L:M' fields.

For the 'Scalar, single-precision and double-precision' and 'Vector, single-precision and double-precision' variants: is the element index, encoded in 'sz:L:H':

|   sz | L   | <index>   |
|------|-----|-----------|
|    0 | x   | UInt(H:L) |
|    1 | 0   | UInt(H)   |
|    1 | 1   | RESERVED  |

Is a width specifier, encoded in 'sz':

&lt;V&gt;

- &lt;d&gt;
- &lt;n&gt;

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Ts&gt; Is an element size specifier, encoded in 'sz':

&lt;Vn&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

|   sz | <Ts>   |
|------|--------|
|    0 | S      |
|    1 | D      |

- &lt;Vd&gt; Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.
- &lt;T&gt; For the 'Vector, half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector, single-precision and double-precision' variant: is an arrangement specifier, encoded in 'Q:sz':

|   Q |   sz | <T>      |
|-----|------|----------|
|   0 |    0 | 2S       |
|   0 |    1 | RESERVED |
|   1 |    0 | 4S       |
|   1 |    1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; constant bits(datasize) operand3 = V[d, datasize]; bits(esize) element1; constant bits(esize) element2 = Elem[operand2, index, esize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR); V[d, 128] = result;
```

## C7.2.142 FMLA (vector)

Floating-point fused multiply-add to accumulator (vector)

This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&amp;FP registers, adds the product to the corresponding vector element of the destination SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMLA
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMLA
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = constant bits(datasize) operand3 = bits(datasize) result; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize];
```

&lt;T&gt;

&lt;Vn&gt;

```
V[n, datasize]; V[m, datasize]; V[d, datasize];
```

```
Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR); V[d, datasize] = result;
```

## C7.2.143 FMLAL, FMLAL2 (by element)

Floating-point fused multiply-add long to accumulator (by element)

This instruction multiplies the half-precision vector elements in the first source SIMD&amp;FP register by the specified half-precision value in the second source SIMD&amp;FP register, and accumulates the intermediate product without rounding to the corresponding single-precision vector element of the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4, it is mandatory for all implementations to support it.

## Note

ID\_AA64ISAR0\_EL1.FHM indicates whether this instruction is supported.

It has encodings from 2 classes: FMLAL and FMLAL2

## FMLAL

(FEAT\_FHM)

<!-- image -->

## Encoding

```
FMLAL <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FHM) then EndOfDecode(Decode_UNDEF); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt('0':Rm); // Vm can only be in bottom 16 registers. constant integer index = UInt(H:L:M); constant integer esize = 32; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = 0;
```

## FMLAL2

(FEAT\_FHM)

<!-- image -->

## Encoding

```
FMLAL2 <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FHM) then EndOfDecode(Decode_UNDEF); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt('0':Rm); // Vm can only be in bottom 16 registers. constant integer index = UInt(H:L:M); constant integer esize = 32; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = 1;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;index&gt;

Is the element index, encoded in the 'H:L:M' fields.

|   Q | <Tb>   |
|-----|--------|
|   0 | 2H     |
|   1 | 4H     |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize DIV 2) operand1 = Vpart[n, part, datasize DIV 2]; constant bits(128) operand2 = V[m, 128]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; bits(esize DIV 2) element1; constant bits(esize DIV 2) element2 = Elem[operand2, index, esize DIV 2]; for e = 0 to elements-1 element1 = Elem[operand1, e, esize DIV 2]; Elem[result, e, esize] = FPMulAddH(Elem[operand3, V[d, datasize] = result;
```

```
e, esize], element1, element2, FPCR);
```

## C7.2.144 FMLAL, FMLAL2 (vector)

Floating-point fused multiply-add long to accumulator (vector)

This instruction multiplies corresponding half-precision floating-point values in the vectors in the two source SIMD&amp;FP registers, and accumulates the intermediate product without rounding to the corresponding single-precision vector element of the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4, it is mandatory for all implementations to support it.

## Note

ID\_AA64ISAR0\_EL1.FHM indicates whether this instruction is supported.

It has encodings from 2 classes: FMLAL and FMLAL2

## FMLAL

(FEAT\_FHM)

<!-- image -->

## Encoding

```
FMLAL <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FHM) then EndOfDecode(Decode_UNDEF); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = 0;
```

## FMLAL2

(FEAT\_FHM)

<!-- image -->

## Encoding

```
FMLAL2 <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FHM) then EndOfDecode(Decode_UNDEF); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = 1;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

&lt;Vn&gt;

&lt;Tb&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize DIV 2) operand1 = Vpart[n, part, datasize DIV 2]; constant bits(datasize DIV 2) operand2 = Vpart[m, part, datasize DIV 2]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; bits(esize DIV 2) element1; bits(esize DIV 2) element2;
```

|   Q | <Tb>   |
|-----|--------|
|   0 | 2H     |
|   1 | 4H     |

```
for e = 0 to elements-1 element1 = Elem[operand1, e, esize DIV 2]; element2 = Elem[operand2, e, esize DIV 2]; Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR); V[d, datasize] = result;
```

## C7.2.145 FMLALB, FMLALT (by element)

8-bit floating-point multiply-add to half-precision (vector, by element)

This instruction widens the even-numbered (bottom) or odd-numbered (top) 8-bit elements in the first source vector and the indexed element from the second source vector to half-precision format and multiplies the corresponding elements. The intermediate products are scaled by 2 -UInt(FPMR.LSCALE[3:0]) , before being destructively added without intermediate rounding to the half-precision elements of the destination vector that overlap with the corresponding 8-bit floating-point elements in the first source vector.

The 8-bit floating-point encoding format for the elements of the first source vector is selected by FPMR.F8S1. The 8-bit floating-point encoding format for the elements of the second source vector is selected by FPMR.F8S2.

## Advanced SIMD

(FEAT\_FP8FMA)

<!-- image -->

## Encoding for the FMLALB variant

```
Applies when (Q == 0) FMLALB <Vd>.8H, <Vn>.16B, <Vm>.B[<index>]
```

## Encoding for the FMLALT variant

```
Applies when (Q == 1) FMLALT <Vd>.8H,
```

```
<Vn>.16B, <Vm>.B[<index>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP8FMA) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer m = UInt('00':Rm<2:0>); constant integer d = UInt(Rd); constant integer index = UInt(H:L:M:Rm<3>); constant integer elements = 128 DIV 16; constant integer sel = UInt(Q);
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, in the range V0 to V7, encoded in the 'Rm&lt;2:0&gt;' field.

## &lt;index&gt;

Is the element index, in the range 0 to 15, encoded in the 'H:L:M:Rm&lt;3&gt;' fields.

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[n, 128]; constant bits(128) operand2 = V[m, 128]; constant bits(128) operand3 = V[d, 128]; bits(128) result; for e = 0 to elements-1 constant bits(8) element1 = Elem[operand1, 2 * e + sel, 8]; constant bits(8) element2 = Elem[operand2, index, 8]; constant bits(16) element3 = Elem[operand3, e, 16]; Elem[result, e, 16] = FP8MulAddFP(element3, element1, element2, FPCR, V[d, 128] = result;
```

```
FPMR);
```

## C7.2.146 FMLALB, FMLALT (vector)

8-bit floating-point multiply-add to half-precision (vector)

This instruction widens the even-numbered (bottom) or odd-numbered (top) 8-bit elements in the first and second source vectors to half-precision format and multiplies the corresponding elements. The intermediate products are scaled by 2 -UInt(FPMR.LSCALE[3:0]) , before being destructively added without intermediate rounding to the half-precision elements of the destination vector that overlap with the corresponding 8-bit floating-point elements in the source vectors.

The 8-bit floating-point encoding format for the elements of the first source vector is selected by FPMR.F8S1. The 8-bit floating-point encoding format for the elements of the second source vector is selected by FPMR.F8S2.

## Advanced SIMD (FEAT\_FP8FMA)

<!-- image -->

## Encoding for the FMLALB variant

```
Applies when (Q == 0) FMLALB <Vd>.8H, <Vn>.16B, <Vm>.16B
```

## Encoding for the FMLALT variant

```
Applies when (Q == 1) FMLALT <Vd>.8H, <Vn>.16B, <Vm>.16B
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP8FMA) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer elements = 128 DIV 16; constant integer sel = UInt(Q);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

```
EndOfDecode(Decode_UNDEF);
```

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[n, 128]; constant bits(128) operand2 = V[m, 128]; constant bits(128) operand3 = V[d, 128]; bits(128) result; for e = 0 to elements-1 constant bits(8) element1 = Elem[operand1, 2 * e + sel, 8]; constant bits(8) element2 = Elem[operand2, 2 * e + sel, 8]; constant bits(16) element3 = Elem[operand3, e, 16]; Elem[result, e, 16] = FP8MulAddFP(element3, element1, element2, FPCR, V[d, 128] = result;
```

```
FPMR);
```

## C7.2.147 FMLALLBB, FMLALLBT, FMLALLTB, FMLALLTT (by element)

8-bit floating-point multiply-add to single-precision (vector, by element)

This instruction widens the first (bottom bottom), second (bottom top), third (top bottom), or fourth (top top) 8-bit element of each 32-bit container in the first source vector and the indexed element from the second source vector to single-precision format and multiplies the corresponding elements. The intermediate products are scaled by 2 -UInt(FPMR.LSCALE) , before being destructively added without intermediate rounding to the single-precision elements of the destination vector that overlap with the corresponding 8-bit floating-point elements in the first source vector.

The 8-bit floating-point encoding format for the elements of the first source vector is selected by FPMR.F8S1. The 8-bit floating-point encoding format for the elements of the second source vector is selected by FPMR.F8S2.

## Advanced SIMD (FEAT\_FP8FMA)

<!-- image -->

## Encoding for the FMLALLBB variant

```
Applies when (Q == 0 && size == 00) FMLALLBB <Vd>.4S, <Vn>.16B, <Vm>.B[<index>]
```

## Encoding for the FMLALLBT variant

```
Applies when (Q == 0 && size == 01) FMLALLBT <Vd>.4S, <Vn>.16B, <Vm>.B[<index>]
```

## Encoding for the FMLALLTB variant

```
Applies when (Q == 1 && size == 00) FMLALLTB <Vd>.4S,
```

```
<Vn>.16B, <Vm>.B[<index>]
```

## Encoding for the FMLALLTT variant

```
Applies when (Q == 1 && size == 01) FMLALLTT <Vd>.4S,
```

```
<Vn>.16B, <Vm>.B[<index>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP8FMA) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer m = UInt('00':Rm<2:0>); constant integer d = UInt(Rd); constant integer index = UInt(H:L:M:Rm<3>); constant integer elements = 128 DIV 32; constant integer sel = UInt(Q:size<0>);
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, in the range V0 to V7, encoded in the 'Rm&lt;2:0&gt;' field.

## &lt;index&gt;

Is the element index, in the range 0 to 15, encoded in the 'H:L:M:Rm&lt;3&gt;' fields.

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[n, 128]; constant bits(128) operand2 = V[m, 128]; constant bits(128) operand3 = V[d, 128]; bits(128) result; for e = 0 to elements-1 constant bits(8) element1 = Elem[operand1, 4 * e + sel, 8]; constant bits(8) element2 = Elem[operand2, index, 8]; constant bits(32) element3 = Elem[operand3, e, 32]; Elem[result, e, 32] = FP8MulAddFP(element3, element1, element2, FPCR, FPMR); V[d, 128] = result;
```

## C7.2.148 FMLALLBB, FMLALLBT, FMLALLTB, FMLALLTT (vector)

8-bit floating-point multiply-add to single-precision (vector)

This instruction widens the first (bottom bottom), second (bottom top), third (top bottom), or fourth (top top) 8-bit element of each 32-bit container in the first and second source vectors to single-precision format and multiplies the corresponding elements. The intermediate products are scaled by 2 -UInt(FPMR.LSCALE) , before being destructively added without intermediate rounding to the single-precision elements of the destination vector that overlap with the corresponding 8-bit floating-point elements in the source vectors.

The 8-bit floating-point encoding format for the elements of the first source vector is selected by FPMR.F8S1. The 8-bit floating-point encoding format for the elements of the second source vector is selected by FPMR.F8S2.

## Advanced SIMD

(FEAT\_FP8FMA)

<!-- image -->

## Encoding for the FMLALLBB variant

```
Applies when (Q == 0 && size == 00) FMLALLBB <Vd>.4S, <Vn>.16B, <Vm>.16B
```

## Encoding for the FMLALLBT variant

```
Applies when (Q == 0 && size == 01) FMLALLBT <Vd>.4S, <Vn>.16B, <Vm>.16B
```

## Encoding for the FMLALLTB variant

```
== 00)
```

```
Applies when (Q == 1 && size FMLALLTB <Vd>.4S, <Vn>.16B, <Vm>.16B
```

## Encoding for the FMLALLTT variant

```
== 01)
```

```
Applies when (Q == 1 && size FMLALLTT <Vd>.4S, <Vn>.16B, <Vm>.16B
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP8FMA) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer elements = 128 DIV 32; constant integer sel = UInt(Q:size<0>);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[n, 128]; constant bits(128) operand2 = V[m, 128]; constant bits(128) operand3 = V[d, 128]; bits(128) result; for e = 0 to elements-1 constant bits(8) element1 = Elem[operand1, 4 * e + sel, 8]; constant bits(8) element2 = Elem[operand2, 4 * e + sel, 8]; constant bits(32) element3 = Elem[operand3, e, 32]; Elem[result, e, 32] = FP8MulAddFP(element3, element1, element2, FPCR, FPMR); V[d, 128] = result;
```

## C7.2.149 FMLS (by element)

Floating-point fused multiply-subtract from accumulator (by element)

This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and subtracts the results from the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are floating-point values.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar, half-precision, Scalar, single-precision and double-precision, Vector, half-precision, and Vector, single-precision and double-precision

## Scalar, half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMLS
```

```
<Hd>, <Hn>, <Vm>.H[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer d = UInt(Rd); constant integer index = UInt(H:L:M); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar, single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMLS <V><d>, <V><n>, <Vm>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); integer index; constant bit Rmhi = M; case sz:L of when '0x' index = UInt(H:L); when '10' index = UInt(H); when '11' EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector, half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMLS <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer d = UInt(Rd); constant integer index = UInt(H:L:M); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

Vector, single-precision and double-precision (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMLS <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); integer index; constant bit Rmhi = M; case sz:L of when '0x' index = UInt(H:L); when '10' index = UInt(H); when '11' EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

For the 'Scalar, half-precision' and 'Vector, half-precision' variants: is the name of the second SIMD&amp;FP source register, in the range V0 to V15, encoded in the 'Rm' field.

For the 'Scalar, single-precision and double-precision' and 'Vector, single-precision and double-precision' variants: is the name of the second SIMD&amp;FP source register, encoded in the 'M:Rm' fields.

## &lt;index&gt;

For the 'Scalar, half-precision' and 'Vector, half-precision' variants: is the element index, in the range 0 to 7, encoded in the 'H:L:M' fields.

For the 'Scalar, single-precision and double-precision' and 'Vector, single-precision and double-precision' variants: is the element index, encoded in 'sz:L:H':

|   sz | L   | <index>   |
|------|-----|-----------|
|    0 | x   | UInt(H:L) |
|    1 | 0   | UInt(H)   |
|    1 | 1   | RESERVED  |

Is a width specifier, encoded in 'sz':

&lt;V&gt;

- &lt;d&gt;
- &lt;n&gt;

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Ts&gt; Is an element size specifier, encoded in 'sz':

&lt;Vn&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

|   sz | <Ts>   |
|------|--------|
|    0 | S      |
|    1 | D      |

- &lt;Vd&gt; Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.
- &lt;T&gt; For the 'Vector, half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector, single-precision and double-precision' variant: is an arrangement specifier, encoded in 'Q:sz':

|   Q |   sz | <T>      |
|-----|------|----------|
|   0 |    0 | 2S       |
|   0 |    1 | RESERVED |
|   1 |    0 | 4S       |
|   1 |    1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; constant bits(datasize) operand3 = V[d, datasize]; bits(esize) element1; constant bits(esize) element2 = Elem[operand2, index, esize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); for e = 0 to elements-1 element1 = FPNeg(Elem[operand1, e, esize], FPCR); Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR); V[d, 128] = result;
```

## C7.2.150 FMLS (vector)

Floating-point fused multiply-subtract from accumulator (vector)

This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&amp;FP registers, negates the product, adds the result to the corresponding vector element of the destination SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMLS
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMLS
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = FPNeg(Elem[operand1, e, esize], FPCR); element2 = Elem[operand2, e, esize];
```

&lt;T&gt;

&lt;Vn&gt;

```
Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR); V[d, datasize] = result;
```

## C7.2.151 FMLSL, FMLSL2 (by element)

Floating-point fused multiply-subtract long from accumulator (by element)

This instruction multiplies the negated half-precision vector elements in the first source SIMD&amp;FP register by the specified half-precision value in the second source SIMD&amp;FP register, and accumulates the intermediate product without rounding to the corresponding single-precision vector element of the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4, it is mandatory for all implementations to support it.

## Note

ID\_AA64ISAR0\_EL1.FHM indicates whether this instruction is supported.

It has encodings from 2 classes: FMLSL and FMLSL2

## FMLSL

(FEAT\_FHM)

<!-- image -->

## Encoding

```
FMLSL <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FHM) then EndOfDecode(Decode_UNDEF); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt('0':Rm); // Vm can only be in bottom 16 registers. constant integer index = UInt(H:L:M); constant integer esize = 32; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = 0;
```

## FMLSL2 (FEAT\_FHM)

<!-- image -->

## Encoding

```
FMLSL2 <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FHM) then EndOfDecode(Decode_UNDEF); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt('0':Rm); // Vm can only be in bottom 16 registers. constant integer index = UInt(H:L:M); constant integer esize = 32; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = 1;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;index&gt;

Is the element index, encoded in the 'H:L:M' fields.

|   Q | <Tb>   |
|-----|--------|
|   0 | 2H     |
|   1 | 4H     |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize DIV 2) operand1 = Vpart[n, part, datasize DIV 2]; constant bits(128) operand2 = V[m, 128]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; bits(esize DIV 2) element1; constant bits(esize DIV 2) element2 = Elem[operand2, index, esize DIV 2]; for e = 0 to elements-1 element1 = FPNeg(Elem[operand1, e, esize DIV 2], FPCR); Elem[result, e, esize] = FPMulAddH(Elem[operand3, V[d, datasize] = result;
```

```
e, esize], element1, element2, FPCR);
```

## C7.2.152 FMLSL, FMLSL2 (vector)

Floating-point fused multiply-subtract long from accumulator (vector)

This instruction negates the half-precision values in the vector of one SIMD&amp;FP register, multiplies these with the corresponding half-precision values in another vector, and accumulates the intermediate product without rounding to the corresponding single-precision vector element of the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4, it is mandatory for all implementations to support it.

## Note

ID\_AA64ISAR0\_EL1.FHM indicates whether this instruction is supported.

It has encodings from 2 classes: FMLSL and FMLSL2

## FMLSL

(FEAT\_FHM)

<!-- image -->

## Encoding

```
FMLSL <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FHM) then EndOfDecode(Decode_UNDEF); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = 0;
```

## FMLSL2

(FEAT\_FHM)

<!-- image -->

## Encoding

```
FMLSL2 <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FHM) then EndOfDecode(Decode_UNDEF); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = 1;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

&lt;Vn&gt;

&lt;Tb&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize DIV 2) operand1 = Vpart[n, part, datasize DIV 2]; constant bits(datasize DIV 2) operand2 = Vpart[m, part, datasize DIV 2]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; bits(esize DIV 2) element1; bits(esize DIV 2) element2;
```

|   Q | <Tb>   |
|-----|--------|
|   0 | 2H     |
|   1 | 4H     |

```
for e = 0 to elements-1 element1 = FPNeg(Elem[operand1, e, esize DIV 2], FPCR); element2 = Elem[operand2, e, esize DIV 2]; Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR); V[d, datasize] = result;
```

## C7.2.153 FMMLA (widening, 8-bit floating-point to half-precision)

8-bit floating-point matrix multiply-accumulate to half-precision

This instruction performs the fused sum-of-products within each four adjacent 8-bit elements while multiplying the 2 × 4 matrix of 8-bit floating-point values held in each 64-bit segment of the first source vector by the 4 × 2 matrix of 8-bit floating-point values in the corresponding segment of the second source vector. The half-precision sum-of-products are scaled by 2 -UInt(FPMR.LSCALE[3:0]) , before being destructively added without intermediate rounding to the 2x2 half-precision matrix in the destination vector. This is equivalent to accumulating 4-way dot product per destination element.

The 8-bit floating-point encoding format for the elements of the first source vector is selected by FPMR.F8S1. The 8-bit floating-point encoding format for the elements of the second source vector is selected by FPMR.F8S2.

## Advanced SIMD

(FEAT\_F8F16MM)

<!-- image -->

## Encoding

```
FMMLA <Vd>.8H, <Vn>.16B, <Vm>.16B
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_F8F16MM) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer d = UInt(Rd);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP third source and destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = constant bits(128) operand2 = constant bits(128) operand3 = bits(128) result; bits(64) op1, op2, acc; for s = 0 to 1 op1 = Elem[operand1, s, 64]; op2 = Elem[operand2, s, 64];
```

```
V[n, 128]; V[m, 128]; V[d, 128];
```

```
acc = Elem[operand3, s, 64]; Elem[result, s, 64] = FP8MatMulAddFP(acc, op1, op2, 4, FPCR, FPMR); V[d, 128] = result;
```

## C7.2.154 FMMLA (widening, 8-bit floating-point to single-precision)

8-bit floating-point matrix multiply-accumulate to single-precision

This instruction performs the fused sum-of-products within each eight adjacent 8-bit elements while multiplying the 2 × 8 matrix of 8-bit floating-point values in the first source vector by the 8 × 2 matrix of 8-bit floating-point values in the second source vector. The single-precision sum-of-products are scaled by 2 -UInt(FPMR.LSCALE) , before being destructively added without intermediate rounding to the 2x2 single-precision matrix in the destination vector. This is equivalent to accumulating 8-way dot product per destination element.

The 8-bit floating-point encoding format for the elements of the first source vector is selected by FPMR.F8S1. The 8-bit floating-point encoding format for the elements of the second source vector is selected by FPMR.F8S2.

## Advanced SIMD

(FEAT\_F8F32MM)

<!-- image -->

## Encoding

```
FMMLA <Vd>.4S, <Vn>.16B, <Vm>.16B
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_F8F32MM) then EndOfDecode(Decode_UNDEF);
```

```
constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer d = UInt(Rd);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP third source and destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
CheckFPMREnabled(); AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) op1 = V[n, 128]; constant bits(128) op2 = V[m, 128]; constant bits(128) acc = V[d, 128]; V[d, 128] = FP8MatMulAddFP(acc, op1, op2, 8, FPCR, FPMR);
```

## C7.2.155 FMOV (vector, immediate)

Floating-point move immediate (vector)

This instruction copies an immediate floating-point constant into every element of the SIMD&amp;FP destination register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMOV <Vd>.<T>, #<imm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer rd = UInt(Rd); constant integer datasize = 64 << UInt(Q); constant bits(8) imm8 = a:b:c:d:e:f:g:h; constant bits(16) imm16 = imm8<7>:NOT(imm8<6>):Replicate(imm8<6>, 2):imm8<5:0>:Zeros(6); constant bits(datasize) imm = Replicate(imm16, datasize DIV 16);
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the Single-precision variant

```
Applies when (op == 0) FMOV <Vd>.<T>, #<imm>
```

## Encoding for the Double-precision variant

```
Applies when
```

```
(Q == 1 && op == 1) FMOV <Vd>.2D, #<imm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if cmode:op == '11111' then // FMOV Dn,#imm is in main FP instruction set if Q == '0' then EndOfDecode(Decode_UNDEF); constant integer rd = UInt(Rd); constant integer datasize = 64 << UInt(Q); constant bits(64) imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h); constant bits(datasize) imm = Replicate(imm64, datasize DIV 64);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 2S    |
|   1 | 4S    |

<!-- image -->

## &lt;imm&gt;

Is a signed floating-point constant with 3-bit exponent and normalized 4 bits of precision, encoded in 'a:b:c:d:e:f:g:h'. For details of the range of constants available and the encoding of &lt;imm&gt; , see Modified immediate constants in A64 floating-point instructions.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); V[rd, datasize] = imm;
```

## C7.2.156 FMOV (register)

Floating-point move register without conversion

This instruction copies the floating-point value in the SIMD&amp;FP source register to the SIMD&amp;FP destination register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11)
```

```
FMOV <Hd>, <Hn>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FMOV <Sd>, <Sn>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FMOV <Dd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

&lt;Sd&gt;

&lt;Sn&gt;

&lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; bits(128) result = Zeros(128); Elem[result, 0, esize] = operand; V[d, 128] = result;
```

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.157 FMOV (general)

Floating-point move to or from general-purpose register without conversion

This instruction transfers the contents of a SIMD&amp;FP register to a general-purpose register, or the contents of a general-purpose register to a SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision to 32-bit variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11 && rmode == 00 && opcode == 110)
```

```
FMOV <Wd>, <Hn>
```

## Encoding for the Half-precision to 64-bit variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11 && rmode == 00 && opcode == 110)
```

```
FMOV <Xd>, <Hn>
```

## Encoding for the 32-bit to half-precision variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11 && rmode == 00 && opcode == 111)
```

```
FMOV <Hd>, <Wn>
```

## Encoding for the 32-bit to single-precision variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00 && rmode == 00 && opcode == 111)
```

```
FMOV <Sd>, <Wn>
```

## Encoding for the Single-precision to 32-bit variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00 && rmode == 00 && opcode == 110)
```

```
FMOV <Wd>, <Sn>
```

## Encoding for the 64-bit to half-precision variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11 && rmode == 00 && opcode == 111)
```

```
FMOV <Hd>, <Xn>
```

## Encoding for the 64-bit to double-precision variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01 && rmode == 00 && opcode == 111)
```

```
FMOV <Dd>, <Xn>
```

## Encoding for the 64-bit to top half of 128-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 10 && rmode == 01 && opcode == 111)
```

```
FMOV <Vd>.D[1], <Xn>
```

## Encoding for the Double-precision to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01 && rmode == 00 && opcode == 110)
```

```
FMOV <Xd>, <Dn>
```

## Encoding for the Top half of 128-bit to 64-bit variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 10 && rmode == 01 && opcode == 110)
```

```
FMOV <Xd>, <Vn>.D[1]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' && opcode<2:1>:rmode != '11 01' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = if ftype == '10' then 64 else (8 << UInt(ftype EOR '10')); constant integer part = UInt(rmode<0>); FPConvOp op; case opcode<2:1>:rmode of when '11 00' // FMOV if fltsize != 16 && fltsize != intsize then EndOfDecode(Decode_UNDEF); op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI; when '11 01' // FMOV D[1] if intsize != 64 || ftype != '10' then EndOfDecode(Decode_UNDEF); op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI; otherwise Unreachable();
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

- &lt;Xd&gt;
- &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Sd&gt;

&lt;Sn&gt;

&lt;Xn&gt;

&lt;Dd&gt;

&lt;Vd&gt;

## &lt;Dn&gt;

&lt;Vn&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(fltsize) fltval; bits(intsize) intval; case op of when FPConvOp_MOV_FtoI fltval = Vpart[n, part, fltsize]; X[d, intsize] = ZeroExtend(fltval, intsize); when FPConvOp_MOV_ItoF intval = X[n, intsize]; Vpart[d, part, fltsize] = intval<fltsize-1:0>; otherwise Unreachable();
```

## Operational Information

If FEAT\_SME is implemented and the PE is in Streaming SVE mode, then any subsequent instruction which is dependent on the general-purpose register written by this instruction might be significantly delayed.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.158 FMOV (scalar, immediate)

Floating-point move immediate (scalar)

This instruction copies a floating-point immediate constant into the SIMD&amp;FP destination register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11)
```

```
FMOV <Hd>, #<imm>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FMOV <Sd>, #<imm>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FMOV <Dd>, #<imm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer datasize = 8 << UInt(ftype EOR '10'); constant bits(datasize) imm = VFPExpandImm(imm8, datasize);
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;imm&gt;

Is a signed floating-point constant with 3-bit exponent and normalized 4 bits of precision, encoded in the 'imm8' field. For details of the range of constants available and the encoding of &lt;imm&gt; , see Modified immediate constants in A64 floating-point instructions.

<!-- image -->

## &lt;Dd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

<!-- image -->

## C7.2.159 FMSUB

Floating-point fused multiply-subtract (scalar)

This instruction multiplies the values of the first two SIMD&amp;FP source registers, negates the product, adds that to the value of the third SIMD&amp;FP source register, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

(FEAT\_FP16) Applies when (ftype == 11)

```
FMSUB <Hd>, <Hn>, <Hm>, <Ha>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FMSUB <Sd>, <Sn>, <Sm>, <Sa>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when
```

```
FMSUB <Dd>, <Dn>, <Dm>,
```

```
(ftype == 01) <Da>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer a = UInt(Ra); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Ha&gt;

## &lt;Sd&gt;

## &lt;Sn&gt;

Is the 32-bit name of the first SIMD&amp;FP source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register holding the multiplier, encoded in the 'Rm' field.

&lt;Sa&gt;

## &lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Da&gt;

Is the 64-bit name of the third SIMD&amp;FP source register holding the minuend, encoded in the 'Ra' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) addend = V[a, esize]; constant bits(esize) operand1 = FPNeg(V[n, esize], FPCR); constant bits(esize) operand2 = V[m, esize]; bits(128) result = if IsMerging(FPCR) then V[a, 128] else Zeros(128); Elem[result, 0, esize] = FPMulAdd(addend, operand1, operand2, FPCR); V[d, 128] = result;
```

Is the 16-bit name of the third SIMD&amp;FP source register holding the minuend, encoded in the 'Ra' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the third SIMD&amp;FP source register holding the minuend, encoded in the 'Ra' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.160 FMUL (by element)

Floating-point multiply (by element)

This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar, half-precision, Scalar, single-precision and double-precision, Vector, half-precision, and Vector, single-precision and double-precision

## Scalar, half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMUL <Hd>, <Hn>, <Vm>.H[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer index = UInt(H:L:M); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

## Scalar, single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMUL <V><d>, <V><n>, <Vm>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; constant bit Rmhi = M; case sz:L of when '0x' index = UInt(H:L); when '10' index = UInt(H); when '11' EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector, half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer index = UInt(H:L:M); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

Vector, single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; constant bit Rmhi = M; case sz:L of when '0x' index = UInt(H:L); when '10' index = UInt(H); when '11' EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

For the 'Scalar, half-precision' and 'Vector, half-precision' variants: is the name of the second SIMD&amp;FP source register, in the range V0 to V15, encoded in the 'Rm' field.

For the 'Scalar, single-precision and double-precision' and 'Vector, single-precision and double-precision' variants: is the name of the second SIMD&amp;FP source register, encoded in the 'M:Rm' fields.

## &lt;index&gt;

For the 'Scalar, half-precision' and 'Vector, half-precision' variants: is the element index, in the range 0 to 7, encoded in the 'H:L:M' fields.

For the 'Scalar, single-precision and double-precision' and 'Vector, single-precision and double-precision' variants: is the element index, encoded in 'sz:L:H':

|   sz | L   | <index>   |
|------|-----|-----------|
|    0 | x   | UInt(H:L) |
|    1 | 0   | UInt(H)   |
|    1 | 1   | RESERVED  |

Is a width specifier, encoded in 'sz':

## &lt;V&gt;

- &lt;d&gt;
- &lt;n&gt;

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Ts&gt; Is an element size specifier, encoded in 'sz':

&lt;Vn&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

|   sz | <Ts>   |
|------|--------|
|    0 | S      |
|    1 | D      |

- &lt;Vd&gt; Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.
- &lt;T&gt; For the 'Vector, half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector, single-precision and double-precision' variant: is an arrangement specifier, encoded in 'Q:sz':

|   Q |   sz | <T>      |
|-----|------|----------|
|   0 |    0 | 2S       |
|   0 |    1 | RESERVED |
|   1 |    0 | 4S       |
|   1 |    1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; bits(esize) element1; constant bits(esize) element2 = Elem[operand2, index, constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[n, 128] else Zeros(128); for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; Elem[result, e, esize] = FPMul(element1, element2, V[d, 128] = result;
```

```
esize]; FPCR);
```

## C7.2.161 FMUL (vector)

Floating-point multiply (vector)

This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&amp;FP registers, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = FPMul(element1, element2,
```

&lt;T&gt;

&lt;Vn&gt;

```
FPCR);
```

V[d, datasize] = result;

## C7.2.162 FMUL (scalar)

Floating-point multiply (scalar)

This instruction multiplies the floating-point values of the two source SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

(FEAT\_FP16) Applies when (ftype == 11)

```
FMUL <Hd>, <Hn>, <Hm>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FMUL <Sd>, <Sn>, <Sm>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FMUL <Dd>, <Dn>, <Dm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Sd&gt;

&lt;Sn&gt;

Is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand1 = V[n, esize]; constant bits(esize) operand2 = V[m, esize]; bits(128) result = if IsMerging(FPCR) then V[n, 128] Elem[result, 0, esize] = FPMul(operand1, operand2, FPCR); V[d, 128] = result;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

```
else Zeros(128);
```

## C7.2.163 FMULX (by element)

Floating-point multiply extended (by element)

This instruction multiplies the floating-point values in the vector elements in the first source SIMD&amp;FP register by the specified floating-point value in the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register.

If one value is zero and the other value is infinite, the result is 2.0. In this case, the result is negative if only one of the values is negative, otherwise the result is positive.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar, half-precision, Scalar, single-precision and double-precision, Vector, half-precision, and Vector, single-precision and double-precision

## Scalar, half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMULX <Hd>, <Hn>, <Vm>.H[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer index = UInt(H:L:M); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

## Scalar, single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMULX <V><d>, <V><n>, <Vm>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); integer index; constant bit Rmhi = M; case sz:L of when '0x' index = UInt(H:L); when '10' index = UInt(H); when '11' EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector, half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer index = UInt(H:L:M); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

Vector, single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; constant bit Rmhi = M; case sz:L of when '0x' index = UInt(H:L); when '10' index = UInt(H); when '11' EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

For the 'Scalar, half-precision' and 'Vector, half-precision' variants: is the name of the second SIMD&amp;FP source register, in the range V0 to V15, encoded in the 'Rm' field.

For the 'Scalar, single-precision and double-precision' and 'Vector, single-precision and double-precision' variants: is the name of the second SIMD&amp;FP source register, encoded in the 'M:Rm' fields.

## &lt;index&gt;

For the 'Scalar, half-precision' and 'Vector, half-precision' variants: is the element index, in the range 0 to 7, encoded in the 'H:L:M' fields.

For the 'Scalar, single-precision and double-precision' and 'Vector, single-precision and double-precision' variants: is the element index, encoded in 'sz:L:H':

|   sz | L   | <index>   |
|------|-----|-----------|
|    0 | x   | UInt(H:L) |
|    1 | 0   | UInt(H)   |
|    1 | 1   | RESERVED  |

Is a width specifier, encoded in 'sz':

&lt;V&gt;

- &lt;d&gt;
- &lt;n&gt;

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Ts&gt; Is an element size specifier, encoded in 'sz':

&lt;Vn&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

|   sz | <Ts>   |
|------|--------|
|    0 | S      |
|    1 | D      |

- &lt;Vd&gt; Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.
- &lt;T&gt; For the 'Vector, half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector, single-precision and double-precision' variant: is an arrangement specifier, encoded in 'Q:sz':

|   Q |   sz | <T>      |
|-----|------|----------|
|   0 |    0 | 2S       |
|   0 |    1 | RESERVED |
|   1 |    0 | 4S       |
|   1 |    1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; bits(esize) element1; constant bits(esize) element2 = Elem[operand2, index, esize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[n, 128] else Zeros(128); for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; Elem[result, e, esize] = FPMulX(element1, element2, FPCR); V[d, 128] = result;
```

## C7.2.164 FMULX

Floating-point multiply extended

This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&amp;FP registers, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&amp;FP register.

If one value is zero and the other value is infinite, the result is 2.0. In this case, the result is negative if only one of the values is negative, otherwise the result is positive.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMULX <Hd>, <Hn>, <Hm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

FMULX

&lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

- &lt;V&gt;

Is a width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

- &lt;d&gt; Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.
- &lt;n&gt;

&lt;m&gt;

- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz | Q <T>   |
|------|---------|
|    0 | 0 2S    |

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
if elements == 1 then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(esize) element1; bits(esize) element2; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[n, 128] else Zeros(128); for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = FPMulX(element1, element2, FPCR); V[d, 128] = result;
```

## C7.2.165 FNEG (vector)

Floating-point negate (vector)

This instruction negates the value of each vector element in the source SIMD&amp;FP register, writes the result to a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

<!-- image -->

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FNEG <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; for e = 0 to elements-1 constant bits(esize) element = Elem[operand, e, esize]; Elem[result, e, esize] = FPNeg(element, FPCR); V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

## C7.2.166 FNEG (scalar)

Floating-point negate (scalar)

This instruction negates the value in the SIMD&amp;FP source register and writes the result to the SIMD&amp;FP destination register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

(FEAT\_FP16) Applies when (ftype == 11)

```
FNEG <Hd>, <Hn>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FNEG <Sd>, <Sn>
```

## Encoding for the Double-precision variant

(FEAT\_FP) Applies when (ftype == 01)

```
FNEG <Dd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hn&gt;

## &lt;Sd&gt;

<!-- image -->

## &lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPNeg(operand, FPCR); V[d, 128] = result;
```

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.167 FNMADD

Floating-point negated fused multiply-add (scalar)

This instruction multiplies the values of the first two SIMD&amp;FP source registers, negates the product, subtracts the value of the third SIMD&amp;FP source register, and writes the result to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

(FEAT\_FP16) Applies when (ftype == 11)

```
FNMADD <Hd>, <Hn>, <Hm>, <Ha>
```

## Encoding for the Single-precision variant

(FEAT\_FP) Applies when (ftype == 00)

```
FNMADD <Sd>, <Sn>, <Sm>, <Sa>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FNMADD <Dd>, <Dn>, <Dm>, <Da>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer a = UInt(Ra); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Ha&gt;

&lt;Sd&gt;

## &lt;Sn&gt;

Is the 32-bit name of the first SIMD&amp;FP source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register holding the multiplier, encoded in the 'Rm' field.

&lt;Sa&gt;

## &lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Da&gt;

Is the 64-bit name of the third SIMD&amp;FP source register holding the addend, encoded in the 'Ra' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) addend = FPNeg(V[a, esize], FPCR); constant bits(esize) operand1 = FPNeg(V[n, esize], FPCR); constant bits(esize) operand2 = V[m, esize]; bits(128) result = if IsMerging(FPCR) then V[a, 128] else Zeros(128); Elem[result, 0, esize] = FPMulAdd(addend, operand1, operand2, FPCR); V[d, 128] = result;
```

Is the 16-bit name of the third SIMD&amp;FP source register holding the addend, encoded in the 'Ra' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the third SIMD&amp;FP source register holding the addend, encoded in the 'Ra' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.168 FNMSUB

Floating-point negated fused multiply-subtract (scalar)

This instruction multiplies the values of the first two SIMD&amp;FP source registers, subtracts the value of the third SIMD&amp;FP source register, and writes the result to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

(FEAT\_FP16) Applies when (ftype == 11)

```
FNMSUB <Hd>, <Hn>, <Hm>, <Ha>
```

## Encoding for the Single-precision variant

(FEAT\_FP) Applies when (ftype == 00)

```
FNMSUB <Sd>, <Sn>, <Sm>, <Sa>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FNMSUB <Dd>, <Dn>, <Dm>, <Da>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer a = UInt(Ra); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Ha&gt;

## &lt;Sd&gt;

## &lt;Sn&gt;

Is the 32-bit name of the first SIMD&amp;FP source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register holding the multiplier, encoded in the 'Rm' field.

&lt;Sa&gt;

## &lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Da&gt;

Is the 64-bit name of the third SIMD&amp;FP source register holding the minuend, encoded in the 'Ra' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) addend = FPNeg(V[a, esize], FPCR); constant bits(esize) operand1 = V[n, esize]; constant bits(esize) operand2 = V[m, esize]; bits(128) result = if IsMerging(FPCR) then V[a, 128] else Zeros(128); Elem[result, 0, esize] = FPMulAdd(addend, operand1, operand2, FPCR); V[d, 128] = result;
```

Is the 16-bit name of the third SIMD&amp;FP source register holding the minuend, encoded in the 'Ra' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the third SIMD&amp;FP source register holding the minuend, encoded in the 'Ra' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.169 FNMUL (scalar)

Floating-point multiply-negate (scalar)

This instruction multiplies the floating-point values of the two source SIMD&amp;FP registers, and writes the negation of the result to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

(FEAT\_FP16) Applies when (ftype == 11)

```
FNMUL <Hd>, <Hn>, <Hm>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FNMUL <Sd>, <Sn>, <Sm>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FNMUL <Dd>, <Dn>, <Dm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Sd&gt;

&lt;Sn&gt;

Is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand1 = V[n, esize]; constant bits(esize) operand2 = V[m, esize]; bits(128) result = if IsMerging(FPCR) then V[n, 128] else Zeros(128); constant bits(esize) product = FPMul(operand1, operand2, FPCR); Elem[result, 0, esize] = FPNeg(product, FPCR); V[d, 128] = result;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.170 FRECPE

Floating-point reciprocal estimate

This instruction finds an approximate reciprocal estimate for each vector element in the source SIMD&amp;FP register, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRECPE <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

FRECPE

&lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRECPE <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FRECPE <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

&lt;V&gt;

&lt;Vn&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

- &lt;d&gt; Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); for e = 0 to elements-1 constant bits(esize) element = Elem[operand, e, esize]; Elem[result, e, esize] = FPRecipEstimate(element, FPCR); V[d, 128] = result;
```

## C7.2.171 FRECPS

Floating-point reciprocal step

This instruction multiplies the corresponding floating-point values in the vectors of the two source SIMD&amp;FP registers, subtracts each of the products from 2.0, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRECPS <Hd>, <Hn>, <Hm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar single-precision and double-precision (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FRECPS
```

```
<V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRECPS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FRECPS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

- &lt;V&gt;

&lt;d&gt;

- &lt;n&gt;
- &lt;m&gt;
- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz | Q <T>   |
|------|---------|
|    0 | 0 2S    |

Is a width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
if elements == 1 then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(esize) element1; bits(esize) element2; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[n, 128] else Zeros(128); for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = FPRecipStepFused(element1, element2, FPCR); V[d, 128] = result;
```

## C7.2.172 FRECPX

Floating-point reciprocal exponent (scalar)

This instruction finds an approximate reciprocal exponent for the source SIMD&amp;FP register and writes the result to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRECPX <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16;
```

Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FRECPX <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz);
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

## &lt;Hn&gt;

&lt;V&gt;

&lt;d&gt;

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPRecpX(operand, FPCR); V[d, 128] = result;
```

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.173 FRINT32X (vector)

Floating-point round to 32-bit integer, using current rounding mode (vector)

This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values that fit into a 32-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register.

Azero input returns a zero result with the same sign. When one of the result values is not numerically equal to the corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the instruction returns for the corresponding result value the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

Vector single-precision and double-precision

(FEAT\_FRINTTS)

<!-- image -->

## Encoding

```
FRINT32X <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FRINTTS) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer intsize = 32;
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'sz:Q':

|   sz | Q <T>   |
|------|---------|
|    0 | 0 2S    |

&lt;T&gt;

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; constant FPRounding rounding = FPRoundingMode(FPCR); bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize); V[d, datasize] = result;
```

## C7.2.174 FRINT32X (scalar)

Floating-point round to 32-bit integer, using current rounding mode (scalar)

This instruction rounds a floating-point value in the SIMD&amp;FP source register to an integral floating-point value that fits into a 32-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register.

Azero input returns a zero result with the same sign. When the result value is not numerically equal to the input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FRINTTS)

<!-- image -->

## Encoding for the Single-precision variant

```
Applies when (ftype ==
```

```
00) FRINT32X <Sd>, <Sn>
```

## Encoding for the Double-precision variant

```
Applies when (ftype ==
```

```
01)
```

```
FRINT32X <Dd>,
```

```
<Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FRINTTS) then EndOfDecode(Decode_UNDEF);
```

```
if ftype IN {'1x'} then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(ftype<0>); constant integer intsize = 32;
```

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Sn&gt;

&lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; constant FPRounding rounding = FPRoundingMode(FPCR); bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPRoundIntN(operand, FPCR, rounding, intsize); V[d, 128] = result;
```

## C7.2.175 FRINT32Z (vector)

Floating-point round to 32-bit integer toward zero (vector)

This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values that fit into a 32-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input returns a zero result with the same sign. When one of the result values is not numerically equal to the corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the instruction returns for the corresponding result value the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector single-precision and double-precision

(FEAT\_FRINTTS)

<!-- image -->

## Encoding

```
FRINT32Z <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FRINTTS) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer intsize = 32; constant FPRounding rounding = FPRounding_ZERO;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'sz:Q':

<!-- image -->

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize); V[d, datasize] = result;
```

## C7.2.176 FRINT32Z (scalar)

Floating-point round to 32-bit integer toward zero (scalar)

This instruction rounds a floating-point value in the SIMD&amp;FP source register to an integral floating-point value that fits into a 32-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input returns a zero result with the same sign. When the result value is not numerically equal to the input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FRINTTS)

<!-- image -->

## Encoding for the Single-precision variant

```
Applies when (ftype == 00) FRINT32Z <Sd>, <Sn>
```

## Encoding for the Double-precision variant

```
Applies when
```

```
(ftype == FRINT32Z <Dd>, <Dn>
```

```
01)
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FRINTTS) then EndOfDecode(Decode_UNDEF);
```

```
if ftype IN {'1x'} then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(ftype<0>); constant integer intsize = 32; constant FPRounding rounding = FPRounding_ZERO;
```

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

<!-- image -->

## &lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPRoundIntN(operand, FPCR, rounding, intsize); V[d, 128] = result;
```

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.177 FRINT64X (vector)

Floating-point round to 64-bit integer, using current rounding mode (vector)

This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values that fit into a 64-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register.

Azero input returns a zero result with the same sign. When one of the result values is not numerically equal to the corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the instruction returns for the corresponding result value the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

Vector single-precision and double-precision

(FEAT\_FRINTTS)

<!-- image -->

## Encoding

```
FRINT64X <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FRINTTS) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer intsize = 64;
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'sz:Q':

|   sz | Q <T>   |
|------|---------|
|    0 | 0 2S    |

&lt;T&gt;

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; constant FPRounding rounding = FPRoundingMode(FPCR); bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize); V[d, datasize] = result;
```

## C7.2.178 FRINT64X (scalar)

Floating-point round to 64-bit integer, using current rounding mode (scalar)

This instruction rounds a floating-point value in the SIMD&amp;FP source register to an integral floating-point value that fits into a 64-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register.

Azero input returns a zero result with the same sign. When the result value is not numerically equal to the input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FRINTTS)

<!-- image -->

## Encoding for the Single-precision variant

```
Applies when (ftype ==
```

```
00) FRINT64X <Sd>, <Sn>
```

## Encoding for the Double-precision variant

```
Applies when (ftype ==
```

```
01)
```

```
FRINT64X <Dd>,
```

```
<Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FRINTTS) then EndOfDecode(Decode_UNDEF);
```

```
if ftype IN {'1x'} then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(ftype<0>); constant integer intsize = 64;
```

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Sn&gt;

&lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; constant FPRounding rounding = FPRoundingMode(FPCR); bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPRoundIntN(operand, FPCR, rounding, intsize); V[d, 128] = result;
```

## C7.2.179 FRINT64Z (vector)

Floating-point round to 64-bit integer toward zero (vector)

This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values that fit into a 64-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input returns a zero result with the same sign. When one of the result values is not numerically equal to the corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the instruction returns for the corresponding result value the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector single-precision and double-precision

(FEAT\_FRINTTS)

<!-- image -->

## Encoding

```
FRINT64Z <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FRINTTS) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer intsize = 64; constant FPRounding rounding = FPRounding_ZERO;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'sz:Q':

<!-- image -->

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize); V[d, datasize] = result;
```

## C7.2.180 FRINT64Z (scalar)

Floating-point round to 64-bit integer toward zero (scalar)

This instruction rounds a floating-point value in the SIMD&amp;FP source register to an integral floating-point value that fits into a 64-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input returns a zero result with the same sign. When the result value is not numerically equal to the input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Floating-point

(FEAT\_FRINTTS)

<!-- image -->

## Encoding for the Single-precision variant

```
Applies when (ftype == 00) FRINT64Z <Sd>, <Sn>
```

## Encoding for the Double-precision variant

```
Applies when
```

```
(ftype == FRINT64Z <Dd>, <Dn>
```

```
01)
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FRINTTS) then EndOfDecode(Decode_UNDEF);
```

```
if ftype IN {'1x'} then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(ftype<0>); constant integer intsize = 64; constant FPRounding rounding = FPRounding_ZERO;
```

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

<!-- image -->

## &lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPRoundIntN(operand, FPCR, rounding, intsize); V[d, 128] = result;
```

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.181 FRINTA (vector)

Floating-point round to integral, to nearest with ties to away (vector)

This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRINTA <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_TIEAWAY;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

FRINTA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_TIEAWAY;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact); V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

## C7.2.182 FRINTA (scalar)

Floating-point round to integral, to nearest with ties to away (scalar)

This instruction rounds a floating-point value in the SIMD&amp;FP source register to an integral floating-point value of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11)
```

```
FRINTA <Hd>, <Hn>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FRINTA <Sd>, <Sn>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FRINTA <Dd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(ftype EOR '10'); constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_TIEAWAY;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Sd&gt;

## &lt;Sn&gt;

## &lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPRoundInt(operand, FPCR, rounding, exact); V[d, 128] = result;
```

## C7.2.183 FRINTI (vector)

Floating-point round to integral, using current rounding mode (vector)

This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register.

Azero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRINTI <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = FALSE;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

FRINTI

&lt;Vd&gt;.&lt;T&gt;,

&lt;Vn&gt;.&lt;T&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = FALSE;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; bits(esize) element; constant FPRounding rounding = FPRoundingMode(FPCR); for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact); V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

## C7.2.184 FRINTI (scalar)

Floating-point round to integral, using current rounding mode (scalar)

This instruction rounds a floating-point value in the SIMD&amp;FP source register to an integral floating-point value of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register.

Azero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11)
```

```
FRINTI <Hd>,
```

```
<Hn>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FRINTI <Sd>, <Sn>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FRINTI <Dd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(ftype EOR '10'); constant boolean exact = FALSE;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Hn&gt;

## &lt;Sd&gt;

&lt;Sn&gt;

## &lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; constant FPRounding rounding = FPRoundingMode(FPCR); bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPRoundInt(operand, FPCR, rounding, exact); V[d, 128] = result;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.185 FRINTM (vector)

Floating-point round to integral, toward minus infinity (vector)

This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRINTM <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_NEGINF;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FRINTM <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_NEGINF;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact); V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

## C7.2.186 FRINTM (scalar)

Floating-point round to integral, toward minus infinity (scalar)

This instruction rounds a floating-point value in the SIMD&amp;FP source register to an integral floating-point value of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11)
```

```
FRINTM <Hd>, <Hn>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FRINTM <Sd>, <Sn>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FRINTM <Dd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(ftype EOR '10'); constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_NEGINF;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Sd&gt;

&lt;Sn&gt;

## &lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPRoundInt(operand, FPCR, rounding, exact); V[d, 128] = result;
```

## C7.2.187 FRINTN (vector)

Floating-point round to integral, to nearest with ties to even (vector)

This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRINTN <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_TIEEVEN;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FRINTN <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_TIEEVEN;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact); V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

## C7.2.188 FRINTN (scalar)

Floating-point round to integral, to nearest with ties to even (scalar)

This instruction rounds a floating-point value in the SIMD&amp;FP source register to an integral floating-point value of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11)
```

```
FRINTN <Hd>, <Hn>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FRINTN <Sd>, <Sn>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FRINTN <Dd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(ftype EOR '10'); constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_TIEEVEN;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Hn&gt;

## &lt;Sd&gt;

&lt;Sn&gt;

## &lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPRoundInt(operand, FPCR, rounding, exact); V[d, 128] = result;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.189 FRINTP (vector)

Floating-point round to integral, toward plus infinity (vector)

This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRINTP <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_POSINF;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

FRINTP

&lt;Vd&gt;.&lt;T&gt;,

&lt;Vn&gt;.&lt;T&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_POSINF;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact); V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

## C7.2.190 FRINTP (scalar)

Floating-point round to integral, toward plus infinity (scalar)

This instruction rounds a floating-point value in the SIMD&amp;FP source register to an integral floating-point value of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype == 11)
```

```
FRINTP <Hd>, <Hn>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FRINTP <Sd>, <Sn>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FRINTP <Dd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(ftype EOR '10'); constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_POSINF;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Sd&gt;

## &lt;Sn&gt;

## &lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPRoundInt(operand, FPCR, rounding, exact); V[d, 128] = result;
```

## C7.2.191 FRINTX (vector)

Floating-point round to integral exact, using current rounding mode (vector)

This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register.

When a result value is not numerically equal to the corresponding input value, an Inexact exception is raised. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRINTX <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = TRUE;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FRINTX <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = TRUE;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; bits(esize) element; constant FPRounding rounding = FPRoundingMode(FPCR); for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact); V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

## C7.2.192 FRINTX (scalar)

Floating-point round to integral exact, using current rounding mode (scalar)

This instruction rounds a floating-point value in the SIMD&amp;FP source register to an integral floating-point value of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register.

When the result value is not numerically equal to the input value, an Inexact exception is raised. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype
```

```
FRINTX <Hd>,
```

```
== 11) <Hn>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FRINTX <Sd>, <Sn>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FRINTX <Dd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(ftype EOR '10'); constant boolean exact = TRUE;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

&lt;Sd&gt;

&lt;Sn&gt;

&lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; constant FPRounding rounding = FPRoundingMode(FPCR); bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPRoundInt(operand, FPCR, rounding, exact); V[d, 128] = result;
```

## C7.2.193 FRINTZ (vector)

Floating-point round to integral, toward zero (vector)

This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRINTZ <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_ZERO;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FRINTZ <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_ZERO;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact); V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

## C7.2.194 FRINTZ (scalar)

Floating-point round to integral, toward zero (scalar)

This instruction rounds a floating-point value in the SIMD&amp;FP source register to an integral floating-point value of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register.

Azero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

```
(FEAT_FP16) Applies when (ftype
```

```
FRINTZ <Hd>,
```

```
== 11) <Hn>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FRINTZ <Sd>, <Sn>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FRINTZ <Dd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(ftype EOR '10'); constant boolean exact = FALSE; constant FPRounding rounding = FPRounding_ZERO;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Hn&gt;

## &lt;Sd&gt;

&lt;Sn&gt;

## &lt;Dd&gt;

## &lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPRoundInt(operand, FPCR, rounding, exact); V[d, 128] = result;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.195 FRSQRTE

Floating-point reciprocal square root estimate

This instruction calculates an approximate square root for each vector element in the source SIMD&amp;FP register, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRSQRTE <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FRSQRTE <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRSQRTE <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FRSQRTE <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

&lt;V&gt;

- &lt;d&gt;

&lt;n&gt;

- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vn&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); for e = 0 to elements-1 constant bits(esize) element = Elem[operand, e, esize]; Elem[result, e, esize] = FPRSqrtEstimate(element, FPCR); V[d, 128] = result;
```

## C7.2.196 FRSQRTS

Floating-point reciprocal square root step

This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&amp;FP registers, subtracts each of the products from 3.0, divides these results by 2.0, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRSQRTS <Hd>, <Hn>, <Hm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1;
```

Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FRSQRTS <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FRSQRTS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FRSQRTS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

- &lt;V&gt;

Is a width specifier, encoded in 'sz':

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

- &lt;d&gt; Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.
- &lt;n&gt;

&lt;m&gt;

- &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz | Q <T>   |
|------|---------|
|    0 | 0 2S    |

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
if elements == 1 then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(esize) element1; bits(esize) element2; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[n, 128] else Zeros(128); for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = FPRSqrtStepFused(element1, element2, FPCR); V[d, 128] = result;
```

## C7.2.197 FSCALE

Floating-point adjust exponent by vector

This instruction multiplies the floating-point elements of the first source vector by 2.0 to the power of the signed integer values in the corresponding elements of the second source vector, and places the results in the corresponding elements of the destination vector.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_FP8)

<!-- image -->

## Encoding

```
FSCALE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP8) then EndOfDecode(Decode_UNDEF);
```

```
constant integer esize = 16; constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = if Q == '1' then 128 else 64; constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_FP8)

<!-- image -->

## Encoding

```
FSCALE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP8) then EndOfDecode(Decode_UNDEF);
```

```
if Q == '0' && size == '11' then EndOfDecode(Decode_UNDEF); constant integer esize = 8 << UInt(size); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = if Q == '1' then 128 else 64; constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'size&lt;0&gt;:Q':

|   size<0> |   Q | <T>      |
|-----------|-----|----------|
|         0 |   0 | 2S       |
|         0 |   1 | 4S       |
|         1 |   0 | RESERVED |
|         1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; for e = 0 to elements-1 constant bits(esize) op1 = Elem[operand1, e, esize]; constant integer op2 = SInt(Elem[operand2, e, esize]); Elem[result, e, esize] = FPScale(op1, op2, FPCR); V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

## C7.2.198 FSQRT (vector)

Floating-point square root (vector)

This instruction calculates the square root for each vector element in the source SIMD&amp;FP register, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FSQRT <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FSQRT <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; for e = 0 to elements-1 constant bits(esize) element = Elem[operand, e, esize]; Elem[result, e, esize] = FPSqrt(element, FPCR); V[d, datasize] = result;
```

&lt;T&gt;

&lt;Vn&gt;

## C7.2.199 FSQRT (scalar)

Floating-point square root (scalar)

This instruction calculates the square root of the value in the SIMD&amp;FP source register and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

(FEAT\_FP16) Applies when (ftype == 11)

```
FSQRT <Hd>, <Hn>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when
```

```
FSQRT <Sd>,
```

```
(ftype == 00) <Sn>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FSQRT <Dd>, <Dn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Hn&gt;

<!-- image -->

## &lt;Sn&gt;

&lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand = V[n, esize]; bits(128) result = if IsMerging(FPCR) then V[d, 128] else Zeros(128); Elem[result, 0, esize] = FPSqrt(operand, FPCR); V[d, 128] = result;
```

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.200 FSUB (vector)

Floating-point subtract (vector)

This instruction subtracts the elements in the vector in the second source SIMD&amp;FP register, from the corresponding elements in the vector in the first source SIMD&amp;FP register, places each result into elements of a vector, and writes the vector to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Half-precision and Single-precision and double-precision

## Half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
FSUB
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
FSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = bits(esize) element1; bits(esize) element2; bits(datasize) result; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize];
```

&lt;T&gt;

&lt;Vn&gt;

```
V[n, datasize]; V[m, datasize];
```

```
Elem[result, e, esize] = FPSub(element1, element2, FPCR); V[d, datasize] = result;
```

## C7.2.201 FSUB (scalar)

Floating-point subtract (scalar)

This instruction subtracts the floating-point value of the second source SIMD&amp;FP register from the floating-point value of the first source SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the Half-precision variant

(FEAT\_FP16) Applies when (ftype == 11)

```
FSUB <Hd>, <Hn>, <Hm>
```

## Encoding for the Single-precision variant

```
(FEAT_FP) Applies when (ftype == 00)
```

```
FSUB <Sd>, <Sn>, <Sm>
```

## Encoding for the Double-precision variant

```
(FEAT_FP) Applies when (ftype == 01)
```

```
FSUB <Dd>, <Dn>, <Dm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(ftype EOR '10');
```

## Assembler Symbols

&lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Hn&gt;

Is the 16-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Hm&gt;

Is the 16-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Sd&gt;

&lt;Sn&gt;

Is the 32-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Sm&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;Dd&gt;

&lt;Dn&gt;

Is the 64-bit name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Dm&gt;

Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPEnabled(); constant bits(esize) operand1 = V[n, esize]; constant bits(esize) operand2 = V[m, esize]; bits(128) result = if IsMerging(FPCR) then V[n, 128] else Zeros(128); Elem[result, 0, esize] = FPSub(operand1, operand2, FPCR); V[d, 128] = result;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## C7.2.202 INS (element)

Insert vector element from another vector element

This instruction copies the vector element of the source SIMD&amp;FP register to the specified vector element of the destination SIMD&amp;FP register.

This instruction can insert data into individual elements within a SIMD&amp;FP register without clearing the remaining bits to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This instruction is used by the alias MOV (element).

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
INS <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if imm5 == 'x0000' then EndOfDecode(Decode_UNDEF); constant integer size = LowestSetBitNZ(imm5<3:0>); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer dst_index = UInt(imm5<4:size+1>); constant integer src_index = UInt(imm4<3:size>); constant integer idxdsize = 64 << UInt(imm4<3>); // imm4<size-1:0> is IGNORED constant integer esize = 8 << size;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an element size specifier, encoded in 'imm5':

<!-- image -->

&lt;Ts&gt;

| imm5   | <Ts>     |
|--------|----------|
| x0000  | RESERVED |
| xxxx1  | B        |
| xxx10  | H        |

## &lt;index1&gt;

Is the destination element index encoded in 'imm5':

## &lt;Vn&gt;

| imm5   | <Ts>   |
|--------|--------|
| xx100  | S      |
| x1000  | D      |

| imm5   | <index1>        |
|--------|-----------------|
| x0000  | RESERVED        |
| xxxx1  | UInt(imm5<4:1>) |
| xxx10  | UInt(imm5<4:2>) |
| xx100  | UInt(imm5<4:3>) |
| x1000  | UInt(imm5<4>)   |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;index2&gt;

Is the source element index encoded in 'imm5:imm4':

| imm5   | <index2>        |
|--------|-----------------|
| x0000  | RESERVED        |
| xxxx1  | UInt(imm4)      |
| xxx10  | UInt(imm4<3:1>) |
| xx100  | UInt(imm4<3:2>) |
| x1000  | UInt(imm4<3>)   |

Unspecified bits in 'imm4' are ignored but should be set to zero by an assembler.

## Alias Conditions

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(idxdsize) operand = V[n, idxdsize]; bits(128) result; result = V[d, 128]; Elem[result, dst_index, esize] = V[d, 128] = result;
```

| Alias         | Is preferred when   |
|---------------|---------------------|
| MOV (element) | Unconditionally     |

```
Elem[operand, src_index, esize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.203 INS (general)

Insert vector element from general-purpose register

This instruction copies the contents of the source general-purpose register to the specified vector element in the destination SIMD&amp;FP register.

This instruction can insert data into individual elements within a SIMD&amp;FP register without clearing the remaining bits to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This instruction is used by the alias MOV (from general).

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
INS <Vd>.<Ts>[<index>], <R><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if imm5 == 'x0000' then EndOfDecode(Decode_UNDEF); constant integer size = LowestSetBitNZ(imm5<3:0>); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer index = UInt(imm5<4:size+1>); constant integer esize = 8 << size;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an element size specifier, encoded in 'imm5':

<!-- image -->

| imm5   | <Ts>     |
|--------|----------|
| x0000  | RESERVED |
| xxxx1  | B        |
| xxx10  | H        |
| xx100  | S        |
| x1000  | D        |

## &lt;index&gt;

Is the element index encoded in 'imm5':

<!-- image -->

<!-- image -->

Is the number [0-30] of the general-purpose source register or ZR (31), encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
X[n, esize];
```

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(esize) element = bits(128) result = V[d, 128]; Elem[result, index, esize] = element; V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| imm5   | <index>         |
|--------|-----------------|
| x0000  | RESERVED        |
| xxxx1  | UInt(imm5<4:1>) |
| xxx10  | UInt(imm5<4:2>) |
| xx100  | UInt(imm5<4:3>) |
| x1000  | UInt(imm5<4>)   |

Is the width specifier for the general-purpose source register, encoded in 'imm5':

| imm5   | <R>      |
|--------|----------|
| x0000  | RESERVED |
| xxxx1  | W        |
| xxx10  | W        |
| xx100  | W        |
| x1000  | X        |

| Alias              | Is preferred when   |
|--------------------|---------------------|
| MOV (from general) | Unconditionally     |

## C7.2.204 LD1 (multiple structures)

Load multiple single-element structures to one, two, three, or four registers

This instruction loads multiple single-element structures from memory and writes the result to one, two, three, or four SIMD&amp;FP registers.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the One register variant

Applies when (opcode == 0111)

```
LD1 { <Vt>.<T> }, [<Xn|SP>]
```

## Encoding for the Two registers variant

```
Applies when (opcode == 1010) LD1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]
```

## Encoding for the Three registers variant

Applies when

```
(opcode == 0110) LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>
```

## Encoding for the Four registers variant

Applies when (opcode ==

```
0010)
```

```
LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

```
}, [<Xn|SP>]
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the One register, immediate offset variant

Applies when (Rm == 11111 &amp;&amp; opcode == 0111)

```
LD1 { <Vt>.<T> }, [<Xn|SP>],
```

```
<imm>
```

## Encoding for the One register, register offset variant

```
Applies when
```

(Rm != 11111 &amp;&amp; opcode == 0111)

```
LD1 { <Vt>.<T> }, [<Xn|SP>], <Xm>
```

## Encoding for the Two registers, immediate offset variant

```
Applies when (Rm == 11111 &&
```

```
opcode == 1010)
```

```
LD1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>
```

## Encoding for the Two registers, register offset variant

Applies when (Rm != 11111 &amp;&amp;

```
opcode == 1010) LD1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>
```

## Encoding for the Three registers, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 0110) LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>],
```

```
<imm>
```

## Encoding for the Three registers, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 0110)

```
LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>
```

## Encoding for the Four registers, immediate offset variant

Applies when (Rm == 11111 &amp;&amp;

```
opcode == 0010)
```

```
LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>],
```

## Encoding for the Four registers, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 0010)

```
LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>
```

```
<imm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

## &lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |
|     10 |   1 | 4S    |
|     11 |   0 | 1D    |
|     11 |   1 | 2D    |

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Vt3&gt;

Is the name of the third SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 2 modulo 32.

## &lt;Vt4&gt;

Is the name of the fourth SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 3 modulo 32.

## &lt;imm&gt;

For the 'One register, immediate offset' variant: is the post-index immediate offset, encoded in 'Q':

|   Q | <imm>   |
|-----|---------|
|   0 | #8      |

&lt;T&gt;

<!-- image -->

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(size); constant integer elements = datasize DIV esize; integer rpt; // number of iterations constant integer selem = 1; // structure elements case opcode of when '0010' rpt = 4; // LD/ST1 (4 registers) when '0110' rpt = 3; // LD/ST1 (3 registers) when '1010' rpt = 2; // LD/ST1 (2 registers) when '0111' rpt = 1; // LD/ST1 (1 register) otherwise EndOfDecode(Decode_UNDEF); end
```

|   Q | <imm>   |
|-----|---------|
|   1 | #16     |

For the 'Two registers, immediate offset' variant: is the post-index immediate offset, encoded in 'Q':

|   Q | <imm>   |
|-----|---------|
|   0 | #16     |
|   1 | #32     |

For the 'Three registers, immediate offset' variant: is the post-index immediate offset, encoded in 'Q':

|   Q | <imm>   |
|-----|---------|
|   0 | #24     |
|   1 | #48     |

For the 'Four registers, immediate offset' variant: is the post-index immediate offset, encoded in 'Q':

|   Q | <imm>   |
|-----|---------|
|   0 | #32     |
|   1 | #64     |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(datasize) rval; integer tt; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); for r = 0 to rpt-1 for e = 0 to elements-1 tt = (t + r) MOD 32; for s = 0 to selem-1 rval = V[tt, datasize]; eaddr = AddressIncrement(address, offs, accdesc); Elem[rval, e, esize] = Mem[eaddr, ebytes, accdesc]; V[tt, datasize] = rval; offs = offs + ebytes; tt = (tt + 1) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.205 LD1 (single structure)

Load one single-element structure to one lane of one register

This instruction loads a single-element structure from memory and writes the result to the specified lane of the SIMD&amp;FP register without affecting the other bits of the register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit variant

Applies when (opcode ==

```
000)
```

```
LD1 { <Vt>.B
```

```
}[<index>], [<Xn|SP>]
```

## Encoding for the 16-bit variant

```
(opcode == 010 && size == x0)
```

```
Applies when LD1 { <Vt>.H }[<index>], [<Xn|SP>]
```

## Encoding for the 32-bit variant

```
Applies when (opcode == 100 && size == 00) LD1 { <Vt>.S }[<index>], [<Xn|SP>]
```

## Encoding for the 64-bit variant

```
Applies when (opcode == 100 && S == 0 && size == 01) LD1 { <Vt>.D }[<index>], [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit, immediate offset variant

```
Applies when (Rm == 11111 &&
```

```
LD1 { <Vt>.B
```

```
opcode == 000) }[<index>], [<Xn|SP>], #1
```

## Encoding for the 8-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 000) LD1 { <Vt>.B }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 64-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 100 && S == 0 && size == 01)
```

```
LD1 { <Vt>.D }[<index>], [<Xn|SP>], #8
```

## Encoding for the 64-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 100 &amp;&amp; S == 0 &amp;&amp; size == 01)

```
LD1 { <Vt>.D }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 16-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 010 && size == x0) LD1 { <Vt>.H }[<index>], [<Xn|SP>], #2
```

## Encoding for the 16-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 010 &amp;&amp; size == x0)

```
LD1 { <Vt>.H }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 32-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 100 && size == 00) LD1 { <Vt>.S }[<index>], [<Xn|SP>], #4
```

## Encoding for the 32-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 100 && size == 00)
```

```
LD1 { <Vt>.S }[<index>], [<Xn|SP>], <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

## &lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;index&gt;

For the '8-bit', '8-bit, immediate offset', and '8-bit, register offset' variants: is the element index, encoded in 'Q:S:size'.

For the '16-bit', '16-bit, immediate offset', and '16-bit, register offset' variants: is the element index, encoded in 'Q:S:size&lt;1&gt;'.

For the '32-bit', '32-bit, immediate offset', and '32-bit, register offset' variants: is the element index, encoded in 'Q:S'.

For the '64-bit', '64-bit, immediate offset', and '64-bit, register offset' variants: is the element index, encoded in 'Q'.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then EndOfDecode(Decode_UNDEF); end scale = size; replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then EndOfDecode(Decode_UNDEF); end if size<0> == '0' then index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1] scale = '11'; end end
```

```
constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize); offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register for s = 0 to selem-1 rval = V[t, 128]; eaddr = AddressIncrement(address, offs, accdesc); Elem[rval, index, esize] = Mem[eaddr, ebytes, accdesc]; V[t, 128] = rval; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.206 LD1R

Load one single-element structure and replicate to all lanes (of one register)

This instruction loads a single-element structure from memory and replicates the structure to all the lanes of the SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

LD1R

{

&lt;Vt&gt;.&lt;T&gt;

}, [&lt;Xn|SP&gt;]

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

## (FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the Immediate offset variant

```
Applies when (Rm == 11111) LD1R { <Vt>.<T> }, [<Xn|SP>], <imm>
```

## Encoding for the Register offset variant

```
Applies when (Rm != 11111) LD1R { <Vt>.<T> }, [<Xn|SP>], <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

&lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |
|     10 |   1 | 4S    |
|     11 |   0 | 1D    |
|     11 |   1 | 2D    |

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the post-index immediate offset, encoded in 'size':

|   size | <imm>   |
|--------|---------|
|     00 | #1      |
|     01 | #2      |
|     10 | #4      |
|     11 | #8      |

&lt;T&gt;

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then scale = size; replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then EndOfDecode(Decode_UNDEF); end if size<0> == '0' then index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1] scale = '11'; end end constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize); offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register
```

```
EndOfDecode(Decode_UNDEF); end Operation CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked,
```

```
for s = 0 to selem-1 rval = V[t, 128]; eaddr = AddressIncrement(address, offs, accdesc); Elem[rval, index, esize] = Mem[eaddr, ebytes, accdesc]; V[t, 128] = rval; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.207 LD2 (multiple structures)

Load multiple 2-element structures to two registers

This instruction loads multiple 2-element structures from memory and writes the result to the two SIMD&amp;FP registers, with de-interleaving.

For an example of de-interleaving, see LD3 (multiple structures) .

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
LD2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the Immediate offset variant

```
Applies when (Rm == 11111) LD2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>
```

## Encoding for the Register offset variant

```
Applies when (Rm != 11111) LD2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

&lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the post-index immediate offset, encoded in 'Q':

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

&lt;T&gt;

|   Q | <imm>   |
|-----|---------|
|   0 | #16     |
|   1 | #32     |

## Shared Decode

```
constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(size); constant integer elements = datasize DIV esize; constant integer rpt = 1; constant integer selem = 2; // .1D format only permitted with LD1 & ST1 if size:Q == '110' && selem != 1 then
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(datasize) rval; integer tt; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); for r = 0 to rpt-1 for e = 0 to elements-1 tt = (t + r) MOD 32; for s = 0 to selem-1 rval = V[tt, datasize]; eaddr = AddressIncrement(address, offs, accdesc); Elem[rval, e, esize] = Mem[eaddr, ebytes, accdesc]; V[tt, datasize] = rval; offs = offs + ebytes; tt = (tt + 1) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF); end
```

## C7.2.208 LD2 (single structure)

Load single 2-element structure to one lane of two registers

This instruction loads a 2-element structure from memory and writes the result to the corresponding elements of the two SIMD&amp;FP registers without affecting the other bits of the registers.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit variant

Applies when (opcode ==

```
<Vt2>.B }[<index>], [<Xn|SP>]
```

```
000) LD2 { <Vt>.B,
```

## Encoding for the 16-bit variant

```
Applies when (opcode == 010 && size == x0) LD2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]
```

## Encoding for the 32-bit variant

```
Applies when (opcode == 100 && size == 00) LD2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]
```

## Encoding for the 64-bit variant

```
Applies when (opcode == 100 && S == 0 && size == 01) LD2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp;

```
LD2 { <Vt>.B,
```

```
opcode == 000) <Vt2>.B }[<index>], [<Xn|SP>], #2
```

## Encoding for the 8-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 000)
```

```
LD2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 16-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 010 && size ==
```

```
LD2 { <Vt>.H,
```

```
x0) <Vt2>.H }[<index>], [<Xn|SP>], #4
```

## Encoding for the 16-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 010 &amp;&amp; size ==

```
LD2 { <Vt>.H,
```

```
x0) <Vt2>.H }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 32-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 100 && size == 00) LD2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8
```

## Encoding for the 32-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 100 && size ==
```

```
LD2 { <Vt>.S,
```

```
00) <Vt2>.S }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 64-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp; opcode == 100 &amp;&amp; S == 0 &amp;&amp; size == 01)

```
LD2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16
```

## Encoding for the 64-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 100 && S == 0 && size == 01)
```

```
LD2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

## &lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;index&gt;

For the '8-bit', '8-bit, immediate offset', and '8-bit, register offset' variants: is the element index, encoded in 'Q:S:size'.

For the '16-bit', '16-bit, immediate offset', and '16-bit, register offset' variants: is the element index, encoded in 'Q:S:size&lt;1&gt;'.

For the '32-bit', '32-bit, immediate offset', and '32-bit, register offset' variants: is the element index, encoded in 'Q:S'.

For the '64-bit', '64-bit, immediate offset', and '64-bit, register offset' variants: is the element index, encoded in 'Q'.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then EndOfDecode(Decode_UNDEF); end scale = size; replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then EndOfDecode(Decode_UNDEF); end if size<0> == '0' then index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1]
```

```
scale = '11'; end end constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize); offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register for s = 0 to selem-1 rval = V[t, 128]; eaddr = AddressIncrement(address, offs, accdesc); Elem[rval, index, esize] = Mem[eaddr, ebytes, accdesc]; V[t, 128] = rval; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.209 LD2R

Load single 2-element structure and replicate to all lanes of two registers

This instruction loads a 2-element structure from memory and replicates the structure to all the lanes of the two SIMD&amp;FP registers.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

LD2R

{

&lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

## (FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the Immediate offset variant

```
Applies when (Rm == 11111) LD2R { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>
```

## Encoding for the Register offset variant

```
Applies when (Rm != 11111) LD2R { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>],
```

```
<Xm>
```

}, [&lt;Xn|SP&gt;]

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

&lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |
|     10 |   1 | 4S    |
|     11 |   0 | 1D    |
|     11 |   1 | 2D    |

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the post-index immediate offset, encoded in 'size':

|   size | <imm>   |
|--------|---------|
|     00 | #2      |
|     01 | #4      |
|     10 | #8      |
|     11 | #16     |

&lt;T&gt;

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then scale = size; replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then EndOfDecode(Decode_UNDEF); end if size<0> == '0' then index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1] scale = '11'; end end constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

```
EndOfDecode(Decode_UNDEF); end Operation
```

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize); offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register
```

```
for s = 0 to selem-1 rval = V[t, 128]; eaddr = AddressIncrement(address, offs, accdesc); Elem[rval, index, esize] = Mem[eaddr, ebytes, accdesc]; V[t, 128] = rval; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.210 LD3 (multiple structures)

Load multiple 3-element structures to three registers

This instruction loads multiple 3-element structures from memory and writes the result to the three SIMD&amp;FP registers, with de-interleaving.

A is a packed  array of 3-element structures. Each element is a 16-bit halfword.

Figure C7-2 de-interleaving of a LD3.16 (multiple 3-element structures) instruction:

<!-- image -->

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
LD3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the Immediate offset variant

Applies when (Rm == 11111)

```
LD3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>],
```

## Encoding for the Register offset variant

Applies when

```
(Rm != 11111) LD3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>],
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

&lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

&lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

<!-- image -->

```
<imm>
```

```
<Xm>
```

## &lt;Vt3&gt;

Is the name of the third SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 2 modulo 32.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the post-index immediate offset, encoded in 'Q':

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(size); constant integer elements = datasize DIV esize; constant integer rpt = 1; constant integer selem = 3; // .1D format only permitted with LD1 & ST1 if size:Q == '110' && selem != 1 then EndOfDecode(Decode_UNDEF); end
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(datasize) rval; integer tt; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); for r = 0 to rpt-1 for e = 0 to elements-1 tt = (t + r) MOD 32; for s = 0 to selem-1 rval = V[tt, datasize]; eaddr = AddressIncrement(address, offs, accdesc); Elem[rval, e, esize] = Mem[eaddr, ebytes, accdesc]; V[tt, datasize] = rval;
```

|   Q | <imm>   |
|-----|---------|
|   0 | #24     |
|   1 | #48     |

```
offs = offs + ebytes; tt = (tt + 1) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.211 LD3 (single structure)

Load single 3-element structure to one lane of three registers

This instruction loads a 3-element structure from memory and writes the result to the corresponding elements of the three SIMD&amp;FP registers without affecting the other bits of the registers.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit variant

```
Applies when (opcode == 001) LD3 { <Vt>.B, <Vt2>.B, <Vt3>.B
```

```
}[<index>], [<Xn|SP>]
```

## Encoding for the 16-bit variant

```
Applies when (opcode == 011 && size == x0) LD3 { <Vt>.H, <Vt2>.H, <Vt3>.H
```

```
}[<index>], [<Xn|SP>]
```

## Encoding for the 32-bit variant

Applies when

```
(opcode == 101 && size == 00) LD3 { <Vt>.S, <Vt2>.S, <Vt3>.S
```

## Encoding for the 64-bit variant

```
Applies when (opcode == 101 && S == 0 && size == LD3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]
```

```
01)
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

```
}[<index>], [<Xn|SP>]
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp;

```
opcode == 001)
```

```
LD3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3
```

## Encoding for the 8-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 001)

```
LD3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 16-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 011 && size ==
```

```
LD3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6
```

## Encoding for the 16-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 011 &amp;&amp; size ==

```
LD3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 32-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp; opcode == 101 &amp;&amp; size == 00) LD3 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #12

## Encoding for the 32-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 101 &amp;&amp; size == 00)

```
LD3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 64-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp; opcode == 101 &amp;&amp; S == 0 &amp;&amp; size == 01)

```
LD3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24
```

## Encoding for the 64-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 101 &amp;&amp; S == 0 &amp;&amp; size == 01)

```
LD3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>
```

```
x0)
```

```
x0)
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

## &lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Vt3&gt;

Is the name of the third SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 2 modulo 32.

## &lt;index&gt;

For the '8-bit', '8-bit, immediate offset', and '8-bit, register offset' variants: is the element index, encoded in 'Q:S:size'.

For the '16-bit', '16-bit, immediate offset', and '16-bit, register offset' variants: is the element index, encoded in 'Q:S:size&lt;1&gt;'.

For the '32-bit', '32-bit, immediate offset', and '32-bit, register offset' variants: is the element index, encoded in 'Q:S'.

For the '64-bit', '64-bit, immediate offset', and '64-bit, register offset' variants: is the element index, encoded in 'Q'.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then EndOfDecode(Decode_UNDEF); end scale = size; replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then EndOfDecode(Decode_UNDEF); end if size<0> == '0' then
```

```
index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1] scale = '11'; end end constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize); offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register for s = 0 to selem-1 rval = V[t, 128]; eaddr = AddressIncrement(address, offs, accdesc); Elem[rval, index, esize] = Mem[eaddr, ebytes, accdesc]; V[t, 128] = rval; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.212 LD3R

Load single 3-element structure and replicate to all lanes of three registers

This instruction loads a 3-element structure from memory and replicates the structure to all the lanes of the three SIMD&amp;FP registers.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
LD3R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

## (FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the Immediate offset variant

```
Applies when (Rm == 11111) LD3R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>
```

## Encoding for the Register offset variant

Applies when

```
(Rm != 11111) LD3R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

&lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |
|     10 |   1 | 4S    |
|     11 |   0 | 1D    |
|     11 |   1 | 2D    |

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Vt3&gt;

Is the name of the third SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 2 modulo 32.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the post-index immediate offset, encoded in 'size':

|   size | <imm>   |
|--------|---------|
|     00 | #3      |
|     01 | #6      |
|     10 | #12     |
|     11 | #24     |

&lt;T&gt;

<!-- image -->

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then scale = size; replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then EndOfDecode(Decode_UNDEF); end if size<0> == '0' then index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1] scale = '11'; end end constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize);
```

```
EndOfDecode(Decode_UNDEF); end
```

```
offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register for s = 0 to selem-1 rval = V[t, 128]; eaddr = AddressIncrement(address, offs, accdesc); Elem[rval, index, esize] = Mem[eaddr, ebytes, accdesc]; V[t, 128] = rval; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.213 LD4 (multiple structures)

Load multiple 4-element structures to four registers

This instruction loads multiple 4-element structures from memory and writes the result to the four SIMD&amp;FP registers, with de-interleaving.

For an example of de-interleaving, see LD3 (multiple structures) .

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
LD4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the Immediate offset variant

```
Applies when (Rm == 11111) LD4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>
```

## Encoding for the Register offset variant

```
Applies when (Rm != 11111) LD4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

## &lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Vt3&gt;

Is the name of the third SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 2 modulo 32.

## &lt;Vt4&gt;

Is the name of the fourth SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 3 modulo 32.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the post-index immediate offset, encoded in 'Q':

&lt;T&gt;

|   Q | <imm>   |
|-----|---------|
|   0 | #32     |

<!-- image -->

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(size); constant integer elements = datasize DIV esize; constant integer rpt = 1; constant integer selem = 4; // .1D format only permitted with LD1 & ST1 if size:Q == '110' && selem != 1 then EndOfDecode(Decode_UNDEF); end
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(datasize) rval; integer tt; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); for r = 0 to rpt-1 for e = 0 to elements-1 tt = (t + r) MOD 32; for s = 0 to selem-1 rval = V[tt, datasize]; eaddr = AddressIncrement(address, offs, accdesc); Elem[rval, e, esize] = Mem[eaddr, ebytes, accdesc]; V[tt, datasize] = rval; offs = offs + ebytes; tt = (tt + 1) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   Q | <imm>   |
|-----|---------|
|   1 | #64     |

## C7.2.214 LD4 (single structure)

Load single 4-element structure to one lane of four registers

This instruction loads a 4-element structure from memory and writes the result to the corresponding elements of the four SIMD&amp;FP registers without affecting the other bits of the registers.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit variant

Applies when (opcode ==

```
LD4 { <Vt>.B, <Vt2>.B, <Vt3>.B,
```

```
001) <Vt4>.B }[<index>], [<Xn|SP>]
```

## Encoding for the 16-bit variant

```
Applies when (opcode == 011 && size == x0) LD4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]
```

## Encoding for the 32-bit variant

Applies when

```
(opcode == 101 && size == 00) LD4 { <Vt>.S, <Vt2>.S, <Vt3>.S,
```

## Encoding for the 64-bit variant

```
Applies when (opcode == 101 && S == 0 && size == 01) LD4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

```
<Vt4>.S }[<index>], [<Xn|SP>]
```

## Post-index

## (FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp;

```
opcode == 001)
```

```
LD4 { <Vt>.B, <Vt2>.B, <Vt3>.B,
```

```
<Vt4>.B }[<index>], [<Xn|SP>], #4
```

## Encoding for the 8-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 001)

```
LD4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 16-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp; opcode == 011 &amp;&amp; size == x0)

```
LD4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8
```

## Encoding for the 16-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 011 &amp;&amp; size ==

```
x0)
```

```
LD4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 32-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 101 && size == 00) LD4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16
```

## Encoding for the 32-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 101 &amp;&amp; size ==

```
00)
```

```
LD4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 64-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp; opcode == 101 &amp;&amp; S == 0 &amp;&amp; size == 01) LD4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #32

## Encoding for the 64-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 101 &amp;&amp; S == 0 &amp;&amp; size == 01)

```
LD4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

## &lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Vt3&gt;

Is the name of the third SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 2 modulo 32.

## &lt;Vt4&gt;

Is the name of the fourth SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 3 modulo 32.

## &lt;index&gt;

For the '8-bit', '8-bit, immediate offset', and '8-bit, register offset' variants: is the element index, encoded in 'Q:S:size'.

For the '16-bit', '16-bit, immediate offset', and '16-bit, register offset' variants: is the element index, encoded in 'Q:S:size&lt;1&gt;'.

For the '32-bit', '32-bit, immediate offset', and '32-bit, register offset' variants: is the element index, encoded in 'Q:S'.

For the '64-bit', '64-bit, immediate offset', and '64-bit, register offset' variants: is the element index, encoded in 'Q'.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then EndOfDecode(Decode_UNDEF); end scale = size; replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then EndOfDecode(Decode_UNDEF); end
```

```
index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then EndOfDecode(Decode_UNDEF); end if size<0> == '0' then index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1] scale = '11'; end end constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize); offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register for s = 0 to selem-1 rval = V[t, 128]; eaddr = AddressIncrement(address, offs, accdesc); Elem[rval, index, esize] = Mem[eaddr, ebytes, accdesc]; V[t, 128] = rval; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.215 LD4R

Load single 4-element structure and replicate to all lanes of four registers

This instruction loads a 4-element structure from memory and replicates the structure to all the lanes of the four SIMD&amp;FP registers.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
LD4R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

## (FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the Immediate offset variant

```
Applies when (Rm == 11111) LD4R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>
```

## Encoding for the Register offset variant

Applies when (Rm != 11111)

```
LD4R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>],
```

```
<Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

## &lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |
|     10 |   1 | 4S    |
|     11 |   0 | 1D    |
|     11 |   1 | 2D    |

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Vt3&gt;

Is the name of the third SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 2 modulo 32.

## &lt;Vt4&gt;

Is the name of the fourth SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 3 modulo 32.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the post-index immediate offset, encoded in 'size':

|   size | <imm>   |
|--------|---------|
|     00 | #4      |

&lt;T&gt;

<!-- image -->

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then scale = size; replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then EndOfDecode(Decode_UNDEF); end if size<0> == '0' then index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1] scale = '11'; end end constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64);
```

|   size | <imm>   |
|--------|---------|
|     01 | #8      |
|     10 | #16     |
|     11 | #32     |

```
EndOfDecode(Decode_UNDEF); end
```

```
if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize); offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register for s = 0 to selem-1 rval = V[t, 128]; eaddr = AddressIncrement(address, offs, accdesc); Elem[rval, index, esize] = Mem[eaddr, ebytes, accdesc]; V[t, 128] = rval; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.216 LDAP1 (SIMD&amp;FP)

Load-acquire RCpc one single-element structure to one lane of one register

This instruction loads a single-element structure from memory and writes the result to the specified lane of the SIMD&amp;FP register without affecting the other bits of the register.

The instruction has memory ordering semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release, except that:

- There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
- The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.

For information about addressing modes, see Load/Store addressing modes.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## 64-bit

(FEAT\_AdvSIMD &amp;&amp; FEAT\_LRCPC3)

<!-- image -->

## Encoding

```
LDAP1 { <Vt>.D
```

```
}[<index>], [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_LRCPC3) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

&lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;index&gt;

Is the element index, encoded in 'Q'.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then scale = size; replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then EndOfDecode(Decode_UNDEF); end if size<0> == '0' then index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1] scale = '11'; end end constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant AccessDescriptor accdesc = if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize); offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register for s = 0 to selem-1 rval = V[t, 128];
```

```
EndOfDecode(Decode_UNDEF); end Operation CreateAccDescASIMDAcqRel(MemOp_LOAD, tagchecked);
```

```
eaddr = AddressIncrement(address, offs, accdesc); Elem[rval, index, esize] = Mem[eaddr, ebytes, accdesc]; V[t, 128] = rval; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.217 LDAPUR (SIMD&amp;FP)

Load-acquire RCpc SIMD&amp;FP register (unscaled offset)

This instruction loads a SIMD&amp;FP register from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset.

The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release, except that:

- There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
- The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Unscaled offset

(FEAT\_FP &amp;&amp; FEAT\_LRCPC3)

<!-- image -->

## Encoding for the 8-bit variant

```
Applies when (size == 00 && opc == 01) LDAPUR <Bt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 16-bit variant

```
Applies when (size == 01 && opc == 01) LDAPUR <Ht>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 32-bit variant

```
Applies when (size == 10 && opc == 01) LDAPUR <St>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11 && opc == 01) LDAPUR <Dt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 128-bit variant

```
Applies when (size == 00 && opc == 11) LDAPUR <Qt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) || !IsFeatureImplemented(FEAT_LRCPC3) then EndOfDecode(Decode_UNDEF); if opc<1> == '1' && size != '00' then EndOfDecode(Decode_UNDEF); constant integer scale = if opc<1> == '1' then 4 else UInt(size); constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Bt&gt;

Is the 8-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## &lt;Ht&gt;

## &lt;St&gt;

## &lt;Dt&gt;

## &lt;Qt&gt;

Is the 128-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8 << constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; constant AccessDescriptor accdesc = if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); V[t, datasize] = Mem[address, datasize DIV 8, accdesc];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

Is the 16-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 32-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 64-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

```
scale;
```

```
CreateAccDescASIMDAcqRel(MemOp_LOAD, tagchecked);
```

## C7.2.218 LDBFADD, LDBFADDA, LDBFADDAL, LDBFADDL

Atomic BFloat16 add

This instruction atomically loads a 16-bit value from memory, adds it to the BFloat16 value held in a register, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- LDBFADDA and LDBFADDAL load from memory with acquire semantics.
- LDBFADDL and LDBFADDAL store to memory with release semantics.
- LDBFADD has neither acquire nor release semantics.

## This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R == 0) LDBFADD <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDBFADDA <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R == 1) LDBFADDAL <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R == 1) LDBFADDL <Hs>, <Ht>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer s = UInt(Rs); constant integer datasize = 16; constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Ht&gt;

Is the 16-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_BFADD, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc); V[t, datasize] = data;
```

## C7.2.219 LDBFMAX, LDBFMAXA, LDBFMAXAL, LDBFMAXL

Atomic BFloat16 maximum

This instruction atomically loads a 16-bit value from memory, computes the BFloat16 maximum with the value held in a register, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- LDBFMAXA and LDBFMAXAL load from memory with acquire semantics.
- LDBFMAXL and LDBFMAXAL store to memory with release semantics.
- LDBFMAX has neither acquire nor release semantics.

This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R == 0) LDBFMAX <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDBFMAXA <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R == 1) LDBFMAXAL <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Release variant

Applies when

(A == 0

LDBFMAXL

&amp;&amp;

R

==

&lt;Hs&gt;, &lt;Ht&gt;, [&lt;Xn|SP&gt;]

1)

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer s = UInt(Rs); constant integer datasize = 16; constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Ht&gt;

Is the 16-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_BFMAX, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc); V[t, datasize] = data;
```

## C7.2.220 LDBFMAXNM, LDBFMAXNMA, LDBFMAXNMAL, LDBFMAXNML

Atomic BFloat16 maximum number

This instruction atomically loads a 16-bit value from memory, computes the BFloat16 maximum number with the value held in a register, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- LDBFMAXNMA and LDBFMAXNMAL load from memory with acquire semantics.
- LDBFMAXNML and LDBFMAXNMAL store to memory with release semantics.
- LDBFMAXNM has neither acquire nor release semantics.

This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the No memory ordering variant

Applies when

(A == 0

&amp;&amp;

R

==

0)

LDBFMAXNM

&lt;Hs&gt;, &lt;Ht&gt;, [&lt;Xn|SP&gt;]

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDBFMAXNMA <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R == 1) LDBFMAXNMAL <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Release variant

Applies when

(A == 0

LDBFMAXNML

&amp;&amp;

R

==

1)

&lt;Hs&gt;, &lt;Ht&gt;, [&lt;Xn|SP&gt;]

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer s = UInt(Rs); constant integer datasize = 16; constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Ht&gt;

Is the 16-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_BFMAXNM, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc); V[t, datasize] = data;
```

## C7.2.221 LDBFMIN, LDBFMINA, LDBFMINAL, LDBFMINL

Atomic BFloat16 minimum

This instruction atomically loads a 16-bit value from memory, computes the BFloat16 minimum with the value held in a register, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- LDBFMINA and LDBFMINAL load from memory with acquire semantics.
- LDBFMINL and LDBFMINAL store to memory with release semantics.
- LDBFMIN has neither acquire nor release semantics.

## This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R == 0) LDBFMIN <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDBFMINA <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R == 1) LDBFMINAL <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Release variant

Applies when

(A == 0

LDBFMINL

&amp;&amp;

R

==

&lt;Hs&gt;, &lt;Ht&gt;, [&lt;Xn|SP&gt;]

1)

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer s = UInt(Rs); constant integer datasize = 16; constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Ht&gt;

Is the 16-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_BFMIN, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc); V[t, datasize] = data;
```

## C7.2.222 LDBFMINNM, LDBFMINNMA, LDBFMINNMAL, LDBFMINNML

Atomic BFloat16 minimum number

This instruction atomically loads a 16-bit value from memory, computes the BFloat16 minimum number with the value held in a register, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- LDBFMINNMA and LDBFMINNMAL load from memory with acquire semantics.
- LDBFMINNML and LDBFMINNMAL store to memory with release semantics.
- LDBFMINNM has neither acquire nor release semantics.

This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the No memory ordering variant

Applies when

(A == 0

&amp;&amp;

R

==

0)

LDBFMINNM

&lt;Hs&gt;, &lt;Ht&gt;, [&lt;Xn|SP&gt;]

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDBFMINNMA <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R == 1) LDBFMINNMAL <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Release variant

Applies when

(A == 0

LDBFMINNML

&amp;&amp;

R

==

1)

&lt;Hs&gt;, &lt;Ht&gt;, [&lt;Xn|SP&gt;]

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer s = UInt(Rs); constant integer datasize = 16; constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Ht&gt;

Is the 16-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_BFMINNM, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc); V[t, datasize] = data;
```

## C7.2.223 LDFADD, LDFADDA, LDFADDAL, LDFADDL

Atomic floating-point add

This instruction atomically loads a 16-bit, 32-bit, or 64-bit value from memory, performs a floating-point add with the value held in a register, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- LDFADDA and LDFADDAL load from memory with acquire semantics.
- LDFADDL and LDFADDAL store to memory with release semantics.
- LDFADD has neither acquire nor release semantics.

## This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the Half-precision no memory ordering variant

```
Applies when (size == 01 && A == 0 && R == 0)
```

```
LDFADD <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision acquire variant

```
Applies when (size == 01 && A == 1 && R ==
```

```
LDFADDA
```

```
0) <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision acquire-release variant

```
Applies when (size == 01 && A == 1 && R ==
```

```
LDFADDAL
```

```
1) <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision release variant

```
Applies when (size == 01 && A == 0 && R ==
```

```
LDFADDL
```

```
1) <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Single-precision no memory ordering variant

```
Applies when (size == 10 && A == 0 && R == 0)
```

```
LDFADD <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision acquire variant

```
Applies when (size == 10 && A == 1 && R == 0)
```

```
LDFADDA <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision acquire-release variant

```
Applies when (size == 10 && A == 1 && R == 1)
```

```
LDFADDAL <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision release variant

```
Applies when (size == 10 && A == 0 && R == 1)
```

LDFADDL

&lt;Ss&gt;, &lt;St&gt;, [&lt;Xn|SP&gt;]

## Encoding for the Double-precision no memory ordering variant

```
Applies when (size == 11 && A == 0 && R == 0)
```

```
LDFADD <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision acquire variant

```
Applies when (size == 11 && A == 1 && R == 0)
```

```
LDFADDA <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision acquire-release variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDFADDAL
```

```
1) <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision release variant

```
Applies when (size == 11 && A == 0 && R == 1)
```

```
LDFADDL <Ds>, <Dt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LSFE) then constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer s = UInt(Rs); constant integer datasize = 8 << UInt(size); constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Ht&gt;

Is the 16-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Ss&gt;

<!-- image -->

## &lt;Ds&gt;

## &lt;Dt&gt;

Is the 64-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_FPADD, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc); V[t, datasize] = data;
```

Is the 32-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

Is the 32-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

Is the 64-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## C7.2.224 LDFMAX, LDFMAXA, LDFMAXAL, LDFMAXL

Atomic floating-point maximum

This instruction atomically loads a 16-bit, 32-bit, or 64-bit value from memory, computes the floating-point maximum with the value held in a register, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- LDFMAXA and LDFMAXAL load from memory with acquire semantics.
- LDFMAXL and LDFMAXAL store to memory with release semantics.
- LDFMAX has neither acquire nor release semantics.

## This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the Half-precision no memory ordering variant

```
Applies when (size == 01 && A == 0 && R == 0)
```

```
LDFMAX <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision acquire variant

```
Applies when (size == 01 && A == 1 && R ==
```

```
LDFMAXA
```

```
0) <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision acquire-release variant

```
Applies when (size == 01 && A == 1 && R == 1) LDFMAXAL <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision release variant

```
Applies when (size == 01 && A == 0 && R == 1)
```

```
LDFMAXL <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Single-precision no memory ordering variant

```
Applies when (size == 10 && A == 0 && R == 0)
```

```
LDFMAX <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision acquire variant

```
Applies when (size == 10 && A == 1 && R == 0)
```

```
LDFMAXA <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision acquire-release variant

```
Applies when (size == 10 && A == 1 && R == 1)
```

```
LDFMAXAL <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision release variant

```
Applies when (size == 10 && A == 0 && R == 1)
```

LDFMAXL

&lt;Ss&gt;, &lt;St&gt;, [&lt;Xn|SP&gt;]

## Encoding for the Double-precision no memory ordering variant

```
Applies when (size == 11 && A == 0 && R == 0)
```

```
LDFMAX <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision acquire variant

```
Applies when (size == 11 && A == 1 && R == 0)
```

```
LDFMAXA <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision acquire-release variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDFMAXAL
```

```
1) <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision release variant

```
Applies when (size == 11 && A == 0 && R == 1)
```

```
LDFMAXL <Ds>, <Dt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LSFE) then constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer s = UInt(Rs); constant integer datasize = 8 << UInt(size); constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Ht&gt;

Is the 16-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Ss&gt;

<!-- image -->

## &lt;Ds&gt;

## &lt;Dt&gt;

Is the 64-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_FPMAX, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc); V[t, datasize] = data;
```

Is the 32-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

Is the 32-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

Is the 64-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## C7.2.225 LDFMAXNM, LDFMAXNMA, LDFMAXNMAL, LDFMAXNML

Atomic floating-point maximum number

This instruction atomically loads a 16-bit, 32-bit, or 64-bit value from memory, computes the floating-point maximum number with the value held in a register, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- LDFMAXNMA and LDFMAXNMAL load from memory with acquire semantics.
- LDFMAXNML and LDFMAXNMAL store to memory with release semantics.
- LDFMAXNM has neither acquire nor release semantics.

## This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the Half-precision no memory ordering variant

```
Applies when (size == 01 && A == 0 && R == 0)
```

```
LDFMAXNM <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision acquire variant

```
Applies when (size == 01 && A == 1 && R == 0) LDFMAXNMA <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision acquire-release variant

```
Applies when (size == 01 && A == 1 && R == 1) LDFMAXNMAL <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision release variant

```
Applies when (size == 01 && A == 0 && R == 1) LDFMAXNML <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Single-precision no memory ordering variant

```
Applies when (size == 10 && A == 0 && R == 0)
```

```
LDFMAXNM <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision acquire variant

```
Applies when (size == 10 && A == 1 && R == 0)
```

```
LDFMAXNMA <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision acquire-release variant

```
Applies when (size == 10 && A == 1 && R == 1)
```

```
LDFMAXNMAL <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision release variant

```
Applies when (size == 10 && A == 0 && R == 1)
```

LDFMAXNML

&lt;Ss&gt;, &lt;St&gt;, [&lt;Xn|SP&gt;]

## Encoding for the Double-precision no memory ordering variant

```
Applies when (size == 11 && A == 0 && R == 0)
```

```
LDFMAXNM <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision acquire variant

```
Applies when (size == 11 && A == 1 && R == 0)
```

```
LDFMAXNMA <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision acquire-release variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDFMAXNMAL
```

```
1) <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision release variant

```
Applies when (size == 11 && A == 0 && R == 1)
```

```
LDFMAXNML <Ds>, <Dt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LSFE) then constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer s = UInt(Rs); constant integer datasize = 8 << UInt(size); constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Ht&gt;

Is the 16-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Ss&gt;

<!-- image -->

## &lt;Ds&gt;

## &lt;Dt&gt;

Is the 64-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_FPMAXNM, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc); V[t, datasize] = data;
```

Is the 32-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

Is the 32-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

Is the 64-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## C7.2.226 LDFMIN, LDFMINA, LDFMINAL, LDFMINL

Atomic floating-point minimum

This instruction atomically loads a 16-bit, 32-bit, or 64-bit value from memory, computes the floating-point minimum with the value held in a register, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- LDFMINA and LDFMINAL load from memory with acquire semantics.
- LDFMINL and LDFMINAL store to memory with release semantics.
- LDFMIN has neither acquire nor release semantics.

## This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the Half-precision no memory ordering variant

```
Applies when (size == 01 && A == 0 && R == 0)
```

```
LDFMIN <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision acquire variant

```
Applies when (size == 01 && A == 1 && R ==
```

```
0) LDFMINA <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision acquire-release variant

```
Applies when (size == 01 && A == 1 && R == 1) LDFMINAL <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision release variant

```
Applies when (size == 01 && A == 0 && R ==
```

```
LDFMINL
```

```
1) <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Single-precision no memory ordering variant

```
Applies when (size == 10 && A == 0 && R == 0)
```

```
LDFMIN <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision acquire variant

```
Applies when (size == 10 && A == 1 && R == 0)
```

```
LDFMINA <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision acquire-release variant

```
Applies when (size == 10 && A == 1 && R == 1)
```

```
LDFMINAL <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision release variant

```
Applies when (size == 10 && A == 0 && R == 1)
```

LDFMINL

&lt;Ss&gt;, &lt;St&gt;, [&lt;Xn|SP&gt;]

## Encoding for the Double-precision no memory ordering variant

```
Applies when (size == 11 && A == 0 && R == 0)
```

```
LDFMIN <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision acquire variant

```
Applies when (size == 11 && A == 1 && R == 0)
```

```
LDFMINA <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision acquire-release variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDFMINAL
```

```
1) <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision release variant

```
Applies when (size == 11 && A == 0 && R == 1)
```

```
LDFMINL <Ds>, <Dt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LSFE) then constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer s = UInt(Rs); constant integer datasize = 8 << UInt(size); constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Ht&gt;

Is the 16-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Ss&gt;

<!-- image -->

## &lt;Ds&gt;

## &lt;Dt&gt;

Is the 64-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_FPMIN, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc); V[t, datasize] = data;
```

Is the 32-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

Is the 32-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

Is the 64-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## C7.2.227 LDFMINNM, LDFMINNMA, LDFMINNMAL, LDFMINNML

Atomic floating-point minimum number

This instruction atomically loads a 16-bit, 32-bit, or 64-bit value from memory, computes the floating-point minimum number with the value held in a register, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- LDFMINNMA and LDFMINNMAL load from memory with acquire semantics.
- LDFMINNML and LDFMINNMAL store to memory with release semantics.
- LDFMINNM has neither acquire nor release semantics.

## This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the Half-precision no memory ordering variant

```
Applies when (size == 01 && A == 0 && R == 0)
```

```
LDFMINNM <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision acquire variant

```
Applies when (size == 01 && A == 1 && R == 0) LDFMINNMA <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision acquire-release variant

```
Applies when (size == 01 && A == 1 && R == 1) LDFMINNMAL <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Half-precision release variant

```
Applies when (size == 01 && A == 0 && R == 1) LDFMINNML <Hs>, <Ht>, [<Xn|SP>]
```

## Encoding for the Single-precision no memory ordering variant

```
Applies when (size == 10 && A == 0 && R == 0)
```

```
LDFMINNM <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision acquire variant

```
Applies when (size == 10 && A == 1 && R == 0)
```

```
LDFMINNMA <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision acquire-release variant

```
Applies when (size == 10 && A == 1 && R == 1)
```

```
LDFMINNMAL <Ss>, <St>, [<Xn|SP>]
```

## Encoding for the Single-precision release variant

```
Applies when (size == 10 && A == 0 && R == 1)
```

LDFMINNML

&lt;Ss&gt;, &lt;St&gt;, [&lt;Xn|SP&gt;]

## Encoding for the Double-precision no memory ordering variant

```
Applies when (size == 11 && A == 0 && R == 0)
```

```
LDFMINNM <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision acquire variant

```
Applies when (size == 11 && A == 1 && R == 0)
```

```
LDFMINNMA <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision acquire-release variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDFMINNMAL
```

```
1) <Ds>, <Dt>, [<Xn|SP>]
```

## Encoding for the Double-precision release variant

```
Applies when (size == 11 && A == 0 && R == 1)
```

```
LDFMINNML <Ds>, <Dt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LSFE) then constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer s = UInt(Rs); constant integer datasize = 8 << UInt(size); constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Ht&gt;

Is the 16-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Ss&gt;

<!-- image -->

## &lt;Ds&gt;

## &lt;Dt&gt;

Is the 64-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_FPMINNM, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc); V[t, datasize] = data;
```

Is the 32-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

Is the 32-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

Is the 64-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## C7.2.228 LDNP (SIMD&amp;FP)

Load pair of SIMD&amp;FP registers, with non-temporal hint

This instruction loads a pair of SIMD&amp;FP registers from memory, issuing a hint to the memory system that the access is non-temporal. The address that is used for the load is calculated from a base register value and an optional immediate offset.

For information about non-temporal pair instructions, see Load/Store SIMD and Floating-point non-temporal pair.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Signed offset

(FEAT\_FP)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) LDNP
```

```
<St1>, <St2>, [<Xn|SP>{, #<imm>}]
```

## Encoding for the 64-bit variant

Applies when

```
(opc == 01) LDNP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]
```

## Encoding for the 128-bit variant

```
Applies when (opc == 10) LDNP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for all variants of this encoding

// Empty.

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDNP (SIMD&amp;FP).

## Assembler Symbols

&lt;St1&gt;

Is the 32-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

&lt;St2&gt;

Is the 32-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the '32-bit' variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/4.

For the '64-bit' variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/8.

For the '128-bit' variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/16.

## &lt;Dt1&gt;

Is the 64-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Dt2&gt;

Is the 64-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## &lt;Qt1&gt;

Is the 128-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Qt2&gt;

Is the 128-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## Shared Decode

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); end constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = TRUE; constant integer{} scale = 2 + (UInt(opc) as integer{0..2}); constant integer{} datasize = 8 << scale; constant bits(64) offset = LSL(SignExtend(imm7, 64), scale); constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // Result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; constant integer dbytes = datasize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged, ispair); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64];
```

```
address = AddressAdd(address, offset, accdesc); constant bits(2*datasize) data = Mem[address, 2*dbytes, accdesc]; if rt_unknown then V[t , datasize] = bits(datasize) UNKNOWN; elsif BigEndian(accdesc.acctype) then V[t2, datasize] = data<(datasize-1):0>; V[t , datasize] = data<(2*datasize-1):datasize>; else V[t , datasize] = data<(datasize-1):0>; V[t2, datasize] = data<(2*datasize-1):datasize>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.229 LDP (SIMD&amp;FP)

Load pair of SIMD&amp;FP registers

This instruction loads a pair of SIMD&amp;FP registers from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

(FEAT\_FP)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) LDP <St1>, <St2>, [<Xn|SP>], #<imm>
```

## Encoding for the 64-bit variant

```
Applies when (opc == 01) LDP
```

```
<Dt1>, <Dt2>, [<Xn|SP>], #<imm>
```

## Encoding for the 128-bit variant

```
Applies when (opc == 10) LDP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF);
```

```
constant boolean wback = TRUE; constant boolean postindex = TRUE;
```

## Pre-index

## (FEAT\_FP)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) LDP
```

```
<St1>, <St2>, [<Xn|SP>, #<imm>]!
```

## Encoding for the 64-bit variant

```
Applies when (opc == 01) LDP <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!
```

## Encoding for the 128-bit variant

```
Applies when (opc == 10) LDP <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF);
```

```
constant boolean wback = TRUE; constant boolean postindex = FALSE;
```

## Signed offset

(FEAT\_FP)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) LDP
```

```
<St1>, <St2>, [<Xn|SP>{, #<imm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 01) LDP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]
```

## Encoding for the 128-bit variant

```
Applies when (opc == 10) LDP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF);
```

```
constant boolean wback = FALSE; constant boolean postindex = FALSE;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDP (SIMD&amp;FP).

## Assembler Symbols

## &lt;St1&gt;

Is the 32-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;St2&gt;

Is the 32-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the 'Post-index 32-bit' and 'Pre-index 32-bit' variants: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the 'imm7' field as &lt;imm&gt;/4.

For the 'Post-index 64-bit' and 'Pre-index 64-bit' variants: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the 'imm7' field as &lt;imm&gt;/8.

For the 'Post-index 128-bit' and 'Pre-index 128-bit' variants: is the signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, encoded in the 'imm7' field as &lt;imm&gt;/16.

For the 'Signed offset 32-bit' variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/4.

For the 'Signed offset 64-bit' variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/8.

For the 'Signed offset 128-bit' variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/16.

## &lt;Dt1&gt;

Is the 64-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Dt2&gt;

Is the 64-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## &lt;Qt1&gt;

Is the 128-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Qt2&gt;

Is the 128-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = FALSE; constant integer{} scale = 2 + (UInt(opc) as integer{0..2}); constant integer{} datasize = 8 << scale; constant bits(64) offset = LSL(SignExtend(imm7, 64), scale); constant boolean tagchecked = wback || n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // Result is UNKNOWN
```

```
when Constraint_UNDEF when Constraint_NOP end end
```

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; constant integer dbytes = datasize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged, ispair); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); constant bits(2*datasize) data = Mem[address, 2*dbytes, accdesc]; if rt_unknown then V[t , datasize] = bits(datasize) UNKNOWN; elsif BigEndian(accdesc.acctype) then V[t2, datasize] = data<(datasize-1):0>; V[t , datasize] = data<(2*datasize-1):datasize>; else V[t , datasize] = data<(datasize-1):0>; V[t2, datasize] = data<(2*datasize-1):datasize>; if wback then if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF); EndOfDecode(Decode_NOP);
```

## C7.2.230 LDR (immediate, SIMD&amp;FP)

Load SIMD&amp;FP register (immediate offset)

This instruction loads an element from memory, and writes the result as a scalar to the SIMD&amp;FP register. The address that is used for the load is calculated from a base register value, a signed immediate offset, and an optional offset that is a multiple of the element size.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 3 classes: Post-index, Pre-index, and Unsigned offset

## Post-index

(FEAT\_FP)

<!-- image -->

## Encoding for the 8-bit variant

```
Applies when (size == 00 && opc == 01) LDR <Bt>, [<Xn|SP>], #<simm>
```

## Encoding for the 16-bit variant

Applies when

```
LDR
```

```
(size == 01 && opc == 01) <Ht>, [<Xn|SP>], #<simm>
```

## Encoding for the 32-bit variant

Applies when (size == 10 &amp;&amp; opc == 01)

```
LDR <St>, [<Xn|SP>], #<simm>
```

## Encoding for the 64-bit variant

```
Applies when (size == 11 && opc == 01) LDR <Dt>, [<Xn|SP>], #<simm>
```

## Encoding for the 128-bit variant

Applies when (size == 00 &amp;&amp; opc == 11)

```
LDR <Qt>, [<Xn|SP>], #<simm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); UInt(size);
```

```
if opc<1> == '1' && size != '00' then EndOfDecode(Decode_UNDEF); constant integer scale = if opc<1> == '1' then 4 else constant boolean wback = TRUE; constant boolean postindex = TRUE; constant bits(64) offset = SignExtend(imm9, 64);
```

## Pre-index

(FEAT\_FP)

<!-- image -->

## Encoding for the 8-bit variant

Applies when

```
LDR
```

```
(size == 00 && opc == 01) <Bt>, [<Xn|SP>, #<simm>]!
```

## Encoding for the 16-bit variant

```
Applies when
```

```
LDR
```

```
(size == 01 && opc == 01) <Ht>, [<Xn|SP>, #<simm>]!
```

## Encoding for the 32-bit variant

```
Applies when
```

```
LDR
```

```
(size == 10 && opc == 01) <St>, [<Xn|SP>, #<simm>]!
```

## Encoding for the 64-bit variant

Applies when (size == 11 &amp;&amp; opc == 01)

```
LDR
```

```
<Dt>, [<Xn|SP>, #<simm>]!
```

## Encoding for the 128-bit variant

Applies when (size == 00 &amp;&amp; opc == 11)

```
LDR
```

```
<Qt>, [<Xn|SP>, #<simm>]!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); UInt(size);
```

```
if opc<1> == '1' && size != '00' then EndOfDecode(Decode_UNDEF); constant integer scale = if opc<1> == '1' then 4 else constant boolean wback = TRUE; constant boolean postindex = FALSE; constant bits(64) offset = SignExtend(imm9, 64);
```

## Unsigned offset

(FEAT\_FP)

<!-- image -->

## Encoding for the 8-bit variant

```
Applies when
```

```
LDR
```

```
(size == 00 && opc == 01) <Bt>, [<Xn|SP>{, #<pimm>}]
```

## Encoding for the 16-bit variant

```
Applies when
```

```
LDR
```

```
(size == 01 && opc == 01) <Ht>, [<Xn|SP>{, #<pimm>}]
```

## Encoding for the 32-bit variant

```
Applies when
```

```
LDR
```

```
(size == 10 && opc == 01) <St>, [<Xn|SP>{, #<pimm>}]
```

## Encoding for the 64-bit variant

Applies when (size == 11 &amp;&amp; opc == 01)

```
LDR
```

```
<Dt>, [<Xn|SP>{, #<pimm>}]
```

## Encoding for the 128-bit variant

Applies when (size == 00 &amp;&amp; opc == 11)

```
LDR
```

```
<Qt>, [<Xn|SP>{, #<pimm>}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); UInt(size);
```

```
if opc<1> == '1' && size != '00' then EndOfDecode(Decode_UNDEF); constant integer scale = if opc<1> == '1' then 4 else constant boolean wback = FALSE; constant boolean postindex = FALSE; constant bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
```

## Assembler Symbols

## &lt;Bt&gt;

Is the 8-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the signed immediate byte offset, in the range -256 to 255, encoded in the 'imm9' field.

## &lt;Ht&gt;

&lt;St&gt;

## &lt;Dt&gt;

## &lt;Qt&gt;

Is the 128-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;pimm&gt;

For the '8-bit' variant: is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the 'imm12' field.

For the '16-bit' variant: is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/2.

For the '32-bit' variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/4.

For the '64-bit' variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/8.

For the '128-bit' variant: is the optional positive immediate byte offset, a multiple of 16 in the range 0 to 65520, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/16.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8 << scale; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64];
```

Is the 16-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 32-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 64-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

```
else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); V[t, datasize] = Mem[address, datasize DIV 8, accdesc]; if wback then if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.231 LDR (literal, SIMD&amp;FP)

Load SIMD&amp;FP register (PC-relative literal)

This instruction loads a SIMD&amp;FP register from memory. The address that is used for the load is calculated from the PC value and an immediate offset.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Literal

(FEAT\_FP)

<!-- image -->

VR

## Encoding for the 32-bit variant

Applies when (opc ==

```
00) LDR <St>, <label>
```

## Encoding for the 64-bit variant

```
Applies when (opc == 01) LDR <Dt>, <label>
```

## Encoding for the 128-bit variant

```
(opc ==
```

```
Applies when LDR <Qt>, <label>
```

```
10)
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF);
```

```
constant integer t = UInt(Rt); if opc == '11' then EndOfDecode(Decode_UNDEF); constant integer size = 4 << (UInt(opc)); constant boolean nontemporal = FALSE; constant boolean tagchecked = FALSE; constant bits(64) offset = SignExtend(imm19:'00', 64);
```

## Assembler Symbols

&lt;St&gt;

Is the 32-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as 'imm19' times 4.

## &lt;Dt&gt;

Is the 64-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

<!-- image -->

Is the 128-bit name of the SIMD&amp;FP register to be loaded, encoded in the 'Rt' field.

## Operation

```
constant bits(64) address = PC64 + offset; AArch64.CheckFPEnabled(); constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); constant bits(size*8) data = Mem[address, size, accdesc]; V[t, size*8] = data;
```

## C7.2.232 LDR (register, SIMD&amp;FP)

Load SIMD&amp;FP register (register offset)

This instruction loads a SIMD&amp;FP register from memory. The address that is used for the load is calculated from a base register value and an offset register value. The offset can be optionally shifted and extended.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## SIMD&amp;FP registers

(FEAT\_FP)

<!-- image -->

## Encoding for the 8-bit with extended register offset variant

Applies when (size == 00 &amp;&amp; opc == 01 &amp;&amp; option != 011)

```
LDR <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend>
```

```
{<amount>}]
```

## Encoding for the 8-bit with shifted register offset variant

Applies when (size == 00 &amp;&amp; opc == 01 &amp;&amp; option ==

```
LDR <Bt>, [<Xn|SP>, <Xm>{, LSL
```

## Encoding for the 16-bit variant

```
Applies when (size == 01 && opc == 01) LDR <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]
```

## Encoding for the 32-bit variant

Applies when

```
(size == 10 && opc == 01) LDR <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>
```

## Encoding for the 64-bit variant

```
Applies when (size == 11 && opc == 01) LDR <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>
```

## Encoding for the 128-bit variant

```
Applies when (size == 00 && opc == 11)
```

```
LDR <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>
```

```
011) <amount>}]
```

```
{<amount>}}]
```

```
{<amount>}}]
```

```
{<amount>}}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if option<1> == '0' then EndOfDecode(Decode_UNDEF); // sub-word index if opc<1> == '1' && size != '00' then EndOfDecode(Decode_UNDEF); constant integer scale = if opc<1> == '1' then 4 else UInt(size); constant ExtendType extend_type = DecodeRegExtend(option); constant integer shift = if S == '1' then scale else 0;
```

## Assembler Symbols

## &lt;Bt&gt;

Is the 8-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

When option&lt;0&gt; is set to 0, is the 32-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;Xm&gt;

When option&lt;0&gt; is set to 1, is the 64-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;extend&gt;

For the '8-bit with extended register offset' variant: is the index extend specifier, encoded in 'option':

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |
|      110 | SXTW       |
|      111 | SXTX       |

For the '128-bit', '16-bit', '32-bit', and '64-bit' variants: is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option when &lt;amount&gt; is omitted, encoded in 'option':

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |
|      011 | LSL        |
|      110 | SXTW       |
|      111 | SXTX       |

## &lt;amount&gt;

For the '8-bit with extended register offset' and '8-bit with shifted register offset' variants: is the index shift amount, it must be #0 , encoded in 'S' as 0 if omitted, or as 1 if present.

For the '16-bit' variant: is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

## &lt;Ht&gt;

&lt;St&gt;

&lt;Dt&gt;

&lt;Qt&gt;

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #1         |

For the '32-bit' variant: is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #2         |

For the '64-bit' variant: is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #3         |

For the '128-bit' variant: is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #4         |

Is the 16-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 32-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 64-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 128-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer{} datasize = 8 << scale; constant boolean nontemporal = FALSE; constant boolean tagchecked = TRUE;
```

## Operation

```
AArch64.CheckFPEnabled(); constant bits(64) offset = ExtendReg(m, extend_type, shift, 64); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); V[t, datasize] = Mem[address, datasize DIV 8, accdesc];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.233 LDTNP (SIMD&amp;FP)

Load unprivileged pair of SIMD&amp;FP registers, with non-temporal hint

This instruction loads a pair of SIMD&amp;FP registers from memory, issuing a hint to the memory system that the access is non-temporal. The address that is used for the load is calculated from a base register value and an optional immediate offset. For information about non-temporal pair instructions, see Load/Store SIMD and Floating-point non-temporal pair.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Signed offset

(FEAT\_FP &amp;&amp; FEAT\_LSUI)

<!-- image -->

## Encoding

```
LDTNP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP) || !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = TRUE; constant integer datasize = 128; constant bits(64) offset = LSL(SignExtend(imm7, 64), 4); constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // Result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

LDTNP (SIMD&amp;FP) has the same CONSTRAINED UNPREDICTABLE behavior as LDNP (SIMD&amp;FP) . See Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDNP (SIMD&amp;FP).

## Assembler Symbols

## &lt;Qt1&gt;

Is the 128-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Qt2&gt;

Is the 128-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/16.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; constant integer dbytes = datasize DIV 8; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged, ispair); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(2*datasize) data = Mem[address, 2*dbytes, accdesc]; if rt_unknown then V[t , datasize] = bits(datasize) UNKNOWN; elsif BigEndian(accdesc.acctype) then V[t2, datasize] = data<(datasize-1):0>; V[t , datasize] = data<(2*datasize-1):datasize>; else V[t , datasize] = data<(datasize-1):0>; V[t2, datasize] = data<(2*datasize-1):datasize>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.234 LDTP (SIMD&amp;FP)

Load unprivileged pair of SIMD&amp;FP registers

This instruction loads a pair of SIMD&amp;FP registers from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

(FEAT\_FP &amp;&amp; FEAT\_LSUI)

<!-- image -->

## Encoding

```
LDTP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP) || !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant boolean wback = TRUE; constant boolean postindex = TRUE;
```

## Pre-index

(FEAT\_FP &amp;&amp; FEAT\_LSUI)

<!-- image -->

## Encoding

```
LDTP <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP) || !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant boolean wback = TRUE; constant boolean postindex = FALSE;
```

## Signed offset

(FEAT\_FP &amp;&amp; FEAT\_LSUI)

<!-- image -->

## Encoding

```
LDTP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP) || !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant boolean wback = FALSE; constant boolean postindex = FALSE;
```

LDTP has the same CONSTRAINED UNPREDICTABLE behavior as LDP (SIMD&amp;FP) . See Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDP (SIMD&amp;FP).

## Assembler Symbols

## &lt;Qt1&gt;

Is the 128-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Qt2&gt;

Is the 128-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the 'Load/store register pair (post-indexed)' and 'Load/store register pair (pre-indexed)' variants: is the signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, encoded in the 'imm7' field as &lt;imm&gt;/16.

For the 'Load/store register pair (offset)' variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/16.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = FALSE; constant integer{} datasize = 128; constant bits(64) offset = LSL(SignExtend(imm7, 64), 4); constant boolean tagchecked = wback || n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // Result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

```
Operation
```

```
AArch64.CheckFPEnabled(); bits(64) address; constant integer dbytes = datasize DIV 8; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged, ispair); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); constant bits(2*datasize) data = Mem[address, 2*dbytes, accdesc]; if rt_unknown then V[t , datasize] = bits(datasize) UNKNOWN; elsif BigEndian(accdesc.acctype) then V[t2, datasize] = data<(datasize-1):0>; V[t , datasize] = data<(2*datasize-1):datasize>; else V[t , datasize] = data<(datasize-1):0>; V[t2, datasize] = data<(2*datasize-1):datasize>; if wback then if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.235 LDUR (SIMD&amp;FP)

Load SIMD&amp;FP register (unscaled offset)

This instruction loads a SIMD&amp;FP register from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Unscaled offset

(FEAT\_FP)

<!-- image -->

## Encoding for the 8-bit variant

Applies when (size == 00 &amp;&amp; opc == 01)

```
LDUR
```

```
<Bt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 16-bit variant

```
(size == 01 && opc == 01)
```

```
Applies when LDUR <Ht>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 32-bit variant

```
Applies when (size == 10 && opc == 01) LDUR <St>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11 && opc == 01) LDUR <Dt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 128-bit variant

```
Applies when
```

```
(size == 00 && opc == 11) LDUR <Qt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); UInt(size);
```

```
if opc<1> == '1' && size != '00' then EndOfDecode(Decode_UNDEF); constant integer scale = if opc<1> == '1' then 4 else constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Bt&gt;

Is the 8-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## &lt;Ht&gt;

## &lt;St&gt;

## &lt;Dt&gt;

## &lt;Qt&gt;

Is the 128-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8 << constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); V[t, datasize] = Mem[address, datasize DIV 8, accdesc];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

Is the 16-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 32-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 64-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

```
scale;
```

## C7.2.236 LUTI2

Lookup table read with 2-bit indices

This instruction copies indexed 8-bit or 16-bit elements from the table vector to the destination vector using packed 2-bit indices from a segment of the source vector. A segment corresponds to a portion of the source vector that is consumed in order to fill the destination vector. The segment is selected by the vector segment index.

## Advanced SIMD

(FEAT\_AdvSIMD &amp;&amp; FEAT\_LUT)

<!-- image -->

## Encoding for the Byte variant

Applies when (op2 == 10 &amp;&amp; op ==

```
1)
```

```
LUTI2 <Vd>.16B, { <Vn>.16B },
```

```
<Vm>[<index>]
```

## Encoding for the Halfword variant

```
Applies when (op2 == 11) LUTI2 <Vd>.8H, { <Vn>.8H },
```

```
<Vm>[<index>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_LUT) EndOfDecode(Decode_UNDEF); if op2 == '10' && op == '0' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer isize = 2; constant integer esize = if op2 == '10' then 8 else 16; constant integer part = if op2 == '10' then UInt(len) else UInt(len:op);
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the SIMD&amp;FP table register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;index&gt;

For the 'Byte' variant: is the vector segment index, in the range 0 to 3, encoded in the 'len' field.

For the 'Halfword' variant: is the vector segment index, in the range 0 to 7, encoded in the 'len:op' fields.

```
then
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant integer elements = 128 DIV esize; constant integer ibase = elements * part; constant bits(128) indices = V[m, 128]; constant bits(128) table = V[n, 128]; bits(128) result; for e = 0 to elements-1 constant integer index = UInt(Elem[indices, ibase + Elem[result, e, esize] = Elem[table, index, esize]; V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
e, isize]);
```

## C7.2.237 LUTI4

Lookup table read with 4-bit indices

This instruction copies indexed 8-bit or 16-bit elements from the one or two table vectors to the destination vector using packed 4-bit indices from a segment of the source vector. A segment corresponds to a portion of the source vector that is consumed in order to fill the destination vector. The segment is selected by the vector segment index.

## Advanced SIMD

(FEAT\_AdvSIMD &amp;&amp; FEAT\_LUT)

<!-- image -->

## Encoding for the Byte variant

Applies when (len == x1 &amp;&amp; op ==

```
0)
```

```
LUTI4 <Vd>.16B, { <Vn>.16B },
```

```
<Vm>[<index>]
```

## Encoding for the Halfword variant

```
Applies when (op == 1)
```

```
LUTI4 <Vd>.8H, { <Vn1>.8H, <Vn2>.8H },
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_LUT) EndOfDecode(Decode_UNDEF); if len<0> == '0' && op == '0' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer isize = 4; constant integer esize = 8 << UInt(op); constant integer ntblr = 1 << UInt(op); constant integer part = if op == '0' then UInt(len<1>) else UInt(len);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the SIMD&amp;FP table register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;index&gt;

For the 'Byte' variant: is the vector segment index, in the range 0 to 1, encoded in the 'len&lt;1&gt;' field.

For the 'Halfword' variant: is the vector segment index, in the range 0 to 3, encoded in the 'len' field.

```
<Vm>[<index>]
```

```
then
```

## &lt;Vn1&gt;

Is the name of the first SIMD&amp;FP table register, encoded in the 'Rn' field.

&lt;Vn2&gt;

Is the name of the second SIMD&amp;FP table register, encoded as 'Rn' plus 1 modulo 32.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant integer elements = 128 DIV esize; constant integer ibase = elements * part; constant bits(128) indices = V[m, 128]; constant bits(128) table1 = V[n+0, 128]; constant bits(128) table2 = if ntblr == 2 then V[(n+1) MOD 32, 128] else Zeros(128); bits(128) result; bits(esize) res; for e = 0 to elements-1 constant integer index = UInt(Elem[indices, ibase + e, isize]); if index < elements then res = Elem[table1, index, esize]; else assert ntblr == 2; res = Elem[table2, index -elements, esize]; Elem[result, e, esize] = res; V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.238 MLA (by element)

Multiply-add to accumulator (vector, by element)

This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and accumulates the results with the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
MLA <Vd>.<T>, <Vn>.<T>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |

<!-- image -->

## &lt;Vn&gt;

&lt;m&gt;

&lt;Ts&gt;

Is an element size specifier, encoded in 'size':

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

|   size | Q   | <T>      |
|--------|-----|----------|
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |
|     11 | RESERVED     |

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

Restricted to 0-15 when element size &lt;Ts&gt; is H.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; integer element1; integer element2; bits(esize) product; element2 = UInt(Elem[operand2, index, esize]); for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); product = (element1 * element2)<esize-1:0>; Elem[result, e, esize] = Elem[operand3, e, esize] + V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
product;
```

## C7.2.239 MLA (vector)

Multiply-add to accumulator (vector)

This instruction multiplies corresponding elements in the vectors of the two source SIMD&amp;FP registers, and accumulates the results with the vector elements of the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
MLA
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; bits(esize) product; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; product = (UInt(element1) * UInt(element2))<esize-1:0>; Elem[result, e, esize] = Elem[operand3, e, esize] + product; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.240 MLS (by element)

Multiply-subtract from accumulator (vector, by element)

This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and subtracts the results from the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
MLS <Vd>.<T>, <Vn>.<T>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |

<!-- image -->

## &lt;Vn&gt;

&lt;m&gt;

&lt;Ts&gt;

Is an element size specifier, encoded in 'size':

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

|   size | Q   | <T>      |
|--------|-----|----------|
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |
|     11 | RESERVED     |

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

Restricted to 0-15 when element size &lt;Ts&gt; is H.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; integer element1; integer element2; bits(esize) product; element2 = UInt(Elem[operand2, index, esize]); for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); product = (element1 * element2)<esize-1:0>; Elem[result, e, esize] = Elem[operand3, e, esize] V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
product;
```

## C7.2.241 MLS (vector)

Multiply-subtract from accumulator (vector)

This instruction multiplies corresponding elements in the vectors of the two source SIMD&amp;FP registers, and subtracts the results from the vector elements of the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
MLS
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; bits(esize) product; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; product = (UInt(element1) * UInt(element2))<esize-1:0>; Elem[result, e, esize] = Elem[operand3, e, esize] product; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.242 MOV (scalar)

Move vector element to scalar

This instruction duplicates the specified vector element in the SIMD&amp;FP source register into a scalar, and writes the result to the SIMD&amp;FP destination register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This is an alias of DUP (element). This means:

- The encodings in this description are named to match the encodings of DUP (element).
- The description of DUP (element) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

MOV

&lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;[&lt;index&gt;]

is equivalent to

DUP

&lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;[&lt;index&gt;]

and is always the preferred disassembly.

## Assembler Symbols

<!-- image -->

&lt;V&gt;

Is the destination width specifier, encoded in 'imm5':

| imm5   | <V>      |
|--------|----------|
| x0000  | RESERVED |
| xxxx1  | B        |
| xxx10  | H        |
| xx100  | S        |
| x1000  | D        |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

<!-- image -->

&lt;Vn&gt;

&lt;T&gt;

Is the element width specifier, encoded in 'imm5':

## &lt;index&gt;

Is the element index encoded in 'imm5':

## Operation

The description of DUP (element) gives the operational pseudocode for this instruction.

## Operational Information

The description of DUP (element) gives the operational information for this instruction.

| imm5   | <T>      |
|--------|----------|
| x0000  | RESERVED |
| xxxx1  | B        |
| xxx10  | H        |
| xx100  | S        |
| x1000  | D        |

| imm5   | <index>         |
|--------|-----------------|
| x0000  | RESERVED        |
| xxxx1  | UInt(imm5<4:1>) |
| xxx10  | UInt(imm5<4:2>) |
| xx100  | UInt(imm5<4:3>) |
| x1000  | UInt(imm5<4>)   |

## C7.2.243 MOV (element)

Move vector element to another vector element

This instruction copies the vector element of the source SIMD&amp;FP register to the specified vector element of the destination SIMD&amp;FP register.

This instruction can insert data into individual elements within a SIMD&amp;FP register without clearing the remaining bits to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This is an alias of INS (element). This means:

- The encodings in this description are named to match the encodings of INS (element).
- The description of INS (element) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

| MOV              | <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]   |
|------------------|--------------------------------------------|
| is equivalent to | is equivalent to                           |
| INS              | <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]   |

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an element size specifier, encoded in 'imm5':

## &lt;Ts&gt;

| imm5   | <Ts>     |
|--------|----------|
| x0000  | RESERVED |
| xxxx1  | B        |
| xxx10  | H        |
| xx100  | S        |
| x1000  | D        |

## &lt;index1&gt;

Is the destination element index encoded in 'imm5':

## &lt;Vn&gt;

| imm5   | <index1>        |
|--------|-----------------|
| x0000  | RESERVED        |
| xxxx1  | UInt(imm5<4:1>) |
| xxx10  | UInt(imm5<4:2>) |
| xx100  | UInt(imm5<4:3>) |
| x1000  | UInt(imm5<4>)   |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;index2&gt;

Is the source element index encoded in 'imm5:imm4':

| imm5   | <index2>        |
|--------|-----------------|
| x0000  | RESERVED        |
| xxxx1  | UInt(imm4)      |
| xxx10  | UInt(imm4<3:1>) |
| xx100  | UInt(imm4<3:2>) |
| x1000  | UInt(imm4<3>)   |

Unspecified bits in 'imm4' are ignored but should be set to zero by an assembler.

## Operation

The description of INS (element) gives the operational pseudocode for this instruction.

## Operational Information

The description of INS (element) gives the operational information for this instruction.

## C7.2.244 MOV (from general)

Move general-purpose register to a vector element

This instruction copies the contents of the source general-purpose register to the specified vector element in the destination SIMD&amp;FP register.

This instruction can insert data into individual elements within a SIMD&amp;FP register without clearing the remaining bits to zero.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This is an alias of INS (general). This means:

- The encodings in this description are named to match the encodings of INS (general).
- The description of INS (general) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

| MOV              | <Vd>.<Ts>[<index>], <R><n>   |
|------------------|------------------------------|
| is equivalent to | is equivalent to             |
| INS              | <Vd>.<Ts>[<index>], <R><n>   |

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an element size specifier, encoded in 'imm5':

## &lt;Ts&gt;

| imm5   | <Ts>     |
|--------|----------|
| x0000  | RESERVED |
| xxxx1  | B        |
| xxx10  | H        |
| xx100  | S        |
| x1000  | D        |

## &lt;index&gt;

Is the element index encoded in 'imm5':

<!-- image -->

<!-- image -->

Is the number [0-30] of the general-purpose source register or ZR (31), encoded in the 'Rn' field.

## Operation

The description of INS (general) gives the operational pseudocode for this instruction.

## Operational Information

The description of INS (general) gives the operational information for this instruction.

| imm5   | <index>         |
|--------|-----------------|
| x0000  | RESERVED        |
| xxxx1  | UInt(imm5<4:1>) |
| xxx10  | UInt(imm5<4:2>) |
| xx100  | UInt(imm5<4:3>) |
| x1000  | UInt(imm5<4>)   |

Is the width specifier for the general-purpose source register, encoded in 'imm5':

| imm5   | <R>      |
|--------|----------|
| x0000  | RESERVED |
| xxxx1  | W        |
| xxx10  | W        |
| xx100  | W        |
| x1000  | X        |

## C7.2.245 MOV (vector)

Move vector

This instruction copies the vector in the source SIMD&amp;FP register into the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This is an alias of ORR (vector, register). This means:

- The encodings in this description are named to match the encodings of ORR (vector, register).
- The description of ORR (vector, register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
MOV <Vd>.<T>, <Vn>.<T>
```

## is equivalent to

```
ORR <Vd>.<T>, <Vn>.<T>, <Vn>.<T>
```

and is the preferred disassembly when Rm == Rn .

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;T&gt;

## &lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

The description of ORR (vector, register) gives the operational pseudocode for this instruction.

## Operational Information

The description of ORR (vector, register) gives the operational information for this instruction.

## C7.2.246 MOV (to general)

Move vector element to general-purpose register

This instruction reads the unsigned integer from the source SIMD&amp;FP register, zero-extends it to form a 32-bit or 64-bit value, and writes the result to the destination general-purpose register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This is an alias of UMOV. This means:

- The encodings in this description are named to match the encodings of UMOV.
- The description of UMOV gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 32-bit variant

Applies when (Q == 0 &amp;&amp; imm5 == xx100)

```
MOV
```

```
<Wd>, <Vn>.S[<index>]
```

## is equivalent to

```
UMOV <Wd>, <Vn>.S[<index>]
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (Q == 1 && imm5 == x1000) MOV <Xd>, <Vn>.D[<index>]
```

## is equivalent to

```
UMOV <Xd>, <Vn>.D[<index>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;index&gt;

For the '32-bit' variant: is the element index encoded in 'imm5&lt;4:3&gt;'.

For the '64-bit' variant: is the element index encoded in 'imm5&lt;4&gt;'.

<!-- image -->

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

The description of UMOV gives the operational pseudocode for this instruction.

## Operational Information

The description of UMOV gives the operational information for this instruction.

## C7.2.247 MOVI

Move immediate (vector)

This instruction places an immediate constant into every vector element of the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit variant

```
Applies when (op == 0 && cmode == MOVI <Vd>.<T>, #<imm8>{, LSL #0}
```

1110)

## Encoding for the 16-bit shifted immediate variant

```
Applies when (op == 0 && cmode == 10x0)
```

```
MOVI <Vd>.<T>, #<imm8>{, LSL #<amount>}
```

## Encoding for the 32-bit shifted immediate variant

Applies when (op == 0 &amp;&amp; cmode ==

```
MOVI <Vd>.<T>, #<imm8>{, LSL
```

```
0xx0) #<amount>}
```

## Encoding for the 32-bit shifting ones variant

Applies when (op == 0 &amp;&amp; cmode ==

```
110x) MOVI <Vd>.<T>, #<imm8>, MSL #<amount>
```

## Encoding for the 64-bit scalar variant

```
Applies when (Q == 0 && op == 1 && cmode == 1110)
```

```
MOVI <Dd>, #<imm>
```

## Encoding for the 64-bit vector variant

```
Applies when (Q == 1 && op == 1 && cmode == 1110)
```

```
MOVI <Vd>.2D, #<imm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer rd = UInt(Rd); constant integer datasize = 64 << UInt(Q); constant bits(64) imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h); constant bits(datasize) imm = Replicate(imm64, datasize DIV 64);
```

o2

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the '8-bit' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

For the '16-bit shifted immediate' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the '32-bit shifted immediate' and '32-bit shifting ones' variants: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 2S    |
|   1 | 4S    |

&lt;T&gt;

## &lt;imm8&gt;

Is an 8-bit immediate encoded in 'a:b:c:d:e:f:g:h'.

## &lt;amount&gt;

For the '16-bit shifted immediate' variant: is the shift amount encoded in 'cmode&lt;1&gt;':

|   cmode<1> |   <amount> |
|------------|------------|
|          0 |          0 |
|          1 |          8 |

defaulting to 0 if LSL is omitted.

For the '32-bit shifted immediate' variant: is the shift amount encoded in 'cmode&lt;2:1&gt;':

## &lt;Dd&gt;

defaulting to 0 if LSL is omitted.

For the '32-bit shifting ones' variant: is the shift amount encoded in 'cmode&lt;0&gt;':

|   cmode<0> |   <amount> |
|------------|------------|
|          0 |          8 |
|          1 |         16 |

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;imm&gt;

Is a 64-bit immediate 'aaaaaaaabbbbbbbbccccccccddddddddeeeeeeeeffffffffgggggggghhhhhhhh', encoded in 'a:b:c:d:e:f:g:h'.

## Operation

| AArch64.CheckFPAdvSIMDEnabled();   |
|------------------------------------|
| V[rd, datasize] = imm;             |

|   cmode<2:1> |   <amount> |
|--------------|------------|
|           00 |          0 |
|           01 |          8 |
|           10 |         16 |
|           11 |         24 |

## C7.2.248 MUL (by element)

Multiply (vector, by element)

This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
MUL <Vd>.<T>, <Vn>.<T>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |

&lt;T&gt;

## &lt;Vn&gt;

&lt;m&gt;

&lt;Ts&gt;

Is an element size specifier, encoded in 'size':

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

|   size | Q   | <T>      |
|--------|-----|----------|
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |
|     11 | RESERVED     |

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

Restricted to 0-15 when element size &lt;Ts&gt; is H.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(idxdsize) operand2 = bits(datasize) result; integer element1; integer element2; bits(esize) product; element2 = UInt(Elem[operand2, index, esize]); for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); product = (element1 * element2)<esize-1:0>; Elem[result, e, esize] = product; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
V[n, datasize]; V[m, idxdsize];
```

## C7.2.249 MUL (vector)

Multiply (vector)

This instruction multiplies corresponding elements in the vectors of the two source SIMD&amp;FP registers, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
MUL
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if U == '1' && size != '00' then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; bits(esize) product; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; product = (UInt(element1) * UInt(element2))<esize-1:0>; Elem[result, e, esize] = product; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.250 MVN

Bitwise NOT (vector)

This instruction reads each vector element from the source SIMD&amp;FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This is an alias of NOT. This means:

- The encodings in this description are named to match the encodings of NOT.
- The description of NOT gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

MVN

&lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

## is equivalent to

<!-- image -->

and is always the preferred disassembly.

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;T&gt;

## &lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

The description of NOT gives the operational pseudocode for this instruction.

## Operational Information

The description of NOT gives the operational information for this instruction.

## C7.2.251 MVNI

Move inverted immediate (vector)

This instruction places the inverse of an immediate constant into every vector element of the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 16-bit shifted immediate variant

Applies when (cmode ==

```
10x0) MVNI <Vd>.<T>, #<imm8>{, LSL
```

```
#<amount>}
```

## Encoding for the 32-bit shifted immediate variant

```
Applies when (cmode == 0xx0) MVNI <Vd>.<T>, #<imm8>{, LSL
```

```
#<amount>}
```

## Encoding for the 32-bit shifting ones variant

```
Applies when (cmode == 110x) MVNI
```

```
<Vd>.<T>, #<imm8>, MSL #<amount>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer rd = UInt(Rd); constant integer datasize = 64 << UInt(Q); constant bits(64) imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h); constant bits(datasize) imm = Replicate(imm64, datasize DIV 64);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the '16-bit shifted immediate' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |

<!-- image -->

## &lt;imm8&gt;

Is an 8-bit immediate encoded in 'a:b:c:d:e:f:g:h'.

## &lt;amount&gt;

For the '16-bit shifted immediate' variant: is the shift amount encoded in 'cmode&lt;1&gt;':

|   cmode<1> |   <amount> |
|------------|------------|
|          0 |          0 |
|          1 |          8 |

defaulting to 0 if LSL is omitted.

For the '32-bit shifted immediate' variant: is the shift amount encoded in 'cmode&lt;2:1&gt;':

|   cmode<2:1> |   <amount> |
|--------------|------------|
|           00 |          0 |
|           01 |          8 |
|           10 |         16 |
|           11 |         24 |

defaulting to 0 if LSL is omitted.

For the '32-bit shifting ones' variant: is the shift amount encoded in 'cmode&lt;0&gt;':

|   cmode<0> |   <amount> |
|------------|------------|
|          0 |          8 |
|          1 |         16 |

|   Q | <T>   |
|-----|-------|
|   1 | 8H    |

For the '32-bit shifted immediate' and '32-bit shifting ones' variants: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 2S    |
|   1 | 4S    |

## Operation

AArch64.CheckFPAdvSIMDEnabled();

V[rd, datasize] = NOT(imm);

## C7.2.252 NEG (vector)

Negate (vector)

This instruction reads each vector element from the source SIMD&amp;FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
NEG D<d>, D<n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
NEG <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

- &lt;Vd&gt; Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.
- &lt;T&gt;

&lt;Vn&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 element = SInt(Elem[operand, e, esize]); element = -element; Elem[result, e, esize] = element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.253 NOT

Bitwise NOT (vector)

This instruction reads each vector element from the source SIMD&amp;FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This instruction is used by the alias MVN.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
NOT <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV 8;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

<!-- image -->

<!-- image -->

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = bits(datasize) result; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = NOT(element); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
V[n, datasize];
```

| Alias   | Is preferred when   |
|---------|---------------------|
| MVN     | Unconditionally     |

## C7.2.254 ORN (vector)

Bitwise inclusive OR NOT (vector)

This instruction performs a bitwise OR NOT between the two source SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ORN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q);
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;T&gt;

## &lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[d, datasize] = operand1 OR operand2;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
NOT(V[m, datasize]);
```

## C7.2.255 ORR (vector, immediate)

Bitwise inclusive OR (vector, immediate)

This instruction reads each vector element from the destination SIMD&amp;FP register, performs a bitwise OR between each result and an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Shifted immediate

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 16-bit variant

Applies when (cmode == 10x1) ORR &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}

## Encoding for the 32-bit variant

Applies when (cmode ==

```
ORR <Vd>.<T>, #<imm8>{,
```

```
0xx1) LSL #<amount>}
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer rd = UInt(Rd); constant integer datasize = 64 << UInt(Q); constant bits(64) imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h); constant bits(datasize) imm = Replicate(imm64, datasize DIV 64);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP register, encoded in the 'Rd' field.

For the '16-bit' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |

<!-- image -->

## &lt;imm8&gt;

Is an 8-bit immediate encoded in 'a:b:c:d:e:f:g:h'.

## &lt;amount&gt;

For the '16-bit' variant: is the shift amount encoded in 'cmode&lt;1&gt;':

|   cmode<1> |   <amount> |
|------------|------------|
|          0 |          0 |
|          1 |          8 |

defaulting to 0 if LSL is omitted.

For the '32-bit' variant: is the shift amount encoded in 'cmode&lt;2:1&gt;':

|   cmode<2:1> |   <amount> |
|--------------|------------|
|           00 |          0 |
|           01 |          8 |
|           10 |         16 |
|           11 |         24 |

defaulting to 0 if LSL is omitted.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[rd, datasize]; V[rd, datasize] = operand OR imm;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| 1   | 8H   |
|-----|------|

For the '32-bit' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 2S    |
|   1 | 4S    |

## C7.2.256 ORR (vector, register)

Bitwise inclusive OR (vector, register)

This instruction performs a bitwise OR between the two source SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This instruction is used by the alias MOV (vector).

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ORR <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;T&gt;

## &lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Alias Conditions

## Operation

```
V[n, datasize]; V[m, datasize];
```

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = V[d, datasize] = operand1 OR operand2;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

MOV (vector)

## Is preferred when

Rm == Rn

## C7.2.257 PMUL

Polynomial multiply

This instruction multiplies corresponding elements in the vectors of the two source SIMD&amp;FP registers, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register.

For information about multiplying polynomials see Polynomial arithmetic over {0, 1}.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
PMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if U == '1' && size != '00' then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

| size   | Q   | <T>      |
|--------|-----|----------|
| 00     | 0   | 8B       |
| 00     | 1   | 16B      |
| 01     | x   | RESERVED |
| 1x     | x   | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

<!-- image -->

&lt;Vn&gt;

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; bits(esize) product; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; product = PolynomialMult(element1, Elem[result, e, esize] = product; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
element2)<esize-1:0>;
```

## C7.2.258 PMULL, PMULL2

Polynomial multiply long

This instruction multiplies corresponding elements in the lower or upper half of the vectors of the two source SIMD&amp;FP registers, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied.

For information about multiplying polynomials, see Polynomial arithmetic over {0, 1}.

The PMULL instruction extracts each source vector from the lower half of each source register. The PMULL2 instruction extracts each source vector from the upper half of each source register.

The PMULL and PMULL2 variants that operate on 64-bit source elements are defined only when FEAT\_PMULL is implemented.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
PMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '01' || size == '10' then EndOfDecode(Decode_UNDEF); if size == '11' && !IsFeatureImplemented(FEAT_PMULL) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

&lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | RESERVED |
|     10 | RESERVED |
|     11 | 1Q       |

The '1Q' arrangement is only allocated in an implementation that includes the Cryptographic Extension, and is otherwise RESERVED.

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | x   | RESERVED |
|     10 | x   | RESERVED |
|     11 | 0   | 1D       |
|     11 | 1   | 2D       |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(datasize) operand2 = Vpart[m, part, datasize]; bits(2*datasize) result; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, 2*esize] = PolynomialMult(element1, element2); V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.259 RADDHN, RADDHN2

Rounding add returning high narrow

This instruction adds each vector element in the first source SIMD&amp;FP register to the corresponding vector element in the second source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register.

The results are rounded. For truncated results, see ADDHN.

The RADDHN instruction writes the vector to the lower half of the destination register and clears the upper half. The RADDHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
RADDHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant boolean round = TRUE;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Tb&gt;

## &lt;Vn&gt;

&lt;Ta&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand1 = V[n, 2*datasize]; constant bits(2*datasize) operand2 = V[m, 2*datasize]; bits(datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, 2*esize]); element2 = UInt(Elem[operand2, e, 2*esize]); sum = element1 + element2; sum = RShr(sum, esize, round); Elem[result, e, esize] = sum<esize-1:0>; Vpart[d, part, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

## C7.2.260 RAX1

Rotate and exclusive-OR

This instruction rotates each 64-bit element of the 128-bit vector in a source SIMD&amp;FP register left by 1, performs a bitwise exclusive-OR of the resulting 128-bit vector and the vector in another source SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP register.

## Advanced SIMD

(FEAT\_SHA3)

<!-- image -->

## Encoding

```
RAX1 <Vd>.2D, <Vn>.2D, <Vm>.2D
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA3) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) Vm = V[m, 128]; constant bits(128) Vn = V[n, 128]; V[d, 128] = Vn
```

```
EOR (ROL(Vm<127:64>, 1):ROL(Vm<63:0>, 1));
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

## C7.2.261 RBIT (vector)

Reverse bit order (vector)

This instruction reads each vector element from the source SIMD&amp;FP register, reverses the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
RBIT <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV 8;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;T&gt;

&lt;Vn&gt;

|   Q | <T>   |
|-----|-------|
|   0 | 8B    |
|   1 | 16B   |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = bits(datasize) result; bits(esize) element; bits(esize) rev; for e = 0 to elements-1 element = Elem[operand, e, esize]; for i = 0 to esize-1 rev<(esize-1)-i> = element<i>; Elem[result, e, esize] = rev; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
V[n, datasize];
```

## C7.2.262 REV16 (vector)

Reverse elements in 16-bit halfwords (vector)

This instruction reverses the order of 8-bit elements in each halfword of the vector in the source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
REV16 <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer csize = 64 >> UInt(o0:U); constant integer esize = 8 << UInt(size); if csize <= esize then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 64 << UInt(Q); constant integer containers = datasize DIV csize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

| size   | Q   | <T>      |
|--------|-----|----------|
| 00     | 0   | 8B       |
| 00     | 1   | 16B      |
| 01     | x   | RESERVED |
| 1x     | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; for c = 0 to containers-1 constant bits(csize) container = Elem[operand, c, Elem[result, c, csize] = Reverse(container, esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
csize];
```

## C7.2.263 REV32 (vector)

Reverse elements in 32-bit words (vector)

This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
REV32 <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer csize = 64 >> UInt(o0:U); constant integer esize = 8 << UInt(size); if csize <= esize then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 64 << UInt(Q); constant integer containers = datasize DIV csize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

| size   | Q   | <T>      |
|--------|-----|----------|
| 00     | 0   | 8B       |
| 00     | 1   | 16B      |
| 01     | 0   | 4H       |
| 01     | 1   | 8H       |
| 1x     | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; for c = 0 to containers-1 constant bits(csize) container = Elem[operand, c, Elem[result, c, csize] = Reverse(container, esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
csize];
```

## C7.2.264 REV64

Reverse elements in 64-bit doublewords (vector)

This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
REV64 <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer csize = 64 >> UInt(o0:U); constant integer esize = 8 << UInt(size); if csize <= esize then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 64 << UInt(Q); constant integer containers = datasize DIV csize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; for c = 0 to containers-1 constant bits(csize) container = Elem[operand, c, csize]; Elem[result, c, csize] = Reverse(container, esize); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.265 RSHRN, RSHRN2

Rounding shift right narrow (immediate)

This instruction reads each unsigned integer value from the vector in the source SIMD&amp;FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SHRN.

The RSHRN instruction writes the vector to the lower half of the destination register and clears the upper half. The RSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
RSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = TRUE;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

## &lt;Tb&gt;

## &lt;Vn&gt;

## &lt;Ta&gt;

Is an arrangement specifier, encoded in 'immh':

| immh   | <Ta>     |
|--------|----------|
| 0001   | 8H       |
| 001x   | 4S       |
| 01xx   | 2D       |
| 1xxx   | RESERVED |

Is an arrangement specifier, encoded in 'immh:Q':

| immh   | Q   | <Tb>     |
|--------|-----|----------|
| 0001   | 0   | 8B       |
| 0001   | 1   | 16B      |
| 001x   | 0   | 4H       |
| 001x   | 1   | 8H       |
| 01xx   | 0   | 2S       |
| 01xx   | 1   | 4S       |
| 1xxx   | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

Is the right shift amount, in the range 1 to the destination element width in bits, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize*2) operand = V[n, datasize*2]; bits(datasize) result; integer element; for e = 0 to elements-1 element = RShr(UInt(Elem[operand, e, 2*esize]), shift, round);
```

```
Elem[result, e, esize] = element<esize-1:0>; Vpart[d, part, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.266 RSUBHN, RSUBHN2

Rounding subtract returning high narrow

This instruction subtracts each vector element of the second source SIMD&amp;FP register from the corresponding vector element of the first source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register.

The results are rounded. For truncated results, see SUBHN.

The RSUBHN instruction writes the vector to the lower half of the destination register and clears the upper half. The RSUBHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
RSUBHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant boolean round = TRUE;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Tb&gt;

## &lt;Vn&gt;

&lt;Ta&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand1 = V[n, 2*datasize]; constant bits(2*datasize) operand2 = V[m, 2*datasize]; bits(datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, 2*esize]); element2 = UInt(Elem[operand2, e, 2*esize]); sum = element1 - element2; sum = RShr(sum, esize, round); Elem[result, e, esize] = sum<esize-1:0>; Vpart[d, part, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

## C7.2.267 SABA

Signed absolute difference and accumulate

This instruction subtracts the elements of the vector of the second source SIMD&amp;FP register from the corresponding elements of the first source SIMD&amp;FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SABA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result = V[d, datasize]; integer element1; integer element2; bits(esize) absdiff; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); absdiff = Abs(element1 - element2)<esize-1:0>; Elem[result, e, esize] = Elem[result, e, esize] + absdiff; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.268 SABAL, SABAL2

Signed absolute difference and accumulate long

This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements.

The SABAL instruction extracts each source vector from the lower half of each source register. The SABAL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SABAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(datasize) operand2 = Vpart[m, part, datasize]; bits(2*datasize) result = V[d, 2*datasize]; integer element1; integer element2; bits(2*esize) absdiff; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); absdiff = Abs(element1-element2)<2*esize-1:0>; Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.269 SABD

Signed absolute difference

This instruction subtracts the elements of the vector of the second source SIMD&amp;FP register from the corresponding elements of the first source SIMD&amp;FP register, places the absolute values of the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result = Zeros(datasize); integer element1; integer element2; bits(esize) absdiff; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); absdiff = Abs(element1 - element2)<esize-1:0>; Elem[result, e, esize] = Elem[result, e, esize] + absdiff; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.270 SABDL, SABDL2

Signed absolute difference long

This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, places the absolute value of the results into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements.

The SABDL instruction extracts each source vector from the lower half of each source register. The SABDL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SABDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(datasize) operand2 = Vpart[m, part, datasize]; bits(2*datasize) result = Zeros(2*datasize); integer element1; integer element2; bits(2*esize) absdiff; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); absdiff = Abs(element1-element2)<2*esize-1:0>; Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.271 SADALP

Signed add and accumulate long pairwise

This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&amp;FP register and accumulates the results into the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SADALP <Vd>.<Ta>, <Vn>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV (2 * esize);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Ta>     |
|--------|-----|----------|
|     00 | 0   | 4H       |
|     00 | 1   | 8H       |
|     01 | 0   | 2S       |
|     01 | 1   | 4S       |
|     10 | 0   | 1D       |
|     10 | 1   | 2D       |
|     11 | x   | RESERVED |

&lt;Ta&gt;

&lt;Vn&gt;

&lt;Tb&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result = V[d, datasize]; bits(2*esize) sum; integer op1; integer op2; for e = 0 to elements-1 op1 = SInt(Elem[operand, 2*e+0, esize]); op2 = SInt(Elem[operand, 2*e+1, esize]); sum = (op1+op2)<2*esize-1:0>; Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
sum;
```

## C7.2.272 SADDL, SADDL2

Signed add long (vector)

This instruction adds each vector element in the lower or upper half of the first source SIMD&amp;FP register to the corresponding vector element of the second source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.

The SADDL instruction extracts each source vector from the lower half of each source register. The SADDL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SADDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

<!-- image -->

&lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(datasize) operand2 = Vpart[m, part, datasize]; bits(2*datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); sum = element1 + element2; Elem[result, e, 2*esize] = sum<2*esize-1:0>; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.273 SADDLP

Signed add long pairwise

This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SADDLP <Vd>.<Ta>, <Vn>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV (2 * esize);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Ta>     |
|--------|-----|----------|
|     00 | 0   | 4H       |
|     00 | 1   | 8H       |
|     01 | 0   | 2S       |
|     01 | 1   | 4S       |
|     10 | 0   | 1D       |
|     10 | 1   | 2D       |
|     11 | x   | RESERVED |

&lt;Ta&gt;

&lt;Vn&gt;

&lt;Tb&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = bits(datasize) result; bits(2*esize) sum; integer op1; integer op2; for e = 0 to elements-1 op1 = SInt(Elem[operand, 2*e+0, esize]); op2 = SInt(Elem[operand, 2*e+1, esize]); sum = (op1+op2)<2*esize-1:0>; Elem[result, e, 2*esize] = sum; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
V[n, datasize];
```

## C7.2.274 SADDLV

Signed add long across vector

This instruction adds every vector element in the source SIMD&amp;FP register together, and writes the scalar result to the destination SIMD&amp;FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are signed integer values.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SADDLV <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '100' then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = FALSE;
```

## Assembler Symbols

<!-- image -->

&lt;V&gt;

Is the destination width specifier, encoded in 'size':

<!-- image -->

|   size | <V>      |
|--------|----------|
|     00 | H        |
|     01 | S        |
|     10 | D        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

<!-- image -->

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | RESERVED |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(esize) opelt = Elem[operand, 0, esize]; integer sum = if unsigned then UInt(opelt) else SInt(opelt); for e = 1 to elements-1 opelt = Elem[operand, e, esize]; constant integer element = if unsigned then UInt(opelt) else SInt(opelt); sum = sum + element; V[d, 2*esize] = sum<2*esize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.275 SADDW, SADDW2

Signed add wide

This instruction adds vector elements of the first source SIMD&amp;FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the SIMD&amp;FP destination register.

The SADDW instruction extracts the second source vector from the lower half of the second source register. The SADDW2 instruction extracts the second source vector from the upper half of the second source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SADDW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

## &lt;Ta&gt;

## &lt;Vn&gt;

Is an arrangement specifier, encoded in 'size':

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand1 = V[n, 2*datasize]; constant bits(datasize) operand2 = bits(2*datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, 2*esize]); element2 = SInt(Elem[operand2, e, esize]); sum = element1 + element2; Elem[result, e, 2*esize] = sum<2*esize-1:0>; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Tb&gt;

```
Vpart[m, part, datasize];
```

## C7.2.276 SCVTF (vector, fixed-point)

Signed fixed-point convert to floating-point (vector)

This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SCVTF <V><d>, <V><n>, #<fbits>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh IN {'000x'} || (immh IN {'001x'} && !IsFeatureImplemented(FEAT_FP16)) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = if immh IN {'1xxx'} then 64 else if immh IN {'01xx'} then 32 else 16; constant integer datasize = esize; constant integer elements = 1; constant integer fracbits = (esize * 2) UInt(immh:immb); constant boolean unsigned = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SCVTF <Vd>.<T>, <Vn>.<T>, #<fbits>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh IN {'000x'} || (immh IN {'001x'} && !IsFeatureImplemented(FEAT_FP16)) then EndOfDecode(Decode_UNDEF); if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = if immh IN {'1xxx'} then 64 else if immh IN {'01xx'} then 32 else 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer fracbits = (esize * 2) UInt(immh:immb); constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'immh':

| immh   | <V>      | Architectural Feature   |
|--------|----------|-------------------------|
| 0001   | RESERVED | -                       |
| 001x   | H        | FEAT_FP16               |
| 01xx   | S        | -                       |
| 1xxx   | D        | -                       |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;d&gt;

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;fbits&gt;

For the 'Scalar' variant: is the number of fractional bits, in the range 1 to the operand width, encoded in 'immh:immb':

| immh   | <fbits>               |
|--------|-----------------------|
| 0001   | RESERVED              |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

For the 'Vector' variant: is the number of fractional bits, in the range 1 to the element width, encoded in 'immh:immb':

## &lt;Vd&gt;

&lt;T&gt;

| immh   | <fbits>               |
|--------|-----------------------|
| 0001   | RESERVED              |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   | Q   | <T>      | Architectural Feature   |
|--------|-----|----------|-------------------------|
| 0001   | x   | RESERVED | -                       |
| 001x   | 0   | 4H       | FEAT_FP16               |
| 001x   | 1   | 8H       | FEAT_FP16               |
| 01xx   | 0   | 2S       | -                       |
| 01xx   | 1   | 4S       | -                       |
| 1xxx   | 0   | RESERVED | -                       |
| 1xxx   | 1   | 2D       | -                       |

## &lt;Vn&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant FPRounding rounding = FPRoundingMode(FPCR); constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.277 SCVTF (vector, integer)

Signed integer convert to floating-point (vector)

This instruction converts each element in a vector from signed integer to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
SCVTF <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1; constant boolean unsigned = FALSE;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SCVTF <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1; constant boolean unsigned = FALSE;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
SCVTF <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = FALSE;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SCVTF <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = FALSE;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

&lt;V&gt;

&lt;d&gt;

&lt;n&gt;

&lt;Vd&gt;

&lt;T&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 && IsFeatureImplemented(FEAT_FPRCVT) then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); constant FPRounding rounding = FPRoundingMode(FPCR); constant integer fracbits = 0; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.278 SCVTF (scalar, fixed-point)

Signed fixed-point convert to floating-point (scalar)

This instruction converts the signed value in the 32-bit or 64-bit general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the 32-bit to half-precision variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
SCVTF <Hd>, <Wn>, #<fbits>
```

## Encoding for the 64-bit to half-precision variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
SCVTF <Hd>, <Xn>, #<fbits>
```

## Encoding for the 32-bit to single-precision variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

```
SCVTF <Sd>, <Wn>, #<fbits>
```

## Encoding for the 64-bit to single-precision variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
SCVTF <Sd>, <Xn>, #<fbits>
```

## Encoding for the 32-bit to double-precision variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

```
SCVTF <Dd>, <Wn>, #<fbits>
```

## Encoding for the 64-bit to double-precision variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
SCVTF <Dd>, <Xn>, #<fbits>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); if sf == '0' && scale<5> == '0' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer decode_fltsize = 8 << UInt(ftype EOR '10'); constant integer fracbits = 64 -UInt(scale); constant boolean unsigned = FALSE;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;fbits&gt;

For the '32-bit to double-precision', '32-bit to half-precision', and '32-bit to single-precision' variants: is the number of bits after the binary point in the fixed-point source, in the range 1 to 32, encoded as 64 minus 'scale'.

For the '64-bit to double-precision', '64-bit to half-precision', and '64-bit to single-precision' variants: is the number of bits after the binary point in the fixed-point source, in the range 1 to 64, encoded as 64 minus 'scale'.

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Xn&gt;

## &lt;Sd&gt;

## &lt;Dd&gt;

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## Operation

```
AArch64.CheckFPEnabled(); constant boolean merge = IsMerging(FPCR); constant integer fltsize = if merge then 128 else decode_fltsize; bits(fltsize) fltval = if merge then V[d, fltsize] else Zeros(fltsize); constant bits(intsize) intval = X[n, intsize]; constant FPRounding rounding = FPRoundingMode(FPCR); Elem[fltval, 0, decode_fltsize] = FixedToFP(intval, fracbits, unsigned, FPCR, rounding, decode_fltsize); V[d, fltsize] = fltval;
```

## C7.2.279 SCVTF (scalar, integer)

Signed integer convert to floating-point (scalar)

This instruction converts the signed integer value in the general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the 32-bit to half-precision variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
SCVTF <Hd>, <Wn>
```

## Encoding for the 32-bit to single-precision variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

```
SCVTF <Sd>, <Wn>
```

## Encoding for the 32-bit to double-precision variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

SCVTF

&lt;Dd&gt;,

&lt;Wn&gt;

## Encoding for the 64-bit to half-precision variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
SCVTF <Hd>, <Xn>
```

## Encoding for the 64-bit to single-precision variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
SCVTF <Sd>, <Xn>
```

## Encoding for the 64-bit to double-precision variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
SCVTF <Dd>, <Xn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer decode_fltsize = 8 << UInt(ftype EOR '10'); constant boolean unsigned = FALSE;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

&lt;Sd&gt;

&lt;Dd&gt;

&lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant integer fltsize = if IsMerging(FPCR) then 128 else decode_fltsize; constant bits(intsize) intval = X[n, intsize]; constant FPRounding rounding = FPRoundingMode(FPCR); constant integer fracbits = 0; bits(fltsize) fltval = if IsMerging(FPCR) then V[d, fltsize] else Elem[fltval, 0, decode_fltsize] = FixedToFP(intval, fracbits, unsigned, FPCR, rounding, decode_fltsize); V[d, fltsize] = fltval;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

```
Zeros(fltsize);
```

## C7.2.280 SCVTF (scalar SIMD&amp;FP)

Signed integer convert to floating-point (scalar SIMD&amp;FP)

This instruction converts the signed integer value in the SIMD&amp;FP source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Integer

(FEAT\_FPRCVT)

<!-- image -->

## Encoding for the 32-bit to half-precision variant

Applies when

SCVTF

&lt;Hd&gt;,

(sf

&lt;Sn&gt;

## Encoding for the 32-bit to double-precision variant

```
Applies when (sf == 0 && ftype == 01)
```

SCVTF

&lt;Dd&gt;,

&lt;Sn&gt;

## Encoding for the 64-bit to half-precision variant

```
Applies when (sf == 1 && ftype == 11)
```

```
SCVTF <Hd>, <Dn>
```

## Encoding for the 64-bit to single-precision variant

```
Applies when (sf == 1 && ftype == 00)
```

```
SCVTF <Sd>, <Dn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_FPRCVT) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10'); constant FPRounding rounding = FPRoundingMode(FPCR);
```

==

0

&amp;&amp;

ftype ==

11)

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Sn&gt;

&lt;Dd&gt;

## &lt;Dn&gt;

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(fltsize) fltval; bits(intsize) intval; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); intval = V[n, intsize]; fltval = FixedToFP(intval, 0, FALSE, FPCR, rounding, Elem[result, 0, fltsize] = fltval; V[d, 128] = result;
```

```
fltsize);
```

## C7.2.281 SDOT (by element)

Dot product signed arithmetic (vector, by element)

This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations to support it.

Note

ID\_AA64ISAR0\_EL1.DP indicates whether this instruction is supported.

## Vector

(FEAT\_DotProd)

<!-- image -->

## Encoding

```
SDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_DotProd) then EndOfDecode(Decode_UNDEF);
```

```
if size != '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(M:Rm); constant integer index = UInt(H:L); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP third source and destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

## &lt;Vn&gt;

&lt;Tb&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'M:Rm' fields.

## &lt;index&gt;

Is the element index, encoded in the 'H:L' fields.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(128) operand2 = V[m, 128]; bits(datasize) result = V[d, datasize]; for e = 0 to elements-1 integer res = 0; integer element1, element2; for i = 0 to 3 element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); element2 = SInt(Elem[operand2, 4 * index + i, esize res = res + element1 * element2; Elem[result, e, esize] = Elem[result, e, esize] + res; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   Q | <Tb>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

```
DIV 4]);
```

## C7.2.282 SDOT (vector)

Dot product signed arithmetic (vector)

This instruction performs the dot product of the four signed 8-bit elements in each 32-bit element of the first source register with the four signed 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations to support it.

Note

ID\_AA64ISAR0\_EL1.DP indicates whether this instruction is supported.

## Vector

(FEAT\_DotProd)

<!-- image -->

## Encoding

```
SDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_DotProd) then EndOfDecode(Decode_UNDEF); if size != '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP third source and destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

&lt;Vn&gt;

&lt;Tb&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; result = V[d, datasize]; for e = 0 to elements-1 integer res = 0; integer element1, element2; for i = 0 to 3 element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]); res = res + element1 * element2; Elem[result, e, esize] = Elem[result, e, esize] + res; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   Q | <Tb>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

## C7.2.283 SHA1C

SHA1 hash update (choose).

## Advanced SIMD

(FEAT\_SHA1)

<!-- image -->

## Encoding

```
SHA1C <Qd>, <Sn>, <Vm>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA1) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Qd&gt;

Is the 128-bit name of the SIMD&amp;FP source and destination, encoded in the 'Rd' field.

&lt;Sn&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(128) x = V[d, 128]; bits(32) y = V[n, 32]; // Note: 32 not 128 bits wide constant bits(128) w = V[m, 128]; for e = 0 to 3 constant bits(32) t = SHAchoose(x<63:32>, x<95:64>, y = y + ROL(x<31:0>, 5) + t + Elem[w, e, 32]; x<63:32> = ROL(x<63:32>, 30); constant bits(160) yx = ROL(y:x, 32); (y, x) = (yx<159:128>, yx<127:0>); V[d, 128] = x;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

```
x<127:96>);
```

## C7.2.284 SHA1H

SHA1 fixed rotate.

## Advanced SIMD

(FEAT\_SHA1)

<!-- image -->

## Encoding

```
SHA1H <Sd>, <Sn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA1) then constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

<!-- image -->

&lt;Sn&gt;

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(32) operand = V[d, 32] = ROL(operand, 30);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

```
V[n, 32]; // read element [0] only, [1-3] zeroed
```

## C7.2.285 SHA1M

SHA1 hash update (majority).

## Advanced SIMD

(FEAT\_SHA1)

<!-- image -->

## Encoding

```
SHA1M <Qd>, <Sn>, <Vm>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA1) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Qd&gt;

Is the 128-bit name of the SIMD&amp;FP source and destination, encoded in the 'Rd' field.

&lt;Sn&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(128) x = V[d, 128]; bits(32) y = V[n, 32]; // Note: 32 not 128 bits wide constant bits(128) w = V[m, 128]; for e = 0 to 3 constant bits(32) t = SHAmajority(x<63:32>, x<95:64>, x<127:96>); y = y + ROL(x<31:0>, 5) + t + Elem[w, e, 32]; x<63:32> = ROL(x<63:32>, 30); constant bits(160) yx = ROL(y:x, 32); (y, x) = (yx<159:128>, yx<127:0>); V[d, 128] = x;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

## C7.2.286 SHA1P

SHA1 hash update (parity).

## Advanced SIMD

(FEAT\_SHA1)

<!-- image -->

## Encoding

```
SHA1P <Qd>, <Sn>, <Vm>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA1) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Qd&gt;

Is the 128-bit name of the SIMD&amp;FP source and destination, encoded in the 'Rd' field.

&lt;Sn&gt;

Is the 32-bit name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(128) x = V[d, 128]; bits(32) y = V[n, 32]; // Note: 32 not 128 bits wide constant bits(128) w = V[m, 128]; for e = 0 to 3 constant bits(32) t = SHAparity(x<63:32>, x<95:64>, y = y + ROL(x<31:0>, 5) + t + Elem[w, e, 32]; x<63:32> = ROL(x<63:32>, 30); constant bits(160) yx = ROL(y:x, 32); (y, x) = (yx<159:128>, yx<127:0>); V[d, 128] = x;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

```
x<127:96>);
```

## C7.2.287 SHA1SU0

SHA1 schedule update 0.

## Advanced SIMD

(FEAT\_SHA1)

<!-- image -->

## Encoding

```
SHA1SU0 <Vd>.4S, <Vn>.4S, <Vm>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA1) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[d, 128]; constant bits(128) operand2 = V[n, 128]; constant bits(128) operand3 = V[m, 128]; bits(128) result = operand2<63:0> : operand1<127:64>; result = result EOR operand1 EOR operand3; V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

## C7.2.288 SHA1SU1

SHA1 schedule update 1.

## Advanced SIMD

(FEAT\_SHA1)

<!-- image -->

## Encoding

```
SHA1SU1 <Vd>.4S, <Vn>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA1) then constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[d, 128]; constant bits(128) operand2 = V[n, 128]; constant bits(128) T = operand1 EOR LSR(operand2, 32); bits(128) result; result<31:0> = ROL(T<31:0>, 1); result<63:32> = ROL(T<63:32>, 1); result<95:64> = ROL(T<95:64>, 1); result<127:96> = ROL(T<127:96>, 1) EOR ROL(T<31:0>, 2); V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

## C7.2.289 SHA256H2

SHA256 hash update (part 2).

## Advanced SIMD

(FEAT\_SHA256)

<!-- image -->

## Encoding

```
SHA256H2 <Qd>, <Qn>, <Vm>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA256) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Qd&gt;

Is the 128-bit name of the SIMD&amp;FP source and destination, encoded in the 'Rd' field.

&lt;Qn&gt;

Is the 128-bit name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant boolean part1 = FALSE; V[d, 128] = SHA256hash(V[n, 128], V[d, 128], V[m, 128],
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

```
part1);
```

## C7.2.290 SHA256H

SHA256 hash update (part 1).

## Advanced SIMD

(FEAT\_SHA256)

<!-- image -->

## Encoding

```
SHA256H <Qd>, <Qn>, <Vm>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA256) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Qd&gt;

Is the 128-bit name of the SIMD&amp;FP source and destination, encoded in the 'Rd' field.

&lt;Qn&gt;

Is the 128-bit name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant boolean part1 = TRUE; V[d, 128] = SHA256hash(V[d, 128], V[n, 128], V[m, 128],
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

```
part1);
```

## C7.2.291 SHA256SU0

SHA256 schedule update 0.

## Advanced SIMD

(FEAT\_SHA256)

<!-- image -->

## Encoding

```
SHA256SU0 <Vd>.4S, <Vn>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA256) then constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[d, 128]; constant bits(128) operand2 = V[n, 128]; constant bits(128) T = operand2<31:0> : operand1<127:32>; bits(128) result; bits(32) elt; for e = 0 to 3 elt = Elem[T, e, 32]; elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3); Elem[result, e, 32] = elt + Elem[operand1, e, 32]; V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

## C7.2.292 SHA256SU1

SHA256 schedule update 1.

## Advanced SIMD

(FEAT\_SHA256)

<!-- image -->

## Encoding

```
SHA256SU1 <Vd>.4S, <Vn>.4S, <Vm>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA256) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[d, 128]; constant bits(128) operand2 = V[n, 128]; constant bits(128) operand3 = V[m, 128]; constant bits(128) T0 = operand3<31:0> : operand2<127:32>; bits(64) T1; bits(32) elt; bits(128) result; T1 = operand3<127:64>; for e = 0 to 1 elt = Elem[T1, e, 32]; elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10); elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32]; Elem[result, e, 32] = elt; T1 = result<63:0>; for e = 2 to 3 elt = Elem[T1, e - 2, 32]; elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
```

```
EndOfDecode(Decode_UNDEF);
```

```
elt = elt + Elem[operand1, e, 32] + Elem[result, e, 32] = elt; V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
Elem[T0, e, 32];
```

## C7.2.293 SHA512H2

SHA512 hash update part 2

This instruction takes the values from the three 128-bit source SIMD&amp;FP registers and produces a 128-bit output value that combines the sigma0 and majority functions of two iterations of the SHA512 computation. It returns this value to the destination SIMD&amp;FP register.

## Advanced SIMD

(FEAT\_SHA512)

<!-- image -->

## Encoding

```
SHA512H2 <Qd>, <Qn>, <Vm>.2D
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA512) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Qd&gt;

Is the 128-bit name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

&lt;Qn&gt;

Is the 128-bit name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(128) Vtmp; bits(64) NSigma0; constant bits(128) x = V[n, 128]; constant bits(128) y = V[m, 128]; constant bits(128) w = V[d, 128]; NSigma0 = ROR(y<63:0>, 28) EOR ROR(y<63:0>, 34) EOR ROR(y<63:0>, 39); Vtmp<127:64> = SHAmajority(x<63:0>, y<127:64>, y<63:0>); Vtmp<127:64> = (Vtmp<127:64> + NSigma0 + w<127:64>); NSigma0 = ROR(Vtmp<127:64>, 28) EOR ROR(Vtmp<127:64>, 34) EOR ROR(Vtmp<127:64>, 39); Vtmp<63:0> = SHAmajority(Vtmp<127:64>, y<63:0>, y<127:64>); Vtmp<63:0> = (Vtmp<63:0> + NSigma0 + w<63:0>); V[d, 128] = Vtmp;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.294 SHA512H

SHA512 hash update part 1

This instruction takes the values from the three 128-bit source SIMD&amp;FP registers and produces a 128-bit output value that combines the sigma1 and chi functions of two iterations of the SHA512 computation. It returns this value to the destination SIMD&amp;FP register.

## Advanced SIMD

(FEAT\_SHA512)

<!-- image -->

## Encoding

```
SHA512H <Qd>, <Qn>, <Vm>.2D
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA512) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Qd&gt;

Is the 128-bit name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

&lt;Qn&gt;

Is the 128-bit name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(128) Vtmp; bits(64) MSigma1; bits(64) tmp; constant bits(128) x = V[n, 128]; constant bits(128) y = V[m, 128]; constant bits(128) w = V[d, 128]; MSigma1 = ROR(y<127:64>, 14) EOR ROR(y<127:64>, 18) EOR ROR(y<127:64>, 41); Vtmp<127:64> = (y<127:64> AND x<63:0>) EOR (NOT(y<127:64>) AND x<127:64>); Vtmp<127:64> = (Vtmp<127:64> + MSigma1 + w<127:64>); tmp = Vtmp<127:64> + y<63:0>; MSigma1 = ROR(tmp, 14) EOR ROR(tmp, 18) EOR ROR(tmp, 41); Vtmp<63:0> = (tmp AND y<127:64>) EOR (NOT(tmp) AND x<63:0>); Vtmp<63:0> = (Vtmp<63:0> + MSigma1 + w<63:0>); V[d, 128] = Vtmp;
```

```
EndOfDecode(Decode_UNDEF);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.295 SHA512SU0

SHA512 schedule update 0

This instruction takes the values from the two 128-bit source SIMD&amp;FP registers and produces a 128-bit output value that combines the gamma0 functions of two iterations of the SHA512 schedule update that are performed after the first 16 iterations within a block. It returns this value to the destination SIMD&amp;FP register.

## Advanced SIMD

(FEAT\_SHA512)

<!-- image -->

## Encoding

```
SHA512SU0 <Vd>.2D, <Vn>.2D
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA512) then constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) sig0; bits(128) Vtmp; constant bits(128) x = V[n, 128]; constant bits(128) w = V[d, 128]; sig0 = ROR(w<127:64>, 1) EOR ROR(w<127:64>, 8) EOR ('0000000':w<127:71>); Vtmp<63:0> = w<63:0> + sig0; sig0 = ROR(x<63:0>, 1) EOR ROR(x<63:0>, 8) EOR ('0000000':x<63:7>); Vtmp<127:64> = w<127:64> + sig0; V[d, 128] = Vtmp;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

## C7.2.296 SHA512SU1

SHA512 schedule update 1

This instruction takes the values from the three source SIMD&amp;FP registers and produces a 128-bit output value that combines the gamma1 functions of two iterations of the SHA512 schedule update that are performed after the first 16 iterations within a block. It returns this value to the destination SIMD&amp;FP register.

## Advanced SIMD

(FEAT\_SHA512)

<!-- image -->

## Encoding

```
SHA512SU1 <Vd>.2D, <Vn>.2D, <Vm>.2D
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA512) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) sig1; bits(128) Vtmp; constant bits(128) x = V[n, 128]; constant bits(128) y = V[m, 128]; constant bits(128) w = V[d, 128]; sig1 = ROR(x<127:64>, 19) EOR ROR(x<127:64>, 61) EOR ('000000':x<127:70>); Vtmp<127:64> = w<127:64> + sig1 + y<127:64>; sig1 = ROR(x<63:0>, 19) EOR ROR(x<63:0>, 61) EOR ('000000':x<63:6>); Vtmp<63:0> = w<63:0> + sig1 + y<63:0>; V[d, 128] = Vtmp;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.297 SHADD

Signed halving add

This instruction adds corresponding signed integer values from the two source SIMD&amp;FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

The results are truncated. For rounded results, see SRHADD.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); sum = (element1 + element2) >> 1; Elem[result, e, esize] = sum<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.298 SHL

Shift left (immediate)

This instruction reads each value from a vector, left shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SHL D<d>, D<n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh<3> != '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << 3; constant integer datasize = esize; constant integer elements = 1; constant integer shift = UInt(immh:immb) esize;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SHL <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = UInt(immh:immb) esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

<!-- image -->

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the left shift amount, in the range 0 to 63, encoded as UInt('immh:immb') - 64 .

For the 'Vector' variant: is the left shift amount, in the range 0 to the element width in bits minus 1, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | UInt(immh:immb) - 8  |
| 001x   | UInt(immh:immb) - 16 |
| 01xx   | UInt(immh:immb) - 32 |
| 1xxx   | UInt(immh:immb) - 64 |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>      |
|--------|-----|----------|
| 0001   |   0 | 8B       |
| 0001   |   1 | 16B      |
| 001x   |   0 | 4H       |
| 001x   |   1 | 8H       |
| 01xx   |   0 | 2S       |
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

## &lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; for e = 0 to elements-1 Elem[result, e, esize] = LSL(Elem[operand, e, esize], shift); V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

immh

Q

&lt;T&gt;

## C7.2.299 SHLL, SHLL2

Shift left long (by element size)

This instruction reads each vector element in the lower or upper half of the source SIMD&amp;FP register, left shifts each result by the element size, writes the final result to a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements.

The SHLL instruction extracts vector elements from the lower half of the source register. The SHLL2 instruction extracts vector elements from the upper half of the source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

## &lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = Vpart[n, part, datasize]; bits(2*datasize) result; integer element; for e = 0 to elements-1 element = SInt(Elem[operand, e, esize]) << shift;
```

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;shift&gt;

Is the left shift amount, which must be equal to the source element width in bits, encoded in 'size':

|   size | <shift>   |
|--------|-----------|
|     00 | 8         |
|     01 | 16        |
|     10 | 32        |
|     11 | RESERVED  |

```
Elem[result, e, 2*esize] = element<2*esize-1:0>; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.300 SHRN, SHRN2

Shift right narrow (immediate)

This instruction reads each unsigned integer value from the source SIMD&amp;FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. The results are truncated. For rounded results, see RSHRN.

The SHRN instruction writes the vector to the lower half of the destination register and clears the upper half. The SHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = FALSE;
```

## Assembler Symbols

- 2 Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the

registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

## &lt;Tb&gt;

## &lt;Vn&gt;

## &lt;Ta&gt;

Is an arrangement specifier, encoded in 'immh':

| immh   | <Ta>     |
|--------|----------|
| 0001   | 8H       |
| 001x   | 4S       |
| 01xx   | 2D       |
| 1xxx   | RESERVED |

Is an arrangement specifier, encoded in 'immh:Q':

| immh   | Q   | <Tb>     |
|--------|-----|----------|
| 0001   | 0   | 8B       |
| 0001   | 1   | 16B      |
| 001x   | 0   | 4H       |
| 001x   | 1   | 8H       |
| 01xx   | 0   | 2S       |
| 01xx   | 1   | 4S       |
| 1xxx   | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

Is the right shift amount, in the range 1 to the destination element width in bits, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize*2) operand = V[n, datasize*2]; bits(datasize) result; integer element; for e = 0 to elements-1 element = RShr(UInt(Elem[operand, e, 2*esize]), shift, round);
```

```
Elem[result, e, esize] = element<esize-1:0>; Vpart[d, part, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.301 SHSUB

Signed halving subtract

This instruction subtracts the elements in the vector in the second source SIMD&amp;FP register from the corresponding elements in the vector in the first source SIMD&amp;FP register, shifts each result right one bit, places each result into elements of a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SHSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer diff; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); diff = (element1 -element2) >> 1; Elem[result, e, esize] = diff<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.302 SLI

Shift left and insert (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, left shifts each vector element by an immediate value, and inserts the result into the corresponding vector element in the destination SIMD&amp;FP register such that the new zero bits created by the shift are not inserted but retain their existing value. Bits shifted out of the left of each vector element in the source register are lost.

Figure C7-3 shift left by 3 for an 8-bit vector element

<!-- image -->

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SLI D<d>, D<n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh<3> != '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << 3; constant integer datasize = esize; constant integer elements = 1; constant integer shift = UInt(immh:immb) esize;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SLI <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = UInt(immh:immb) esize;
```

## Assembler Symbols

## &lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

<!-- image -->

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the left shift amount, in the range 0 to 63, encoded as UInt('immh:immb') - 64 For the 'Vector' variant: is the left shift amount, in the range 0 to the element width in bits minus 1, encoded in 'immh:immb':

.

| immh   | <shift>              |
|--------|----------------------|
| 0001   | UInt(immh:immb) - 8  |
| 001x   | UInt(immh:immb) - 16 |
| 01xx   | UInt(immh:immb) - 32 |
| 1xxx   | UInt(immh:immb) - 64 |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>      |
|--------|-----|----------|
| 0001   |   0 | 8B       |
| 0001   |   1 | 16B      |
| 001x   |   0 | 4H       |
| 001x   |   1 | 8H       |
| 01xx   |   0 | 2S       |
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant bits(datasize) operand2 = V[d, datasize]; constant bits(esize) mask = LSL(Ones(esize), shift); bits(datasize) result; bits(esize) shifted; for e = 0 to elements-1 shifted = LSL(Elem[operand, e, esize], shift); Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.303 SM3PARTW1

## SM3PARTW1

This instruction takes three 128-bit vectors from the three source SIMD&amp;FP registers and returns a 128-bit result in the destination SIMD&amp;FP register. The result is obtained by a three-way exclusive-OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information.

## Advanced SIMD

(FEAT\_SM3)

<!-- image -->

## Encoding

```
SM3PARTW1 <Vd>.4S, <Vn>.4S, <Vm>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SM3) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) Vm = V[m, 128]; constant bits(128) Vn = V[n, 128]; constant bits(128) Vd = V[d, 128]; bits(128) result; result<95:0> = (Vd EOR Vn)<95:0> EOR (ROL(Vm<127:96>, 15):ROL(Vm<95:64>, 15):ROL(Vm<63:32>, 15)); for i = 0 to 3 if i == 3 then result<127:96> = (Vd EOR Vn)<127:96> EOR (ROL(result<31:0>, 15)); result<(32*i)+31:(32*i)> = (result<(32*i)+31:(32*i)> EOR ROL(result<(32*i)+31:(32*i)>, 15) EOR ROL(result<(32*i)+31:(32*i)>, 23)); V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.304 SM3PARTW2

## SM3PARTW2

This instruction takes three 128-bit vectors from three source SIMD&amp;FP registers and returns a 128-bit result in the destination SIMD&amp;FP register. The result is obtained by a three-way exclusive-OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information.

## Advanced SIMD

(FEAT\_SM3)

<!-- image -->

## Encoding

```
SM3PARTW2 <Vd>.4S, <Vn>.4S, <Vm>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SM3) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) Vm = V[m, 128]; constant bits(128) Vn = V[n, 128]; constant bits(128) Vd = V[d, 128]; bits(128) result; bits(128) tmp; bits(32) tmp2; tmp<127:0> = Vn EOR (ROL(Vm<127:96>, 7) : ROL(Vm<95:64>, 7) : ROL(Vm<63:32>, 7) : ROL(Vm<31:0>, 7)); result<127:0> = Vd<127:0> EOR tmp<127:0>; tmp2 = ROL(tmp<31:0>, 15); tmp2 = tmp2 EOR ROL(tmp2, 15) EOR ROL(tmp2, 23); result<127:96> = result<127:96> EOR tmp2; V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.305 SM3SS1

## SM3SS1

This instruction rotates the top 32 bits of the 128-bit vector in the first source SIMD&amp;FP register by 12, and adds that 32-bit value to the two other 32-bit values held in the top 32 bits of each of the 128-bit vectors in the second and third source SIMD&amp;FP registers, rotating this result left by 7 and writing the final result into the top 32 bits of the vector in the destination SIMD&amp;FP register, with the bottom 96 bits of the vector being written to 0.

## Advanced SIMD

(FEAT\_SM3)

<!-- image -->

## Encoding

```
SM3SS1 <Vd>.4S, <Vn>.4S, <Vm>.4S, <Va>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SM3) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer a = UInt(Ra);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Va&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Ra' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) Vm = V[m, 128]; constant bits(128) Vn = V[n, 128]; constant bits(128) Va = V[a, 128]; bits(128) result; result<127:96> = ROL((ROL(Vn<127:96>, 12) + Vm<127:96> + Va<127:96>), 7); result<95:0> = Zeros(96); V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.306 SM3TT1A

## SM3TT1A

This instruction takes three 128-bit vectors from three source SIMD&amp;FP registers and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&amp;FP register. It performs a three-way exclusive-OR of the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:

- The bottom 32-bit element of the first source vector, Vd, that was used for the three-way exclusive-OR.
- The result of the exclusive-OR of the top 32-bit element of the second source vector, Vn, with a rotation left by 12 of the top 32-bit element of the first source vector.
- A32-bit element indexed out of the third source vector, Vm.

The result of this addition is returned as the top element of the result. The other elements of the result are taken from elements of the first source vector, with the element returned in bits&lt;63:32&gt; being rotated left by 9.

## Advanced SIMD

(FEAT\_SM3)

<!-- image -->

## Encoding

```
SM3TT1A <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SM3) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer i = UInt(imm2);
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;imm2&gt;

Is a 32-bit element indexed out of &lt;Vm&gt;, encoded in 'imm2'.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) Vm = V[m, 128]; constant bits(128) Vn = V[n, 128]; constant bits(128) Vd = V[d, 128]; bits(32) WjPrime; bits(128) result; bits(32) TT1; bits(32) SS2; WjPrime = Elem[Vm, i, 32]; SS2 = Vn<127:96> EOR ROL(Vd<127:96>, 12); TT1 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>); TT1 = (TT1 + Vd<31:0> + SS2 + WjPrime)<31:0>; result<31:0> = Vd<63:32>; result<63:32> = ROL(Vd<95:64>, 9); result<95:64> = Vd<127:96>; result<127:96> = TT1; V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.307 SM3TT1B

## SM3TT1B

This instruction takes three 128-bit vectors from three source SIMD&amp;FP registers and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&amp;FP register. It performs a 32-bit majority function between the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:

- The bottom 32-bit element of the first source vector, Vd, that was used for the 32-bit majority function.
- The result of the exclusive-OR of the top 32-bit element of the second source vector, Vn, with a rotation left by 12 of the top 32-bit element of the first source vector.
- A32-bit element indexed out of the third source vector, Vm.

The result of this addition is returned as the top element of the result. The other elements of the result are taken from elements of the first source vector, with the element returned in bits&lt;63:32&gt; being rotated left by 9.

## Advanced SIMD

(FEAT\_SM3)

<!-- image -->

## Encoding

```
SM3TT1B <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SM3) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer i = UInt(imm2);
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;imm2&gt;

Is a 32-bit element indexed out of &lt;Vm&gt;, encoded in 'imm2'.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) Vm = V[m, 128]; constant bits(128) Vn = V[n, 128]; constant bits(128) Vd = V[d, 128]; bits(32) WjPrime; bits(128) result; bits(32) TT1; bits(32) SS2; WjPrime = Elem[Vm, i, 32]; SS2 = Vn<127:96> EOR ROL(Vd<127:96>, 12); TT1 = (Vd<127:96> AND Vd<63:32>) OR (Vd<127:96> AND Vd<95:64>) OR (Vd<63:32> AND Vd<95:64>); TT1 = (TT1 + Vd<31:0> + SS2 + WjPrime)<31:0>; result<31:0> = Vd<63:32>; result<63:32> = ROL(Vd<95:64>, 9); result<95:64> = Vd<127:96>; result<127:96> = TT1; V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.308 SM3TT2A

## SM3TT2A

This instruction takes three 128-bit vectors from three source SIMD&amp;FP register and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&amp;FP register. It performs a three-way exclusive-OR of the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:

- The bottom 32-bit element of the first source vector, Vd, that was used for the three-way exclusive-OR.
- The 32-bit element held in the top 32 bits of the second source vector, Vn.
- A32-bit element indexed out of the third source vector, Vm.

Athree-way exclusive-OR is performed of the result of this addition, the result of the addition rotated left by 9, and the result of the addition rotated left by 17. The result of this exclusive-OR is returned as the top element of the returned result. The other elements of this result are taken from elements of the first source vector, with the element returned in bits&lt;63:32&gt; being rotated left by 19.

## Advanced SIMD

(FEAT\_SM3)

<!-- image -->

## Encoding

```
SM3TT2A <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SM3) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer i = UInt(imm2);
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;imm2&gt;

Is a 32-bit element indexed out of &lt;Vm&gt;, encoded in 'imm2'.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) Vm = V[m, 128]; constant bits(128) Vn = V[n, 128]; constant bits(128) Vd = V[d, 128]; bits(32) Wj; bits(128) result; bits(32) TT2; Wj = Elem[Vm, i, 32]; TT2 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>); TT2 = (TT2 + Vd<31:0> + Vn<127:96> + Wj)<31:0>; result<31:0> = Vd<63:32>; result<63:32> = ROL(Vd<95:64>, 19); result<95:64> = Vd<127:96>; result<127:96> = TT2 EOR ROL(TT2, 9) EOR V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
ROL(TT2, 17);
```

## C7.2.309 SM3TT2B

## SM3TT2B

This instruction takes three 128-bit vectors from three source SIMD&amp;FP registers, and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&amp;FP register. It performs a 32-bit majority function between the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:

- The bottom 32-bit element of the first source vector, Vd, that was used for the 32-bit majority function.
- The 32-bit element held in the top 32 bits of the second source vector, Vn.
- A32-bit element indexed out of the third source vector, Vm.

Athree-way exclusive-OR is performed of the result of this addition, the result of the addition rotated left by 9, and the result of the addition rotated left by 17. The result of this exclusive-OR is returned as the top element of the returned result. The other elements of this result are taken from elements of the first source vector, with the element returned in bits&lt;63:32&gt; being rotated left by 19.

## Advanced SIMD

(FEAT\_SM3)

<!-- image -->

## Encoding

```
SM3TT2B <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SM3) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer i = UInt(imm2);
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the third SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;imm2&gt;

Is a 32-bit element indexed out of &lt;Vm&gt;, encoded in 'imm2'.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) Vm = V[m, 128]; constant bits(128) Vn = V[n, 128]; constant bits(128) Vd = V[d, 128]; bits(32) Wj; bits(128) result; bits(32) TT2; Wj = Elem[Vm, i, 32]; TT2 = (Vd<127:96> AND Vd<95:64>) OR (NOT(Vd<127:96>) AND Vd<63:32>); TT2 = (TT2 + Vd<31:0> + Vn<127:96> + Wj)<31:0>; result<31:0> = Vd<63:32>; result<63:32> = ROL(Vd<95:64>, 19); result<95:64> = Vd<127:96>; result<127:96> = TT2 EOR ROL(TT2, 9) EOR ROL(TT2, 17); V[d, 128] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.310 SM4E

## SM4 encode

This instruction takes input data as a 128-bit vector from the first source SIMD&amp;FP register, and four iterations of the round key held as the elements of the 128-bit vector in the second source SIMD&amp;FP register. It encrypts the data by four rounds, in accordance with the SM4 standard, returning the 128-bit result to the destination SIMD&amp;FP register.

## Advanced SIMD

(FEAT\_SM4)

<!-- image -->

## Encoding

```
SM4E <Vd>.4S, <Vn>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SM4) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP source and destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) Vn = V[n, 128]; bits(32) intval; bits(128) roundresult; bits(32) roundkey; roundresult = V[d, 128]; for index = 0 to 3 roundkey = Elem[Vn, index, 32]; intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR roundkey; for i = 0 to 3 Elem[intval, i, 8] = Sbox(Elem[intval, i, 8]); intval = intval EOR ROL(intval, 2) EOR ROL(intval, 10) EOR ROL(intval, 18) EOR ROL(intval, 24); intval = intval EOR roundresult<31:0>; roundresult<31:0> = roundresult<63:32>; roundresult<63:32> = roundresult<95:64>; roundresult<95:64> = roundresult<127:96>; roundresult<127:96> = intval;
```

V[d, 128] = roundresult;

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.311 SM4EKEY

SM4 key

This instruction takes an input as a 128-bit vector from the first source SIMD&amp;FP register and a 128-bit constant from the second SIMD&amp;FP register. It derives four iterations of the output key, in accordance with the SM4 standard, returning the 128-bit result to the destination SIMD&amp;FP register.

## Advanced SIMD

(FEAT\_SM4)

<!-- image -->

## Encoding

```
SM4EKEY <Vd>.4S, <Vn>.4S, <Vm>.4S
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SM4) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) Vm = V[m, 128]; bits(32) intval; bits(32) const; bits(128) roundresult; roundresult = V[n, 128]; for index = 0 to 3 const = Elem[Vm, index, 32]; intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR const; for i = 0 to 3 Elem[intval, i, 8] = Sbox(Elem[intval, i, 8]); intval = intval EOR ROL(intval, 13) EOR ROL(intval, 23); intval = intval EOR roundresult<31:0>;
```

```
roundresult<31:0> = roundresult<63:32>; roundresult<63:32> = roundresult<95:64>; roundresult<95:64> = roundresult<127:96>; roundresult<127:96> = intval; V[d, 128] = roundresult;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.312 SMAX

Signed maximum (vector)

This instruction compares corresponding elements in the vectors in the two source SIMD&amp;FP registers, places the larger of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SMAX
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer max; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); max = Max(element1, element2); Elem[result, e, esize] = max<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.313 SMAXP

Signed maximum pairwise

This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements in the two source SIMD&amp;FP registers, writes the largest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; constant bits(2*datasize) concat = operand2:operand1; integer element1; integer element2; integer max; for e = 0 to elements-1 element1 = SInt(Elem[concat, 2*e, esize]); element2 = SInt(Elem[concat, (2*e)+1, esize]); max = Max(element1, element2); Elem[result, e, esize] = max<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.314 SMAXV

Signed maximum across vector

This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the largest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SMAXV <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '100' then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = FALSE;
```

## Assembler Symbols

<!-- image -->

&lt;V&gt;

Is the destination width specifier, encoded in 'size':

<!-- image -->

<!-- image -->

&lt;Vn&gt;

|   size | <V>      |
|--------|----------|
|     00 | B        |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;T&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | RESERVED |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(esize) opelt = Elem[operand, 0, esize]; integer max = if unsigned then UInt(opelt) else SInt(opelt); for e = 1 to elements-1 opelt = Elem[operand, e, esize]; constant integer element = if unsigned then UInt(opelt) else SInt(opelt); max = Max(max, element); V[d, esize] = max<esize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.315 SMIN

Signed minimum (vector)

This instruction compares corresponding elements in the vectors in the two source SIMD&amp;FP registers, places the smaller of each of the two signed integer values into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SMIN
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer min; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); min = Min(element1, element2); Elem[result, e, esize] = min<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.316 SMINP

Signed minimum pairwise

This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements in the two source SIMD&amp;FP registers, writes the smallest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; constant bits(2*datasize) concat = operand2:operand1; integer element1; integer element2; integer min; for e = 0 to elements-1 element1 = SInt(Elem[concat, 2*e, esize]); element2 = SInt(Elem[concat, (2*e)+1, esize]); min = Min(element1, element2); Elem[result, e, esize] = min<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.317 SMINV

Signed minimum across vector

This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the smallest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SMINV <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '100' then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = FALSE;
```

## Assembler Symbols

<!-- image -->

&lt;V&gt;

Is the destination width specifier, encoded in 'size':

<!-- image -->

<!-- image -->

&lt;Vn&gt;

|   size | <V>      |
|--------|----------|
|     00 | B        |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;T&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | RESERVED |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(esize) opelt = Elem[operand, 0, esize]; integer min = if unsigned then UInt(opelt) else SInt(opelt); for e = 1 to elements-1 opelt = Elem[operand, e, esize]; constant integer element = if unsigned then UInt(opelt) else SInt(opelt); min = Min(min, element); V[d, esize] = min<esize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.318 SMLAL, SMLAL2 (by element)

Signed multiply-add long (vector, by element)

This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element in the second source SIMD&amp;FP register, and accumulates the results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values.

The SMLAL instruction extracts vector elements from the lower half of the first source register. The SMLAL2 instruction extracts vector elements from the upper half of the first source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

<!-- image -->

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

&lt;m&gt;

Restricted to 0-15 when element size &lt;Ts&gt; is H.

| Q   | 2   |
|-----|-----|

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | RESERVED |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |
|     11 | RESERVED     |

&lt;Ts&gt;

Is an element size specifier, encoded in 'size':

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; constant bits(2*datasize) operand3 = V[d, 2*datasize]; bits(2*datasize) result; integer element1; constant integer element2 = SInt(Elem[operand2, index, esize]); bits(2*esize) product; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); product = (element1 * element2)<2*esize-1:0>; Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

```
product;
```

## C7.2.319 SMLAL, SMLAL2 (vector)

Signed multiply-add long (vector)

This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&amp;FP registers, and accumulates the results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied.

The SMLAL instruction extracts each source vector from the lower half of each source register. The SMLAL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = constant bits(2*datasize) operand3 = V[d, 2*datasize]; bits(2*datasize) result; integer element1; integer element2; bits(2*esize) product; bits(2*esize) accum; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); product = (element1 * element2)<2*esize-1:0>; accum = Elem[operand3, e, 2*esize] + product; Elem[result, e, 2*esize] = accum; V[d, 2*datasize] = result;
```

```
Vpart[n, part, datasize]; Vpart[m, part, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.320 SMLSL, SMLSL2 (by element)

Signed multiply-subtract long (vector, by element)

This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register and subtracts the results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied.

The SMLSL instruction extracts vector elements from the lower half of the first source register. The SMLSL2 instruction extracts vector elements from the upper half of the first source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

&lt;m&gt;

&lt;Ts&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size':

Restricted to 0-15 when element size &lt;Ts&gt; is H.

Is an element size specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | RESERVED |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |
|     11 | RESERVED     |

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; constant bits(2*datasize) operand3 = V[d, 2*datasize]; bits(2*datasize) result; integer element1; constant integer element2 = SInt(Elem[operand2, index, esize]); bits(2*esize) product; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); product = (element1 * element2)<2*esize-1:0>; Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

```
product;
```

## C7.2.321 SMLSL, SMLSL2 (vector)

Signed multiply-subtract long (vector)

This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&amp;FP registers, and subtracts the results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied.

The SMLSL instruction extracts each source vector from the lower half of each source register. The SMLSL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = constant bits(2*datasize) operand3 = V[d, 2*datasize]; bits(2*datasize) result; integer element1; integer element2; bits(2*esize) product; bits(2*esize) accum; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); product = (element1 * element2)<2*esize-1:0>; accum = Elem[operand3, e, 2*esize] product; Elem[result, e, 2*esize] = accum; V[d, 2*datasize] = result;
```

```
Vpart[n, part, datasize]; Vpart[m, part, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.322 SMMLA (vector)

Signed 8-bit integer matrix multiply-accumulate to 32-bit integer (vector)

This instruction multiplies the 2x8 matrix of signed 8-bit integer values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element.

From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID\_AA64ISAR1\_EL1.I8MM indicates whether this instruction is supported.

## Vector

(FEAT\_I8MM)

<!-- image -->

## Encoding

```
SMMLA <Vd>.4S, <Vn>.16B, <Vm>.16B
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_I8MM) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean op1_unsigned = FALSE; constant boolean op2_unsigned = FALSE;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP third source and destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[n, 128]; constant bits(128) operand2 = V[m, 128]; constant bits(128) addend = V[d, 128]; V[d, 128] = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned);
```

## Operational Information

Arm expects that the SMMLA (vector) instruction will deliver a peak integer multiply throughput that is at least as high as can be achieved using two SDOT (vector) instructions, with a goal that it should have significantly higher throughput.

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.323 SMOV

Signed move vector element to general-purpose register

This instruction reads the signed integer from the source SIMD&amp;FP register, sign-extends it to form a 32-bit or 64-bit value, and writes the result to destination general-purpose register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 32-bit variant

Applies when

```
(Q == 0)
```

```
SMOV
```

```
<Wd>, <Vn>.<Ts>[<index>]
```

## Encoding for the 64-bit variant

```
Applies when (Q == 1) SMOV <Xd>, <Vn>.<Ts>[<index>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if imm5 == 'xx000' then EndOfDecode(Decode_UNDEF); constant integer size = LowestSetBitNZ(imm5<2:0>); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << size; constant integer datasize = 32 << UInt(Q); if datasize <= esize then EndOfDecode(Decode_UNDEF); constant integer index = UInt(imm5<4:size+1>); constant integer idxdsize = 64 << UInt(imm5<4>);
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

&lt;Ts&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

For the '32-bit' variant: is an element size specifier, encoded in 'imm5':

## &lt;index&gt;

For the '32-bit' variant: is the element index encoded in 'imm5':

| imm5   | <index>         |
|--------|-----------------|
| xxx00  | RESERVED        |
| xxxx1  | UInt(imm5<4:1>) |
| xxx10  | UInt(imm5<4:2>) |

For the '64-bit' variant: is the element index encoded in 'imm5':

| imm5   | <index>         |
|--------|-----------------|
| xx000  | RESERVED        |
| xxxx1  | UInt(imm5<4:1>) |
| xxx10  | UInt(imm5<4:2>) |
| xx100  | UInt(imm5<4:3>) |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

```
if index == 0 then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(idxdsize) operand = V[n, idxdsize]; X[d, datasize] = SignExtend(Elem[operand, index, esize], datasize);
```

## &lt;Xd&gt;

| imm5   | <Ts>     |
|--------|----------|
| xxx00  | RESERVED |
| xxxx1  | B        |
| xxx10  | H        |

For the '64-bit' variant: is an element size specifier, encoded in 'imm5':

| imm5   | <Ts>     |
|--------|----------|
| xx000  | RESERVED |
| xxxx1  | B        |
| xxx10  | H        |
| xx100  | S        |

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.324 SMULL, SMULL2 (by element)

Signed multiply long (vector, by element)

This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied.

The SMULL instruction extracts vector elements from the lower half of the first source register. The SMULL2 instruction extracts vector elements from the upper half of the first source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

&lt;m&gt;

&lt;Ts&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size':

Restricted to 0-15 when element size &lt;Ts&gt; is H.

Is an element size specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | RESERVED |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |
|     11 | RESERVED     |

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; bits(2*datasize) result; integer element1; constant integer element2 = SInt(Elem[operand2, index, esize]); bits(2*esize) product; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); product = (element1 * element2)<2*esize-1:0>; Elem[result, e, 2*esize] = product; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

## C7.2.325 SMULL, SMULL2 (vector)

Signed multiply long (vector)

This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&amp;FP registers, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register.

The destination vector elements are twice as long as the elements that are multiplied.

The SMULL instruction extracts each source vector from the lower half of each source register. The SMULL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Ta&gt;

&lt;Vn&gt;

&lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(datasize) operand2 = Vpart[m, part, datasize]; bits(2*datasize) result; integer element1; integer element2; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.326 SQABS

Signed saturating absolute value

This instruction reads each vector element from the source SIMD&amp;FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQABS <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

SQABS

&lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vn&gt;

|   size | <V>   |
|--------|-------|
|     00 | B     |
|     01 | H     |
|     10 | S     |
|     11 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; integer element; boolean sat; for e = 0 to elements-1 element = SInt(Elem[operand, e, esize]); element = Abs(element); (Elem[result, e, esize], sat) = SignedSatQ(element, if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

```
esize);
```

## C7.2.327 SQADD

Signed saturating add

This instruction adds the values of corresponding elements of the two source SIMD&amp;FP registers, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQADD <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean unsigned = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

|   size | <V>   |
|--------|-------|
|     00 | B     |
|     01 | H     |
|     10 | S     |
|     11 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |
|     10 |   1 | 4S    |

&lt;Vn&gt;

|   size |   Q | <T>      |
|--------|-----|----------|
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer sum; boolean sat; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); sum = element1 + element2; (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.328 SQDMLAL, SQDMLAL2 (by element)

Signed saturating doubling multiply-add long (by element)

This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLAL instruction extracts vector elements from the lower half of the first source register. The SQDMLAL2 instruction extracts vector elements from the upper half of the first source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQDMLAL <Va><d>, <Vb><n>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant integer part = 0;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQDMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Va&gt;

Is the destination width specifier, encoded in 'size':

&lt;d&gt;

&lt;Vb&gt;

<!-- image -->

&lt;n&gt;

|   size | <Va>     |
|--------|----------|
|     00 | RESERVED |
|     01 | S        |
|     10 | D        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'size':

|   size | <Vb>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;m&gt;

## &lt;Ts&gt;

Is an element size specifier, encoded in 'size':

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

2

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |
|     11 | RESERVED     |

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Restricted to 0-15 when element size &lt;Ts&gt; is H.

&lt;Vd&gt;

&lt;Ta&gt;

&lt;Vn&gt;

&lt;Tb&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | RESERVED |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; constant bits(2*datasize) operand3 = V[d, 2*datasize]; bits(2*datasize) result; integer element1; integer element2; bits(2*esize) product; integer accum; boolean sat1; boolean sat2; element2 = SInt(Elem[operand2, index, esize]); for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); (product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize); accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product); (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2 * esize); if sat1 || sat2 then FPSR.QC = '1'; V[d, 2*datasize] = result;
```

## C7.2.329 SQDMLAL, SQDMLAL2 (vector)

Signed saturating doubling multiply-add long

This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&amp;FP registers, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLAL instruction extracts each source vector from the lower half of each source register. The SQDMLAL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQDMLAL <Va><d>, <Vb><n>, <Vb><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '00' || size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant integer part = 0;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

SQDMLAL{2}

&lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '00' || size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Va&gt;

Is the destination width specifier, encoded in 'size':

&lt;d&gt;

&lt;Vb&gt;

&lt;n&gt;

&lt;m&gt;

2

|   size | <Va>     |
|--------|----------|
|     00 | RESERVED |
|     01 | S        |
|     10 | D        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'size':

|   size | <Vb>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

&lt;Tb&gt;

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | RESERVED |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = constant bits(2*datasize) operand3 = V[d, 2*datasize]; bits(2*datasize) result; integer element1; integer element2; bits(2*esize) product; integer accum; boolean sat1;
```

```
Vpart[n, part, datasize]; Vpart[m, part, datasize];
```

```
boolean sat2; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); (product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize); accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product); (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2 * esize); if sat1 || sat2 then FPSR.QC = '1'; V[d, 2*datasize] = result;
```

## C7.2.330 SQDMLSL, SQDMLSL2 (by element)

Signed saturating doubling multiply-subtract long (by element)

This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLSL instruction extracts vector elements from the lower half of the first source register. The SQDMLSL2 instruction extracts vector elements from the upper half of the first source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQDMLSL <Va><d>, <Vb><n>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant integer part = 0;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQDMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Va&gt;

Is the destination width specifier, encoded in 'size':

&lt;d&gt;

&lt;Vb&gt;

<!-- image -->

&lt;n&gt;

|   size | <Va>     |
|--------|----------|
|     00 | RESERVED |
|     01 | S        |
|     10 | D        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'size':

|   size | <Vb>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;m&gt;

## &lt;Ts&gt;

Is an element size specifier, encoded in 'size':

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

2

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |
|     11 | RESERVED     |

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Restricted to 0-15 when element size &lt;Ts&gt; is H.

&lt;Vd&gt;

&lt;Ta&gt;

&lt;Vn&gt;

&lt;Tb&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | RESERVED |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; constant bits(2*datasize) operand3 = V[d, 2*datasize]; bits(2*datasize) result; integer element1; integer element2; bits(2*esize) product; integer accum; boolean sat1; boolean sat2; element2 = SInt(Elem[operand2, index, esize]); for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); (product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize); accum = SInt(Elem[operand3, e, 2*esize]) SInt(product); (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2 * esize); if sat1 || sat2 then FPSR.QC = '1'; V[d, 2*datasize] = result;
```

## C7.2.331 SQDMLSL, SQDMLSL2 (vector)

Signed saturating doubling multiply-subtract long

This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&amp;FP registers, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLSL instruction extracts each source vector from the lower half of each source register. The SQDMLSL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQDMLSL <Va><d>, <Vb><n>, <Vb><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '00' || size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant integer part = 0;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

SQDMLSL{2}

&lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '00' || size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Va&gt;

Is the destination width specifier, encoded in 'size':

&lt;d&gt;

&lt;Vb&gt;

&lt;n&gt;

&lt;m&gt;

2

|   size | <Va>     |
|--------|----------|
|     00 | RESERVED |
|     01 | S        |
|     10 | D        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'size':

|   size | <Vb>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

&lt;Tb&gt;

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | RESERVED |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = constant bits(2*datasize) operand3 = V[d, 2*datasize]; bits(2*datasize) result; integer element1; integer element2; bits(2*esize) product; integer accum; boolean sat1;
```

```
Vpart[n, part, datasize]; Vpart[m, part, datasize];
```

```
boolean sat2; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); (product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize); accum = SInt(Elem[operand3, e, 2*esize]) SInt(product); (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2 * esize); if sat1 || sat2 then FPSR.QC = '1'; V[d, 2*datasize] = result;
```

## C7.2.332 SQDMULH (by element)

Signed saturating doubling multiply returning high half (by element)

This instruction multiplies each vector element in the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&amp;FP register.

The results are truncated. For rounded results, see SQRDMULH.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQDMULH <V><d>, <V><n>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean round = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQDMULH <Vd>.<T>, <Vn>.<T>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean round = FALSE;
```

## Assembler Symbols

<!-- image -->

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

<!-- image -->

&lt;m&gt;

|   size | <V>      |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |

## &lt;Ts&gt;

Is an element size specifier, encoded in 'size':

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

## &lt;Vd&gt;

## &lt;T&gt;

## &lt;Vn&gt;

Restricted to 0-15 when element size &lt;Ts&gt; is H.

| 11   | RESERVED   |
|------|------------|

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; bits(datasize) result; integer element1; integer element2; integer product; boolean sat; element2 = SInt(Elem[operand2, index, esize]); for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); product = 2 * element1 * element2; product = RShr(product, esize, round); // The following only saturates if element1 and element2 (Elem[result, e, esize], sat) = SignedSatQ(product, esize); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
equal -(2^(esize-1))
```

## C7.2.333 SQDMULH (vector)

Signed saturating doubling multiply returning high half

This instruction multiplies the values of corresponding elements of the two source SIMD&amp;FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&amp;FP register.

The results are truncated. For rounded results, see SQRDMULH.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQDMULH <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' || size == '00' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean rounding = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' || size == '00' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean rounding = FALSE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

|   size | <V>      |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer product; boolean sat; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); product = 2 * element1 * element2; product = RShr(product, esize, rounding); (Elem[result, e, esize], sat) = SignedSatQ(product, esize); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.334 SQDMULL, SQDMULL2 (by element)

Signed saturating doubling multiply long (by element)

This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMULL instruction extracts the first source vector from the lower half of the first source register. The SQDMULL2 instruction extracts the first source vector from the upper half of the first source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Vector and Scalar

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQDMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQDMULL <Va><d>, <Vb><n>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant integer part = 0;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size':

&lt;Vd&gt;

&lt;Ta&gt;

&lt;Vn&gt;

|   size | <Ta>     |
|--------|----------|
|     00 | RESERVED |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Tb&gt;

## &lt;m&gt;

&lt;Ts&gt;

Is an element size specifier, encoded in 'size':

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |
|     11 | RESERVED     |

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>   |
|--------|-----------|
|     00 | RESERVED  |

Restricted to 0-15 when element size &lt;Ts&gt; is H.

&lt;Va&gt;

&lt;d&gt;

## &lt;Vb&gt;

<!-- image -->

Is the destination width specifier, encoded in 'size':

|   size | <index>     |
|--------|-------------|
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

|   size | <Va>     |
|--------|----------|
|     00 | RESERVED |
|     01 | S        |
|     10 | D        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'size':

|   size | <Vb>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; bits(2*datasize) result; integer element1; constant integer element2 = SInt(Elem[operand2, index, esize]); bits(2*esize) product; boolean sat; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); (product, sat) = SignedSatQ(2 * element1 * element2, 2 * Elem[result, e, 2*esize] = product;
```

```
esize); if sat then FPSR.QC = '1';
```

V[d, 2*datasize] = result;

## C7.2.335 SQDMULL, SQDMULL2 (vector)

Signed saturating doubling multiply long

This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&amp;FP registers, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&amp;FP register.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMULL instruction extracts each source vector from the lower half of each source register. The SQDMULL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQDMULL <Va><d>, <Vb><n>, <Vb><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '00' || size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant integer part = 0;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

SQDMULL{2}

&lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '00' || size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Va&gt;

Is the destination width specifier, encoded in 'size':

&lt;d&gt;

&lt;Vb&gt;

&lt;n&gt;

&lt;m&gt;

|   size | <Va>     |
|--------|----------|
|     00 | RESERVED |
|     01 | S        |
|     10 | D        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'size':

|   size | <Vb>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

- 2 Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the

registers holding the narrower elements, and is encoded in 'Q':

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

&lt;Tb&gt;

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | RESERVED |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(datasize) operand2 = Vpart[m, part, datasize]; bits(2*datasize) result; integer element1; integer element2; bits(2*esize) product; boolean sat; for e = 0 to elements-1
```

```
element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); (product, sat) = SignedSatQ(2 * element1 * element2, 2 * esize); Elem[result, e, 2*esize] = product; if sat then FPSR.QC = '1'; V[d, 2*datasize] = result;
```

## C7.2.336 SQNEG

Signed saturating negate

This instruction reads each vector element from the source SIMD&amp;FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQNEG <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

SQNEG

&lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

- &lt;T&gt; Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vn&gt;

|   size | <V>   |
|--------|-------|
|     00 | B     |
|     01 | H     |
|     10 | S     |
|     11 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; integer element; boolean sat; for e = 0 to elements-1 element = SInt(Elem[operand, e, esize]); element = -element; (Elem[result, e, esize], sat) = SignedSatQ(element, esize); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.337 SQRDMLAH (by element)

Signed saturating rounding doubling multiply accumulate returning high half (by element)

This instruction multiplies the vector elements of the first source SIMD&amp;FP register with the value of a vector element of the second source SIMD&amp;FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&amp;FP register. The results are rounded.

If any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_RDM)

<!-- image -->

## Encoding

```
SQRDMLAH <V><d>, <V><n>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_RDM) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean rounding = TRUE;
```

## Vector

(FEAT\_RDM)

<!-- image -->

## Encoding

```
SQRDMLAH <Vd>.<T>, <Vn>.<T>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_RDM) then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean rounding = TRUE;
```

## Assembler Symbols

<!-- image -->

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

<!-- image -->

&lt;m&gt;

|   size | <V>      |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |

## &lt;Ts&gt;

Is an element size specifier, encoded in 'size':

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

## &lt;Vd&gt;

## &lt;T&gt;

## &lt;Vn&gt;

Restricted to 0-15 when element size &lt;Ts&gt; is H.

| 11   | RESERVED   |
|------|------------|

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; integer element1; integer element2; integer element3; integer accum; boolean sat; element2 = SInt(Elem[operand2, index, esize]); for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element3 = SInt(Elem[operand3, e, esize]); accum = (element3 << esize) + 2 * (element1 * element2); accum = RShr(accum, esize, rounding); (Elem[result, e, esize], sat) = SignedSatQ(accum, esize); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.338 SQRDMLAH (vector)

Signed saturating rounding doubling multiply accumulate returning high half (vector)

This instruction multiplies the vector elements of the first source SIMD&amp;FP register with the corresponding vector elements of the second source SIMD&amp;FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&amp;FP register. The results are rounded.

If any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_RDM)

<!-- image -->

## Encoding

```
SQRDMLAH <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_RDM) then EndOfDecode(Decode_UNDEF); if size == '11' || size == '00' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean rounding = TRUE;
```

## Vector

(FEAT\_RDM)

<!-- image -->

## Encoding

```
SQRDMLAH <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_RDM) then EndOfDecode(Decode_UNDEF); if size == '11' || size == '00' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean rounding = TRUE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

|   size | <V>      |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; integer element1; integer element2; integer element3; integer accum; boolean sat; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); element3 = SInt(Elem[operand3, e, esize]); accum = (element3 << esize) + 2 * (element1 * element2); accum = RShr(accum, esize, rounding); (Elem[result, e, esize], sat) = SignedSatQ(accum, esize); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.339 SQRDMLSH (by element)

Signed saturating rounding doubling multiply subtract returning high half (by element)

This instruction multiplies the vector elements of the first source SIMD&amp;FP register with the value of a vector element of the second source SIMD&amp;FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&amp;FP register. The results are rounded.

If any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_RDM)

<!-- image -->

## Encoding

```
SQRDMLSH <V><d>, <V><n>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_RDM) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean rounding = TRUE;
```

## Vector

(FEAT\_RDM)

<!-- image -->

## Encoding

```
SQRDMLSH <Vd>.<T>, <Vn>.<T>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_RDM) then EndOfDecode(Decode_UNDEF); constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean rounding = TRUE;
```

## Assembler Symbols

<!-- image -->

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

<!-- image -->

&lt;m&gt;

|   size | <V>      |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |

## &lt;Ts&gt;

Is an element size specifier, encoded in 'size':

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

## &lt;Vd&gt;

## &lt;T&gt;

## &lt;Vn&gt;

Restricted to 0-15 when element size &lt;Ts&gt; is H.

| 11   | RESERVED   |
|------|------------|

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; integer element1; integer element2; integer element3; integer accum; boolean sat; element2 = SInt(Elem[operand2, index, esize]); for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element3 = SInt(Elem[operand3, e, esize]); accum = (element3 << esize) - 2 * (element1 * element2); accum = RShr(accum, esize, rounding); (Elem[result, e, esize], sat) = SignedSatQ(accum, esize); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.340 SQRDMLSH (vector)

Signed saturating rounding doubling multiply subtract returning high half (vector)

This instruction multiplies the vector elements of the first source SIMD&amp;FP register with the corresponding vector elements of the second source SIMD&amp;FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&amp;FP register. The results are rounded.

If any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_RDM)

<!-- image -->

## Encoding

```
SQRDMLSH <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_RDM) then EndOfDecode(Decode_UNDEF); if size == '11' || size == '00' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean rounding = TRUE;
```

## Vector

(FEAT\_RDM)

<!-- image -->

## Encoding

SQRDMLSH

&lt;Vd&gt;.&lt;T&gt;,

&lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_RDM) then EndOfDecode(Decode_UNDEF); if size == '11' || size == '00' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean rounding = TRUE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

|   size | <V>      |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; integer element1; integer element2; integer element3; integer accum; boolean sat; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); element3 = SInt(Elem[operand3, e, esize]); accum = (element3 << esize) - 2 * (element1 * element2); accum = RShr(accum, esize, rounding); (Elem[result, e, esize], sat) = SignedSatQ(accum, esize); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.341 SQRDMULH (by element)

Signed saturating rounding doubling multiply returning high half (by element)

This instruction multiplies each vector element in the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&amp;FP register.

The results are rounded. For truncated results, see SQDMULH.

If any of the results overflows, they are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQRDMULH <V><d>, <V><n>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean round = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQRDMULH <Vd>.<T>, <Vn>.<T>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean round = TRUE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;m&gt;

|   size | <V>      |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |

## &lt;Ts&gt;

Is an element size specifier, encoded in 'size':

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

## &lt;Vd&gt;

&lt;T&gt;

## &lt;Vn&gt;

Restricted to 0-15 when element size &lt;Ts&gt; is H.

|   size | <m>      |
|--------|----------|
|     11 | RESERVED |

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; bits(datasize) result; integer element1; integer element2; integer product; boolean sat; element2 = SInt(Elem[operand2, index, esize]); for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); product = 2 * element1 * element2; product = RShr(product, esize, round); // The following only saturates if element1 and element2 (Elem[result, e, esize], sat) = SignedSatQ(product, esize); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
equal -(2^(esize-1))
```

## C7.2.342 SQRDMULH (vector)

Signed saturating rounding doubling multiply returning high half

This instruction multiplies the values of corresponding elements of the two source SIMD&amp;FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&amp;FP register.

The results are rounded. For truncated results, see SQDMULH.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQRDMULH <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' || size == '00' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean rounding = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQRDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' || size == '00' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean rounding = TRUE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

|   size | <V>      |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer product; boolean sat; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); product = 2 * element1 * element2; product = RShr(product, esize, rounding); (Elem[result, e, esize], sat) = SignedSatQ(product, esize); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.343 SQRSHL

Signed saturating rounding shift left (register)

This instruction takes each vector element in the first source SIMD&amp;FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are rounded. For truncated results, see SQSHL.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQRSHL <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if S == '0' && size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean unsigned = FALSE; constant boolean rounding = TRUE; constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQRSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean unsigned = FALSE; constant boolean rounding = TRUE; constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

|   size | <V>   |
|--------|-------|
|     00 | B     |
|     01 | H     |
|     10 | S     |
|     11 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |

&lt;Vn&gt;

|   size |   Q | <T>      |
|--------|-----|----------|
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; boolean sat; for e = 0 to elements-1 integer element = SInt(Elem[operand1, e, esize]); integer shift = ShiftSat(SInt(Elem[operand2, e, esize]<7:0>), esize); if shift >= 0 then // left shift element = element << shift; else // right shift shift = -shift; element = RShr(element, shift, rounding); (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.344 SQRSHRN, SQRSHRN2

Signed saturating rounded shift right narrow (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SQSHRN.

The SQRSHRN instruction writes the vector to the lower half of the destination register and clears the upper half. The SQRSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQRSHRN <Vb><d>, <Va><n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh == '0000' then EndOfDecode(Decode_UNDEF); if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = esize; constant integer elements = 1; constant integer part = 0; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = TRUE; constant boolean unsigned = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQRSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = TRUE; constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;Vb&gt;

Is the destination width specifier, encoded in 'immh':

| immh   | <Vb>     |
|--------|----------|
| 0001   | B        |
| 001x   | H        |
| 01xx   | S        |
| 1xxx   | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'immh':

&lt;d&gt;

&lt;Va&gt;

&lt;n&gt;

| immh   | <Va>     |
|--------|----------|
| 0001   | H        |
| 001x   | S        |
| 01xx   | D        |
| 1xxx   | RESERVED |

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to the destination operand width in bits, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

For the 'Vector' variant: is the right shift amount, in the range 1 to the destination element width in bits, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

- 2 Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the

registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <Tb>   |
|--------|-----|--------|
| 0001   |   0 | 8B     |
| 0001   |   1 | 16B    |
| 001x   |   0 | 4H     |

## &lt;Vd&gt;

## &lt;Tb&gt;

&lt;Vn&gt;

&lt;Ta&gt;

Is an arrangement specifier, encoded in 'immh':

| immh   | <Ta>     |
|--------|----------|
| 0001   | 8H       |
| 001x   | 4S       |
| 01xx   | 2D       |
| 1xxx   | RESERVED |

```
esize);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize*2) operand = V[n, datasize*2]; bits(datasize) result; boolean sat; for e = 0 to elements-1 constant bits(2*esize) opelt = Elem[operand, e, 2*esize]; if unsigned then constant integer element = RShr(UInt(opelt), shift, round); (Elem[result, e, esize], sat) = UnsignedSatQ(element, else constant integer element = RShr(SInt(opelt), shift, round); (Elem[result, e, esize], sat) = SignedSatQ(element, esize); if sat then FPSR.QC = '1'; Vpart[d, part, datasize] = result;
```

| immh   | Q   | <Tb>     |
|--------|-----|----------|
| 001x   | 1   | 8H       |
| 01xx   | 0   | 2S       |
| 01xx   | 1   | 4S       |
| 1xxx   | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.345 SQRSHRUN, SQRSHRUN2

Signed saturating rounded shift right unsigned narrow (immediate)

This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&amp;FP register. The results are rounded. For truncated results, see SQSHRUN.

The SQRSHRUN instruction writes the vector to the lower half of the destination register and clears the upper half. The SQRSHRUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQRSHRUN <Vb><d>, <Va><n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh == '0000' then EndOfDecode(Decode_UNDEF); if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = esize; constant integer elements = 1; constant integer part = 0; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQRSHRUN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = TRUE;
```

## Assembler Symbols

&lt;Vb&gt;

Is the destination width specifier, encoded in 'immh':

| immh   | <Vb>     |
|--------|----------|
| 0001   | B        |
| 001x   | H        |
| 01xx   | S        |
| 1xxx   | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'immh':

&lt;d&gt;

&lt;Va&gt;

<!-- image -->

&lt;n&gt;

| immh   | <Va>     |
|--------|----------|
| 0001   | H        |
| 001x   | S        |
| 01xx   | D        |
| 1xxx   | RESERVED |

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to the destination operand width in bits, encoded in 'immh:immb':

2

## &lt;Vd&gt;

## &lt;Tb&gt;

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

For the 'Vector' variant: is the right shift amount, in the range 1 to the destination element width in bits, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <Tb>   |
|--------|-----|--------|
| 0001   |   0 | 8B     |
| 0001   |   1 | 16B    |
| 001x   |   0 | 4H     |
| 001x   |   1 | 8H     |
| 01xx   |   0 | 2S     |
| 01xx   |   1 | 4S     |

&lt;Vn&gt;

&lt;Ta&gt;

Is an arrangement specifier, encoded in 'immh':

| immh   | <Ta>     |
|--------|----------|
| 0001   | 8H       |
| 001x   | 4S       |
| 01xx   | 2D       |
| 1xxx   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize*2) operand = V[n, datasize*2]; bits(datasize) result; integer element; boolean sat; for e = 0 to elements-1 element = RShr(SInt(Elem[operand, e, 2*esize]), shift, round); (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize); if sat then FPSR.QC = '1'; Vpart[d, part, datasize] = result;
```

| immh   | Q   | <Tb>     |
|--------|-----|----------|
| 1xxx   | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.346 SQSHL (immediate)

Signed saturating shift left (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, shifts each result by an immediate value, places the final result in a vector, and writes the vector to the destination SIMD&amp;FP register. The results are truncated. For rounded results, see UQRSHL.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQSHL <V><d>, <V><n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh == '0000' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = esize; constant integer elements = 1; constant integer shift = UInt(immh:immb) esize; constant boolean src_unsigned = FALSE; constant boolean dst_unsigned = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQSHL <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = UInt(immh:immb) esize; constant boolean src_unsigned = FALSE; constant boolean dst_unsigned = FALSE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'immh':

&lt;d&gt;

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the left shift amount, in the range 0 to the operand width in bits minus 1, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | UInt(immh:immb) - 8  |
| 001x   | UInt(immh:immb) - 16 |
| 01xx   | UInt(immh:immb) - 32 |
| 1xxx   | UInt(immh:immb) - 64 |

For the 'Vector' variant: is the left shift amount, in the range 0 to the element width in bits minus 1, encoded in 'immh:immb':

| immh   | <V>   |
|--------|-------|
| 0001   | B     |
| 001x   | H     |
| 01xx   | S     |
| 1xxx   | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

| immh   | <shift>              |
|--------|----------------------|
| 0001   | UInt(immh:immb) - 8  |
| 001x   | UInt(immh:immb) - 16 |
| 01xx   | UInt(immh:immb) - 32 |
| 1xxx   | UInt(immh:immb) - 64 |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>      |
|--------|-----|----------|
| 0001   |   0 | 8B       |
| 0001   |   1 | 16B      |
| 001x   |   0 | 4H       |
| 001x   |   1 | 8H       |
| 01xx   |   0 | 2S       |
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; boolean sat; for e = 0 to elements-1 constant bits(esize) opelt = Elem[operand, e, esize]; constant integer element = if src_unsigned then UInt(opelt) else SInt(opelt); (Elem[result, e, esize], sat) = SatQ(element << shift, esize, dst_unsigned); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.347 SQSHL (register)

Signed saturating shift left (register)

This instruction takes each element in the vector of the first source SIMD&amp;FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register.

If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are truncated. For rounded results, see SQRSHL.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQSHL <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if S == '0' && size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean unsigned = FALSE; constant boolean rounding = FALSE; constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean unsigned = FALSE; constant boolean rounding = FALSE; constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

|   size | <V>   |
|--------|-------|
|     00 | B     |
|     01 | H     |
|     10 | S     |
|     11 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |

&lt;Vn&gt;

|   size |   Q | <T>      |
|--------|-----|----------|
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; boolean sat; for e = 0 to elements-1 integer element = SInt(Elem[operand1, e, esize]); integer shift = ShiftSat(SInt(Elem[operand2, e, esize]<7:0>), esize); if shift >= 0 then // left shift element = element << shift; else // right shift shift = -shift; element = RShr(element, shift, rounding); (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.348 SQSHLU

Signed saturating shift left unsigned (immediate)

This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, shifts each value by an immediate value, saturates the shifted result to an unsigned integer value, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register. The results are truncated. For rounded results, see UQRSHL.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQSHLU <V><d>, <V><n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh == '0000' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = esize; constant integer elements = 1; constant integer shift = UInt(immh:immb) esize; constant boolean src_unsigned = FALSE; constant boolean dst_unsigned = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQSHLU <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = UInt(immh:immb) esize; constant boolean src_unsigned = FALSE; constant boolean dst_unsigned = TRUE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'immh':

&lt;d&gt;

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the left shift amount, in the range 0 to the operand width in bits minus 1, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | UInt(immh:immb) - 8  |
| 001x   | UInt(immh:immb) - 16 |
| 01xx   | UInt(immh:immb) - 32 |
| 1xxx   | UInt(immh:immb) - 64 |

For the 'Vector' variant: is the left shift amount, in the range 0 to the element width in bits minus 1, encoded in 'immh:immb':

| immh   | <V>   |
|--------|-------|
| 0001   | B     |
| 001x   | H     |
| 01xx   | S     |
| 1xxx   | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

| immh   | <shift>              |
|--------|----------------------|
| 0001   | UInt(immh:immb) - 8  |
| 001x   | UInt(immh:immb) - 16 |
| 01xx   | UInt(immh:immb) - 32 |
| 1xxx   | UInt(immh:immb) - 64 |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>      |
|--------|-----|----------|
| 0001   |   0 | 8B       |
| 0001   |   1 | 16B      |
| 001x   |   0 | 4H       |
| 001x   |   1 | 8H       |
| 01xx   |   0 | 2S       |
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; boolean sat; for e = 0 to elements-1 constant bits(esize) opelt = Elem[operand, e, esize]; constant integer element = if src_unsigned then UInt(opelt) else SInt(opelt); (Elem[result, e, esize], sat) = SatQ(element << shift, esize, dst_unsigned); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.349 SQSHRN, SQSHRN2

Signed saturating shift right narrow (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, right shifts and truncates each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. For rounded results, see SQRSHRN.

The SQSHRN instruction writes the vector to the lower half of the destination register and clears the upper half. The SQSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQSHRN <Vb><d>, <Va><n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh == '0000' then EndOfDecode(Decode_UNDEF); if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = esize; constant integer elements = 1; constant integer part = 0; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = FALSE; constant boolean unsigned = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = FALSE; constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;Vb&gt;

Is the destination width specifier, encoded in 'immh':

| immh   | <Vb>     |
|--------|----------|
| 0001   | B        |
| 001x   | H        |
| 01xx   | S        |
| 1xxx   | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'immh':

&lt;d&gt;

&lt;Va&gt;

&lt;n&gt;

| immh   | <Va>     |
|--------|----------|
| 0001   | H        |
| 001x   | S        |
| 01xx   | D        |
| 1xxx   | RESERVED |

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to the destination operand width in bits, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

For the 'Vector' variant: is the right shift amount, in the range 1 to the destination element width in bits, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

- 2 Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the

registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <Tb>   |
|--------|-----|--------|
| 0001   |   0 | 8B     |
| 0001   |   1 | 16B    |
| 001x   |   0 | 4H     |

## &lt;Vd&gt;

## &lt;Tb&gt;

## &lt;Vn&gt;

&lt;Ta&gt;

Is an arrangement specifier, encoded in 'immh':

| immh   | <Ta>     |
|--------|----------|
| 0001   | 8H       |
| 001x   | 4S       |
| 01xx   | 2D       |
| 1xxx   | RESERVED |

```
esize);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize*2) operand = V[n, datasize*2]; bits(datasize) result; boolean sat; for e = 0 to elements-1 constant bits(2*esize) opelt = Elem[operand, e, 2*esize]; if unsigned then constant integer element = RShr(UInt(opelt), shift, round); (Elem[result, e, esize], sat) = UnsignedSatQ(element, else constant integer element = RShr(SInt(opelt), shift, round); (Elem[result, e, esize], sat) = SignedSatQ(element, esize); if sat then FPSR.QC = '1'; Vpart[d, part, datasize] = result;
```

| immh   | Q   | <Tb>     |
|--------|-----|----------|
| 001x   | 1   | 8H       |
| 01xx   | 0   | 2S       |
| 01xx   | 1   | 4S       |
| 1xxx   | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.350 SQSHRUN, SQSHRUN2

Signed saturating shift right unsigned narrow (immediate)

This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&amp;FP register. The results are truncated. For rounded results, see SQRSHRUN.

The SQSHRUN instruction writes the vector to the lower half of the destination register and clears the upper half. The SQSHRUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQSHRUN <Vb><d>, <Va><n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh == '0000' then EndOfDecode(Decode_UNDEF); if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = esize; constant integer elements = 1; constant integer part = 0; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQSHRUN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = FALSE;
```

## Assembler Symbols

&lt;Vb&gt;

Is the destination width specifier, encoded in 'immh':

| immh   | <Vb>     |
|--------|----------|
| 0001   | B        |
| 001x   | H        |
| 01xx   | S        |
| 1xxx   | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'immh':

&lt;d&gt;

&lt;Va&gt;

<!-- image -->

&lt;n&gt;

| immh   | <Va>     |
|--------|----------|
| 0001   | H        |
| 001x   | S        |
| 01xx   | D        |
| 1xxx   | RESERVED |

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to the destination operand width in bits, encoded in 'immh:immb':

2

## &lt;Vd&gt;

## &lt;Tb&gt;

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

For the 'Vector' variant: is the right shift amount, in the range 1 to the destination element width in bits, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <Tb>   |
|--------|-----|--------|
| 0001   |   0 | 8B     |
| 0001   |   1 | 16B    |
| 001x   |   0 | 4H     |
| 001x   |   1 | 8H     |
| 01xx   |   0 | 2S     |
| 01xx   |   1 | 4S     |

&lt;Vn&gt;

&lt;Ta&gt;

Is an arrangement specifier, encoded in 'immh':

| immh   | <Ta>     |
|--------|----------|
| 0001   | 8H       |
| 001x   | 4S       |
| 01xx   | 2D       |
| 1xxx   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize*2) operand = V[n, datasize*2]; bits(datasize) result; integer element; boolean sat; for e = 0 to elements-1 element = RShr(SInt(Elem[operand, e, 2*esize]), shift, round); (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize); if sat then FPSR.QC = '1'; Vpart[d, part, datasize] = result;
```

| immh   | Q   | <Tb>     |
|--------|-----|----------|
| 1xxx   | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.351 SQSUB

Signed saturating subtract

This instruction subtracts the element values of the second source SIMD&amp;FP register from the corresponding element values of the first source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQSUB <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean unsigned = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

|   size | <V>   |
|--------|-------|
|     00 | B     |
|     01 | H     |
|     10 | S     |
|     11 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |
|     10 |   1 | 4S    |

&lt;Vn&gt;

|   size |   Q | <T>      |
|--------|-----|----------|
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer diff; boolean sat; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); diff = element1 -element2; (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.352 SQXTN, SQXTN2

Signed saturating extract narrow

This instruction reads each vector element from the source SIMD&amp;FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQXTN instruction writes the vector to the lower half of the destination register and clears the upper half. The SQXTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQXTN <Vb><d>, <Va><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer part = 0; constant integer elements = 1; constant boolean unsigned = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

SQXTN{2}

&lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = FALSE;
```

## Assembler Symbols

## &lt;Vb&gt;

Is the destination width specifier, encoded in 'size':

&lt;d&gt;

&lt;Va&gt;

&lt;n&gt;

2

|   size | <Vb>     |
|--------|----------|
|     00 | B        |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'size':

|   size | <Va>     |
|--------|----------|
|     00 | H        |
|     01 | S        |
|     10 | D        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

&lt;Vd&gt;

&lt;Tb&gt;

## &lt;Vn&gt;

## &lt;Ta&gt;

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand = V[n, 2*datasize]; bits(datasize) result; bits(2*esize) element; boolean sat; for e = 0 to elements-1 element = Elem[operand, e, 2*esize]; (Elem[result, e, esize], sat) = if sat then FPSR.QC = '1'; Vpart[d, part, datasize] = result;
```

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

```
SatQ(SInt(element), esize, unsigned);
```

## C7.2.353 SQXTUN, SQXTUN2

Signed saturating extract unsigned narrow

This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQXTUN instruction writes the vector to the lower half of the destination register and clears the upper half. The SQXTUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SQXTUN <Vb><d>, <Va><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer part = 0; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

SQXTUN{2}

&lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vb&gt;

Is the destination width specifier, encoded in 'size':

&lt;d&gt;

&lt;Va&gt;

&lt;n&gt;

2

|   size | <Vb>     |
|--------|----------|
|     00 | B        |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'size':

|   size | <Va>     |
|--------|----------|
|     00 | H        |
|     01 | S        |
|     10 | D        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

&lt;Vd&gt;

&lt;Tb&gt;

## &lt;Vn&gt;

## &lt;Ta&gt;

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand = V[n, 2*datasize]; bits(datasize) result; bits(2*esize) element; boolean sat; for e = 0 to elements-1 element = Elem[operand, e, 2*esize]; (Elem[result, e, esize], sat) = if sat then FPSR.QC = '1'; Vpart[d, part, datasize] = result;
```

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

```
UnsignedSatQ(SInt(element), esize);
```

## C7.2.354 SRHADD

Signed rounding halving add

This instruction adds corresponding signed integer values from the two source SIMD&amp;FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

The results are rounded. For truncated results, see SHADD.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SRHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); sum = (element1 + element2 + 1) >> 1; Elem[result, e, esize] = sum<esize-1:0>; V[d, datasize] = result;
```

## C7.2.355 SRI

Shift right and insert (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each vector element by an immediate value, and inserts the result into the corresponding vector element in the destination SIMD&amp;FP register such that the new zero bits created by the shift are not inserted but retain their existing value. Bits shifted out of the right of each vector element of the source register are lost.

Figure C7-4 shift right by 3 for an 8-bit vector element

<!-- image -->

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SRI D<d>, D<n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh<3> != '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << 3; constant integer datasize = esize; constant integer elements = 1; constant integer shift = (esize * 2) -UInt(immh:immb);
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SRI <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (esize * 2) -UInt(immh:immb);
```

## Assembler Symbols

## &lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

<!-- image -->

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to 64, encoded as 128 - UInt('immh:immb') .

For the 'Vector' variant: is the right shift amount, in the range 1 to the element width in bits, encoded in 'immh:immb':

| immh   | <shift>               |
|--------|-----------------------|
| 0001   | 16 - UInt(immh:immb)  |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>      |
|--------|-----|----------|
| 0001   |   0 | 8B       |
| 0001   |   1 | 16B      |
| 001x   |   0 | 4H       |
| 001x   |   1 | 8H       |
| 01xx   |   0 | 2S       |
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant bits(datasize) operand2 = V[d, datasize]; constant bits(esize) mask = LSR(Ones(esize), shift); bits(datasize) result; bits(esize) shifted; for e = 0 to elements-1 shifted = LSR(Elem[operand, e, esize], shift); Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.356 SRSHL

Signed rounding shift left (register)

This instruction takes each signed integer value in the vector of the first source SIMD&amp;FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register.

If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift. For a truncating shift, see SSHL.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SRSHL D<d>, D<n>, D<m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if S == '0' && size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean rounding = TRUE; constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SRSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean rounding = TRUE; constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

## Operation

```
ShiftSat(SInt(Elem[operand2, e, esize]<7:0>), esize);
```

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; for e = 0 to elements-1 integer element = SInt(Elem[operand1, e, esize]); integer shift = if shift >= 0 then // left shift element = element << shift; else // right shift shift = -shift; element = RShr(element, shift, rounding); Elem[result, e, esize] = element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.357 SRSHR

Signed rounding shift right (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, places the final result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The results are rounded. For truncated results, see SSHR.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SRSHR D<d>, D<n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> != '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << 3; constant integer datasize = esize; constant integer elements = 1; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = FALSE; constant boolean round = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SRSHR <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = FALSE; constant boolean round = TRUE;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to 64, encoded as 128 - UInt('immh:immb') .

For the 'Vector' variant: is the right shift amount, in the range 1 to the element width in bits, encoded in 'immh:immb':

| immh   | <shift>               |
|--------|-----------------------|
| 0001   | 16 - UInt(immh:immb)  |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>   |
|--------|-----|-------|
| 0001   |   0 | 8B    |
| 0001   |   1 | 16B   |
| 001x   |   0 | 4H    |
| 001x   |   1 | 8H    |
| 01xx   |   0 | 2S    |

## &lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

| immh   |   Q | <T>      |
|--------|-----|----------|
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 constant bits(esize) opelt = Elem[operand, e, esize]; if unsigned then element = RShr(UInt(opelt), shift, round); else element = RShr(SInt(opelt), shift, round); Elem[result, e, esize] = element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.358 SRSRA

Signed rounding shift right and accumulate (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The results are rounded. For truncated results, see SSRA.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SRSRA D<d>, D<n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> != '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << 3; constant integer datasize = esize; constant integer elements = 1; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = FALSE; constant boolean round = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SRSRA <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = FALSE; constant boolean round = TRUE;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to 64, encoded as 128 - UInt('immh:immb') .

For the 'Vector' variant: is the right shift amount, in the range 1 to the element width in bits, encoded in 'immh:immb':

| immh   | <shift>               |
|--------|-----------------------|
| 0001   | 16 - UInt(immh:immb)  |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>   |
|--------|-----|-------|
| 0001   |   0 | 8B    |
| 0001   |   1 | 16B   |
| 001x   |   0 | 4H    |
| 001x   |   1 | 8H    |
| 01xx   |   0 | 2S    |

## &lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

| immh   |   Q | <T>      |
|--------|-----|----------|
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant bits(datasize) operand2 = V[d, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 constant bits(esize) opelt = Elem[operand, e, esize]; if unsigned then element = RShr(UInt(opelt), shift, round); else element = RShr(SInt(opelt), shift, round); Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.359 SSHL

Signed shift left (register)

This instruction takes each signed integer value in the vector of the first source SIMD&amp;FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register.

If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift. For a rounding shift, see SRSHL.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SSHL D<d>, D<n>, D<m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if S == '0' && size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean rounding = FALSE; constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean rounding = FALSE; constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

## Operation

```
ShiftSat(SInt(Elem[operand2, e, esize]<7:0>), esize);
```

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; for e = 0 to elements-1 integer element = SInt(Elem[operand1, e, esize]); integer shift = if shift >= 0 then // left shift element = element << shift; else // right shift shift = -shift; element = RShr(element, shift, rounding); Elem[result, e, esize] = element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.360 SSHLL, SSHLL2

Signed shift left long (immediate)

This instruction reads each vector element from the source SIMD&amp;FP register, left shifts each vector element by the specified shift amount, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.

The SSHLL instruction extracts vector elements from the lower half of the source register. The SSHLL2 instruction extracts vector elements from the upper half of the source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This instruction is used by the alias SXTL, SXTL2.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SSHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = UInt(immh:immb) esize; constant boolean unsigned = FALSE;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh':

## Alias Conditions

| immh   | <Ta>     |
|--------|----------|
| 0001   | 8H       |
| 001x   | 4S       |
| 01xx   | 2D       |
| 1xxx   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   | Q   | <Tb>     |
|--------|-----|----------|
| 0001   | 0   | 8B       |
| 0001   | 1   | 16B      |
| 001x   | 0   | 4H       |
| 001x   | 1   | 8H       |
| 01xx   | 0   | 2S       |
| 01xx   | 1   | 4S       |
| 1xxx   | x   | RESERVED |

## &lt;shift&gt;

Is the left shift amount, in the range 0 to the source element width in bits minus 1, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | UInt(immh:immb) - 8  |
| 001x   | UInt(immh:immb) - 16 |
| 01xx   | UInt(immh:immb) - 32 |
| 1xxx   | RESERVED             |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = Vpart[n, part, datasize]; bits(datasize*2) result; for e = 0 to elements-1 constant bits(esize) opelt = Elem[operand, e, esize]; constant integer element = if unsigned then UInt(opelt) else SInt(opelt); Elem[result, e, 2*esize] = (element << shift)<2*esize-1:0>; V[d, datasize*2] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias       | Is preferred when                    |
|-------------|--------------------------------------|
| SXTL, SXTL2 | immb == '000' && BitCount(immh) == 1 |

## C7.2.361 SSHR

Signed shift right (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, places the final result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The results are truncated. For rounded results, see SRSHR.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SSHR D<d>, D<n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> != '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << 3; constant integer datasize = esize; constant integer elements = 1; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = FALSE; constant boolean round = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SSHR <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = FALSE; constant boolean round = FALSE;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to 64, encoded as 128 - UInt('immh:immb') .

For the 'Vector' variant: is the right shift amount, in the range 1 to the element width in bits, encoded in 'immh:immb':

| immh   | <shift>               |
|--------|-----------------------|
| 0001   | 16 - UInt(immh:immb)  |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>   |
|--------|-----|-------|
| 0001   |   0 | 8B    |
| 0001   |   1 | 16B   |
| 001x   |   0 | 4H    |
| 001x   |   1 | 8H    |
| 01xx   |   0 | 2S    |

## &lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

| immh   |   Q | <T>      |
|--------|-----|----------|
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 constant bits(esize) opelt = Elem[operand, e, esize]; if unsigned then element = RShr(UInt(opelt), shift, round); else element = RShr(SInt(opelt), shift, round); Elem[result, e, esize] = element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.362 SSRA

Signed shift right and accumulate (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The results are truncated. For rounded results, see SRSRA.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SSRA D<d>, D<n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> != '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << 3; constant integer datasize = esize; constant integer elements = 1; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = FALSE; constant boolean round = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SSRA <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = FALSE; constant boolean round = FALSE;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to 64, encoded as 128 - UInt('immh:immb') .

For the 'Vector' variant: is the right shift amount, in the range 1 to the element width in bits, encoded in 'immh:immb':

| immh   | <shift>               |
|--------|-----------------------|
| 0001   | 16 - UInt(immh:immb)  |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>   |
|--------|-----|-------|
| 0001   |   0 | 8B    |
| 0001   |   1 | 16B   |
| 001x   |   0 | 4H    |
| 001x   |   1 | 8H    |
| 01xx   |   0 | 2S    |

## &lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

| immh   |   Q | <T>      |
|--------|-----|----------|
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant bits(datasize) operand2 = V[d, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 constant bits(esize) opelt = Elem[operand, e, esize]; if unsigned then element = RShr(UInt(opelt), shift, round); else element = RShr(SInt(opelt), shift, round); Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.363 SSUBL, SSUBL2

Signed subtract long

This instruction subtracts each vector element in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector element of the first source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements.

The SSUBL instruction extracts each source vector from the lower half of each source register. The SSUBL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SSUBL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

<!-- image -->

&lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(datasize) operand2 = Vpart[m, part, datasize]; bits(2*datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, esize]); element2 = SInt(Elem[operand2, e, esize]); sum = element1 - element2; Elem[result, e, 2*esize] = sum<2*esize-1:0>; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.364 SSUBW, SSUBW2

Signed subtract wide

This instruction subtracts each vector element in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector element in the first source SIMD&amp;FP register, places the result in a vector, and writes the vector to the SIMD&amp;FP destination register. All the values in this instruction are signed integer values.

The SSUBW instruction extracts the second source vector from the lower half of the second source register. The SSUBW2 instruction extracts the second source vector from the upper half of the second source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SSUBW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

## &lt;Ta&gt;

## &lt;Vn&gt;

Is an arrangement specifier, encoded in 'size':

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand1 = V[n, 2*datasize]; constant bits(datasize) operand2 = bits(2*datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = SInt(Elem[operand1, e, 2*esize]); element2 = SInt(Elem[operand2, e, esize]); sum = element1 - element2; Elem[result, e, 2*esize] = sum<2*esize-1:0>; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Tb&gt;

```
Vpart[m, part, datasize];
```

## C7.2.365 ST1 (multiple structures)

Store multiple single-element structures from one, two, three, or four registers

This instruction stores elements to memory from one, two, three, or four SIMD&amp;FP registers, without interleaving. Every element of each register is stored.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the One register variant

Applies when (opcode == 0111)

```
ST1 { <Vt>.<T> }, [<Xn|SP>]
```

## Encoding for the Two registers variant

```
Applies when (opcode == 1010) ST1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]
```

## Encoding for the Three registers variant

Applies when

```
(opcode == 0110) ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]
```

## Encoding for the Four registers variant

Applies when

```
(opcode == 0010)
```

```
ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the One register, immediate offset variant

Applies when (Rm == 11111 &amp;&amp; opcode == 0111)

```
ST1 { <Vt>.<T> }, [<Xn|SP>],
```

```
<imm>
```

## Encoding for the One register, register offset variant

```
Applies when (Rm != 11111 && opcode == 0111)
```

```
ST1 { <Vt>.<T> }, [<Xn|SP>], <Xm>
```

## Encoding for the Two registers, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 1010)
```

```
ST1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>
```

## Encoding for the Two registers, register offset variant

Applies when (Rm != 11111 &amp;&amp;

```
opcode == 1010) ST1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>
```

## Encoding for the Three registers, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 0110) ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>],
```

```
<imm>
```

## Encoding for the Three registers, register offset variant

Applies when (Rm != 11111 &amp;&amp;

```
ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>],
```

```
opcode == 0110) <Xm>
```

## Encoding for the Four registers, immediate offset variant

Applies when (Rm == 11111 &amp;&amp;

```
ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>],
```

```
opcode == 0010) <imm>
```

## Encoding for the Four registers, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 0010)

```
ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

## &lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |
|     10 |   1 | 4S    |
|     11 |   0 | 1D    |
|     11 |   1 | 2D    |

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Vt3&gt;

Is the name of the third SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 2 modulo 32.

## &lt;Vt4&gt;

Is the name of the fourth SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 3 modulo 32.

## &lt;imm&gt;

For the 'One register, immediate offset' variant: is the post-index immediate offset, encoded in 'Q':

|   Q | <imm>   |
|-----|---------|
|   0 | #8      |

&lt;T&gt;

<!-- image -->

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(size); constant integer elements = datasize DIV esize; integer rpt; // number of iterations constant integer selem = 1; // structure elements case opcode of when '0010' rpt = 4; // LD/ST1 (4 registers) when '0110' rpt = 3; // LD/ST1 (3 registers) when '1010' rpt = 2; // LD/ST1 (2 registers) when '0111' rpt = 1; // LD/ST1 (1 register) otherwise EndOfDecode(Decode_UNDEF); end
```

|   Q | <imm>   |
|-----|---------|
|   1 | #16     |

For the 'Two registers, immediate offset' variant: is the post-index immediate offset, encoded in 'Q':

|   Q | <imm>   |
|-----|---------|
|   0 | #16     |
|   1 | #32     |

For the 'Three registers, immediate offset' variant: is the post-index immediate offset, encoded in 'Q':

|   Q | <imm>   |
|-----|---------|
|   0 | #24     |
|   1 | #48     |

For the 'Four registers, immediate offset' variant: is the post-index immediate offset, encoded in 'Q':

|   Q | <imm>   |
|-----|---------|
|   0 | #32     |
|   1 | #64     |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(datasize) rval; integer tt; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); for r = 0 to rpt-1 for e = 0 to elements-1 tt = (t + r) MOD 32; for s = 0 to selem-1 rval = V[tt, datasize]; eaddr = AddressIncrement(address, offs, accdesc); Mem[eaddr, ebytes, accdesc] = Elem[rval, e, esize]; offs = offs + ebytes; tt = (tt + 1) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.366 ST1 (single structure)

Store a single-element structure from one lane of one register

This instruction stores the specified element of a SIMD&amp;FP register to memory.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit variant

```
Applies when (opcode == 000) ST1 { <Vt>.B }[<index>], [<Xn|SP>]
```

## Encoding for the 16-bit variant

```
Applies when
```

```
(opcode == 010 && size == x0) ST1 { <Vt>.H }[<index>], [<Xn|SP>]
```

## Encoding for the 32-bit variant

```
Applies when (opcode == 100 && size == 00) ST1 { <Vt>.S }[<index>], [<Xn|SP>]
```

## Encoding for the 64-bit variant

```
Applies when (opcode == 100 && S == 0 && size == 01) ST1 { <Vt>.D }[<index>], [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit, immediate offset variant

```
Applies when (Rm == 11111 &&
```

```
ST1 { <Vt>.B
```

```
opcode == 000) }[<index>], [<Xn|SP>], #1
```

## Encoding for the 8-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 000) ST1 { <Vt>.B }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 16-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 010 && size == x0)
```

```
ST1 { <Vt>.H }[<index>], [<Xn|SP>], #2
```

## Encoding for the 16-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 010 &amp;&amp; size ==

```
ST1 { <Vt>.H }[<index>], [<Xn|SP>],
```

```
x0) <Xm>
```

## Encoding for the 32-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 100 && size == 00) ST1 { <Vt>.S }[<index>], [<Xn|SP>], #4
```

## Encoding for the 32-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 100 && size == 00)
```

```
ST1 { <Vt>.S }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 64-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 100 && S == 0 && size == 01)
```

```
ST1 { <Vt>.D }[<index>], [<Xn|SP>], #8
```

## Encoding for the 64-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 100 && S == 0 && size == 01)
```

```
ST1 { <Vt>.D }[<index>], [<Xn|SP>], <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

## &lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;index&gt;

For the '8-bit', '8-bit, immediate offset', and '8-bit, register offset' variants: is the element index, encoded in 'Q:S:size'.

For the '16-bit', '16-bit, immediate offset', and '16-bit, register offset' variants: is the element index, encoded in 'Q:S:size&lt;1&gt;'.

For the '32-bit', '32-bit, immediate offset', and '32-bit, register offset' variants: is the element index, encoded in 'Q:S'.

For the '64-bit', '64-bit, immediate offset', and '64-bit, register offset' variants: is the element index, encoded in 'Q'.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then EndOfDecode(Decode_UNDEF); end scale = size; replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then EndOfDecode(Decode_UNDEF); end if size<0> == '0' then index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1] scale = '11'; end end
```

```
constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize); offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register for s = 0 to selem-1 rval = V[t, 128]; eaddr = AddressIncrement(address, offs, accdesc); // extract from one lane of 128-bit register Mem[eaddr, ebytes, accdesc] = Elem[rval, index, esize]; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.367 ST2 (multiple structures)

Store multiple 2-element structures from two registers

This instruction stores multiple 2-element structures from two SIMD&amp;FP registers to memory, with interleaving. Every element of each register is stored.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ST2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the Immediate offset variant

```
Applies when (Rm == 11111) ST2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>
```

## Encoding for the Register offset variant

```
Applies when (Rm != 11111) ST2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

&lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the post-index immediate offset, encoded in 'Q':

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

&lt;T&gt;

|   Q | <imm>   |
|-----|---------|
|   0 | #16     |
|   1 | #32     |

## Shared Decode

```
constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(size); constant integer elements = datasize DIV esize; constant integer rpt = 1; constant integer selem = 2; // .1D format only permitted with LD1 & ST1 if size:Q == '110' && selem != 1 then
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(datasize) rval; integer tt; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); for r = 0 to rpt-1 for e = 0 to elements-1 tt = (t + r) MOD 32; for s = 0 to selem-1 rval = V[tt, datasize]; eaddr = AddressIncrement(address, offs, accdesc); Mem[eaddr, ebytes, accdesc] = Elem[rval, e, esize]; offs = offs + ebytes; tt = (tt + 1) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF); end
```

## C7.2.368 ST2 (single structure)

Store single 2-element structure from one lane of two registers

This instruction stores a 2-element structure to memory from corresponding elements of two SIMD&amp;FP registers.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit variant

```
Applies when (opcode == 000) ST2 { <Vt>.B,
```

```
<Vt2>.B }[<index>], [<Xn|SP>]
```

## Encoding for the 16-bit variant

Applies when

```
(opcode == 010 && size == x0) ST2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]
```

## Encoding for the 32-bit variant

```
Applies when (opcode == 100 && size == 00) ST2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]
```

## Encoding for the 64-bit variant

```
Applies when (opcode == 100 && S == 0 && size == 01) ST2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp;

```
ST2 { <Vt>.B,
```

```
opcode == 000) <Vt2>.B }[<index>], [<Xn|SP>], #2
```

## Encoding for the 8-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 000)
```

```
ST2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 16-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 010 && size ==
```

```
ST2 { <Vt>.H,
```

```
x0) <Vt2>.H }[<index>], [<Xn|SP>], #4
```

## Encoding for the 16-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 010 &amp;&amp; size ==

```
ST2 { <Vt>.H,
```

```
x0) <Vt2>.H }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 32-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 100 && size == 00) ST2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8
```

## Encoding for the 32-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 100 && size ==
```

```
ST2 { <Vt>.S,
```

```
00) <Vt2>.S }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 64-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp; opcode == 100 &amp;&amp; S == 0 &amp;&amp; size == 01)

```
ST2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16
```

## Encoding for the 64-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 100 && S == 0 && size == 01)
```

```
ST2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

## &lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;index&gt;

For the '8-bit', '8-bit, immediate offset', and '8-bit, register offset' variants: is the element index, encoded in 'Q:S:size'.

For the '16-bit', '16-bit, immediate offset', and '16-bit, register offset' variants: is the element index, encoded in 'Q:S:size&lt;1&gt;'.

For the '32-bit', '32-bit, immediate offset', and '32-bit, register offset' variants: is the element index, encoded in 'Q:S'.

For the '64-bit', '64-bit, immediate offset', and '64-bit, register offset' variants: is the element index, encoded in 'Q'.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then EndOfDecode(Decode_UNDEF); end scale = size; replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then EndOfDecode(Decode_UNDEF); end if size<0> == '0' then index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1]
```

```
scale = '11'; end end constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize); offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register for s = 0 to selem-1 rval = V[t, 128]; eaddr = AddressIncrement(address, offs, accdesc); // extract from one lane of 128-bit register Mem[eaddr, ebytes, accdesc] = Elem[rval, index, esize]; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.369 ST3 (multiple structures)

Store multiple 3-element structures from three registers

This instruction stores multiple 3-element structures to memory from three SIMD&amp;FP registers, with interleaving. Every element of each register is stored.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ST3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the Immediate offset variant

Applies when (Rm ==

```
ST3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>],
```

```
11111) <imm>
```

## Encoding for the Register offset variant

```
Applies when (Rm != 11111) ST3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

&lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Vt3&gt;

Is the name of the third SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 2 modulo 32.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the post-index immediate offset, encoded in 'Q':

&lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

&lt;T&gt;

|   Q | <imm>   |
|-----|---------|
|   0 | #24     |
|   1 | #48     |

## Shared Decode

```
constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(size); constant integer elements = datasize DIV esize; constant integer rpt = 1; constant integer selem = 3; // .1D format only permitted with LD1 & ST1 if size:Q == '110' && selem != 1 then
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(datasize) rval; integer tt; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); for r = 0 to rpt-1 for e = 0 to elements-1 tt = (t + r) MOD 32; for s = 0 to selem-1 rval = V[tt, datasize]; eaddr = AddressIncrement(address, offs, accdesc); Mem[eaddr, ebytes, accdesc] = Elem[rval, e, esize]; offs = offs + ebytes; tt = (tt + 1) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF); end
```

## C7.2.370 ST3 (single structure)

Store single 3-element structure from one lane of three registers

This instruction stores a 3-element structure to memory from corresponding elements of three SIMD&amp;FP registers.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit variant

```
Applies when (opcode == 001) ST3 { <Vt>.B, <Vt2>.B, <Vt3>.B
```

## Encoding for the 16-bit variant

Applies when

```
(opcode == 011 && size == x0) ST3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]
```

## Encoding for the 32-bit variant

```
Applies when (opcode == 101 && size == 00) ST3 { <Vt>.S, <Vt2>.S, <Vt3>.S
```

```
}[<index>], [<Xn|SP>]
```

## Encoding for the 64-bit variant

```
Applies when (opcode == 101 && S == 0 && size == 01) ST3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

```
}[<index>], [<Xn|SP>]
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp;

```
opcode == 001)
```

```
ST3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3
```

## Encoding for the 8-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 001)
```

```
ST3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 16-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 011 && size ==
```

```
ST3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6
```

## Encoding for the 16-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 011 &amp;&amp; size ==

```
ST3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 32-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 101 && size == 00) ST3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12
```

## Encoding for the 32-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 101 &amp;&amp; size == 00)

```
ST3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 64-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp; opcode == 101 &amp;&amp; S == 0 &amp;&amp; size == 01)

```
ST3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24
```

## Encoding for the 64-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 101 && S == 0 && size == 01)
```

```
ST3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>
```

```
x0)
```

```
x0)
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

&lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Vt3&gt;

Is the name of the third SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 2 modulo 32.

## &lt;index&gt;

For the '8-bit', '8-bit, immediate offset', and '8-bit, register offset' variants: is the element index, encoded in 'Q:S:size'.

For the '16-bit', '16-bit, immediate offset', and '16-bit, register offset' variants: is the element index, encoded in 'Q:S:size&lt;1&gt;'.

For the '32-bit', '32-bit, immediate offset', and '32-bit, register offset' variants: is the element index, encoded in 'Q:S'.

For the '64-bit', '64-bit, immediate offset', and '64-bit, register offset' variants: is the element index, encoded in 'Q'.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then EndOfDecode(Decode_UNDEF); end scale = size; replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then EndOfDecode(Decode_UNDEF); end if size<0> == '0' then
```

```
index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1] scale = '11'; end end constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize); offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register for s = 0 to selem-1 rval = V[t, 128]; eaddr = AddressIncrement(address, offs, accdesc); // extract from one lane of 128-bit register Mem[eaddr, ebytes, accdesc] = Elem[rval, index, esize]; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.371 ST4 (multiple structures)

Store multiple 4-element structures from four registers

This instruction stores multiple 4-element structures to memory from four SIMD&amp;FP registers, with interleaving. Every element of each register is stored.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ST4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the Immediate offset variant

Applies when (Rm == 11111)

```
ST4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>],
```

## Encoding for the Register offset variant

```
Applies when (Rm != 11111) ST4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>
```

```
<imm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

## &lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Vt3&gt;

Is the name of the third SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 2 modulo 32.

## &lt;Vt4&gt;

Is the name of the fourth SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 3 modulo 32.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the post-index immediate offset, encoded in 'Q':

&lt;T&gt;

|   Q | <imm>   |
|-----|---------|
|   0 | #32     |

<!-- image -->

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(size); constant integer elements = datasize DIV esize; constant integer rpt = 1; constant integer selem = 4; // .1D format only permitted with LD1 & ST1 if size:Q == '110' && selem != 1 then EndOfDecode(Decode_UNDEF); end
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(datasize) rval; integer tt; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); for r = 0 to rpt-1 for e = 0 to elements-1 tt = (t + r) MOD 32; for s = 0 to selem-1 rval = V[tt, datasize]; eaddr = AddressIncrement(address, offs, accdesc); Mem[eaddr, ebytes, accdesc] = Elem[rval, e, esize]; offs = offs + ebytes; tt = (tt + 1) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   Q | <imm>   |
|-----|---------|
|   1 | #64     |

## C7.2.372 ST4 (single structure)

Store single 4-element structure from one lane of four registers

This instruction stores a 4-element structure to memory from corresponding elements of four SIMD&amp;FP registers.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: No offset and Post-index

## No offset

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit variant

```
Applies when (opcode == 001) ST4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]
```

## Encoding for the 16-bit variant

Applies when

```
(opcode == 011 && size == x0) ST4 { <Vt>.H, <Vt2>.H, <Vt3>.H,
```

```
<Vt4>.H }[<index>], [<Xn|SP>]
```

## Encoding for the 32-bit variant

```
Applies when (opcode == 101 && size == 00) ST4 { <Vt>.S, <Vt2>.S, <Vt3>.S,
```

```
<Vt4>.S }[<index>], [<Xn|SP>]
```

## Encoding for the 64-bit variant

```
Applies when (opcode == 101 && S == 0 && size == 01) ST4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Post-index

## (FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 8-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp;

```
opcode == 001)
```

```
ST4 { <Vt>.B, <Vt2>.B, <Vt3>.B,
```

```
<Vt4>.B }[<index>], [<Xn|SP>], #4
```

## Encoding for the 8-bit, register offset variant

```
Applies when (Rm != 11111 && opcode == 001)
```

```
ST4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 16-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp; opcode == 011 &amp;&amp; size ==

```
x0) ST4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8
```

## Encoding for the 16-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 011 &amp;&amp; size ==

```
x0) ST4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>],
```

```
<Xm>
```

## Encoding for the 32-bit, immediate offset variant

```
Applies when (Rm == 11111 && opcode == 101 && size == 00)
```

```
ST4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16
```

## Encoding for the 32-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 101 &amp;&amp; size == 00)

```
ST4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>
```

## Encoding for the 64-bit, immediate offset variant

Applies when (Rm == 11111 &amp;&amp; opcode == 101 &amp;&amp; S == 0 &amp;&amp; size == 01) ST4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #32

## Encoding for the 64-bit, register offset variant

Applies when (Rm != 11111 &amp;&amp; opcode == 101 &amp;&amp; S == 0 &amp;&amp; size == 01)

```
ST4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean wback = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

## &lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Vt2&gt;

Is the name of the second SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 1 modulo 32.

## &lt;Vt3&gt;

Is the name of the third SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 2 modulo 32.

## &lt;Vt4&gt;

Is the name of the fourth SIMD&amp;FP register to be transferred, encoded as 'Rt' plus 3 modulo 32.

## &lt;index&gt;

For the '8-bit', '8-bit, immediate offset', and '8-bit, register offset' variants: is the element index, encoded in 'Q:S:size'.

For the '16-bit', '16-bit, immediate offset', and '16-bit, register offset' variants: is the element index, encoded in 'Q:S:size&lt;1&gt;'.

For the '32-bit', '32-bit, immediate offset', and '32-bit, register offset' variants: is the element index, encoded in 'Q:S'.

For the '64-bit', '64-bit, immediate offset', and '64-bit, register offset' variants: is the element index, encoded in 'Q'.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the 'Rm' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then EndOfDecode(Decode_UNDEF); end scale = size; replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then EndOfDecode(Decode_UNDEF); end
```

```
index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then EndOfDecode(Decode_UNDEF); end if size<0> == '0' then index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1] scale = '11'; end end constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize); offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register for s = 0 to selem-1 rval = V[t, 128]; eaddr = AddressIncrement(address, offs, accdesc); // extract from one lane of 128-bit register Mem[eaddr, ebytes, accdesc] = Elem[rval, index, esize]; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.373 STBFADD, STBFADDL

Atomic BFloat16 floating-point add, without return

This instruction atomically loads a 16-bit value from memory, adds it to the BFloat16 value held in a register, and stores the result back to memory.

- STBFADDL stores to memory with release semantics.
- STBFADD has no release semantics.

This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

## (FEAT\_LSFE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STBFADD <Hs>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (R == 1) STBFADDL <Hs>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer n = UInt(Rn); constant integer datasize = 16; constant boolean acquire = FALSE; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_BFADD, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc);
```

## C7.2.374 STBFMAX, STBFMAXL

Atomic BFloat16 floating-point maximum, without return

This instruction atomically loads a 16-bit value from memory, computes the BFloat16 maximum with the value held in a register, and stores the result back to memory.

- STBFMAXL stores to memory with release semantics.
- STBFMAX has no release semantics.

This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

## (FEAT\_LSFE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STBFMAX <Hs>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (R == 1) STBFMAXL <Hs>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer n = UInt(Rn); constant integer datasize = 16; constant boolean acquire = FALSE; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_BFMAX, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc);
```

## C7.2.375 STBFMAXNM, STBFMAXNML

Atomic BFloat16 floating-point maximum number, without return

This instruction atomically loads a 16-bit value from memory, computes the BFloat16 maximum number with the value held in a register, and stores the result back to memory.

- STBFMAXNML stores to memory with release semantics.
- STBFMAXNM has no release semantics.

This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point (FEAT\_LSFE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when
```

```
(R == 0) STBFMAXNM <Hs>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (R == 1) STBFMAXNML
```

```
<Hs>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer n = UInt(Rn); constant integer datasize = 16; constant boolean acquire = FALSE; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_BFMAXNM, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc);
```

## C7.2.376 STBFMIN, STBFMINL

Atomic BFloat16 floating-point minimum, without return

This instruction atomically loads a 16-bit value from memory, computes the BFloat16 minimum with the value held in a register, and stores the result back to memory.

- STBFMINL stores to memory with release semantics.
- STBFMIN has no release semantics.

This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

## (FEAT\_LSFE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STBFMIN <Hs>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (R == 1) STBFMINL <Hs>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer n = UInt(Rn); constant integer datasize = 16; constant boolean acquire = FALSE; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_BFMIN, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc);
```

## C7.2.377 STBFMINNM, STBFMINNML

Atomic BFloat16 floating-point minimum number, without return

This instruction atomically loads a 16-bit value from memory, computes the BFloat16 minimum number with the value held in a register, and stores the result back to memory.

- STBFMINNML stores to memory with release semantics.
- STBFMINNM has no release semantics.

This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

## (FEAT\_LSFE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when
```

```
(R == 0) STBFMINNM <Hs>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (R == 1) STBFMINNML
```

```
<Hs>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer n = UInt(Rn); constant integer datasize = 16; constant boolean acquire = FALSE; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_BFMINNM, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc);
```

## C7.2.378 STFADD, STFADDL

Atomic floating-point add, without return

This instruction atomically loads a 16-bit, 32-bit, or 64-bit value from memory, performs a floating-point add with the value held in a register, and stores the result back to memory.

- STFADDL stores to memory with release semantics.
- STFADD has no release semantics.

This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the Half-precision no memory ordering variant

```
Applies when (size == 01 && R == 0) STFADD <Hs>, [<Xn|SP>]
```

## Encoding for the Half-precision release variant

```
Applies when (size == 01 && R == 1) STFADDL <Hs>, [<Xn|SP>]
```

## Encoding for the Single-precision no memory ordering variant

```
Applies when (size == 10 && R == 0) STFADD <Ss>, [<Xn|SP>]
```

## Encoding for the Single-precision release variant

```
Applies when (size == 10 && R == STFADDL <Ss>, [<Xn|SP>]
```

```
1)
```

## Encoding for the Double-precision no memory ordering variant

Applies when

STFADD

(size ==

&lt;Ds&gt;, [&lt;Xn|SP&gt;]

11

&amp;&amp;

R

==

0)

## Encoding for the Double-precision release variant

```
Applies when (size == 11 && R == 1)
```

```
STFADDL <Ds>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant boolean acquire = FALSE; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

## &lt;Ds&gt;

Is the 64-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_FPADD, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc);
```

Is the 32-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## C7.2.379 STFMAX, STFMAXL

Atomic floating-point maximum, without return

This instruction atomically loads a 16-bit, 32-bit, or 64-bit value from memory, computes the floating-point maximum with the value held in a register, and stores the result back to memory.

- STFMAXL stores to memory with release semantics.
- STFMAX has no release semantics.

This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the Half-precision no memory ordering variant

```
Applies when (size == 01 && R == 0) STFMAX <Hs>, [<Xn|SP>]
```

## Encoding for the Half-precision release variant

```
Applies when (size == 01 && R == 1) STFMAXL <Hs>, [<Xn|SP>]
```

## Encoding for the Single-precision no memory ordering variant

```
Applies when (size == 10 && R == 0) STFMAX <Ss>, [<Xn|SP>]
```

## Encoding for the Single-precision release variant

```
Applies when (size == 10 && R == STFMAXL <Ss>, [<Xn|SP>]
```

```
1)
```

## Encoding for the Double-precision no memory ordering variant

Applies when

STFMAX

(size ==

&lt;Ds&gt;, [&lt;Xn|SP&gt;]

11

&amp;&amp;

R

==

0)

## Encoding for the Double-precision release variant

Applies when (size == 11 &amp;&amp; R == 1)

```
STFMAXL <Ds>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant boolean acquire = FALSE; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

## &lt;Ds&gt;

Is the 64-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_FPMAX, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc);
```

Is the 32-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## C7.2.380 STFMAXNM, STFMAXNML

Atomic floating-point maximum number, without return

This instruction atomically loads a 16-bit, 32-bit, or 64-bit value from memory, computes the floating-point maximum number with the value held in a register, and stores the result back to memory.

- STFMAXNML stores to memory with release semantics.
- STFMAXNM has no release semantics.

This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the Half-precision no memory ordering variant

Applies when

STFMAXNM

(size ==

01

&amp;&amp;

R

==

0)

&lt;Hs&gt;, [&lt;Xn|SP&gt;]

## Encoding for the Half-precision release variant

```
Applies when (size == 01 && R == 1) STFMAXNML <Hs>, [<Xn|SP>]
```

## Encoding for the Single-precision no memory ordering variant

```
Applies when (size == 10 && R == STFMAXNM <Ss>, [<Xn|SP>]
```

```
0)
```

## Encoding for the Single-precision release variant

```
Applies when (size == 10 && R == 1) STFMAXNML <Ss>, [<Xn|SP>]
```

## Encoding for the Double-precision no memory ordering variant

```
Applies when (size == 11 && R == 0) STFMAXNM <Ds>, [<Xn|SP>]
```

## Encoding for the Double-precision release variant

Applies when (size == 11 &amp;&amp; R == 1)

```
STFMAXNML <Ds>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant boolean acquire = FALSE; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

## &lt;Ds&gt;

Is the 64-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_FPMAXNM, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc);
```

Is the 32-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## C7.2.381 STFMIN, STFMINL

Atomic floating-point minimum, without return

This instruction atomically loads a 16-bit, 32-bit, or 64-bit value from memory, computes the floating-point minimum with the value held in a register, and stores the result back to memory.

- STFMINL stores to memory with release semantics.
- STFMIN has no release semantics.

This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the Half-precision no memory ordering variant

```
Applies when (size == 01 && R == 0) STFMIN <Hs>, [<Xn|SP>]
```

## Encoding for the Half-precision release variant

```
Applies when (size == 01 && R == 1) STFMINL <Hs>, [<Xn|SP>]
```

## Encoding for the Single-precision no memory ordering variant

```
Applies when (size == 10 && R == 0) STFMIN <Ss>, [<Xn|SP>]
```

## Encoding for the Single-precision release variant

```
Applies when (size == 10 && R == STFMINL <Ss>, [<Xn|SP>]
```

```
1)
```

## Encoding for the Double-precision no memory ordering variant

Applies when

STFMIN

(size ==

&lt;Ds&gt;, [&lt;Xn|SP&gt;]

11

&amp;&amp;

R

==

0)

## Encoding for the Double-precision release variant

Applies when (size == 11 &amp;&amp; R == 1)

```
STFMINL <Ds>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant boolean acquire = FALSE; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

## &lt;Ds&gt;

Is the 64-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_FPMIN, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc);
```

Is the 32-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## C7.2.382 STFMINNM, STFMINNML

Atomic floating-point minimum number, without return

This instruction atomically loads a 16-bit, 32-bit, or 64-bit value from memory, computes the floating-point minimum number with the value held in a register, and stores the result back to memory.

- STFMINNML stores to memory with release semantics.
- STFMINNM has no release semantics.

This instruction:

- Disables alternative floating-point behaviors, as if FPCR.AH is 0.
- Generates only the default NaN, as if FPCR.DN is 1.
- Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
- Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Floating-point

(FEAT\_LSFE)

<!-- image -->

## Encoding for the Half-precision no memory ordering variant

Applies when

STFMINNM

(size ==

01

&amp;&amp;

R

==

0)

&lt;Hs&gt;, [&lt;Xn|SP&gt;]

## Encoding for the Half-precision release variant

```
Applies when (size == 01 && R == 1) STFMINNML <Hs>, [<Xn|SP>]
```

## Encoding for the Single-precision no memory ordering variant

```
Applies when (size == 10 && R == STFMINNM <Ss>, [<Xn|SP>]
```

```
0)
```

## Encoding for the Single-precision release variant

```
Applies when (size == 10 && R == 1) STFMINNML <Ss>, [<Xn|SP>]
```

## Encoding for the Double-precision no memory ordering variant

```
Applies when (size == 11 && R == 0) STFMINNM <Ds>, [<Xn|SP>]
```

## Encoding for the Double-precision release variant

Applies when (size == 11 &amp;&amp; R == 1)

```
STFMINNML <Ds>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSFE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant boolean acquire = FALSE; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Hs&gt;

Is the 16-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

## &lt;Ds&gt;

Is the 64-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; bits(datasize) value; bits(datasize) data; constant AccessDescriptor accdesc = CreateAccDescFPAtomicOp(MemAtomicOp_FPMINNM, acquire, release, tagchecked); value = V[s, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, value, accdesc);
```

Is the 32-bit name of the SIMD&amp;FP register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## C7.2.383 STL1 (SIMD&amp;FP)

Store-release a single-element structure from one lane of one register

This instruction stores the specified element of a SIMD&amp;FP register to memory.

The instruction also has memory ordering semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release. For information about addressing modes, see Load/Store addressing modes.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## 64-bit

(FEAT\_AdvSIMD &amp;&amp; FEAT\_LRCPC3)

<!-- image -->

## Encoding

```
STL1 { <Vt>.D }[<index>], [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_LRCPC3) then EndOfDecode(Decode_UNDEF); integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = integer UNKNOWN; constant boolean wback = FALSE; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Assembler Symbols

## &lt;Vt&gt;

Is the name of the first or only SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;index&gt;

Is the element index, encoded in 'Q'.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Shared Decode

```
bits(2) scale = opcode<2:1>; constant integer selem = UInt(opcode<0>:R) + 1; boolean replicate = FALSE; integer index; case scale of when '11' // load and replicate if L == '0' || S == '1' then EndOfDecode(Decode_UNDEF); end
```

```
scale = size;
```

```
replicate = TRUE; when '00' index = UInt(Q:S:size); // B[0-15] when '01' if size<0> == '1' then index = UInt(Q:S:size<1>); // H[0-7] when '10' if size<1> == '1' then if size<0> == '0' then index = UInt(Q:S); // S[0-3] else if S == '1' then EndOfDecode(Decode_UNDEF); end index = UInt(Q); // D[0-1] scale = '11'; end end constant integer{} datasize = 64 << UInt(Q); constant integer{} esize = 8 << UInt(scale);
```

```
EndOfDecode(Decode_UNDEF); end EndOfDecode(Decode_UNDEF); end Operation
```

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; bits(64) eaddr; bits(64) offs; bits(128) rval; bits(esize) element; constant integer ebytes = esize DIV 8; constant AccessDescriptor accdesc = CreateAccDescASIMDAcqRel(MemOp_STORE, tagchecked); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; offs = Zeros(64); if replicate then // load and replicate to all elements for s = 0 to selem-1 eaddr = AddressIncrement(address, offs, accdesc); element = Mem[eaddr, ebytes, accdesc]; // replicate to fill 128or 64-bit register V[t, datasize] = Replicate(element, datasize DIV esize); offs = offs + ebytes; t = (t + 1) MOD 32; else // load/store one element per register for s = 0 to selem-1 rval = V[t, 128]; eaddr = AddressIncrement(address, offs, accdesc); // extract from one lane of 128-bit register Mem[eaddr, ebytes, accdesc] = Elem[rval, index, esize]; offs = offs + ebytes; t = ( t + 1 ) MOD 32; if wback then if m != 31 then offs = X[m, 64]; address = AddressAdd(address, offs, accdesc); if n == 31 then SP[64] = address; else
```

```
X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.384 STLUR (SIMD&amp;FP)

Store-release SIMD&amp;FP register (unscaled offset)

This instruction stores a single SIMD&amp;FP register to memory. The address that is used for the store is calculated from a base register value and an optional immediate offset.

The instruction has memory ordering semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Unscaled offset

## (FEAT\_FP &amp;&amp; FEAT\_LRCPC3)

<!-- image -->

## Encoding for the 8-bit variant

```
Applies when (size == 00 && opc == 00) STLUR <Bt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 16-bit variant

```
(size == 01 && opc == 00)
```

```
Applies when STLUR <Ht>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 32-bit variant

```
Applies when (size == 10 && opc == 00) STLUR <St>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11 && opc == 00) STLUR <Dt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 128-bit variant

```
Applies when (size == 00 && opc == 10) STLUR <Qt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) || !IsFeatureImplemented(FEAT_LRCPC3) then EndOfDecode(Decode_UNDEF); if opc<1> == '1' && size != '00' then EndOfDecode(Decode_UNDEF); constant integer scale = if opc<1> == '1' then 4 else UInt(size); constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Bt&gt;

Is the 8-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## &lt;Ht&gt;

## &lt;St&gt;

## &lt;Dt&gt;

## &lt;Qt&gt;

Is the 128-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8 << constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); bits(64) address; constant AccessDescriptor accdesc if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Mem[address, datasize DIV 8, accdesc] = V[t, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

Is the 16-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 32-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 64-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

```
scale;
```

```
= CreateAccDescASIMDAcqRel(MemOp_STORE, tagchecked);
```

## C7.2.385 STNP (SIMD&amp;FP)

Store pair of SIMD&amp;FP registers, with non-temporal hint

This instruction stores a pair of SIMD&amp;FP registers to memory, issuing a hint to the memory system that the access is non-temporal. The address used for the store is calculated from an address from a base register value and an immediate offset. For information about non-temporal pair instructions, see Load/Store SIMD and Floating-point non-temporal pair.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Signed offset

(FEAT\_FP)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) STNP <St1>, <St2>, [<Xn|SP>{, #<imm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 01) STNP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]
```

## Encoding for the 128-bit variant

```
Applies when (opc == 10) STNP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for all variants of this encoding

// Empty.

## Assembler Symbols

&lt;St1&gt;

Is the 32-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

&lt;St2&gt;

Is the 32-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the '32-bit' variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/4.

For the '64-bit' variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/8.

For the '128-bit' variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/16.

## &lt;Dt1&gt;

Is the 64-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Dt2&gt;

Is the 64-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## &lt;Qt1&gt;

Is the 128-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Qt2&gt;

Is the 128-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## Shared Decode

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); end constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = TRUE; constant integer{} scale = 2 + (UInt(opc) as integer{0..2}); constant integer{} datasize = 8 << scale; constant bits(64) offset = LSL(SignExtend(imm7, 64), scale); constant boolean tagchecked = n != 31;
```

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; constant integer dbytes = datasize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged, ispair); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); bits(2*datasize) data; if BigEndian(accdesc.acctype) then data = V[t, datasize] : V[t2, datasize]; else data = V[t2, datasize] : V[t, datasize]; Mem[address, 2*dbytes, accdesc] = data;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.386 STP (SIMD&amp;FP)

Store pair of SIMD&amp;FP registers

This instruction stores a pair of SIMD&amp;FP registers to memory. The address used for the store is calculated from a base register value and an immediate offset.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

(FEAT\_FP)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) STP <St1>, <St2>, [<Xn|SP>], #<imm>
```

## Encoding for the 64-bit variant

```
Applies when (opc == 01) STP
```

```
<Dt1>, <Dt2>, [<Xn|SP>], #<imm>
```

## Encoding for the 128-bit variant

```
Applies when (opc == 10) STP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF);
```

```
constant boolean wback = TRUE; constant boolean postindex = TRUE;
```

## Pre-index

(FEAT\_FP)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) STP
```

```
<St1>, <St2>, [<Xn|SP>, #<imm>]!
```

## Encoding for the 64-bit variant

```
Applies when (opc == 01) STP <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!
```

## Encoding for the 128-bit variant

```
Applies when (opc == 10) STP <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF);
```

```
constant boolean wback = TRUE; constant boolean postindex = FALSE;
```

## Signed offset

(FEAT\_FP)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00)
```

```
STP <St1>, <St2>, [<Xn|SP>{, #<imm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 01) STP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]
```

## Encoding for the 128-bit variant

```
Applies when (opc == 10) STP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF);
```

```
constant boolean wback = FALSE; constant boolean postindex = FALSE;
```

## Assembler Symbols

## &lt;St1&gt;

Is the 32-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;St2&gt;

Is the 32-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the 'Post-index 32-bit' and 'Pre-index 32-bit' variants: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the 'imm7' field as &lt;imm&gt;/4.

For the 'Post-index 64-bit' and 'Pre-index 64-bit' variants: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the 'imm7' field as &lt;imm&gt;/8.

For the 'Post-index 128-bit' and 'Pre-index 128-bit' variants: is the signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, encoded in the 'imm7' field as &lt;imm&gt;/16.

For the 'Signed offset 32-bit' variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/4.

For the 'Signed offset 64-bit' variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/8.

For the 'Signed offset 128-bit' variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/16.

## &lt;Dt1&gt;

Is the 64-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Dt2&gt;

Is the 64-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## &lt;Qt1&gt;

Is the 128-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Qt2&gt;

Is the 128-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = FALSE; constant integer{} scale = 2 + (UInt(opc) as integer{0..2}); constant integer{} datasize = 8 << scale; constant bits(64) offset = LSL(SignExtend(imm7, 64), scale); constant boolean tagchecked = wback || n != 31;
```

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; constant integer dbytes = datasize DIV 8;
```

```
constant boolean privileged = PSTATE.EL != EL0; constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged, ispair); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); bits(2*datasize) data; if BigEndian(accdesc.acctype) then data = V[t, datasize] : V[t2, datasize]; else data = V[t2, datasize] : V[t, datasize]; Mem[address, 2*dbytes, accdesc] = data; if wback then if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.387 STR (immediate, SIMD&amp;FP)

Store SIMD&amp;FP register (immediate offset)

This instruction stores a single SIMD&amp;FP register to memory. The address that is used for the store is calculated from a base register value and an immediate offset.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 3 classes: Post-index, Pre-index, and Unsigned offset

## Post-index

(FEAT\_FP)

<!-- image -->

## Encoding for the 8-bit variant

Applies when (size == 00 &amp;&amp; opc == 00)

```
STR
```

```
<Bt>, [<Xn|SP>], #<simm>
```

## Encoding for the 16-bit variant

```
Applies when (size == 01 && opc == 00) STR <Ht>, [<Xn|SP>], #<simm>
```

## Encoding for the 32-bit variant

```
Applies when
```

```
STR
```

```
(size == 10 && opc == 00) <St>, [<Xn|SP>], #<simm>
```

## Encoding for the 64-bit variant

Applies when

```
(size == 11 && opc == 00) STR <Dt>, [<Xn|SP>], #<simm>
```

## Encoding for the 128-bit variant

```
Applies when
```

```
STR
```

```
(size == 00 && opc == 10) <Qt>, [<Xn|SP>], #<simm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); UInt(size);
```

```
if opc<1> == '1' && size != '00' then EndOfDecode(Decode_UNDEF); constant integer scale = if opc<1> == '1' then 4 else constant boolean wback = TRUE; constant boolean postindex = TRUE; constant bits(64) offset = SignExtend(imm9, 64);
```

## Pre-index

(FEAT\_FP)

<!-- image -->

## Encoding for the 8-bit variant

Applies when

```
STR
```

```
(size == 00 && opc == 00) <Bt>, [<Xn|SP>, #<simm>]!
```

## Encoding for the 16-bit variant

```
Applies when (size == 01 && opc == 00) STR <Ht>, [<Xn|SP>, #<simm>]!
```

## Encoding for the 32-bit variant

```
Applies when (size == 10 && opc == 00)
```

```
STR <St>, [<Xn|SP>, #<simm>]!
```

## Encoding for the 64-bit variant

Applies when (size == 11 &amp;&amp; opc == 00)

```
STR
```

```
<Dt>, [<Xn|SP>, #<simm>]!
```

## Encoding for the 128-bit variant

```
Applies when (size == 00 && opc == 10) STR <Qt>, [<Xn|SP>, #<simm>]!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); UInt(size);
```

```
if opc<1> == '1' && size != '00' then EndOfDecode(Decode_UNDEF); constant integer scale = if opc<1> == '1' then 4 else constant boolean wback = TRUE; constant boolean postindex = FALSE; constant bits(64) offset = SignExtend(imm9, 64);
```

## Unsigned offset

(FEAT\_FP)

<!-- image -->

## Encoding for the 8-bit variant

```
Applies when
```

```
STR
```

```
(size == 00 && opc == 00) <Bt>, [<Xn|SP>{, #<pimm>}]
```

## Encoding for the 16-bit variant

```
Applies when (size == 01 && opc == 00) STR <Ht>, [<Xn|SP>{, #<pimm>}]
```

## Encoding for the 32-bit variant

```
Applies when (size == 10 && opc == 00)
```

```
STR <St>, [<Xn|SP>{, #<pimm>}]
```

## Encoding for the 64-bit variant

Applies when (size == 11 &amp;&amp; opc == 00)

```
STR
```

```
<Dt>, [<Xn|SP>{, #<pimm>}]
```

## Encoding for the 128-bit variant

Applies when (size == 00 &amp;&amp; opc == 10)

```
STR
```

```
<Qt>, [<Xn|SP>{, #<pimm>}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); UInt(size);
```

```
if opc<1> == '1' && size != '00' then EndOfDecode(Decode_UNDEF); constant integer scale = if opc<1> == '1' then 4 else constant boolean wback = FALSE; constant boolean postindex = FALSE; constant bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
```

## Assembler Symbols

## &lt;Bt&gt;

Is the 8-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the signed immediate byte offset, in the range -256 to 255, encoded in the 'imm9' field.

## &lt;Ht&gt;

&lt;St&gt;

## &lt;Dt&gt;

## &lt;Qt&gt;

Is the 128-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;pimm&gt;

For the '8-bit' variant: is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the 'imm12' field.

For the '16-bit' variant: is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/2.

For the '32-bit' variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/4.

For the '64-bit' variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/8.

For the '128-bit' variant: is the optional positive immediate byte offset, a multiple of 16 in the range 0 to 65520, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/16.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8 << scale; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64];
```

Is the 16-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 32-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 64-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

```
else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); Mem[address, datasize DIV 8, accdesc] = V[t, datasize]; if wback then if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.388 STR (register, SIMD&amp;FP)

Store SIMD&amp;FP register (register offset)

This instruction stores a single SIMD&amp;FP register to memory. The address that is used for the store is calculated from a base register value and an offset register value. The offset can be optionally shifted and extended.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## SIMD&amp;FP registers

(FEAT\_FP)

<!-- image -->

## Encoding for the 8-bit with extended register offset variant

Applies when (size == 00 &amp;&amp; opc == 00 &amp;&amp; option != 011)

```
STR <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend>
```

```
{<amount>}]
```

## Encoding for the 8-bit with shifted register offset variant

```
Applies when (size == 00 && opc == 00 && option ==
```

```
STR <Bt>, [<Xn|SP>, <Xm>{, LSL
```

```
011) <amount>}]
```

## Encoding for the 16-bit variant

Applies when (size == 01 &amp;&amp; opc == 00)

```
STR <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]
```

## Encoding for the 32-bit variant

Applies when

```
(size == 10 && opc == 00) STR <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>
```

## Encoding for the 64-bit variant

```
Applies when (size == 11 && opc == 00) STR <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>
```

## Encoding for the 128-bit variant

```
Applies when (size == 00 && opc == 10) STR <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>
```

```
{<amount>}}]
```

```
{<amount>}}]
```

```
{<amount>}}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if option<1> == '0' then EndOfDecode(Decode_UNDEF); // sub-word index if opc<1> == '1' && size != '00' then EndOfDecode(Decode_UNDEF); constant integer scale = if opc<1> == '1' then 4 else UInt(size); constant ExtendType extend_type = DecodeRegExtend(option); constant integer shift = if S == '1' then scale else 0;
```

## Assembler Symbols

## &lt;Bt&gt;

Is the 8-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

When option&lt;0&gt; is set to 0, is the 32-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;Xm&gt;

When option&lt;0&gt; is set to 1, is the 64-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;extend&gt;

For the '8-bit with extended register offset' variant: is the index extend specifier, encoded in 'option':

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |
|      110 | SXTW       |
|      111 | SXTX       |

For the '128-bit', '16-bit', '32-bit', and '64-bit' variants: is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option when &lt;amount&gt; is omitted, encoded in 'option':

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |
|      011 | LSL        |
|      110 | SXTW       |
|      111 | SXTX       |

## &lt;amount&gt;

For the '8-bit with extended register offset' and '8-bit with shifted register offset' variants: is the index shift amount, it must be #0 , encoded in 'S' as 0 if omitted, or as 1 if present.

For the '16-bit' variant: is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

## &lt;Ht&gt;

&lt;St&gt;

&lt;Dt&gt;

&lt;Qt&gt;

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #1         |

For the '32-bit' variant: is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #2         |

For the '64-bit' variant: is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #3         |

For the '128-bit' variant: is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #4         |

Is the 16-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 32-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 64-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 128-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer{} datasize = 8 << scale; constant boolean nontemporal = FALSE; constant boolean tagchecked = TRUE;
```

## Operation

```
AArch64.CheckFPEnabled(); constant bits(64) offset = ExtendReg(m, extend_type, shift, 64); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Mem[address, datasize DIV 8, accdesc] = V[t, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.389 STTNP (SIMD&amp;FP)

Store unprivileged pair of SIMD&amp;FP registers, with non-temporal hint

This instruction stores a pair of SIMD&amp;FP registers to memory, issuing a hint to the memory system that the access is non-temporal. The address used for the store is calculated from an address from a base register value and an immediate offset. For information about non-temporal pair instructions, see Load/Store SIMD and Floating-point non-temporal pair.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Signed offset

(FEAT\_FP &amp;&amp; FEAT\_LSUI)

<!-- image -->

## Encoding

```
STTNP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP) || !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = TRUE; constant integer datasize = 128; constant bits(64) offset = LSL(SignExtend(imm7, 64), 4); constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Qt1&gt;

Is the 128-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Qt2&gt;

Is the 128-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/16.

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; constant integer dbytes = datasize DIV 8; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged, ispair); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); bits(2*datasize) data; if BigEndian(accdesc.acctype) then data = V[t, datasize] : V[t2, datasize]; else data = V[t2, datasize] : V[t, datasize]; Mem[address, 2*dbytes, accdesc] = data;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.390 STTP (SIMD&amp;FP)

Store unprivileged pair of SIMD&amp;FP registers

This instruction stores a pair of SIMD&amp;FP registers to memory. The address used for the store is calculated from a base register value and an immediate offset.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

(FEAT\_FP &amp;&amp; FEAT\_LSUI)

<!-- image -->

## Encoding

```
STTP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP) || !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant boolean wback = TRUE; constant boolean postindex = TRUE;
```

## Pre-index

(FEAT\_FP &amp;&amp; FEAT\_LSUI)

<!-- image -->

## Encoding

```
STTP <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP) || !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant boolean wback = TRUE; constant boolean postindex = FALSE;
```

## Signed offset

(FEAT\_FP &amp;&amp; FEAT\_LSUI)

<!-- image -->

## Encoding

```
STTP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FP) || !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant boolean wback = FALSE; constant boolean postindex = FALSE;
```

## Assembler Symbols

## &lt;Qt1&gt;

Is the 128-bit name of the first SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Qt2&gt;

Is the 128-bit name of the second SIMD&amp;FP register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the 'Load/store register pair (post-indexed)' and 'Load/store register pair (pre-indexed)' variants: is the signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, encoded in the 'imm7' field as &lt;imm&gt;/16.

For the 'Load/store register pair (offset)' variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/16.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = FALSE; constant integer{} datasize = 128; constant bits(64) offset = LSL(SignExtend(imm7, 64), constant boolean tagchecked = wback || n != 31;
```

```
4);
```

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; constant integer dbytes = datasize DIV 8; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged, ispair); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); bits(2*datasize) data; if BigEndian(accdesc.acctype) then data = V[t, datasize] : V[t2, datasize]; else data = V[t2, datasize] : V[t, datasize]; Mem[address, 2*dbytes, accdesc] = data; if wback then if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.391 STUR (SIMD&amp;FP)

Store SIMD&amp;FP register (unscaled offset)

This instruction stores a single SIMD&amp;FP register to memory. The address that is used for the store is calculated from a base register value and an optional immediate offset.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Unscaled offset

(FEAT\_FP)

<!-- image -->

## Encoding for the 8-bit variant

Applies when (size == 00 &amp;&amp; opc == 00)

```
STUR
```

```
<Bt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 16-bit variant

```
Applies when (size == 01 && opc == 00) STUR <Ht>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 32-bit variant

```
Applies when (size == 10 && opc == 00) STUR <St>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11 && opc == 00) STUR <Dt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 128-bit variant

```
Applies when (size == 00 && opc == 10) STUR <Qt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); UInt(size);
```

```
if opc<1> == '1' && size != '00' then EndOfDecode(Decode_UNDEF); constant integer scale = if opc<1> == '1' then 4 else constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Bt&gt;

Is the 8-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## &lt;Ht&gt;

## &lt;St&gt;

## &lt;Dt&gt;

## &lt;Qt&gt;

Is the 128-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8 << constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
AArch64.CheckFPEnabled(); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescASIMD(MemOp_STORE, nontemporal, tagchecked, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Mem[address, datasize DIV 8, accdesc] = V[t, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

Is the 16-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 32-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

Is the 64-bit name of the SIMD&amp;FP register to be transferred, encoded in the 'Rt' field.

```
scale;
```

## C7.2.392 SUB (vector)

Subtract (vector)

This instruction subtracts each vector element in the second source SIMD&amp;FP register from the corresponding vector element in the first source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

SUB

D&lt;d&gt;,

D&lt;n&gt;,

D&lt;m&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;n&gt;

&lt;m&gt;

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

- &lt;Vd&gt; Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.
- &lt;T&gt;

&lt;Vn&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; bits(esize) element1; bits(esize) element2; for e = 0 to elements-1 element1 = Elem[operand1, e, esize]; element2 = Elem[operand2, e, esize]; Elem[result, e, esize] = element1 - element2; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.393 SUBHN, SUBHN2

Subtract returning high narrow

This instruction subtracts each vector element in the second source SIMD&amp;FP register from the corresponding vector element in the first source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values.

The results are truncated. For rounded results, see RSUBHN.

The SUBHN instruction writes the vector to the lower half of the destination register and clears the upper half. The SUBHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SUBHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant boolean round = FALSE;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

&lt;Vd&gt;

&lt;Tb&gt;

&lt;Vn&gt;

&lt;Ta&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size':

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand1 = constant bits(2*datasize) operand2 = bits(datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, 2*esize]); element2 = UInt(Elem[operand2, e, 2*esize]); sum = element1 - element2; sum = RShr(sum, esize, round); Elem[result, e, esize] = sum<esize-1:0>; Vpart[d, part, datasize] = result;
```

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

```
V[n, 2*datasize]; V[m, 2*datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.394 SUDOT (by element)

Dot product with signed and unsigned integers (vector, by element)

This instruction performs the dot product of the four signed 8-bit integer values in each 32-bit element of the first source register with the four unsigned 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination vector.

From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID\_AA64ISAR1\_EL1.I8MM indicates whether this instruction is supported.

## Vector

(FEAT\_I8MM)

<!-- image -->

## Encoding

```
SUDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_I8MM) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer m = UInt(M:Rm); constant integer d = UInt(Rd); constant integer i = UInt(H:L); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV 32;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP third source and destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

&lt;Vn&gt;

<!-- image -->

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'M:Rm' fields.

## &lt;index&gt;

Is the immediate index of a 32-bit group of four 8-bit values, in the range 0 to 3, encoded in the 'H:L' fields.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(128) operand2 = V[m, 128]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; for e = 0 to elements-1 bits(32) res = Elem[operand3, e, 32]; for b = 0 to 3 constant integer element1 = SInt(Elem[operand1, 4 * e + b, 8]); constant integer element2 = UInt(Elem[operand2, 4 * i + b, 8]); res = res + element1 * element2; Elem[result, e, 32] = res; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   Q | <Tb>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

## C7.2.395 SUQADD

Signed saturating accumulate of unsigned value

This instruction adds the unsigned integer values of the vector elements in the source SIMD&amp;FP register to corresponding signed integer values of the vector elements in the destination SIMD&amp;FP register, and writes the resulting signed integer values to the destination SIMD&amp;FP register.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SUQADD <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean unsigned = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SUQADD <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = FALSE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

|   size | <V>   |
|--------|-------|
|     00 | B     |
|     01 | H     |
|     10 | S     |
|     11 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; constant bits(datasize) operand2 = V[d, datasize]; integer op1; integer op2; boolean sat; for e = 0 to elements-1 op1 = UInt(Elem[operand, e, esize]); op2 = SInt(Elem[operand2, e, esize]); (Elem[result, e, esize], sat) = SatQ(op1 + op2, if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

```
esize, unsigned);
```

## C7.2.396 SXTL, SXTL2

Signed extend long

This instruction duplicates each vector element in the lower or upper half of the source SIMD&amp;FP register into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.

The SXTL instruction extracts the source vector from the lower half of the source register. The SXTL2 instruction extracts the source vector from the upper half of the source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This is an alias of SSHLL, SSHLL2. This means:

- The encodings in this description are named to match the encodings of SSHLL, SSHLL2.
- The description of SSHLL, SSHLL2 gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Vector

## (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
SXTL{2} <Vd>.<Ta>, <Vn>.<Tb>
```

## is equivalent to

```
SSHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #0
```

and is the preferred disassembly when BitCount(immh) == 1 .

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'immh':

| immh   | <Ta>     |
|--------|----------|
| 0001   | 8H       |
| 001x   | 4S       |
| 01xx   | 2D       |
| 1xxx   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   | Q   | <Tb>     |
|--------|-----|----------|
| 0001   | 0   | 8B       |
| 0001   | 1   | 16B      |
| 001x   | 0   | 4H       |
| 001x   | 1   | 8H       |
| 01xx   | 0   | 2S       |
| 01xx   | 1   | 4S       |
| 1xxx   | x   | RESERVED |

## Operation

The description of SSHLL, SSHLL2 gives the operational pseudocode for this instruction.

## Operational Information

The description of SSHLL, SSHLL2 gives the operational information for this instruction.

## C7.2.397 TBL

Table vector lookup

This instruction reads each value from the vector elements in the index source SIMD&amp;FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&amp;FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&amp;FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the Single register table variant

```
Applies when (len == 00)
```

```
TBL <Vd>.<Ta>, { <Vn>.16B
```

```
}, <Vm>.<Ta>
```

## Encoding for the Two register table variant

```
Applies when (len == 01) TBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B },
```

```
<Vm>.<Ta>
```

## Encoding for the Three register table variant

```
Applies when (len == 10) TBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B },
```

## Encoding for the Four register table variant

```
Applies when (len == 11)
```

```
TBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV 8; constant integer regs = UInt(len) + 1; constant boolean is_tbl = (op == '0');
```

```
<Vm>.<Ta>
```

```
}, <Vm>.<Ta>
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

## &lt;Ta&gt;

## &lt;Vn&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

For the 'Single register table' variant: is the name of the SIMD&amp;FP table register, encoded in the 'Rn' field.

For the 'Four register table', 'Three register table', and 'Two register table' variants: is the name of the first SIMD&amp;FP table register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the SIMD&amp;FP index register, encoded in the 'Rm' field.

## &lt;Vn+1&gt;

Is the name of the second SIMD&amp;FP table register, encoded as 'Rn' plus 1 modulo 32.

## &lt;Vn+2&gt;

Is the name of the third SIMD&amp;FP table register, encoded as 'Rn' plus 2 modulo 32.

## &lt;Vn+3&gt;

Is the name of the fourth SIMD&amp;FP table register, encoded as 'Rn' plus 3 modulo 32.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) indices = V[m, datasize]; bits(128*regs) table = Zeros(128*regs); bits(datasize) result; integer index; // Create table from registers for i = 0 to regs - 1 Elem[table, i, 128] = V[(n+i) MOD 32, 128]; result = if is_tbl then Zeros(datasize) else V[d, for i = 0 to elements - 1 index = UInt(Elem[indices, i, 8]); if index < 16 * regs then Elem[result, i, 8] = Elem[table, index, 8]; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
datasize];
```

## C7.2.398 TBX

Table vector lookup extension

This instruction reads each value from the vector elements in the index source SIMD&amp;FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&amp;FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&amp;FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the Single register table variant

```
Applies when (len == 00)
```

```
TBX <Vd>.<Ta>, { <Vn>.16B
```

```
}, <Vm>.<Ta>
```

## Encoding for the Two register table variant

```
Applies when (len == 01) TBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>
```

## Encoding for the Three register table variant

```
Applies when (len == 10) TBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>
```

## Encoding for the Four register table variant

```
Applies when (len == 11)
```

```
TBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV 8; constant integer regs = UInt(len) + 1; constant boolean is_tbl = (op == '0');
```

```
}, <Vm>.<Ta>
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

## &lt;Ta&gt;

## &lt;Vn&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

For the 'Single register table' variant: is the name of the SIMD&amp;FP table register, encoded in the 'Rn' field.

For the 'Four register table', 'Three register table', and 'Two register table' variants: is the name of the first SIMD&amp;FP table register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the SIMD&amp;FP index register, encoded in the 'Rm' field.

## &lt;Vn+1&gt;

Is the name of the second SIMD&amp;FP table register, encoded as 'Rn' plus 1 modulo 32.

## &lt;Vn+2&gt;

Is the name of the third SIMD&amp;FP table register, encoded as 'Rn' plus 2 modulo 32.

## &lt;Vn+3&gt;

Is the name of the fourth SIMD&amp;FP table register, encoded as 'Rn' plus 3 modulo 32.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) indices = V[m, datasize]; bits(128*regs) table = Zeros(128*regs); bits(datasize) result; integer index; // Create table from registers for i = 0 to regs - 1 Elem[table, i, 128] = V[(n+i) MOD 32, 128]; result = if is_tbl then Zeros(datasize) else V[d, for i = 0 to elements - 1 index = UInt(Elem[indices, i, 8]); if index < 16 * regs then Elem[result, i, 8] = Elem[table, index, 8]; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
datasize];
```

## C7.2.399 TRN1

Transpose vectors (primary)

This instruction reads corresponding even-numbered vector elements from the two source SIMD&amp;FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&amp;FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.

Note

By using this instruction with TRN2 , a 2 x 2 matrix can be transposed.

Figure C7-5 TRN1 and TRN2 halfword operations where Q = 0

<!-- image -->

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
TRN1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = UInt(op); constant integer pairs = elements DIV 2;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; for p = 0 to pairs-1 Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize]; Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize]; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

&lt;T&gt;

&lt;Vn&gt;

## C7.2.400 TRN2

Transpose vectors (secondary)

This instruction reads corresponding odd-numbered vector elements from the two source SIMD&amp;FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&amp;FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.

Note

By using this instruction with TRN1 , a 2 x 2 matrix can be transposed.

Figure C7-6 TRN1 and TRN2 halfword operations where Q = 0

<!-- image -->

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

Advanced SIMD (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
TRN2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = UInt(op); constant integer pairs = elements DIV 2;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; for p = 0 to pairs-1 Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize]; Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize]; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

&lt;T&gt;

&lt;Vn&gt;

## C7.2.401 UABA

Unsigned absolute difference and accumulate

This instruction subtracts the elements of the vector of the second source SIMD&amp;FP register from the corresponding elements of the first source SIMD&amp;FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UABA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result = V[d, datasize]; integer element1; integer element2; bits(esize) absdiff; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); absdiff = Abs(element1 - element2)<esize-1:0>; Elem[result, e, esize] = Elem[result, e, esize] + absdiff; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.402 UABAL, UABAL2

Unsigned absolute difference and accumulate long

This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.

The UABAL instruction extracts each source vector from the lower half of each source register. The UABAL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UABAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(datasize) operand2 = Vpart[m, part, datasize]; bits(2*datasize) result = V[d, 2*datasize]; integer element1; integer element2; bits(2*esize) absdiff; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); absdiff = Abs(element1-element2)<2*esize-1:0>; Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.403 UABD

Unsigned absolute difference (vector)

This instruction subtracts the elements of the vector of the second source SIMD&amp;FP register from the corresponding elements of the first source SIMD&amp;FP register, places the absolute values of the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result = Zeros(datasize); integer element1; integer element2; bits(esize) absdiff; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); absdiff = Abs(element1 - element2)<esize-1:0>; Elem[result, e, esize] = Elem[result, e, esize] + absdiff; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.404 UABDL, UABDL2

Unsigned absolute difference long

This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.

The UABDL instruction extracts each source vector from the lower half of each source register. The UABDL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UABDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

&lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(datasize) operand2 = Vpart[m, part, datasize]; bits(2*datasize) result = Zeros(2*datasize); integer element1; integer element2; bits(2*esize) absdiff; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); absdiff = Abs(element1-element2)<2*esize-1:0>; Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.405 UADALP

Unsigned add and accumulate long pairwise

This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&amp;FP register and accumulates the results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UADALP <Vd>.<Ta>, <Vn>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV (2 * esize);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Ta>     |
|--------|-----|----------|
|     00 | 0   | 4H       |
|     00 | 1   | 8H       |
|     01 | 0   | 2S       |
|     01 | 1   | 4S       |
|     10 | 0   | 1D       |
|     10 | 1   | 2D       |
|     11 | x   | RESERVED |

&lt;Ta&gt;

&lt;Vn&gt;

&lt;Tb&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result = V[d, datasize]; bits(2*esize) sum; integer op1; integer op2; for e = 0 to elements-1 op1 = UInt(Elem[operand, 2*e+0, esize]); op2 = UInt(Elem[operand, 2*e+1, esize]); sum = (op1+op2)<2*esize-1:0>; Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
sum;
```

## C7.2.406 UADDL, UADDL2

Unsigned add long (vector)

This instruction adds each vector element in the lower or upper half of the first source SIMD&amp;FP register to the corresponding vector element of the second source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.

The UADDL instruction extracts each source vector from the lower half of each source register. The UADDL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UADDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

<!-- image -->

&lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(datasize) operand2 = Vpart[m, part, datasize]; bits(2*datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); sum = element1 + element2; Elem[result, e, 2*esize] = sum<2*esize-1:0>; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.407 UADDLP

Unsigned add long pairwise

This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UADDLP <Vd>.<Ta>, <Vn>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV (2 * esize);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Ta>     |
|--------|-----|----------|
|     00 | 0   | 4H       |
|     00 | 1   | 8H       |
|     01 | 0   | 2S       |
|     01 | 1   | 4S       |
|     10 | 0   | 1D       |
|     10 | 1   | 2D       |
|     11 | x   | RESERVED |

&lt;Ta&gt;

&lt;Vn&gt;

&lt;Tb&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = bits(datasize) result; bits(2*esize) sum; integer op1; integer op2; for e = 0 to elements-1 op1 = UInt(Elem[operand, 2*e+0, esize]); op2 = UInt(Elem[operand, 2*e+1, esize]); sum = (op1+op2)<2*esize-1:0>; Elem[result, e, 2*esize] = sum; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
V[n, datasize];
```

## C7.2.408 UADDLV

Unsigned sum long across vector

This instruction adds every vector element in the source SIMD&amp;FP register together, and writes the scalar result to the destination SIMD&amp;FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are unsigned integer values.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UADDLV <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '100' then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = TRUE;
```

## Assembler Symbols

<!-- image -->

&lt;V&gt;

Is the destination width specifier, encoded in 'size':

<!-- image -->

|   size | <V>      |
|--------|----------|
|     00 | H        |
|     01 | S        |
|     10 | D        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

<!-- image -->

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | RESERVED |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(esize) opelt = Elem[operand, 0, esize]; integer sum = if unsigned then UInt(opelt) else SInt(opelt); for e = 1 to elements-1 opelt = Elem[operand, e, esize]; constant integer element = if unsigned then UInt(opelt) else SInt(opelt); sum = sum + element; V[d, 2*esize] = sum<2*esize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.409 UADDW, UADDW2

Unsigned add wide

This instruction adds the vector elements of the first source SIMD&amp;FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&amp;FP register, places the result in a vector, and writes the vector to the SIMD&amp;FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values.

The UADDW instruction extracts vector elements from the lower half of the second source register. The UADDW2 instruction extracts vector elements from the upper half of the second source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UADDW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

## &lt;Ta&gt;

## &lt;Vn&gt;

Is an arrangement specifier, encoded in 'size':

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand1 = V[n, 2*datasize]; constant bits(datasize) operand2 = bits(2*datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, 2*esize]); element2 = UInt(Elem[operand2, e, esize]); sum = element1 + element2; Elem[result, e, 2*esize] = sum<2*esize-1:0>; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Tb&gt;

```
Vpart[m, part, datasize];
```

## C7.2.410 UCVTF (vector, fixed-point)

Unsigned fixed-point convert to floating-point (vector)

This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UCVTF <V><d>, <V><n>, #<fbits>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh IN {'000x'} || (immh IN {'001x'} && !IsFeatureImplemented(FEAT_FP16)) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = if immh IN {'1xxx'} then 64 else if immh IN {'01xx'} then 32 else 16; constant integer datasize = esize; constant integer elements = 1; constant integer fracbits = (esize * 2) UInt(immh:immb); constant boolean unsigned = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UCVTF <Vd>.<T>, <Vn>.<T>, #<fbits>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh IN {'000x'} || (immh IN {'001x'} && !IsFeatureImplemented(FEAT_FP16)) then EndOfDecode(Decode_UNDEF); if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = if immh IN {'1xxx'} then 64 else if immh IN {'01xx'} then 32 else 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer fracbits = (esize * 2) UInt(immh:immb); constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'immh':

| immh   | <V>      | Architectural Feature   |
|--------|----------|-------------------------|
| 0001   | RESERVED | -                       |
| 001x   | H        | FEAT_FP16               |
| 01xx   | S        | -                       |
| 1xxx   | D        | -                       |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;d&gt;

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;fbits&gt;

For the 'Scalar' variant: is the number of fractional bits, in the range 1 to the operand width, encoded in 'immh:immb':

| immh   | <fbits>               |
|--------|-----------------------|
| 0001   | RESERVED              |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

For the 'Vector' variant: is the number of fractional bits, in the range 1 to the element width, encoded in 'immh:immb':

## &lt;Vd&gt;

&lt;T&gt;

| immh   | <fbits>               |
|--------|-----------------------|
| 0001   | RESERVED              |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   | Q   | <T>      | Architectural Feature   |
|--------|-----|----------|-------------------------|
| 0001   | x   | RESERVED | -                       |
| 001x   | 0   | 4H       | FEAT_FP16               |
| 001x   | 1   | 8H       | FEAT_FP16               |
| 01xx   | 0   | 2S       | -                       |
| 01xx   | 1   | 4S       | -                       |
| 1xxx   | 0   | RESERVED | -                       |
| 1xxx   | 1   | 2D       | -                       |

## &lt;Vn&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant FPRounding rounding = FPRoundingMode(FPCR); constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.411 UCVTF (vector, integer)

Unsigned integer convert to floating-point (vector)

This instruction converts each element in a vector from an unsigned integer value to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 4 classes: Scalar half-precision, Scalar single-precision and double-precision, Vector half-precision, and Vector single-precision and double-precision

## Scalar half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
UCVTF <Hd>, <Hn>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = esize; constant integer elements = 1; constant boolean unsigned = TRUE;
```

## Scalar single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UCVTF <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 32 << UInt(sz); constant integer datasize = esize; constant integer elements = 1; constant boolean unsigned = TRUE;
```

## Vector half-precision

(FEAT\_AdvSIMD &amp;&amp; FEAT\_FP16)

<!-- image -->

## Encoding

```
UCVTF <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) || !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 16; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = TRUE;
```

## Vector single-precision and double-precision

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UCVTF <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); if sz:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer esize = 32 << UInt(sz); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = TRUE;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 16-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is a width specifier, encoded in 'sz':

&lt;Hn&gt;

&lt;V&gt;

&lt;d&gt;

&lt;n&gt;

&lt;Vd&gt;

&lt;T&gt;

|   sz | <V>   |
|------|-------|
|    0 | S     |
|    1 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

For the 'Vector half-precision' variant: is an arrangement specifier, encoded in 'Q':

|   Q | <T>   |
|-----|-------|
|   0 | 4H    |
|   1 | 8H    |

For the 'Vector single-precision and double-precision' variant: is an arrangement specifier, encoded in 'sz:Q':

&lt;Vn&gt;

|   sz |   Q | <T>      |
|------|-----|----------|
|    0 |   0 | 2S       |
|    0 |   1 | 4S       |
|    1 |   0 | RESERVED |
|    1 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
if elements == 1 && IsFeatureImplemented(FEAT_FPRCVT) then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant boolean merge = elements == 1 && IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); constant FPRounding rounding = FPRoundingMode(FPCR); constant integer fracbits = 0; bits(esize) element; for e = 0 to elements-1 element = Elem[operand, e, esize]; Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding, esize); V[d, 128] = result;
```

## C7.2.412 UCVTF (scalar, fixed-point)

Unsigned fixed-point convert to floating-point (scalar)

This instruction converts the unsigned value in the 32-bit or 64-bit general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the 32-bit to half-precision variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
UCVTF <Hd>, <Wn>, #<fbits>
```

## Encoding for the 64-bit to half-precision variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
UCVTF <Hd>, <Xn>, #<fbits>
```

## Encoding for the 32-bit to single-precision variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

```
UCVTF <Sd>, <Wn>, #<fbits>
```

## Encoding for the 64-bit to single-precision variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
UCVTF <Sd>, <Xn>, #<fbits>
```

## Encoding for the 32-bit to double-precision variant

```
(FEAT_FP) Applies when (sf == 0 && ftype ==
```

```
UCVTF <Dd>,
```

```
01) <Wn>, #<fbits>
```

## Encoding for the 64-bit to double-precision variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
UCVTF <Dd>, <Xn>, #<fbits>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); if sf == '0' && scale<5> == '0' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer decode_fltsize = 8 << UInt(ftype EOR '10'); constant integer fracbits = 64 -UInt(scale); constant boolean unsigned = TRUE;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;fbits&gt;

For the '32-bit to double-precision', '32-bit to half-precision', and '32-bit to single-precision' variants: is the number of bits after the binary point in the fixed-point source, in the range 1 to 32, encoded as 64 minus 'scale'.

For the '64-bit to double-precision', '64-bit to half-precision', and '64-bit to single-precision' variants: is the number of bits after the binary point in the fixed-point source, in the range 1 to 64, encoded as 64 minus 'scale'.

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Xn&gt;

## &lt;Sd&gt;

## &lt;Dd&gt;

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## Operation

```
AArch64.CheckFPEnabled(); constant boolean merge = IsMerging(FPCR); constant integer fltsize = if merge then 128 else decode_fltsize; bits(fltsize) fltval = if merge then V[d, fltsize] else Zeros(fltsize); constant bits(intsize) intval = X[n, intsize]; constant FPRounding rounding = FPRoundingMode(FPCR); Elem[fltval, 0, decode_fltsize] = FixedToFP(intval, fracbits, unsigned, FPCR, rounding, decode_fltsize); V[d, fltsize] = fltval;
```

## C7.2.413 UCVTF (scalar, integer)

Unsigned integer convert to floating-point (scalar)

This instruction converts the unsigned integer value in the general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding for the 32-bit to half-precision variant

```
(FEAT_FP16) Applies when (sf == 0 && ftype == 11)
```

```
UCVTF <Hd>, <Wn>
```

## Encoding for the 32-bit to single-precision variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 00)
```

```
UCVTF <Sd>, <Wn>
```

## Encoding for the 32-bit to double-precision variant

```
(FEAT_FP) Applies when (sf == 0 && ftype == 01)
```

UCVTF

&lt;Dd&gt;,

&lt;Wn&gt;

## Encoding for the 64-bit to half-precision variant

```
(FEAT_FP16) Applies when (sf == 1 && ftype == 11)
```

```
UCVTF <Hd>, <Xn>
```

## Encoding for the 64-bit to single-precision variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 00)
```

```
UCVTF <Sd>, <Xn>
```

## Encoding for the 64-bit to double-precision variant

```
(FEAT_FP) Applies when (sf == 1 && ftype == 01)
```

```
UCVTF <Dd>, <Xn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FP) then EndOfDecode(Decode_UNDEF); if ftype == '10' then EndOfDecode(Decode_UNDEF); if ftype == '11' && !IsFeatureImplemented(FEAT_FP16) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer decode_fltsize = 8 << UInt(ftype EOR '10'); constant boolean unsigned = TRUE;
```

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

&lt;Sd&gt;

&lt;Dd&gt;

&lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPEnabled(); constant integer fltsize = if IsMerging(FPCR) then 128 else decode_fltsize; constant bits(intsize) intval = X[n, intsize]; constant FPRounding rounding = FPRoundingMode(FPCR); constant integer fracbits = 0; bits(fltsize) fltval = if IsMerging(FPCR) then V[d, fltsize] else Elem[fltval, 0, decode_fltsize] = FixedToFP(intval, fracbits, unsigned, FPCR, rounding, decode_fltsize); V[d, fltsize] = fltval;
```

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

```
Zeros(fltsize);
```

## C7.2.414 UCVTF (scalar SIMD&amp;FP)

Unsigned integer convert to floating-point (scalar SIMD&amp;FP)

This instruction converts the unsigned integer value in the SIMD&amp;FP source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Integer

(FEAT\_FPRCVT)

<!-- image -->

## Encoding for the 32-bit to half-precision variant

Applies when

UCVTF

&lt;Hd&gt;,

(sf

&lt;Sn&gt;

## Encoding for the 32-bit to double-precision variant

```
Applies when (sf == 0 && ftype == 01)
```

UCVTF

&lt;Dd&gt;,

&lt;Sn&gt;

## Encoding for the 64-bit to half-precision variant

```
Applies when (sf == 1 && ftype == 11)
```

UCVTF

&lt;Hd&gt;,

&lt;Dn&gt;

## Encoding for the 64-bit to single-precision variant

```
Applies when (sf == 1 && ftype == 00)
```

```
UCVTF <Sd>, <Dn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_FPRCVT) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer intsize = 32 << UInt(sf); constant integer fltsize = 8 << UInt(ftype EOR '10'); constant FPRounding rounding = FPRoundingMode(FPCR);
```

==

0

&amp;&amp;

ftype ==

11)

## Assembler Symbols

## &lt;Hd&gt;

Is the 16-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 32-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the 64-bit name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Sn&gt;

&lt;Dd&gt;

## &lt;Dn&gt;

&lt;Sd&gt;

Is the 32-bit name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## Operation

```
AArch64.CheckFPEnabled(); bits(fltsize) fltval; bits(intsize) intval; constant boolean merge = IsMerging(FPCR); bits(128) result = if merge then V[d, 128] else Zeros(128); intval = V[n, intsize]; fltval = FixedToFP(intval, 0, TRUE, FPCR, rounding, fltsize); Elem[result, 0, fltsize] = fltval; V[d, 128] = result;
```

## C7.2.415 UDOT (by element)

Dot product unsigned arithmetic (vector, by element)

This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations to support it.

Note

ID\_AA64ISAR0\_EL1.DP indicates whether this instruction is supported.

## Vector

(FEAT\_DotProd)

<!-- image -->

## Encoding

```
UDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_DotProd) then EndOfDecode(Decode_UNDEF);
```

```
if size != '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(M:Rm); constant integer index = UInt(H:L); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP third source and destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

## &lt;Vn&gt;

&lt;Tb&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'M:Rm' fields.

## &lt;index&gt;

Is the element index, encoded in the 'H:L' fields.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(128) operand2 = V[m, 128]; bits(datasize) result = V[d, datasize]; for e = 0 to elements-1 integer res = 0; integer element1, element2; for i = 0 to 3 element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); element2 = UInt(Elem[operand2, 4 * index + i, esize res = res + element1 * element2; Elem[result, e, esize] = Elem[result, e, esize] + res; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   Q | <Tb>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

```
DIV 4]);
```

## C7.2.416 UDOT (vector)

Dot product unsigned arithmetic (vector)

This instruction performs the dot product of the four unsigned 8-bit elements in each 32-bit element of the first source register with the four unsigned 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations to support it.

Note

ID\_AA64ISAR0\_EL1.DP indicates whether this instruction is supported.

## Vector

(FEAT\_DotProd)

<!-- image -->

## Encoding

```
UDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_DotProd) then EndOfDecode(Decode_UNDEF); if size != '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP third source and destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

&lt;Vn&gt;

&lt;Tb&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; result = V[d, datasize]; for e = 0 to elements-1 integer res = 0; integer element1, element2; for i = 0 to 3 element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]); res = res + element1 * element2; Elem[result, e, esize] = Elem[result, e, esize] + res; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   Q | <Tb>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

## C7.2.417 UHADD

Unsigned halving add

This instruction adds corresponding unsigned integer values from the two source SIMD&amp;FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

The results are truncated. For rounded results, see URHADD.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); sum = (element1 + element2) >> 1; Elem[result, e, esize] = sum<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.418 UHSUB

Unsigned halving subtract

This instruction subtracts the vector elements in the second source SIMD&amp;FP register from the corresponding vector elements in the first source SIMD&amp;FP register, shifts each result right one bit, places each result into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UHSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer diff; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); diff = (element1 -element2) >> 1; Elem[result, e, esize] = diff<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.419 UMAX

Unsigned maximum (vector)

This instruction compares corresponding elements in the vectors in the two source SIMD&amp;FP registers, places the larger of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UMAX
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer max; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); max = Max(element1, element2); Elem[result, e, esize] = max<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.420 UMAXP

Unsigned maximum pairwise

This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements in the two source SIMD&amp;FP registers, writes the largest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; constant bits(2*datasize) concat = operand2:operand1; integer element1; integer element2; integer max; for e = 0 to elements-1 element1 = UInt(Elem[concat, 2*e, esize]); element2 = UInt(Elem[concat, (2*e)+1, esize]); max = Max(element1, element2); Elem[result, e, esize] = max<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.421 UMAXV

Unsigned maximum across vector

This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the largest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UMAXV <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '100' then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = TRUE;
```

## Assembler Symbols

<!-- image -->

&lt;V&gt;

Is the destination width specifier, encoded in 'size':

<!-- image -->

<!-- image -->

&lt;Vn&gt;

|   size | <V>      |
|--------|----------|
|     00 | B        |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;T&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | RESERVED |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(esize) opelt = Elem[operand, 0, esize]; integer max = if unsigned then UInt(opelt) else SInt(opelt); for e = 1 to elements-1 opelt = Elem[operand, e, esize]; constant integer element = if unsigned then UInt(opelt) else SInt(opelt); max = Max(max, element); V[d, esize] = max<esize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.422 UMIN

Unsigned minimum (vector)

This instruction compares corresponding vector elements in the two source SIMD&amp;FP registers, places the smaller of each of the two unsigned integer values into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UMIN
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer min; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); min = Min(element1, element2); Elem[result, e, esize] = min<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.423 UMINP

Unsigned minimum pairwise

This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements in the two source SIMD&amp;FP registers, writes the smallest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; constant bits(2*datasize) concat = operand2:operand1; integer element1; integer element2; integer min; for e = 0 to elements-1 element1 = UInt(Elem[concat, 2*e, esize]); element2 = UInt(Elem[concat, (2*e)+1, esize]); min = Min(element1, element2); Elem[result, e, esize] = min<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.424 UMINV

Unsigned minimum across vector

This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the smallest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UMINV <V><d>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '100' then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = TRUE;
```

## Assembler Symbols

<!-- image -->

&lt;V&gt;

Is the destination width specifier, encoded in 'size':

<!-- image -->

<!-- image -->

|   size | <V>      |
|--------|----------|
|     00 | B        |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;T&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | RESERVED |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(esize) opelt = Elem[operand, 0, esize]; integer min = if unsigned then UInt(opelt) else SInt(opelt); for e = 1 to elements-1 opelt = Elem[operand, e, esize]; constant integer element = if unsigned then UInt(opelt) else SInt(opelt); min = Min(min, element); V[d, esize] = min<esize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.425 UMLAL, UMLAL2 (by element)

Unsigned multiply-add long (vector, by element)

This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register and accumulates the results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied.

The UMLAL instruction extracts vector elements from the lower half of the first source register. The UMLAL2 instruction extracts vector elements from the upper half of the first source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

&lt;m&gt;

&lt;Ts&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size':

Restricted to 0-15 when element size &lt;Ts&gt; is H.

Is an element size specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | RESERVED |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |
|     11 | RESERVED     |

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; constant bits(2*datasize) operand3 = V[d, 2*datasize]; bits(2*datasize) result; integer element1; constant integer element2 = UInt(Elem[operand2, index, esize]); bits(2*esize) product; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); product = (element1 * element2)<2*esize-1:0>; Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

```
product;
```

## C7.2.426 UMLAL, UMLAL2 (vector)

Unsigned multiply-add long (vector)

This instruction multiplies the vector elements in the lower or upper half of the first source SIMD&amp;FP register by the corresponding vector elements of the second source SIMD&amp;FP register, and accumulates the results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied.

The UMLAL instruction extracts vector elements from the lower half of the first source register. The UMLAL2 instruction extracts vector elements from the upper half of the first source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

- 2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = constant bits(2*datasize) operand3 = V[d, 2*datasize]; bits(2*datasize) result; integer element1; integer element2; bits(2*esize) product; bits(2*esize) accum; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); product = (element1 * element2)<2*esize-1:0>; accum = Elem[operand3, e, 2*esize] + product; Elem[result, e, 2*esize] = accum; V[d, 2*datasize] = result;
```

```
Vpart[n, part, datasize]; Vpart[m, part, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.427 UMLSL, UMLSL2 (by element)

Unsigned multiply-subtract long (vector, by element)

This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register and subtracts the results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied.

The UMLSL instruction extracts vector elements from the lower half of the first source register. The UMLSL2 instruction extracts vector elements from the upper half of the first source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

&lt;m&gt;

&lt;Ts&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size':

Restricted to 0-15 when element size &lt;Ts&gt; is H.

Is an element size specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | RESERVED |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |
|     11 | RESERVED     |

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; constant bits(2*datasize) operand3 = V[d, 2*datasize]; bits(2*datasize) result; integer element1; constant integer element2 = UInt(Elem[operand2, index, esize]); bits(2*esize) product; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); product = (element1 * element2)<2*esize-1:0>; Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

```
product;
```

## C7.2.428 UMLSL, UMLSL2 (vector)

Unsigned multiply-subtract long (vector)

This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&amp;FP registers, and subtracts the results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.

The UMLSL instruction extracts each source vector from the lower half of each source register. The UMLSL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = constant bits(datasize) operand2 = constant bits(2*datasize) operand3 = V[d, 2*datasize]; bits(2*datasize) result; integer element1; integer element2; bits(2*esize) product; bits(2*esize) accum; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); product = (element1 * element2)<2*esize-1:0>; accum = Elem[operand3, e, 2*esize] product; Elem[result, e, 2*esize] = accum; V[d, 2*datasize] = result;
```

```
Vpart[n, part, datasize]; Vpart[m, part, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.429 UMMLA (vector)

Unsigned 8-bit integer matrix multiply-accumulate to 32-bit integer (vector)

This instruction multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source vector by the 8x2 matrix of unsigned 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element.

From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID\_AA64ISAR1\_EL1.I8MM indicates whether this instruction is supported.

## Vector

(FEAT\_I8MM)

<!-- image -->

## Encoding

```
UMMLA <Vd>.4S, <Vn>.16B, <Vm>.16B
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_I8MM) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean op1_unsigned = TRUE; constant boolean op2_unsigned = TRUE;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP third source and destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[n, 128]; constant bits(128) operand2 = V[m, 128]; constant bits(128) addend = V[d, 128]; V[d, 128] = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned);
```

## Operational Information

Arm expects that the UMMLA (vector) instruction will deliver a peak integer multiply throughput that is at least as high as can be achieved using two UDOT (vector) instructions, with a goal that it should have significantly higher throughput.

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.430 UMOV

Unsigned move vector element to general-purpose register

This instruction reads the unsigned integer from the source SIMD&amp;FP register, zero-extends it to form a 32-bit or 64-bit value, and writes the result to the destination general-purpose register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This instruction is used by the alias MOV (to general).

## Advanced SIMD (FEAT\_AdvSIMD)

<!-- image -->

## Encoding for the 32-bit variant

Applies when

```
(Q == 0)
```

```
UMOV
```

```
<Wd>, <Vn>.<Ts>[<index>]
```

## Encoding for the 64-bit variant

Applies when

```
(Q == 1 && imm5 == x1000) UMOV <Xd>, <Vn>.D[<index>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if imm5 == 'x0000' then EndOfDecode(Decode_UNDEF); constant integer size = LowestSetBitNZ(imm5<3:0>); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << size; constant integer datasize = 32 << UInt(Q); if datasize == 64 && esize < 64 then EndOfDecode(Decode_UNDEF); if datasize == 32 && esize >= 64 then EndOfDecode(Decode_UNDEF); constant integer index = UInt(imm5<4:size+1>); constant integer idxdsize = 64 << UInt(imm5<4>);
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

&lt;Vn&gt;

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

<!-- image -->

Is an element size specifier, encoded in 'imm5':

## &lt;index&gt;

For the '32-bit' variant: is the element index encoded in 'imm5':

| imm5   | <index>         |
|--------|-----------------|
| xx000  | RESERVED        |
| xxxx1  | UInt(imm5<4:1>) |
| xxx10  | UInt(imm5<4:2>) |
| xx100  | UInt(imm5<4:3>) |

For the '64-bit' variant: is the element index encoded in 'imm5&lt;4&gt;'.

<!-- image -->

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Alias Conditions

## Operation

```
if index == 0 then AArch64.CheckFPEnabled(); else AArch64.CheckFPAdvSIMDEnabled(); constant bits(idxdsize) operand = V[n, idxdsize]; X[d, datasize] = ZeroExtend(Elem[operand, index, esize], datasize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| imm5   | <Ts>     |
|--------|----------|
| xx000  | RESERVED |
| xxxx1  | B        |
| xxx10  | H        |
| xx100  | S        |

| Alias            | Of variant   | Is preferred when   |
|------------------|--------------|---------------------|
| MOV (to general) | 32-bit       | imm5 IN {'xx100'}   |
| MOV (to general) | 64-bit       | imm5 IN {'x1000'}   |

## C7.2.431 UMULL, UMULL2 (by element)

Unsigned multiply long (vector, by element)

This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied.

The UMULL instruction extracts vector elements from the lower half of the first source register. The UMULL2 instruction extracts vector elements from the upper half of the first source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, V<m>.<Ts>[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
constant integer idxdsize = 64 << UInt(H); integer index; bit Rmhi; case size of when '01' index = UInt(H:L:M); Rmhi = '0'; when '10' index = UInt(H:L); Rmhi = M; otherwise EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rmhi:Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

&lt;m&gt;

&lt;Ts&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size':

Restricted to 0-15 when element size &lt;Ts&gt; is H.

Is an element size specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | RESERVED |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | x   | RESERVED |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the number of the second SIMD&amp;FP source register, encoded in 'size:M:Rm':

|   size | <m>          |
|--------|--------------|
|     00 | RESERVED     |
|     01 | UInt('0':Rm) |
|     10 | UInt(M:Rm)   |
|     11 | RESERVED     |

## &lt;index&gt;

Is the element index, encoded in 'size:H:L:M':

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(idxdsize) operand2 = V[m, idxdsize]; bits(2*datasize) result; integer element1; constant integer element2 = UInt(Elem[operand2, index, esize]); bits(2*esize) product; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); product = (element1 * element2)<2*esize-1:0>; Elem[result, e, 2*esize] = product; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   size | <Ts>     |
|--------|----------|
|     00 | RESERVED |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

|   size | <index>     |
|--------|-------------|
|     00 | RESERVED    |
|     01 | UInt(H:L:M) |
|     10 | UInt(H:L)   |
|     11 | RESERVED    |

## C7.2.432 UMULL, UMULL2 (vector)

Unsigned multiply long (vector)

This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&amp;FP registers, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.

The UMULL instruction extracts each source vector from the lower half of each source register. The UMULL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

- 2 Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the

registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Ta&gt;

&lt;Vn&gt;

&lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(datasize) operand2 = Vpart[m, part, datasize]; bits(2*datasize) result; integer element1; integer element2; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.433 UQADD

Unsigned saturating add

This instruction adds the values of corresponding elements of the two source SIMD&amp;FP registers, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQADD <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean unsigned = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

|   size | <V>   |
|--------|-------|
|     00 | B     |
|     01 | H     |
|     10 | S     |
|     11 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |
|     10 |   1 | 4S    |

&lt;Vn&gt;

|   size |   Q | <T>      |
|--------|-----|----------|
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer sum; boolean sat; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); sum = element1 + element2; (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.434 UQRSHL

Unsigned saturating rounding shift left (register)

This instruction takes each vector element of the first source SIMD&amp;FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are rounded. For truncated results, see UQSHL.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQRSHL <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if S == '0' && size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean unsigned = TRUE; constant boolean rounding = TRUE; constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQRSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean unsigned = TRUE; constant boolean rounding = TRUE; constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

|   size | <V>   |
|--------|-------|
|     00 | B     |
|     01 | H     |
|     10 | S     |
|     11 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |

&lt;Vn&gt;

|   size |   Q | <T>      |
|--------|-----|----------|
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; boolean sat; for e = 0 to elements-1 integer element = UInt(Elem[operand1, e, esize]); integer shift = ShiftSat(SInt(Elem[operand2, e, esize]<7:0>), esize); if shift >= 0 then // left shift element = element << shift; else // right shift shift = -shift; element = RShr(element, shift, rounding); (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.435 UQRSHRN, UQRSHRN2

Unsigned saturating rounded shift right narrow (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see UQSHRN.

The UQRSHRN instruction writes the vector to the lower half of the destination register and clears the upper half. The UQRSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQRSHRN <Vb><d>, <Va><n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh == '0000' then EndOfDecode(Decode_UNDEF); if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = esize; constant integer elements = 1; constant integer part = 0; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = TRUE; constant boolean unsigned = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQRSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = TRUE; constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;Vb&gt;

Is the destination width specifier, encoded in 'immh':

| immh   | <Vb>     |
|--------|----------|
| 0001   | B        |
| 001x   | H        |
| 01xx   | S        |
| 1xxx   | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'immh':

&lt;d&gt;

&lt;Va&gt;

&lt;n&gt;

| immh   | <Va>     |
|--------|----------|
| 0001   | H        |
| 001x   | S        |
| 01xx   | D        |
| 1xxx   | RESERVED |

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to the destination operand width in bits, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

For the 'Vector' variant: is the right shift amount, in the range 1 to the destination element width in bits, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

- 2 Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the

registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <Tb>   |
|--------|-----|--------|
| 0001   |   0 | 8B     |
| 0001   |   1 | 16B    |
| 001x   |   0 | 4H     |

## &lt;Vd&gt;

## &lt;Tb&gt;

&lt;Vn&gt;

&lt;Ta&gt;

Is an arrangement specifier, encoded in 'immh':

| immh   | <Ta>     |
|--------|----------|
| 0001   | 8H       |
| 001x   | 4S       |
| 01xx   | 2D       |
| 1xxx   | RESERVED |

```
esize);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize*2) operand = V[n, datasize*2]; bits(datasize) result; boolean sat; for e = 0 to elements-1 constant bits(2*esize) opelt = Elem[operand, e, 2*esize]; if unsigned then constant integer element = RShr(UInt(opelt), shift, round); (Elem[result, e, esize], sat) = UnsignedSatQ(element, else constant integer element = RShr(SInt(opelt), shift, round); (Elem[result, e, esize], sat) = SignedSatQ(element, esize); if sat then FPSR.QC = '1'; Vpart[d, part, datasize] = result;
```

| immh   | Q   | <Tb>     |
|--------|-----|----------|
| 001x   | 1   | 8H       |
| 01xx   | 0   | 2S       |
| 01xx   | 1   | 4S       |
| 1xxx   | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.436 UQSHL (immediate)

Unsigned saturating shift left (immediate)

This instruction takes each vector element in the source SIMD&amp;FP register, shifts it by an immediate value, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. The results are truncated. For rounded results, see UQRSHL.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQSHL <V><d>, <V><n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh == '0000' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = esize; constant integer elements = 1; constant integer shift = UInt(immh:immb) esize; constant boolean src_unsigned = TRUE; constant boolean dst_unsigned = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQSHL <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = UInt(immh:immb) esize; constant boolean src_unsigned = TRUE; constant boolean dst_unsigned = TRUE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'immh':

&lt;d&gt;

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the left shift amount, in the range 0 to the operand width in bits minus 1, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | UInt(immh:immb) - 8  |
| 001x   | UInt(immh:immb) - 16 |
| 01xx   | UInt(immh:immb) - 32 |
| 1xxx   | UInt(immh:immb) - 64 |

For the 'Vector' variant: is the left shift amount, in the range 0 to the element width in bits minus 1, encoded in 'immh:immb':

| immh   | <V>   |
|--------|-------|
| 0001   | B     |
| 001x   | H     |
| 01xx   | S     |
| 1xxx   | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

| immh   | <shift>              |
|--------|----------------------|
| 0001   | UInt(immh:immb) - 8  |
| 001x   | UInt(immh:immb) - 16 |
| 01xx   | UInt(immh:immb) - 32 |
| 1xxx   | UInt(immh:immb) - 64 |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>      |
|--------|-----|----------|
| 0001   |   0 | 8B       |
| 0001   |   1 | 16B      |
| 001x   |   0 | 4H       |
| 001x   |   1 | 8H       |
| 01xx   |   0 | 2S       |
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; boolean sat; for e = 0 to elements-1 constant bits(esize) opelt = Elem[operand, e, esize]; constant integer element = if src_unsigned then UInt(opelt) else SInt(opelt); (Elem[result, e, esize], sat) = SatQ(element << shift, esize, dst_unsigned); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.437 UQSHL (register)

Unsigned saturating shift left (register)

This instruction takes each element in the vector of the first source SIMD&amp;FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register.

If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are truncated. For rounded results, see UQRSHL.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQSHL <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if S == '0' && size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean unsigned = TRUE; constant boolean rounding = FALSE; constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean unsigned = TRUE; constant boolean rounding = FALSE; constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

|   size | <V>   |
|--------|-------|
|     00 | B     |
|     01 | H     |
|     10 | S     |
|     11 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |

&lt;Vn&gt;

|   size |   Q | <T>      |
|--------|-----|----------|
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; boolean sat; for e = 0 to elements-1 integer element = UInt(Elem[operand1, e, esize]); integer shift = ShiftSat(SInt(Elem[operand2, e, esize]<7:0>), esize); if shift >= 0 then // left shift element = element << shift; else // right shift shift = -shift; element = RShr(element, shift, rounding); (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.438 UQSHRN, UQSHRN2

Unsigned saturating shift right narrow (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see UQRSHRN.

The UQSHRN instruction writes the vector to the lower half of the destination register and clears the upper half. The UQSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQSHRN <Vb><d>, <Va><n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh == '0000' then EndOfDecode(Decode_UNDEF); if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = esize; constant integer elements = 1; constant integer part = 0; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = FALSE; constant boolean unsigned = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (2 * esize) UInt(immh:immb); constant boolean round = FALSE; constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;Vb&gt;

Is the destination width specifier, encoded in 'immh':

| immh   | <Vb>     |
|--------|----------|
| 0001   | B        |
| 001x   | H        |
| 01xx   | S        |
| 1xxx   | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'immh':

&lt;d&gt;

&lt;Va&gt;

&lt;n&gt;

| immh   | <Va>     |
|--------|----------|
| 0001   | H        |
| 001x   | S        |
| 01xx   | D        |
| 1xxx   | RESERVED |

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to the destination operand width in bits, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

For the 'Vector' variant: is the right shift amount, in the range 1 to the destination element width in bits, encoded in 'immh:immb':

| immh   | <shift>              |
|--------|----------------------|
| 0001   | 16 - UInt(immh:immb) |
| 001x   | 32 - UInt(immh:immb) |
| 01xx   | 64 - UInt(immh:immb) |
| 1xxx   | RESERVED             |

- 2 Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the

registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <Tb>   |
|--------|-----|--------|
| 0001   |   0 | 8B     |
| 0001   |   1 | 16B    |
| 001x   |   0 | 4H     |

## &lt;Vd&gt;

## &lt;Tb&gt;

## &lt;Vn&gt;

&lt;Ta&gt;

Is an arrangement specifier, encoded in 'immh':

| immh   | <Ta>     |
|--------|----------|
| 0001   | 8H       |
| 001x   | 4S       |
| 01xx   | 2D       |
| 1xxx   | RESERVED |

```
esize);
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize*2) operand = V[n, datasize*2]; bits(datasize) result; boolean sat; for e = 0 to elements-1 constant bits(2*esize) opelt = Elem[operand, e, 2*esize]; if unsigned then constant integer element = RShr(UInt(opelt), shift, round); (Elem[result, e, esize], sat) = UnsignedSatQ(element, else constant integer element = RShr(SInt(opelt), shift, round); (Elem[result, e, esize], sat) = SignedSatQ(element, esize); if sat then FPSR.QC = '1'; Vpart[d, part, datasize] = result;
```

| immh   | Q   | <Tb>     |
|--------|-----|----------|
| 001x   | 1   | 8H       |
| 01xx   | 0   | 2S       |
| 01xx   | 1   | 4S       |
| 1xxx   | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## C7.2.439 UQSUB

Unsigned saturating subtract

This instruction subtracts the element values of the second source SIMD&amp;FP register from the corresponding element values of the first source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQSUB <V><d>, <V><n>, <V><m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean unsigned = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

|   size | <V>   |
|--------|-------|
|     00 | B     |
|     01 | H     |
|     10 | S     |
|     11 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>   |
|--------|-----|-------|
|     00 |   0 | 8B    |
|     00 |   1 | 16B   |
|     01 |   0 | 4H    |
|     01 |   1 | 8H    |
|     10 |   0 | 2S    |
|     10 |   1 | 4S    |

&lt;Vn&gt;

|   size |   Q | <T>      |
|--------|-----|----------|
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer diff; boolean sat; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); diff = element1 -element2; (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned); if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

## C7.2.440 UQXTN, UQXTN2

Unsigned saturating extract narrow

This instruction reads each vector element from the source SIMD&amp;FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The UQXTN instruction writes the vector to the lower half of the destination register and clears the upper half. The UQXTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UQXTN <Vb><d>, <Va><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer part = 0; constant integer elements = 1; constant boolean unsigned = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

UQXTN{2}

&lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = TRUE;
```

## Assembler Symbols

## &lt;Vb&gt;

Is the destination width specifier, encoded in 'size':

&lt;d&gt;

&lt;Va&gt;

&lt;n&gt;

2

|   size | <Vb>     |
|--------|----------|
|     00 | B        |
|     01 | H        |
|     10 | S        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the source width specifier, encoded in 'size':

|   size | <Va>     |
|--------|----------|
|     00 | H        |
|     01 | S        |
|     10 | D        |
|     11 | RESERVED |

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

&lt;Vd&gt;

&lt;Tb&gt;

## &lt;Vn&gt;

## &lt;Ta&gt;

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand = V[n, 2*datasize]; bits(datasize) result; bits(2*esize) element; boolean sat; for e = 0 to elements-1 element = Elem[operand, e, 2*esize]; (Elem[result, e, esize], sat) = if sat then FPSR.QC = '1'; Vpart[d, part, datasize] = result;
```

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

```
SatQ(UInt(element), esize, unsigned);
```

## C7.2.441 URECPE

Unsigned reciprocal estimate

This instruction reads each vector element from the source SIMD&amp;FP register, calculates an approximate inverse for the unsigned integer value, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
URECPE <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer esize = 32; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'sz:Q':

|   sz | Q   | <T>      |
|------|-----|----------|
|    0 | 0   | 2S       |
|    0 | 1   | 4S       |
|    1 | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

<!-- image -->

&lt;T&gt;

&lt;Vn&gt;

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; bits(32) element; for e = 0 to elements-1 element = Elem[operand, e, 32]; Elem[result, e, 32] = V[d, datasize] = result;
```

```
UnsignedRecipEstimate(element);
```

## C7.2.442 URHADD

Unsigned rounding halving add

This instruction adds corresponding unsigned integer values from the two source SIMD&amp;FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.

The results are rounded. For truncated results, see UHADD.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers of the same type

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
URHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <T>      |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

<!-- image -->

&lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); sum = (element1 + element2 + 1) >> 1; Elem[result, e, esize] = sum<esize-1:0>; V[d, datasize] = result;
```

## C7.2.443 URSHL

Unsigned rounding shift left (register)

This instruction takes each element in the vector of the first source SIMD&amp;FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register.

If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

<!-- image -->

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if S == '0' && size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean rounding = TRUE; constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
URSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean rounding = TRUE; constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

## Operation

```
ShiftSat(SInt(Elem[operand2, e, esize]<7:0>), esize);
```

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; for e = 0 to elements-1 integer element = UInt(Elem[operand1, e, esize]); integer shift = if shift >= 0 then // left shift element = element << shift; else // right shift shift = -shift; element = RShr(element, shift, rounding); Elem[result, e, esize] = element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.444 URSHR

Unsigned rounding shift right (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see USHR.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
URSHR D<d>, D<n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> != '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << 3; constant integer datasize = esize; constant integer elements = 1; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = TRUE; constant boolean round = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
URSHR <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = TRUE; constant boolean round = TRUE;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to 64, encoded as 128 - UInt('immh:immb') .

For the 'Vector' variant: is the right shift amount, in the range 1 to the element width in bits, encoded in 'immh:immb':

| immh   | <shift>               |
|--------|-----------------------|
| 0001   | 16 - UInt(immh:immb)  |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>   |
|--------|-----|-------|
| 0001   |   0 | 8B    |
| 0001   |   1 | 16B   |
| 001x   |   0 | 4H    |
| 001x   |   1 | 8H    |
| 01xx   |   0 | 2S    |

## &lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

| immh   |   Q | <T>      |
|--------|-----|----------|
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 constant bits(esize) opelt = Elem[operand, e, esize]; if unsigned then element = RShr(UInt(opelt), shift, round); else element = RShr(SInt(opelt), shift, round); Elem[result, e, esize] = element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.445 URSQRTE

Unsigned reciprocal square root estimate

This instruction reads each vector element from the source SIMD&amp;FP register, calculates an approximate inverse square root for each value, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
URSQRTE <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); if sz == '1' then EndOfDecode(Decode_UNDEF); constant integer esize = 32; constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'sz:Q':

|   sz | Q   | <T>      |
|------|-----|----------|
|    0 | 0   | 2S       |
|    0 | 1   | 4S       |
|    1 | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;T&gt;

&lt;Vn&gt;

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; bits(32) element; for e = 0 to elements-1 element = Elem[operand, e, 32]; Elem[result, e, 32] = V[d, datasize] = result;
```

```
UnsignedRSqrtEstimate(element);
```

## C7.2.446 URSRA

Unsigned rounding shift right and accumulate (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see USRA.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
URSRA D<d>, D<n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> != '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << 3; constant integer datasize = esize; constant integer elements = 1; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = TRUE; constant boolean round = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
URSRA <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = TRUE; constant boolean round = TRUE;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to 64, encoded as 128 - UInt('immh:immb') .

For the 'Vector' variant: is the right shift amount, in the range 1 to the element width in bits, encoded in 'immh:immb':

| immh   | <shift>               |
|--------|-----------------------|
| 0001   | 16 - UInt(immh:immb)  |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>   |
|--------|-----|-------|
| 0001   |   0 | 8B    |
| 0001   |   1 | 16B   |
| 001x   |   0 | 4H    |
| 001x   |   1 | 8H    |
| 01xx   |   0 | 2S    |

## &lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

| immh   |   Q | <T>      |
|--------|-----|----------|
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant bits(datasize) operand2 = V[d, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 constant bits(esize) opelt = Elem[operand, e, esize]; if unsigned then element = RShr(UInt(opelt), shift, round); else element = RShr(SInt(opelt), shift, round); Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.447 USDOT (by element)

Dot product with unsigned and signed integers (vector, by element)

This instruction performs the dot product of the four unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination register.

From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID\_AA64ISAR1\_EL1.I8MM indicates whether this instruction is supported.

## Vector

(FEAT\_I8MM)

<!-- image -->

## Encoding

```
USDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_I8MM) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer m = UInt(M:Rm); constant integer d = UInt(Rd); constant integer i = UInt(H:L); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV 32;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP third source and destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

&lt;Vn&gt;

<!-- image -->

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'M:Rm' fields.

## &lt;index&gt;

Is the immediate index of a 32-bit group of four 8-bit values, in the range 0 to 3, encoded in the 'H:L' fields.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(128) operand2 = V[m, 128]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; for e = 0 to elements-1 bits(32) res = Elem[operand3, e, 32]; for b = 0 to 3 constant integer element1 = UInt(Elem[operand1, 4 * e + b, 8]); constant integer element2 = SInt(Elem[operand2, 4 * i + b, 8]); res = res + element1 * element2; Elem[result, e, 32] = res; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   Q | <Tb>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

## C7.2.448 USDOT (vector)

Dot product with unsigned and signed integers (vector)

This instruction performs the dot product of the four unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer values in the corresponding 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination register.

From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID\_AA64ISAR1\_EL1.I8MM indicates whether this instruction is supported.

## Vector

(FEAT\_I8MM)

<!-- image -->

## Encoding

```
USDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_I8MM) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV 32;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP third source and destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Ta&gt;

&lt;Vn&gt;

&lt;Tb&gt;

|   Q | <Ta>   |
|-----|--------|
|   0 | 2S     |
|   1 | 4S     |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'Q':

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; constant bits(datasize) operand3 = V[d, datasize]; bits(datasize) result; for e = 0 to elements-1 bits(32) res = Elem[operand3, e, 32]; for b = 0 to 3 constant integer element1 = UInt(Elem[operand1, 4 * e + b, 8]); constant integer element2 = SInt(Elem[operand2, 4 * e + b, 8]); res = res + element1 * element2; Elem[result, e, 32] = res; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   Q | <Tb>   |
|-----|--------|
|   0 | 8B     |
|   1 | 16B    |

## C7.2.449 USHL

Unsigned shift left (register)

This instruction takes each element in the vector of the first source SIMD&amp;FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register.

If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift. For a rounding shift, see URSHL.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
USHL D<d>, D<n>, D<m>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if S == '0' && size != '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean rounding = FALSE; constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
USHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean rounding = FALSE; constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the number of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

&lt;n&gt;

&lt;m&gt;

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

## Operation

```
ShiftSat(SInt(Elem[operand2, e, esize]<7:0>), esize);
```

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; for e = 0 to elements-1 integer element = UInt(Elem[operand1, e, esize]); integer shift = if shift >= 0 then // left shift element = element << shift; else // right shift shift = -shift; element = RShr(element, shift, rounding); Elem[result, e, esize] = element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.450 USHLL, USHLL2

Unsigned shift left long (immediate)

This instruction reads each vector element in the lower or upper half of the source SIMD&amp;FP register, shifts the unsigned integer value left by the specified number of bits, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements.

The USHLL instruction extracts vector elements from the lower half of the source register. The USHLL2 instruction extracts vector elements from the upper half of the source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This instruction is used by the alias UXTL, UXTL2.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
USHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if immh<3> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh<2:0>); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = UInt(immh:immb) esize; constant boolean unsigned = TRUE;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

## &lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'immh':

Alias Conditions

| immh   | <Ta>     |
|--------|----------|
| 0001   | 8H       |
| 001x   | 4S       |
| 01xx   | 2D       |
| 1xxx   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   | Q   | <Tb>     |
|--------|-----|----------|
| 0001   | 0   | 8B       |
| 0001   | 1   | 16B      |
| 001x   | 0   | 4H       |
| 001x   | 1   | 8H       |
| 01xx   | 0   | 2S       |
| 01xx   | 1   | 4S       |
| 1xxx   | x   | RESERVED |

## &lt;shift&gt;

Is the left shift amount, in the range 0 to the source element width in bits minus 1, encoded in 'immh:immb':

| immh   | <shift>           |
|--------|-------------------|
| 0001   | UInt(immh:immb) - |
| 001x   | UInt(immh:immb) - |
| 01xx   | UInt(immh:immb) - |
| 1xxx   | RESERVED          |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = Vpart[n, part, datasize]; bits(datasize*2) result; for e = 0 to elements-1 constant bits(esize) opelt = Elem[operand, e, esize]; constant integer element = if unsigned then UInt(opelt) else SInt(opelt); Elem[result, e, 2*esize] = (element << shift)<2*esize-1:0>; V[d, datasize*2] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias       | Is preferred when                    |
|-------------|--------------------------------------|
| UXTL, UXTL2 | immb == '000' && BitCount(immh) == 1 |

## C7.2.451 USHR

Unsigned shift right (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see URSHR.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
USHR D<d>, D<n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> != '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << 3; constant integer datasize = esize; constant integer elements = 1; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = TRUE; constant boolean round = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
USHR <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = TRUE; constant boolean round = FALSE;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to 64, encoded as 128 - UInt('immh:immb') .

For the 'Vector' variant: is the right shift amount, in the range 1 to the element width in bits, encoded in 'immh:immb':

| immh   | <shift>               |
|--------|-----------------------|
| 0001   | 16 - UInt(immh:immb)  |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>   |
|--------|-----|-------|
| 0001   |   0 | 8B    |
| 0001   |   1 | 16B   |
| 001x   |   0 | 4H    |
| 001x   |   1 | 8H    |
| 01xx   |   0 | 2S    |

## &lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

| immh   |   Q | <T>      |
|--------|-----|----------|
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 constant bits(esize) opelt = Elem[operand, e, esize]; if unsigned then element = RShr(UInt(opelt), shift, round); else element = RShr(SInt(opelt), shift, round); Elem[result, e, esize] = element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.452 USMMLA (vector)

Unsigned and signed 8-bit integer matrix multiply-accumulate to 32-bit integer (vector)

This instruction multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element.

From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID\_AA64ISAR1\_EL1.I8MM indicates whether this instruction is supported.

## Vector

(FEAT\_I8MM)

<!-- image -->

## Encoding

```
USMMLA <Vd>.4S, <Vn>.16B, <Vm>.16B
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_I8MM) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean op1_unsigned = TRUE; constant boolean op2_unsigned = FALSE;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP third source and destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) operand1 = V[n, 128]; constant bits(128) operand2 = V[m, 128]; constant bits(128) addend = V[d, 128]; V[d, 128] = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned);
```

## Operational Information

Arm expects that the USMMLA (vector) instruction will deliver a peak integer multiply throughput that is at least as high as can be achieved using two USDOT (vector) instructions, with a goal that it should have significantly higher throughput.

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

## C7.2.453 USQADD

Unsigned saturating accumulate of signed value

This instruction adds the signed integer values of the vector elements in the source SIMD&amp;FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&amp;FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&amp;FP register.

If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
USQADD <V><d>, <V><n>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = esize; constant integer elements = 1; constant boolean unsigned = TRUE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
USQADD <Vd>.<T>, <Vn>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant boolean unsigned = TRUE;
```

## Assembler Symbols

&lt;V&gt;

Is a width specifier, encoded in 'size':

&lt;d&gt;

&lt;n&gt;

&lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

|   size | <V>   |
|--------|-------|
|     00 | B     |
|     01 | H     |
|     10 | S     |
|     11 | D     |

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is the number of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; bits(datasize) result; constant bits(datasize) operand2 = V[d, datasize]; integer op1; integer op2; boolean sat; for e = 0 to elements-1 op1 = SInt(Elem[operand, e, esize]); op2 = UInt(Elem[operand2, e, esize]); (Elem[result, e, esize], sat) = SatQ(op1 + op2, if sat then FPSR.QC = '1'; V[d, datasize] = result;
```

```
esize, unsigned);
```

## C7.2.454 USRA

Unsigned shift right and accumulate (immediate)

This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see URSRA.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

It has encodings from 2 classes: Scalar and Vector

## Scalar

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
USRA D<d>, D<n>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3> != '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << 3; constant integer datasize = esize; constant integer elements = 1; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = TRUE; constant boolean round = FALSE;
```

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
USRA <Vd>.<T>, <Vn>.<T>, #<shift>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if immh<3>:Q == '10' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << HighestSetBitNZ(immh); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer shift = (esize * 2) -UInt(immh:immb); constant boolean unsigned = TRUE; constant boolean round = FALSE;
```

## Assembler Symbols

&lt;d&gt;

Is the number of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;n&gt;

Is the number of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the 'Scalar' variant: is the right shift amount, in the range 1 to 64, encoded as 128 - UInt('immh:immb') .

For the 'Vector' variant: is the right shift amount, in the range 1 to the element width in bits, encoded in 'immh:immb':

| immh   | <shift>               |
|--------|-----------------------|
| 0001   | 16 - UInt(immh:immb)  |
| 001x   | 32 - UInt(immh:immb)  |
| 01xx   | 64 - UInt(immh:immb)  |
| 1xxx   | 128 - UInt(immh:immb) |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   |   Q | <T>   |
|--------|-----|-------|
| 0001   |   0 | 8B    |
| 0001   |   1 | 16B   |
| 001x   |   0 | 4H    |
| 001x   |   1 | 8H    |
| 01xx   |   0 | 2S    |

## &lt;Vd&gt;

&lt;T&gt;

&lt;Vn&gt;

| immh   |   Q | <T>      |
|--------|-----|----------|
| 01xx   |   1 | 4S       |
| 1xxx   |   0 | RESERVED |
| 1xxx   |   1 | 2D       |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand = V[n, datasize]; constant bits(datasize) operand2 = V[d, datasize]; bits(datasize) result; integer element; for e = 0 to elements-1 constant bits(esize) opelt = Elem[operand, e, esize]; if unsigned then element = RShr(UInt(opelt), shift, round); else element = RShr(SInt(opelt), shift, round); Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.455 USUBL, USUBL2

Unsigned subtract long

This instruction subtracts each vector element in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector element of the first source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements.

The USUBL instruction extracts each source vector from the lower half of each source register. The USUBL2 instruction extracts each source vector from the upper half of each source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
USUBL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF);
```

```
if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

<!-- image -->

&lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = Vpart[n, part, datasize]; constant bits(datasize) operand2 = Vpart[m, part, datasize]; bits(2*datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, esize]); element2 = UInt(Elem[operand2, e, esize]); sum = element1 - element2; Elem[result, e, 2*esize] = sum<2*esize-1:0>; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.456 USUBW, USUBW2

Unsigned subtract wide

This instruction subtracts each vector element in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector element in the first source SIMD&amp;FP register, places the result in a vector, and writes the vector to the SIMD&amp;FP destination register. All the values in this instruction are unsigned integer values.

The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register.

The USUBW instruction extracts vector elements from the lower half of the second source register. The USUBW2 instruction extracts vector elements from the upper half of the second source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Three registers, not all the same type (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
USUBW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

<!-- image -->

## &lt;Ta&gt;

## &lt;Vn&gt;

Is an arrangement specifier, encoded in 'size':

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand1 = V[n, 2*datasize]; constant bits(datasize) operand2 = bits(2*datasize) result; integer element1; integer element2; integer sum; for e = 0 to elements-1 element1 = UInt(Elem[operand1, e, 2*esize]); element2 = UInt(Elem[operand2, e, esize]); sum = element1 - element2; Elem[result, e, 2*esize] = sum<2*esize-1:0>; V[d, 2*datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;Tb&gt;

```
Vpart[m, part, datasize];
```

## C7.2.457 UXTL, UXTL2

Unsigned extend long

This instruction copies each vector element from the lower or upper half of the source SIMD&amp;FP register into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements.

The UXTL instruction extracts vector elements from the lower half of the source register. The UXTL2 instruction extracts vector elements from the upper half of the source register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

This is an alias of USHLL, USHLL2. This means:

- The encodings in this description are named to match the encodings of USHLL, USHLL2.
- The description of USHLL, USHLL2 gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Vector

## (FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
UXTL{2} <Vd>.<Ta>, <Vn>.<Tb>
```

## is equivalent to

```
USHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #0
```

and is the preferred disassembly when BitCount(immh) == 1 .

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Ta&gt;

## &lt;Vn&gt;

## &lt;Tb&gt;

Is an arrangement specifier, encoded in 'immh':

| immh   | <Ta>     |
|--------|----------|
| 0001   | 8H       |
| 001x   | 4S       |
| 01xx   | 2D       |
| 1xxx   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'immh:Q':

| immh   | Q   | <Tb>     |
|--------|-----|----------|
| 0001   | 0   | 8B       |
| 0001   | 1   | 16B      |
| 001x   | 0   | 4H       |
| 001x   | 1   | 8H       |
| 01xx   | 0   | 2S       |
| 01xx   | 1   | 4S       |
| 1xxx   | x   | RESERVED |

## Operation

The description of USHLL, USHLL2 gives the operational pseudocode for this instruction.

## Operational Information

The description of USHLL, USHLL2 gives the operational information for this instruction.

## C7.2.458 UZP1

Unzip vectors (primary)

This instruction reads corresponding even-numbered vector elements from the two source SIMD&amp;FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&amp;FP register.

Note

Figure C7-7 UZP1 and UZP2 with the arrangement specifier 8B

<!-- image -->

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding

```
UZP1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = UInt(op);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operandl = V[n, datasize]; constant bits(datasize) operandh = V[m, datasize]; bits(datasize) result; constant bits(datasize*2) zipped = operandh:operandl; for e = 0 to elements-1 Elem[result, e, esize] = Elem[zipped, 2*e+part, esize]; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

&lt;T&gt;

&lt;Vn&gt;

## C7.2.459 UZP2

Unzip vectors (secondary)

This instruction reads corresponding odd-numbered vector elements from the two source SIMD&amp;FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&amp;FP register.

Note

Figure C7-8 UZP1 and UZP2 with the arrangement specifier 8B

<!-- image -->

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

<!-- image -->

## Encoding

```
UZP2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = UInt(op);
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operandl = V[n, datasize]; constant bits(datasize) operandh = V[m, datasize]; bits(datasize) result; constant bits(datasize*2) zipped = operandh:operandl; for e = 0 to elements-1 Elem[result, e, esize] = Elem[zipped, 2*e+part, esize]; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

&lt;T&gt;

&lt;Vn&gt;

## C7.2.460 XAR

Exclusive-OR and rotate

This instruction performs a bitwise exclusive-OR of the 128-bit vectors in the two source SIMD&amp;FP registers, rotates each 64-bit element of the resulting 128-bit vector right by the value specified by a 6-bit immediate value, and writes the result to the destination SIMD&amp;FP register.

## Advanced SIMD

(FEAT\_SHA3)

<!-- image -->

| 31 28 27 25 24 23   | 22 21 20   | 10   | 5 4   | 0   |
|---------------------|------------|------|-------|-----|
| 1 1 0 0 1 1 1 0 1   | 0 0 Rm     | imm6 | Rn    | Rd  |

## Encoding

```
XAR <Vd>.2D, <Vn>.2D, <Vm>.2D, #<imm6>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SHA3) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

## &lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

## &lt;Vn&gt;

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

## &lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## &lt;imm6&gt;

Is a rotation right, encoded in 'imm6'.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(128) Vm = V[m, 128]; constant bits(128) Vn = V[n, 128]; constant bits(128) tmp = Vn EOR Vm; V[d, 128] = ROR(tmp<127:64>, UInt(imm6)):ROR(tmp<63:0>, UInt(imm6));
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

## C7.2.461 XTN, XTN2

Extract narrow

This instruction reads each vector element from the source SIMD&amp;FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements.

The XTN instruction writes the vector to the lower half of the destination register and clears the upper half. The XTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register.

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Vector

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
XTN{2} <Vd>.<Tb>, <Vn>.<Ta>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size == '11' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer esize = 8 << UInt(size); constant integer datasize = 64; constant integer part = UInt(Q); constant integer elements = datasize DIV esize;
```

## Assembler Symbols

2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is encoded in 'Q':

|   Q | 2         |
|-----|-----------|
|   0 | [absent]  |
|   1 | [present] |

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

&lt;Vd&gt;

&lt;Tb&gt;

## &lt;Vn&gt;

&lt;Ta&gt;

Is an arrangement specifier, encoded in 'size:Q':

|   size | Q   | <Tb>     |
|--------|-----|----------|
|     00 | 0   | 8B       |
|     00 | 1   | 16B      |
|     01 | 0   | 4H       |
|     01 | 1   | 8H       |
|     10 | 0   | 2S       |
|     10 | 1   | 4S       |
|     11 | x   | RESERVED |

Is the name of the SIMD&amp;FP source register, encoded in the 'Rn' field.

Is an arrangement specifier, encoded in 'size':

|   size | <Ta>     |
|--------|----------|
|     00 | 8H       |
|     01 | 4S       |
|     10 | 2D       |
|     11 | RESERVED |

```
V[n, 2*datasize];
```

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(2*datasize) operand = bits(datasize) result; bits(2*esize) element; for e = 0 to elements-1 element = Elem[operand, e, 2*esize]; Elem[result, e, esize] = element<esize-1:0>; Vpart[d, part, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C7.2.462 ZIP1

Zip vectors (primary)

This instruction reads adjacent vector elements from the lower half of two source SIMD&amp;FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&amp;FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.

Note

Figure C7-9 ZIP1 and ZIP2 with the arrangement specifier 8B

<!-- image -->

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ZIP1
```

```
<Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = UInt(op); constant integer pairs = elements DIV 2;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; constant integer base = part * pairs; for p = 0 to pairs-1 Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize]; Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize]; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

&lt;T&gt;

&lt;Vn&gt;

## C7.2.463 ZIP2

Zip vectors (secondary)

This instruction reads adjacent vector elements from the upper half of two source SIMD&amp;FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&amp;FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.

Note

Figure C7-10 ZIP1 and ZIP2 with the arrangement specifier 8B

<!-- image -->

Depending on the settings in the CPACR\_EL1, CPTR\_EL2, and CPTR\_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.

## Advanced SIMD

(FEAT\_AdvSIMD)

<!-- image -->

## Encoding

```
ZIP2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_AdvSIMD) then EndOfDecode(Decode_UNDEF); if size:Q == '110' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer esize = 8 << UInt(size); constant integer datasize = 64 << UInt(Q); constant integer elements = datasize DIV esize; constant integer part = UInt(op); constant integer pairs = elements DIV 2;
```

## Assembler Symbols

&lt;Vd&gt;

Is the name of the SIMD&amp;FP destination register, encoded in the 'Rd' field.

Is an arrangement specifier, encoded in 'size:Q':

|   size |   Q | <T>      |
|--------|-----|----------|
|     00 |   0 | 8B       |
|     00 |   1 | 16B      |
|     01 |   0 | 4H       |
|     01 |   1 | 8H       |
|     10 |   0 | 2S       |
|     10 |   1 | 4S       |
|     11 |   0 | RESERVED |
|     11 |   1 | 2D       |

Is the name of the first SIMD&amp;FP source register, encoded in the 'Rn' field.

&lt;Vm&gt;

Is the name of the second SIMD&amp;FP source register, encoded in the 'Rm' field.

## Operation

```
AArch64.CheckFPAdvSIMDEnabled(); constant bits(datasize) operand1 = V[n, datasize]; constant bits(datasize) operand2 = V[m, datasize]; bits(datasize) result; constant integer base = part * pairs; for p = 0 to pairs-1 Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize]; Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize]; V[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

&lt;T&gt;

&lt;Vn&gt;

## Chapter C8 SVE Instruction Descriptions

This chapter describes the SVE instructions. It contains the following sections:

- About the SVE instructions.
- Alphabetical list of SVE instructions.