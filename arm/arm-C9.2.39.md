## C9.2.39 BFMOP4A (widening)

BFloat16 quarter-tile sum of outer products to single-precision, accumulating

This instruction generates four independent quarter-tile BFloat16 sums of outer products from the sub-matrices in the half-vectors of the one or two first and second source vectors and accumulates the results to the corresponding elements of a 32-bit element ZA tile.

Each of the quarter-tile sums of outer products is generated by multiplying the SVLS÷2 × 2 sub-matrix of BFloat16 values held in the half-vectors of the first source vectors by the 2 × SVLS÷2 sub-matrix of BFloat16 values held in the half-vectors of the second source vectors. Each 32-bit container of the first source vectors holds 2 elements of each row of a SVLS÷2 × 2 sub-matrix. Similarly, each 32-bit container of the second source vectors holds 2 elements of each column of a 2 × SVLS÷2 sub-matrix.

The instruction widens the sub-matrices of BFloat16 values held in the first source vectors to single-precision values and multiplies them by the corresponding widened sub-matrices of BFloat16 values in the second source vectors to single-precision values. The resulting quarter-tile SVLS÷2 × SVLS÷2 single-precision sums of outer products are then destructively added to the single-precision destination tile. This is equivalent to performing a 2-way dot product and accumulate to each of the destination tile elements.

This instruction follows SME BFloat16 numerical behaviors.

This instruction is unpredicated.

It has encodings from 4 classes: Single and multiple vectors, Single vectors, Multiple and single vectors, and Multiple vectors

## Single and multiple vectors

(FEAT\_SME\_MOP4)

<!-- image -->

## Encoding

```
BFMOP4A <ZAda>.S, <Zn>.H, { <Zm1>.H-<Zm2>.H }
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) then EndOfDecode(Decode_UNDEF); constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 1; constant integer mreg = 2; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE;
```

## Single vectors

(FEAT\_SME\_MOP4)

<!-- image -->

## Encoding

```
BFMOP4A <ZAda>.S, <Zn>.H, <Zm>.H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) then EndOfDecode(Decode_UNDEF);
```

```
constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 1; constant integer mreg = 1; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE;
```

## Multiple and single vectors

(FEAT\_SME\_MOP4)

<!-- image -->

## Encoding

```
BFMOP4A <ZAda>.S, { <Zn1>.H-<Zn2>.H }, <Zm>.H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) then EndOfDecode(Decode_UNDEF); constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 2; constant integer mreg = 1; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE;
```

## Multiple vectors

(FEAT\_SME\_MOP4)

<!-- image -->

## Encoding

```
BFMOP4A <ZAda>.S, { <Zn1>.H-<Zn2>.H }, { <Zm1>.H-<Zm2>.H }
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) then EndOfDecode(Decode_UNDEF); constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 2; constant integer mreg = 2; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE;
```

## Assembler Symbols

## &lt;ZAda&gt;

Is the name of the ZA tile ZA0-ZA3, encoded in the 'ZAda' field.

## &lt;Zn&gt;

Is the name of the first source scalable vector register, registers in the range Z0-Z15, encoded as 'Zn' times 2.

## &lt;Zm1&gt;

Is the name of the first scalable vector register of the second source multi-vector group, in the range Z16-Z31, encoded as 'Zm' times 2 plus 16.

## &lt;Zm2&gt;

Is the name of the second scalable vector register of the second source multi-vector group, in the range Z16-Z31, encoded as 'Zm' times 2 plus 17.

## &lt;Zm&gt;

Is the name of the second source scalable vector register, registers in the range Z16-Z31, encoded as 'Zm' times 2 plus 16.

## &lt;Zn1&gt;

Is the name of the first scalable vector register of the first source multi-vector group, in the range Z0-Z15, encoded as 'Zn' times 2.

## &lt;Zn2&gt;

Is the name of the second scalable vector register of the first source multi-vector group, in the range Z0-Z15, encoded as 'Zn' times 2 plus 1.

## Operation

```
CheckStreamingSVEAndZAEnabled(); constant integer VL = CurrentVL; constant integer hvsize = VL DIV 2; constant integer dim = hvsize DIV 32; constant integer tilesize = 4*dim*dim*32; constant bits(tilesize) op3 = ZAtile[da, 32, bits(tilesize) result; for outprod = 0 to 3 constant integer row_hv = outprod DIV 2; constant integer col_hv = outprod MOD 2; constant integer row_base = row_hv * dim; constant integer col_base = col_hv * dim; constant bits(VL) op1 = Z[n constant bits(VL) op2 = Z[m for row = 0 to dim-1 for col = 0 to dim-1
```

```
tilesize]; + (nreg-1)*col_hv, VL]; + (mreg-1)*row_hv, VL];
```

```
constant integer row_idx = row_base + row; constant integer col_idx = col_base + col; constant integer tile_idx = row_idx * dim * 2 + col_idx; constant bits(32) sum = Elem[op3, tile_idx, 32]; bits(16) erow_0 = Elem[op1, 2*row_idx + 0, 16]; bits(16) erow_1 = Elem[op1, 2*row_idx + 1, 16]; constant bits(16) ecol_0 = Elem[op2, 2*col_idx + 0, 16]; constant bits(16) ecol_1 = Elem[op2, 2*col_idx + 1, 16]; if sub_op then constant boolean honor_altfp = FALSE; // Alternate handling ignored erow_0 = BFNeg(erow_0, honor_altfp); erow_1 = BFNeg(erow_1, honor_altfp); Elem[result, tile_idx, 32] = BFDotAdd(sum, erow_0, erow_1, ecol_0, ecol_1, FPCR); ZAtile[da, 32, tilesize] = result;
```