## B2.3 Ordering requirements defined by the formal concurrency model

The material presented in the current section corresponds to what is described in the formal concurrency model. The definitions of relations, including but not limited to Dependency-ordered-before, Barrier-ordered-before, or Atomic-ordered-before, are automatically transliterated from the formal concurrency model.

The Arm memory model introduces a number of relations which are as follows:

- Intrinsic relations ; For example, Intrinsic Data Dependencies, Intrinsic Control Dependencies, Intrinsic Order Dependencies and Translation-intrinsically-before are hardware requirements which stem from the instruction semantics.
- After relations ; For example, Coherence-after and TLBI-after are relations which happen to be oriented that way in a specific execution, but could be oriented the other way in a different execution.
- Observation relations ; For example, Explicit-Observed-by and TLBI-Observed-by build on After relations to describe an execution.
- Ordered relations ; For example, Ordered-before and TLBI-ordered-before are architectural requirements which must be respected by hardware in all executions.

This section describes observation and ordering in the Arm memory model. It contains the following subsections:

- Basic definitions.
- Intrinsic Dependency relations.
- Tag-check-intrinsically-before.
- Translation-intrinsically-before.
- Fetch-intrinsically-before.
- Dependency relations.
- Ordering relations.
- Observation relations.
- Definition of an Architecturally Allowed Execution.
- Alternative formulations of the External visibility requirement for Explicit Memory Effects.

For more information about endpoint ordering of memory accesses, see Reordering.

In the Arm memory model, the Shareability memory attribute indicates the degree to which hardware must ensure memory coherency between a set of observers. See Memory types and attributes.

The Arm architecture defines additional memory attributes and associated behaviors, which are defined in the system level section of this manual. See:

- The AArch64 System Level Memory Model.
- The AArch64 Virtual Memory System Architecture.

See also Mismatched memory attributes.

For the purposes of the memory model, all Effects generated due to execution of an instruction are considered to be generated by the PE on which the instruction is executed. The list of all Effects of an instruction in the scope of the Arm Memory Model is further presented in Effects.

In this section Ordering requirements defined by the formal concurrency model, all of the following are assumed:

- One of the following applies:
- -All PEs are part of the same Inner Shareable domain and all Memory Effects are to Inner Shareable or Outer Shareable memory as long as no barriers or TLB invalidations specify the Non-shareable domain.
- -All PEs are part of the same Outer Shareable domain and all Memory Effects are to Outer Shareable memory as long as no barriers or TLB invalidations specify the Non-shareable domain or the Inner Shareable domain.
- -All PEs are part of the Full System domain and all Memory Effects are to Normal, Inner Non-Cacheable, Outer Non-Cacheable memory or Device memory as long as all barriers specify the Full System domain and there are no TLB invalidations.

- All Memory Effects are to Normal, Inner Write-Back, Outer Write-Back memory. Behaviors in Ordering requirements defined by the formal concurrency model also apply to Memory Effects to memory with attributes other than Normal, Inner Write-Back, Outer Write-Back (for example, Device or Inner Write-Through, Outer Write-Through) as long as the behavior of the instruction which generated the Memory Effect is guaranteed for the memory type. For example, atomic instructions are only guaranteed to be atomic for Normal, Inner Write-Back, Outer Write-Back, Shareable memory. Memory Effects to memory with attributes other than Normal, Inner Write-Back, Outer Write-Back may require additional ordering behaviors than specified in Ordering requirements defined by the formal concurrency model. Such additional behaviors are described in Memory types and attributes.
- All Memory Effects to a given Location are not using mismatched memory attributes as described in Mismatched memory attributes.

## B2.3.1 Basic definitions

The Arm memory model provides a set of definitions that are used to construct conditions on the permitted sequences of accesses to memory.

## Location

## Effects

## Program order

## Register Effects

A Location is a Memory Location or a Tag Location. A Memory Location is a byte of data that is associated with an address in the physical address space. A Tag Location is a 4-bit MTE Allocation Tag that is associated with an address in the physical address space.

The Effects of an instruction can be:

- Register Effects.
- Memory Effects.
- Explicit Memory Effects.
- Implicit Translation Table Descriptor (TTD) Memory Effects.
- Hardware Update Effects.
- Tag Memory Effects.
- Implicit Instruction Memory Read Effects.
- Barrier Effects.
- Instruction Fetch Barrier Effects.
- Conditional Branching, and Intrinsic Branching Effects.
- Fault Effects, Exception Entry, and Exception Return Effects.
- TLBI Effects, Completed TLBI Effects and Invalidation Scopes.
- TLBUncacheable Effects.
- DCCVAUEffects.
- IC Effects, Completed IC Effects.
- Empty Effects.

An Effect E1 of an instruction I1 appears in program order before an Effect E2 of an instruction I2 if and only if I1 occurs before I2 in the order specified by the program. Each Effect generated by an instruction has a unique Effect identifier that characterizes it among the Effects generated by the same instruction.

The Register Effects of an instruction are register reads or register writes of that instruction. Register Effects only pertain to:

- General purpose registers from R0 to R30, excluding the zero register.
- SVE registers.
- SIMD/FP registers.
- PSTATE.NZCV.

## Memory Effects

The Memory Effects of an instruction are the Read or Write Effects from memory of that instruction. For an instruction that accesses memory, a Memory Read Effect is generated for each Location read from by the instruction and a Memory Write Effect is generated for each Location written to by the instruction. An instruction can generate both Memory Read and Write Effects.

## Explicit Memory Effects

An Explicit Memory Effect is a Memory Read or Memory Write Effect that is generated by one of the following:

- Aload instruction, store instruction, atomic instruction, Tag and Data store instruction, DC ZVA , DC GZVA , or STZGM ; to access the Memory Location(s) addressed by any of the following from the instruction:
- -The Xn|SP operand, plus any applicable offset.
- -The PC plus the offset specified by the &lt; label &gt; argument.
- ATag load instruction, Tag store instruction, Tag and Data store instruction, Bulk Allocation tag access instruction, DC GZVA , or DC GVA ; to access the Tag Location(s) addressed by the Xn|SP operand, plus any applicable offset, of the instruction.
- AMemory Copy or Memory Set instruction; to access the Memory Location(s) addressed by the Xs or Xd operand of the instruction, including all of the bytes within the range specified by the Xn operand of the instruction.
- AMemory Set with tag setting instruction; to access the Tag Location(s) addressed by the Xs or Xd operand of the instruction, including all of the Allocation tags within the range specified by the Xn operand of the instruction.
- An MRS or MSR instruction that is transformed into a Memory Effect due to FEAT\_NV2; to access the Memory Locations addressed by VNCR\_EL2 plus the offset for the specified register.

Note

Prefetch memory instructions do not generate any Explicit Memory Effects.

## Implicit Translation Table Descriptor Memory Effects

Implicit Translation Table Descriptor Memory Effects (Implicit TTD Memory Effects) are Memory Read or Write Effects to translation table descriptors caused by address translation, including the hardware updates for the Access Flag or the Dirty State of a TTD.

## Hardware Update Effects

Hardware Update Effects are Implicit TTD Memory Write Effects that correspond to writes modifying the Access Flag or the Dirty State of a TTD.

For more information on Hardware Updates of the Access Flag or Dirty State, see Hardware management of the Access flag and Hardware management of the dirty state.

Note

A Hardware Update Effect for the Access Flag may occur even in the absence of corresponding architecturally executed instructions, in which case the Hardware Update Effect is considered autonomous. Autonomous Hardware Update Effects are not constrained by the ordering relations that apply to the Hardware Update Effects of architecturally executed instructions.

## Tag Memory Effects

- Direct reads from System registers that are readable.
- Direct writes to System registers that are writable.
- Direct reads from Special-purpose registers that are readable.
- Direct writes to Special-purpose registers that are writable.

For an instruction that accesses registers, a Register Read Effect is generated for each register read by the instruction and a Register Write Effect is generated for each register written by the instruction. An instruction may generate both Register Read and Write Effects.

Tag Memory Effects are a subset of Memory Effects. A Tag Memory Effect refers to a Memory Read or Write Effect to a Tag Location. For example:

- LDG and LDGM instructions generate an Explicit Tag Memory Read Effect for their read from a Tag Location.
- STG , STGM , STGP , DC GZVA , and DC GVA instructions generate an Explicit Tag Memory Write Effect for their write to a Tag Location.
- ATag Checked memory access generates an Implicit Tag Memory Read Effect for its read of a Tag Location, as well as an Explicit Data Memory Effect.

## Implicit Instruction Memory Read Effects

An Implicit Instruction Memory Read Effect refers to a Memory Read Effect generated as a result of an instruction fetch.

## Barrier Effects

Barrier instructions generate Barrier Effects . In this chapter, the resulting Effect is named after the instruction. Therefore, an ISB instruction generates an ISB Effect, a DMB instruction generates a DMBEffect, and a DSB instruction generates a DSB Effect.

The following conventions are used when referring to DMB Effects:

- ADMBFULLEffect is generated by a DMB instruction with neither a LD nor ST qualifier.
- ADMBLDEffect is generated by a DMB instruction with the LD qualifier.
- ADMBSTEffect is generated by a DMB instruction with the ST qualifier.

The following conventions are used when referring to DSB Effects:

- ADSBFULLEffect is generated by a DSB instruction with neither a LD nor ST qualifier.
- ADSBLDEffect is generated by a DSB instruction with the LD qualifier.
- ADSBSTEffect is generated by a DSB instruction with the ST qualifier.

## Instruction Fetch Barrier Effects

An Instruction Fetch Barrier Effect (IFBE) is one of:

- AContext Synchronization event.
- An exception entry to ELx, regardless of the value of SCTLR\_ELx.EIS, due to an exception generated for any reason other than any of the following:
- -SVC instruction execution that is not trapped.
- -HVC instruction execution that is not disabled.
- -SMC instruction execution that is not trapped or disabled.
- -BKPT instruction execution.
- -BRK instruction execution.

Note

- If FEAT\_ExS is not implemented, or if FEAT\_ExS is implemented and the SCTLR\_ELx.EOS field is 1, an Exception Return effect is an IFBE due to it being a Context Synchronization event.
- If FEAT\_ExS is not implemented, or if FEAT\_ExS is implemented and the SCTLR\_ELx.EIS field is 1, the Exception entry effects due to the exceptions excluded above are IFBEs due to being Context Synchronization events.

## Conditional Branching, and Intrinsic Branching Effects

Branching Effects are generated when a choice is made between two possible paths in the execution flow. Branching Effects represent such decision points.

Conditional Branching Effects are generated by Conditional branch instructions, when as a consequence of evaluating a condition a choice potentially affecting the execution flow of other subsequent instructions is made.

Intrinsic Branching Effects due to a translation occur when, as a consequence of reading a TTD, a choice is made between raising a fault (for example, if the descriptor is invalid) or performing a physical access. Intrinsic Branching Effects represent such decision points.

Intrinsic Branching Effects due to tag checking occur when, as a consequence of reading a tag, a choice is made between raising a fault (that is, due to a failed tag check) or performing a physical access. Intrinsic Branching Effects represent such decision points.

Intrinsic Branching Effects due to instruction fetch occur when, as a consequence of reading and decoding an instruction, a choice is made between raising a fault (for example, as a result of fetching an illegal instruction) or proceeding to execute the valid instruction. Intrinsic Branching Effects represent such decision points.

Note

Conditional Selection instructions and Compare-and-Swap instructions generate Intrinsic Branching Effects .

## Fault Effects, Exception Entry, and Exception Return Effects

An instruction that encounters a fault generates a Fault Effect. An instruction that encounters a fault leading to a synchronous exception generates a Fault Effect that is also an Exception Entry Effect , for example as a result of reading an invalid TTD or fetching an illegal instruction.

An ERET instruction generates an Exception Return Effect.

AFault Effect generated by the MMU is called an MMUFault Effect . See MMU fault types for a full list of faults generated by the MMU.

AFault Effect generated by a failed Tag Check is called a TagCheck Fault Effect .

Instructions that write to memory with Release semantics generate Fault Effects with Release semantics when they encounter a fault.

Note

- An instruction that encounters an asynchronous Tag Check Fault generates a TagCheck Fault Effect that is not an Exception Entry Effect.
- Aninstruction that encounters a synchronous Tag Check Fault generates a TagCheck Fault Effect that is also an Exception Entry Effect.

## TLBI Effects, Completed TLBI Effects and Invalidation Scopes

TLBI Effects are generated by TLBI instructions.

ATLBI Effect E1 is a Completed TLBI Effect if E1 appears in program order before a DSB FULL Effect.

The Invalidation scope of a TLBI Effect is a set Memory Effects. For a Virtual Address x , a Memory Read or Write Effect to the TTD of x is in the Invalidation Scope of a TLBI Effect if x is in the scope of the TLBI instruction. For the full description of the scope of TLBI instructions, see TLB maintenance instruction scope.

## TLBUncacheable Effects

An MMU Fault Effect is TLBUncacheable if it is one of:

- ATranslation Fault Effect.
- An Access Flag Fault Effect.
- An Address Size Fault Effect.
- Asynchronous External Abort on translation table walk, such that it cannot be determined whether the TTD would otherwise generate a Translation Fault, Access Flag Fault, or Address Size Fault effect.

Note

APermission Fault Effect is not TLBUncacheable.

## DCCVAUEffects

DCCVAUEffects are generated by DC CVAU instructions.

## IC Effects, Completed IC Effects

IC Effects are generated by IC IALLUIS, IC IALLU or IC IVAU instructions. An IC Effect E1 is a Completed IC Effect if E1 appears in program order before a DSB FULL Effect.

## Empty Effects

## Low-order Bits

The Low-order Bits of an address are the bits that remain unchanged in the translation process of an input address to an output address. The number of low-order bits that remain unchanged depends on the translation granule size.

## Same Low-order Bits

Two Effects E1 and E2 have the Same Low-order Bits if the Low-order Bits of the address of E1 and the Low-order Bits of the address of E2 match.

Note

The address associated with an MMU Fault Effect is the faulting address as indicated in FAR\_ELx.

## Effects with a valid Physical Address

An Effect E1 has a valid Physical Address if any of the following applies:

- All of the following apply:
- -At least one stage of address translation is enabled.
- -Any of the following applies:
- -E1 is an Implicit TTD Memory Effect and the Physical Address of E1 does not generate an Address Size fault.
- -All of the following apply:
- ꞏ E2 is Translation-intrinsically-before E1.
- ꞏ E2 is an Implicit TTD Memory Read Effect associated with the final stage of translation that has a valid Output Address.
- All of the following apply:
- -Address translation is not enabled.
- -One of the following applies:
- -E1 is a Memory Effect.
- -E1 is a DC Effect.
- -E1 is a IC Effect.
- -The Physical Address of E1 does not generate an Address Size Fault.

Note

In situations where a memory access to a Physical Address generates an Address Size Fault, the PE does not generate the corresponding Memory Effect or DC Effect or IC Effect.

An Effect E1 and an Effect E2 are to the Same Location if one of the following applies:

- All of the following apply:
- -E1 has a valid Physical Address.
- -It is not the case that E1 is a Tag Memory Effect.
- -E1 and E2 are to the same Physical Address.
- -E2 has a valid Physical Address.
- -It is not the case that E2 is a Tag Memory Effect.

## Same Location

Empty Effects are generated by instructions where a decision point, represented by a Branching Effect, leads to no further action resulting from that decision. For example, when FEAT\_MTE\_ASYNC is implemented and Tag Check Faults are reported asynchronously, a successful tag comparison generates an Empty Effect instead of a TagCheck Fault Effect.

- All of the following apply:
- -One of the following applies:
- -E1 is a Tag Memory Effect.
- -E1 is an MMU Fault Effect that has a valid Physical Address.
- -E1 and E2 are to the same Physical Address.
- -One of the following applies:
- -E2 is a Tag Memory Effect.
- -E2 is an MMU Fault Effect that has a valid Physical Address.
- All of the following apply:
- -E1 is an MMU Fault Effect that does not have a valid Physical Address.
- -E1 and E2 have the Same Low Order Bits.
- All of the following apply:
- -E1 and E2 have the Same Low Order Bits.
- -E2 is an MMU Fault Effect that does not have a valid Physical Address.

Note

An Effect E1 and an Effect E2 are to the Same Location, if E1 and E2 are Memory Effects or Fault Effects to the same PA. The PA for a Fault Effect that prevents an output address from being generated, for example a Translation Fault Effect, is considered to be the same as the PA of an Explicit Memory Effect if the two Effects have the Same Low-order Bits.

## Same Cache Line

An Effect E1 and an Effect E2 are to the Same Cache Line if:

- E1 and E2 are Memory Effects or DC CVAU Effects or IC Effects.
- E1 and E2 are to PAs that are on the Same Cache Line as follows from section Cache identification.

## Successful Read-Modify-Write pair

Two Effects E1 and E2 form a Successful Read-Modify-Write pair if all of the following apply:

- E1 is a Memory Read Effect.
- E2 is a Memory Write Effect.
- E1 and E2 are to the Same Location.
- One of the following applies:
- -E1 and E2 are generated by the same atomic instruction.
- -E1 and E2 are generated by the same successful Load-Exclusive/Store-Exclusive instruction pair.

## Reads-from-memory

The Reads-from-memory relation couples Memory Read and Write Effects to the same Location so that each Memory Read Effect is paired with exactly one Memory Write Effect in the execution of a program. A Memory Read Effect E2 Reads-from-memory a Memory Write Effect E1, if and only if E1 and E2 are to the same location and E2 takes its data from E1.

For two Effects E1 and E2 if all of the following apply:

- E1 is an Explicit Memory Read Effect.
- E2 is an Explicit Memory Write Effect.
- E1 appears in program order before E2.
- E1 and E2 are to the Same Location.

then it is not the case that E1 Reads-from-memory E2.

For two Effects E1 and E2 if all of the following apply:

- E1 is an Explicit Memory Read Effect.
- E2 is an Explicit Memory Write Effect.

- E1 and E2 form a successful Read-Modify-Write pair.

then it is not the case that E1 Reads-from-memory E2.

For two Effects E1 and E2 if all of the following apply:

- E1 is an Implicit Tag Memory Read Effect.
- E2 is an Explicit Memory Write Effect.
- E1 appears in program order before E2.
- E1 and E2 are to the Same Location.

then it is not the case that E1 Reads-from-memory E2.

## Coherence order

There is a per-location Coherence order relation that provides a total order over all Memory Write Effects to that Location, starting with a notional Memory Write Effect of the initial value. The Coherence order of a Location represents the order in which Memory Write Effects to the Location arrive at memory.

## Local register read successor

An Effect E2 is a Local register read successor of an Effect E1 if all of the following apply:

- E1 is a Register Write Effect.
- E1 appears in program order before E2.
- E1 and E2 are to the same Register.
- It is not the case that all of the following apply:
- -E1 appears in program order before E3.
- -E1 and E3 are to the same Register.
- -E3 is a Register Write Effect.
- -E3 appears in program order before E2.
- -E3 and E2 are to the same Register.
- E2 is a Register Read Effect.

## Local memory read successor

An Effect E2 is a Local memory read successor of an Effect E1 if all of the following apply:

- E1 is a Memory Write Effect.
- E1 appears in program order before E2.
- E1 and E2 are to the Same Location.
- E2 is a Memory Read Effect.
- There is no Memory Write Effect E3 to the Same Location as E1 such that E1 appears in program order before E3 and E3 appears in program order before E2.

## Local memory write successor

An Effect E2 is a Local memory write successor of an Effect E1 if one of the following applies:

- All of the following apply:
- -One of the following applies:
- -E1 is an Explicit Memory Effect.
- -E1 is an Implicit Tag Memory Read Effect.
- -E1 appears in program order before E2.
- -E1 and E2 are to the Same Location.
- -E2 is an Explicit Memory Write Effect.
- All of the following apply:
- -E1 is an Implicit TTD Memory Read Effect.
- -E1 appears in program order before E2.
- -E1 and E2 are to the Same Location.
- -One of the following applies:

## Local MMU Fault successor

An Effect E2 is a Local MMU Fault successor of an Effect E1 if all of the following apply:

- E1 is an Explicit Memory Effect.
- E1 appears in program order before E2.
- E1 and E2 are to the Same Location.
- E2 is an MMU Fault Effect.

## Coherence-before, Coherence-after

AMemory Write Effect E1 is Coherence-before a Memory Write Effect E2 to the same Location if E1 is sequenced before E2 in the Coherence order for the Location.

AMemory Read Effect E1 is Coherence-before a Memory Write Effect E2 to the same Location if E1 Reads-from-memory a Memory Write Effect E3 and E3 is Coherence-before E2.

An Effect E2 is Coherence-after an Effect E1 if E1 is Coherence-before E2.

For two Effects E1 and E2 if all of the following apply:

- E1 is an Explicit Memory Write Effect.
- E2 is an Explicit Memory Write Effect.
- E1 appears in program order before E2.
- E1 and E2 are to the Same Location.

then it is not the case that E2 is Coherence-before E1.

For two Effects E1 and E2 if all of the following apply:

- E1 is an Explicit Memory Write Effect.
- E2 is an Explicit Memory Read Effect.
- E1 appears in program order before E2.
- E1 and E2 are to the Same Location.

then it is not the case that E2 is Coherence-before E1.

For two Effects E1 and E2 if all of the following apply:

- E1 is an Explicit Memory Write Effect.
- E2 is an Implicit Tag Memory Read Effect.
- E1 appears in program order before E2.
- E1 and E2 are to the Same Location.

then it is not the case that E2 is Coherence-before E1.

## TLBI-before, TLBI-after

For two Effects E1 and E2, if and only if all of the following applies:

- E1 is a Completed TLBI Effect.
- E2 is an Implicit TTD Memory Read Effect.
- E2 is in the Invalidation Scope of E1.

then one and only one of the following applies:

- E1 is TLBI-after E2 (equivalently E2 is TLBI-before E1), or
- E2 is TLBI-after E1 (equivalently E1 is TLBI-before E2).

Note

The TLBI-after relation enumerates all possible pairs (E1,E2) where E1 is a TLBI Effect and E2 is an Implicit TTD Memory Read Effect such that E2 is in the Invalidation Scope of E1, and the TLBI-after relation is asymmetric.

- -E2 is an Explicit Memory Write Effect.
- -E2 is a Hardware Update Effect.

## DC-before, DC-after

For two Effects E1 and E2, if all of the following applies:

- E1 is a DC CVAU Effect.
- E2 is an Explicit Memory Write Effect.
- E1 and E2 are to the Same Cache Line.

then one of the following applies:

- E1 is DC-after E2 (equivalently E2 is DC-before E1), or
- E2 is DC-after E1 (equivalently E1 is DC-before E2).

Note

The DC-after relation enumerates all possible pairs (E1, E2) where E1 is a DC CVAU Effect and E2 is an Explicit Memory Write Effect such that E1 and E2 are to the Same Cache Line, and the relation DC-after is asymmetric.

## IC-before, IC-after

For two Effects E1 and E2, if and only if all of the following applies:

- E1 is a completed IC Effect.
- E2 is an Implicit Instruction Memory Read Effect.
- E1 and E2 are to the Same Cache Line.

then one and only one of the following applies:

- E1 is IC-after E2 (equivalently E2 is IC-before E1), or
- E2 is IC-after E1 (equivalently E1 is IC-before E2).

Note

The IC-after relation enumerates all possible pairs (E1,E2) where E1 is a completed IC Effect and E2 is an Implicit Instruction Memory Read Effect such that E1 and E2 are to the Same Cache Line, and the relation IC-after is asymmetric.

## Single-copy-atomic grouping

A single-copy-atomic grouping gathers Explicit Memory Effects generated by the same instruction when the architecture requires the Explicit Memory Effects to be single-copy atomic as defined in Requirements for single-copy atomicity. For example, an aligned STRH instruction generates two Explicit Memory Write Effects that are in the same single-copy-atomic grouping.

## Atomicity of Successful Read-Modify-Write pair

For two Effects E1 and E2 if all of the following apply:

- E1 and E2 form a successful Read-Modify-Write pair.
- There is an Explicit Memory Write Effect E3.
- It is not the case that all of the following apply:
- -E1 is an Explicit Memory Effect.
- -E1 and E3 are from the same Processing Element.
- -E2 is an Explicit Memory Effect.
- -E2 and E3 are from the same Processing Element.

then it is not the case that E1 is Coherence-before E3 and E3 is Coherence-before E2.

## B2.3.2 Intrinsic Dependency relations

Intrinsic Dependencies are as follows:

## Intrinsic Data Dependency

There is an Intrinsic Data Dependency from an Effect E1 to an Effect E2 if and only if all the following apply:

- It is not the case that E1 is an Intrinsic Branching Effect.
- E1 and E2 are generated by the same instruction I .
- The instruction semantics for that instruction I indicate that the value produced by E1 is consumed by E2.

Note

This applies even in cases where the Intrinsic Data Dependency might be perceived to be a false dependency.

## Intrinsic Control Dependency

There is an Intrinsic Control Dependency from an Effect E1 to an Effect E2 if and only if all the following apply:

- E1 is an Intrinsic Branching Effect.
- E1 and E2 are generated by the same instruction I .
- The instruction semantics for that instruction I indicate that the generation of E2 is conditional and based on the determination of E1.

## Intrinsic Order Dependency

There is an Intrinsic Order Dependency from an Effect E1 to an Effect E2 if and only if all the following apply:

- E1 is a Memory Effect.
- E1 and E2 are generated by the same instruction I .
- The instruction semantics for that instruction I indicate that E1 is generated before E2.
- It is not the case that there is an Intrinsic Data Dependency from E1 to E2.
- It is not the case that there is an Intrinsic Control Dependency from E1 to E2.
- E2 is a Memory Effect.

In the following, instructions whose Intrinsic dependencies are special cases that arose during the formalisation of the memory model are listed. This does not preclude the existence of other special cases in the future.

## B2.3.2.1 Conditional Selection instructions

The following applies to the Effects generated by CSEL Xd,Xn,Xm, cond

When the condition cond is true all of the following apply:

- Dt1: There is an Intrinsic Data Dependency from the Register Read Effect of PSTATE.NZCV to the Intrinsic Branching Effect corresponding to the condition cond .
- Ct1: There is an Intrinsic Control Dependency from the Intrinsic Branching Effect which checks the condition cond to the Register Read Effect of Xn.
- Dt2: There is an Intrinsic Data Dependency from the Register Read Effect of Xn to the Register Write Effect of Xd.

When the condition cond is false all of the following apply:

- Df1: There is an Intrinsic Data Dependency from the Register Read Effect of PSTATE.NZCV to the Intrinsic Branching Effect corresponding to the condition cond .
- Cf1: There is an Intrinsic Control Dependency from the Intrinsic Branching Effect corresponding to the condition cond to the Register Read Effect of Xm.
- Df1: There is an Intrinsic Data Dependency from the Register Read Effect of Xm to the Register Write Effect of Xd.

## B2.3.2.2 Compare-and-Swap instructions

The following apply to the Effects generated by CAS Xs,Xt,[Xn]:

When the value of the Memory Location x addressed by Xn is not equal to the value of Xs one of the following applies:

- D1: There is an Intrinsic Data Dependency from the Register Read Effect of Xn to the Explicit Memory Read Effect of the Memory Location x addressed by Xn.
- D2: There is an Intrinsic Data Dependency from the Explicit Memory Read Effect of the Memory Location x addressed by Xn to the Intrinsic Branching Effect which checks whether the contents of the Memory Location x are equal to the contents of the Register Xs.
- D3: There is an Intrinsic Data Dependency from the Register Read Effect of Xs to the Intrinsic Branching Effect which checks whether the contents of the Memory Location x are equal to the contents of the Register Xs.
- Df1: There is an Intrinsic Data Dependency from the Explicit Memory Read Effect of the Memory Location x addressed by Xn to the Register Write Effect of Xs.

When the value of the Memory Location x addressed by Xn is equal to the value of Xs one of the following applies:

- All of the following apply:
- -D1: There is an Intrinsic Data Dependency from the Register Read Effect of Xn to the Explicit Memory Read Effect of the Memory Location x addressed by Xn.
- -D2: There is an Intrinsic Data Dependency from the Explicit Memory Read Effect of the Memory Location x addressed by Xn to the Intrinsic Branching Effect which checks whether the contents of the Memory Location x are equal to the contents of the Register Xs.
- -D3: There is an Intrinsic Data Dependency from the Register Read Effect of Xs to the Intrinsic Branching Effect which checks whether the contents of the Memory Location x are equal to the contents of the Register Xs.
- -Ds1: There is an Intrinsic Data Dependency from the Register Read Effect of Xn to the Explicit Memory Write Effect of the Memory Location x addressed by Xn.
- -Ds2: There is an Intrinsic Data Dependency from Register Read Effect Xt to the Explicit Memory Write Effect of the Memory Location x addressed by Xn.
- -Cs1: There is an Intrinsic Control Dependency from the Intrinsic Branching Effect which checks whether the contents of the Memory Location x are equal to the contents of the Register Xs to the Explicit Memory Write Effect of the Memory Location x addressed by Xn.
- -Ds31: There is an Intrinsic Data Dependency from the Explicit Memory Read Effect of the Memory Location x addressed by Xn to the Register Write Effect of Xs.
- All of the following apply:
- -D1: There is an Intrinsic Data Dependency from the Register Read Effect of Xn to the Explicit Memory Read Effect of the Memory Location x addressed by Xn.
- -D2: There is an Intrinsic Data Dependency from the Explicit Memory Read Effect of the Memory Location x addressed by Xn to the Intrinsic Branching Effect which checks whether the contents of the Memory Location x are equal to the contents of the Register Xs.
- -D3: There is an Intrinsic Data Dependency from the Register Read Effect of Xs to the Intrinsic Branching Effect which checks whether the contents of the Memory Location x are equal to the contents of the Register Xs.
- -Ds1: There is an Intrinsic Data Dependency from the Register Read Effect of Xn to the Explicit Memory Write Effect of the Memory Location x addressed by Xn.
- -Ds2: There is an Intrinsic Data Dependency from the Register Read Effect of Xt to the Explicit Memory Write Effect of the Memory Location x addressed by Xn.
- -Cs1: There is an Intrinsic Control Dependency from the Intrinsic Branching Effect which checks whether the contents of the Memory Location x are equal to the contents of the Register Xs to the Explicit Memory Write Effect of the Memory Location x addressed by Xn.
- -Ds3: There is an Intrinsic Data Dependency from Register Read Effect Xs to the Register Write Effect of Xs.
- -Cs2: There is an Intrinsic Control Dependency from the Intrinsic Branching Effect which checks whether the contents of the Memory Location x are equal to the contents of the Register Xs to the Register Write Effect of Xs.

## B2.3.2.3 Swap instructions

All of the following apply to the Effects generated by the SWP Xs, Xt,[Xn] instruction:

- D1: There is an Intrinsic Data Dependency from the Register Read Effect of Xn to the Explicit Memory Read Effect of the Memory Location x addressed by Xn.
- D2: There is an Intrinsic Data Dependency from the Register Read Effect of Xn to the Explicit Memory Write Effect of the Memory Location x addressed by Xn.
- O1: There is an Intrinsic Order Dependency from the Explicit Memory Read Effect of the Memory Location x addressed by Xn to the Explicit Memory Write Effect of the Memory Location x addressed by Xn.
- D3: There is an Intrinsic Data Dependency from the Explicit Memory Read Effect of the Memory Location x addressed by Xn to the Register Write Effect of Xt.
- D4: There is an Intrinsic Data Dependency from the Register Read Effect of Xs, to the Explicit Memory Write Effect of the Memory Location x addressed by Xn.

## B2.3.2.4 Branch with Link to Register instructions

All of the following apply to the Effects generated by the BLR Xn instruction:

- D1: There is an Intrinsic Data Dependency from the Register Read Effect of Xn to the Branching Effect of the instruction.

## B2.3.2.5 MTE Checked instructions

If FEAT\_MTE2 is implemented, a Checked LDR Xt,[Xn] instruction has the following additional dependencies:

When Tag Check Faults are configured to raise a Synchronous Exception one of the following applies:

- If the Logical Address Tag is equal to the Allocation tag, all of the following apply:
- -Dst1: There is an Intrinsic Data Dependency from the Implicit Tag Memory Read Effect of the Tag Location x of the Memory Location x addressed by Xn to the Intrinsic Branching Effect which checks whether the Allocation Tag of x is equal to the Logical Address Tag in Xn.
- -Cst1: There is an Intrinsic Control Dependency from the Intrinsic Branching Effect which checks whether the Allocation Tag of x is equal to the Logical Address Tag in Xn to the Explicit Memory Read Effect of the Memory Location x addressed by Xn.
- If the Logical Address Tag is not equal to the Allocation tag, all of the following apply:
- -Dsf1: There is an Intrinsic Data Dependency from the Implicit Tag Memory Read Effect of the Tag Location x of the Memory Location x addressed by Xn to the Intrinsic Branching Effect which checks whether the Allocation Tag of x is equal to the Logical Address Tag in Xn.
- -Csf1: There is an Intrinsic Control Dependency from the Intrinsic Branching Effect which checks whether the Allocation Tag of x is equal to the Logical Address Tag in Xn to the TagCheck Fault Effect.

When Tag Check Faults are configured to not raise a Synchronous Exception one of the following applies:

- If the Logical Address Tag is equal to the Allocation tag, all of the following apply:
- -Dat1: There is an Intrinsic Data Dependency from the Implicit Tag Memory Read Effect of the Tag Location x of the Memory Location x addressed by Xn to the Intrinsic Branching Effect which checks whether the Allocation Tag of x is equal to the Logical Address Tag in Xn.
- -Cat1: There is an Intrinsic Control Dependency from the Intrinsic Branching Effect which checks whether the Allocation Tag of x is equal to the Logical Address Tag in Xn to the empty Effect.
- If the Logical Address Tag is not equal to the Allocation tag, all of the following apply:
- -Daf1: There is an Intrinsic Data Dependency from the Implicit Tag Memory Read Effect of the Tag Location x of the Memory Location x addressed by Xn to the Intrinsic Branching Effect which checks whether the Allocation Tag of x is equal to the Logical Address Tag in Xn.
- -Caf1: There is an Intrinsic Control Dependency from the Intrinsic Branching Effect which checks whether the Allocation Tag of x is equal to the Logical Address Tag in Xn to the TagCheck Fault Effect.

## B2.3.3 Tag-check-intrinsically-before

## Tag-check-before

An Effect E1 is Tag-check-before an Effect E2 if all of the following apply:

- E1 is an Implicit Tag Memory Read Effect.
- There is an Intrinsic Data Dependency from E1 to E3.
- E3 is a Branching Effect.
- There is an Intrinsic Control Dependency from E3 to E2.
- One of the following applies:
- -E2 is an Explicit Memory Effect.
- -E2 is a TagCheck Fault Effect.

## Tag-check-intrinsically-before

An Effect E1 is Tag-check-intrinsically-before an Effect E2 if all of the following apply:

- E1 is Tag-check-before E2.
- It is not the case that E2 is an Explicit Memory Read Effect.

## B2.3.4 Translation-intrinsically-before

An Effect E1 is Translation-intrinsically-before an Effect E2 if all of the following apply:

- E1 is an Implicit TTD Memory Read Effect.
- There is an Intrinsic Data Dependency from E1 to E3.
- E3 is a Branching Effect.
- There is an Intrinsic Control Dependency from E3 to E2.
- One of the following applies:
- -E2 is an Explicit Memory Effect.
- -E2 is an MMU Fault Effect.

## B2.3.5 Fetch-intrinsically-before

An Effect E1 is Fetch-intrinsically-before an Effect E2 if all of the following apply:

- E1 is an Implicit Instruction Memory Read Effect.
- There is an Intrinsic Data Dependency from E1 to E3.
- E3 is a Branching Effect.
- One of the following applies:
- -There is an Intrinsic Control Dependency from E3 to E2.
- -All of the following apply:
- -There is an Intrinsic Control Dependency from E3 to E4.
- -There is an Intrinsic Data Dependency from E4 to E2.

## B2.3.6 Dependency relations

## Dependency through registers and memory

There is a Dependency through registers and memory from an Effect E1 to an Effect E2 if one of the following applies:

- All of the following apply:
- -It is not the case that E1 is generated by a Store-Exclusive instruction as part of a successful Load-Exclusive/Store-Exclusive pair.

## Data dependency

There is a Data dependency from an Effect E1 to an Effect E2 if all of the following apply:

- E1 is an Explicit Memory Read Effect.
- There is a Dependency through registers and memory from E1 to E3.
- E1 appears in program order before E3.
- E3 is a Register Read Effect.
- There is an Intrinsic Data Dependency from E3 to E2.
- The semantics of the instruction that generates E3 and E2 indicate that the value produced by E3 is consumed in the calculation of the data value written by E2.
- E2 is an Explicit Memory Write Effect.

## Address dependency

There is an Address dependency from an Effect E1 to an Effect E2 if all of the following apply:

- E1 is an Explicit Memory Read Effect.
- There is a Dependency through registers and memory from E1 to E3.
- E1 appears in program order before E3.
- E3 is a Register Read Effect.
- There is an Intrinsic Data Dependency from E3 to E2.
- The semantics of the instruction that generates E3 and E2 indicate that the value produced by E3 is consumed in the calculation of the address of the Location of E2.
- One of the following applies:
- -E2 is an Explicit Memory Effect.
- -E2 is an Implicit Tag Memory Read Effect.
- -E2 is an Implicit TTD Memory Read Effect.
- -E2 is a Hardware Update Effect.
- -E2 is a TLBI Effect.
- -E2 is a DC CVAU Effect.
- -E2 is an IC IV AU Effect.

## Control dependency

There is a Control dependency from an Effect E1 to an Effect E2 if all of the following apply:

- E1 is an Explicit Memory Read Effect.
- There is a Dependency through registers and memory from E1 to E3.
- E1 appears in program order before E3.
- E3 is a Register Read Effect.
- There is an Intrinsic Data Dependency from E3 to E4.
- E4 is a Conditional Branching Effect.
- E4 appears in program order before E2.

## Pick dependency through registers and memory

There is a Pick dependency through registers and memory from an Effect E1 to an Effect E2 if one of the following applies:

- There is a Dependency through registers and memory from E1 to E2.
- There is an Intrinsic Control Dependency from E1 to E2.
- All of the following apply:
- -E2 is a Local register read successor of E1.
- E2 is a Local memory read successor of E1.
- There is an Intrinsic Data Dependency from E1 to E2.
- All of the following apply:
- -There is a Dependency through registers and memory from E1 to E3.
- -There is a Dependency through registers and memory from E3 to E2.

## Pick Basic dependency

There is a Pick Basic dependency from an Effect E1 to an Effect E2 if all of the following apply:

- One of the following applies:
- -E1 is an Explicit Memory Read Effect.
- -E1 is a Register Read Effect.
- One of the following applies:
- -There is a Pick dependency through registers and memory from E1 to E2.
- -E1 and E2 are the same Effect.

## Pick Data dependency

There is a Pick Data dependency from an Effect E1 to an Effect E2 if all of the following apply:

- E1 is an Explicit Memory Read Effect.
- There is a Pick dependency through registers and memory from E1 to E3.
- E1 appears in program order before E3.
- E3 is a Register Read Effect.
- One of the following applies:
- -There is an Intrinsic Data Dependency from E3 to E2.
- -All of the following apply:
- -There is an Intrinsic Data Dependency from E3 to E4.
- -There is an Intrinsic Control Dependency from E4 to E2.
- The semantics of the instruction that generates E3 and E2 indicate that the value produced by E3 is consumed in the calculation of the data value written by E2.
- E2 is an Explicit Memory Write Effect.

## Pick Address dependency

There is a Pick Address dependency from an Effect E1 to an Effect E2 if all of the following apply:

- E1 is an Explicit Memory Read Effect.
- There is a Pick dependency through registers and memory from E1 to E3.
- E1 appears in program order before E3.
- E3 is a Register Read Effect.
- There is an Intrinsic Data Dependency from E3 to E2.
- The semantics of the instruction that generates E3 and E2 indicate that the value produced by E3 is consumed in the calculation of the address of the Location of E2.
- One of the following applies:
- -E2 is an Explicit Memory Effect.
- -E2 is an Implicit Tag Memory Read Effect.
- -E2 is an Implicit TTD Memory Read Effect.
- -E2 is a Hardware Update Effect.
- -E2 is a TLBI Effect.
- -E2 is a DC CVAU Effect.
- -E2 is an IC IV AU Effect.

## Pick Control dependency

There is a Pick Control dependency from an Effect E1 to an Effect E2 if all of the following apply:

- E1 is an Explicit Memory Read Effect.
- There is a Pick dependency through registers and memory from E1 to E3.
- E1 appears in program order before E3.
- E3 is a Register Read Effect.
- There is an Intrinsic Data Dependency from E3 to E4.
- -There is a Pick dependency through registers and memory from E1 to E3.
- -There is a Pick dependency through registers and memory from E3 to E2.

- E4 is a Conditional Branching Effect.
- E4 appears in program order before E2.

## Pick dependency

There is a Pick dependency from an Effect E1 to an Effect E2 if all of the following apply:

- One of the following applies:
- -There is a Pick Basic dependency from E1 to E2.
- -There is a Pick Address dependency from E1 to E2.
- -There is a Pick Data dependency from E1 to E2.
- -There is a Pick Control dependency from E1 to E2.
- It is not the case that E1 and E2 are generated by the same instruction.

## B2.3.7 Ordering relations

## Explicit-hazard-ordered-before

An Effect E1 is Explicit-hazard-ordered-before an Effect E2 if all of the following apply:

- E1 is an Explicit Memory Read Effect.
- E1 appears in program order before E3.
- E1 and E3 are to the Same Location.
- E3 is an Explicit Memory Read Effect.
- One of the following applies:
- -E3 belongs to the same single-copy-atomic grouping as E4.
- -E3 and E4 are the same Effect.
- E4 is an Explicit Memory Read Effect.
- E4 is Coherence-before E5.
- E4 and E5 are from different Processing Elements.
- E5 is an Explicit Memory Write Effect.
- One of the following applies:
- -E5 belongs to the same single-copy-atomic grouping as E2.
- -E5 and E2 are the same Effect.
- E2 is an Explicit Memory Write Effect.

Note

The Explicit-hazard-ordered-before relation does not apply when either E1 or E2 or both are generated by SVE instructions.

## TTD-read-ordered-before

An Effect E1 is TTD-read-ordered-before an Effect E2 if one of the following applies:

- All of the following apply:
- -E1 is TLBI-before E3.
- -E3 is a TLBI Effect.
- -E3 appears in program order before E4.
- -E4 is a DSB FULL Effect.
- -E4 appears in program order before E2.
- -It is not the case that E2 is an Implicit Memory Effect.
- All of the following apply:
- -E1 is TLBI-before E3.
- -E3 is a TLBI Effect.
- -E3 appears in program order before E4.
- -E4 is a DSB FULL Effect.
- -E4 appears in program order before E5.

## Same Virtual Address

An Effect E1 and an Effect E2 are to the Same Virtual Address if all of the following apply:

- E1 is an Implicit TTD Memory Read Effect.
- E1 is Translation-intrinsically-before E3.
- E3 and E4 have the Same Low Order Bits.
- E2 is Translation-intrinsically-before E4.
- E2 is an Implicit TTD Memory Read Effect.
- E1 and E2 are to the same Physical Address.

## TLBI-ordered-before

An Effect E1 is TLBI-ordered-before an Effect E2 if one of the following applies:

- E1 is TTD-read-ordered-before E2.
- All of the following apply:
- -E3 is Translation-intrinsically-before E1.
- -E3 is TTD-read-ordered-before E2.
- -E3 and E2 are from different Processing Elements.
- All of the following apply:
- -E1 appears in program order before E3 and E1 and E3 are to the Same Virtual Address.
- -E3 is TTD-read-ordered-before E2.
- -E3 and E2 are from different Processing Elements.

## Instruction-read-ordered-before

An Effect E1 is Instruction-read-ordered-before an Effect E2 if one of the following applies:

- All of the following apply:
- -E1 is IC-before E3.
- -E3 is an IC Effect.
- -E3 appears in program order before E4.
- -E4 is a DSB FULL Effect.
- -E4 appears in program order before E2.
- -It is not the case that E2 is an Implicit Memory Effect.
- All of the following apply:
- -DIC is implemented.
- -E1 is Coherence-before E2.

## IC-ordered-before

An Effect E1 is IC-ordered-before an Effect E2 if all of the following apply:

- E1 is an Implicit Instruction Memory Read Effect.
- E1 appears in program order before E3.
- E3 is an Implicit Instruction Memory Read Effect.
- E3 is Instruction-read-ordered-before E2.
- -E5 is an Instruction Fetch Barrier Effect.
- -E5 appears in program order before E2.
- -E2 is an Implicit Memory Effect.
- All of the following apply:
- -FEAT\_ETS2 is implemented.
- -E1 is TLBI-before E3.
- -E3 is a TLBI Effect.
- -E3 appears in program order before E4.
- -E4 is a DSB FULL Effect.
- -E4 appears in program order before E2.
- -E2 is an Implicit TTD Memory Effect.

## Hazard-ordered-before

An Effect E1 is Hazard-ordered-before an Effect E2 if one of the following applies:

- E1 is Explicit-hazard-ordered-before E2.
- E1 is TLBI-ordered-before E2.
- E1 is IC-ordered-before E2.

## ETS-ordered-before

An Effect E1 is ETS-ordered-before an Effect E2 if one of the following applies:

- All of the following apply:
- -FEAT\_ETS2 is implemented.
- -E1 is an Explicit Memory Effect.
- -E1 appears in program order before E3.
- -E3 is a TLBUncacheable Fault Effect.
- -E2 is Translation-intrinsically-before E3.
- -E2 is an Implicit TTD Memory Read Effect.
- All of the following apply:
- -FEAT\_ETS3 is implemented.
- -E1 is an Explicit Memory Effect.
- -E1 appears in program order before E3.
- -E3 is an MMU Fault Effect.
- -E2 is Translation-intrinsically-before E3.
- -E2 is an Implicit TTD Memory Read Effect.
- All of the following apply:
- -FEAT\_ETS3 is implemented.
- -E1 is an Explicit Memory Effect.
- -E1 appears in program order before E3.
- -E3 is a TagCheck Fault Effect that generates a synchronous exception.
- -E2 is Tag-check-intrinsically-before E3.
- -E2 is an Implicit Tag Memory Read Effect.

## Note

The ETS-ordered-before relation does not apply when E1 is generated by an Advanced SIMD, floatingpoint, SVE, or SME instruction. It also does not apply when E2 is an Implicit TTD Memory Read Effect generated for an instruction fetch.

## Fetch-ordered-before

An Effect E1 is Fetch-ordered-before an Effect E2 if all of the following apply:

- E1 is an Implicit Instruction Memory Read Effect.
- E1 appears in program order before E2.
- It is not the case that E2 is an Implicit Instruction Memory Read Effect.

## Same-Cache-Line-ordered-before

An Effect E1 is Same-Cache-Line-ordered-before an Effect E2 if one of the following applies:

- All of the following apply:
- -E1 is an Explicit Memory Effect.
- -E1 appears in program order before E2.
- -E1 and E2 are to the Same Cache Line.
- -E2 is a DC CVAU Effect.
- All of the following apply:
- -E1 is a DC CVAU Effect.
- -E1 appears in program order before E2.

## DSB-ordered-before

An Effect E1 is DSB-ordered-before an Effect E2 if one of the following applies:

- All of the following apply:
- -One of the following applies:
- -E1 is a Memory Effect.
- -E1 is a DC CVAU Effect.
- -E1 is an IC Effect.
- -E1 appears in program order before E3.
- -E3 is a DSB FULL Effect.
- -E3 appears in program order before E2.
- -It is not the case that one of the following applies:
- -E2 is an Implicit TTD Memory Effect.
- -E2 is an Implicit Instruction Memory Read Effect.
- All of the following apply:
- -FEAT\_ETS2 is implemented.
- -One of the following applies:
- -E1 is a Memory Effect.
- -E1 is a DC CVAU Effect.
- -E1 is an IC Effect.
- -E1 appears in program order before E3.
- -E3 is a DSB FULL Effect.
- -E3 appears in program order before E2.
- -E2 is an Implicit TTD Memory Effect.
- All of the following apply:
- -One of the following applies:
- -All of the following apply:
- ꞏ E1 is an Explicit Memory Read Effect.
- ꞏ It is not the case that E1 is generated by an instruction whose destination register is WZR or XZR.
- -E1 is an Implicit Tag Memory Read Effect.
- -E1 appears in program order before E3.
- -E3 is a DSB LD Effect.
- -E3 appears in program order before E2.
- -It is not the case that one of the following applies:
- -E2 is an Implicit TTD Memory Effect.
- -E2 is an Implicit Instruction Memory Read Effect.
- All of the following apply:
- -FEAT\_ETS2 is implemented.
- -E1 is an Explicit Memory Read Effect.
- -It is not the case that E1 is generated by an instruction whose destination register is WZRor XZR.
- -E1 appears in program order before E3.
- -E3 is a DSB LD Effect.
- -E3 appears in program order before E2.
- -E2 is an Implicit TTD Memory Effect.
- All of the following apply:
- -E1 and E2 are to the Same Cache Line.
- -E2 is an Explicit Memory Effect.
- All of the following apply:
- -E1 is a DC CVAU Effect.
- -E1 appears in program order before E2.
- -E1 and E2 are to the Same Cache Line.
- -E2 is a DC CVAU Effect.

- -E1 is an Explicit Memory Write Effect.
- -E1 appears in program order before E3.
- -E3 is a DSB ST Effect.
- -E3 appears in program order before E2.
- -It is not the case that one of the following applies:
- -E2 is an Implicit TTD Memory Effect.
- -E2 is an Implicit Instruction Memory Read Effect.
- All of the following apply:
- -FEAT\_ETS2 is implemented.
- -E1 is an Explicit Memory Write Effect.
- -E1 appears in program order before E3.
- -E3 is a DSB ST Effect.
- -E3 appears in program order before E2.
- -E2 is an Implicit TTD Memory Effect.

## Instruction-fetch-barrier-ordered-before

An Effect E1 is Instruction-fetch-barrier-ordered-before an Effect E2 if one of the following applies:

- All of the following apply:
- -E1 is an Explicit Memory Read Effect.
- -There is a Control dependency from E1 to E3.
- -E3 is an Instruction Fetch Barrier Effect.
- -E3 appears in program order before E2.
- All of the following apply:
- -E1 is an Explicit Memory Read Effect.
- -There is a Pick Control dependency from E1 to E3.
- -E3 is an Instruction Fetch Barrier Effect.
- -E3 appears in program order before E2.
- All of the following apply:
- -E1 is an Explicit Memory Read Effect.
- -There is an Address dependency from E1 to E3.
- -E3 is an Explicit Memory Effect.
- -E3 appears in program order before E4.
- -E4 is an Instruction Fetch Barrier Effect.
- -E4 appears in program order before E2.
- All of the following apply:
- -E1 is an Explicit Memory Read Effect.
- -There is a Pick Address dependency from E1 to E3.
- -E3 is an Explicit Memory Effect.
- -E3 appears in program order before E4.
- -E4 is an Instruction Fetch Barrier Effect.
- -E4 appears in program order before E2.
- All of the following apply:
- -E1 is an Explicit Memory Read Effect.
- -There is a Pick Address dependency from E1 to E3.
- -One of the following applies:
- -E3 is Tag-check-intrinsically-before E4.
- -E3 is Translation-intrinsically-before E4.
- -E4 is an Instruction Fetch Barrier Effect.
- -E4 appears in program order before E2.
- All of the following apply:
- -E1 is DSB-ordered-before E3.
- -E3 is an Instruction Fetch Barrier Effect.
- -E3 appears in program order before E2.

- All of the following apply:
- -E1 is an Implicit TTD Memory Read Effect.
- -E1 is Translation-intrinsically-before E3.
- -E3 is an Instruction Fetch Barrier Effect.
- -E3 appears in program order before E2.
- All of the following apply:
- -E1 is an Implicit Tag Memory Read Effect.
- -E1 is Tag-check-intrinsically-before E3.
- -E3 is an Instruction Fetch Barrier Effect.
- -E3 appears in program order before E2.
- All of the following apply:
- -E1 is an Implicit TTD Memory Read Effect.
- -E1 is Translation-intrinsically-before E3.
- -E3 is an Explicit Memory Effect.
- -E3 appears in program order before E4.
- -E4 is an Instruction Fetch Barrier Effect.
- -E4 appears in program order before E2.
- All of the following apply:
- -E1 is an Implicit Tag Memory Read Effect.
- -E1 is Tag-check-before E3.
- -E3 is an Explicit Memory Effect.
- -E3 appears in program order before E4.
- -E4 is an Instruction Fetch Barrier Effect.
- -E4 appears in program order before E2.

## Dependency-ordered-before

An Effect E1 is Dependency-ordered-before an Effect E2 if one of the following applies:

- There is an Address dependency from E1 to E2.
- There is a Data dependency from E1 to E2.
- All of the following apply:
- -There is a Control dependency from E1 to E2.
- -One of the following applies:
- -E2 is an Explicit Memory Write Effect.
- -E2 is a Hardware Update Effect.
- -E2 is a TLBI Effect.
- -E2 is a DC CVAU Effect.
- -E2 is an IC Effect.
- All of the following apply:
- -There is an Address dependency from E1 to E3.
- -E3 is an Explicit Memory Effect.
- -E3 appears in program order before E2.
- -One of the following applies:
- -E2 is an Explicit Memory Write Effect.
- -E2 is a Hardware Update Effect.
- All of the following apply:
- -There is an Address dependency from E1 to E3.
- -E3 is an Explicit Memory Effect.
- -E2 is a Local memory read successor of E3.
- -One of the following applies:
- -E2 is an Explicit Memory Read Effect.
- -E2 is an Implicit Tag Memory Read Effect.
- All of the following apply:
- -There is a Data dependency from E1 to E3.

## Pick-ordered-before

An Effect E1 is Pick-ordered-before an Effect E2 if one of the following applies:

- All of the following apply:
- -There is a Pick Address dependency from E1 to E2.
- -One of the following applies:
- -E2 is an Explicit Memory Write Effect.
- -E2 is a Hardware Update Effect.
- -E2 is a TLBI Effect.
- -E2 is a DC CVAU Effect.
- -E2 is an IC Effect.
- There is a Pick Data dependency from E1 to E2.
- All of the following apply:
- -There is a Pick Control dependency from E1 to E2.
- -One of the following applies:
- -E2 is an Explicit Memory Write Effect.
- -E2 is a Hardware Update Effect.
- -E2 is a TLBI Effect.
- -E2 is a DC CVAU Effect.
- -E2 is an IC Effect.
- All of the following apply:
- -There is a Pick Address dependency from E1 to E3.
- -E3 is an Explicit Memory Effect.
- -E3 appears in program order before E2.
- -One of the following applies:
- -E2 is an Explicit Memory Write Effect.
- -E2 is a Hardware Update Effect.

## Atomic-ordered-before

E1 and E2 form a successful Read-Modify-Write pair if and only if E1 and E2 are generated by the same atomic instruction or the same successful Load-Exclusive/Store-Exclusive instruction pair to the Same Location.

An Effect E1 is Atomic-ordered-before an Effect E2 if one of the following applies:

- -E3 is an Explicit Memory Effect.
- -E2 is a Local memory read successor of E3.
- -One of the following applies:
- -E2 is an Explicit Memory Read Effect.
- -E2 is an Implicit Tag Memory Read Effect.
- All of the following apply:
- -E1 is an Implicit TTD Memory Read Effect.
- -E1 is Translation-intrinsically-before E3.
- -E3 is an Explicit Memory Effect.
- -E3 appears in program order before E2.
- -One of the following applies:
- -E2 is an Explicit Memory Write Effect.
- -E2 is a Hardware Update Effect.
- All of the following apply:
- -E1 is an Implicit Tag Memory Read Effect.
- -E1 is Tag-check-before E3.
- -E3 is an Explicit Memory Effect.
- -E3 appears in program order before E2.
- -One of the following applies:
- -E2 is an Explicit Memory Write Effect.
- -E2 is a Hardware Update Effect.

- All of the following apply:
- -E1 is an Explicit Memory Effect.
- -E1 and E2 form a successful Read-Modify-Write pair.
- -E2 is an Explicit Memory Effect.
- All of the following apply:
- -E1 is an Explicit Memory Effect.
- -E1 and E3 form a successful Read-Modify-Write pair.
- -E2 is a Local memory read successor of E3.
- -One of the following applies:
- -E2 is an Explicit Memory Read Effect with Acquire semantics.
- -E2 is an Explicit Memory Read Effect with AcquirePC semantics.
- All of the following apply:
- -E1 is an Implicit TTD Memory Read Effect.
- -E1 and E2 form a successful Read-Modify-Write pair.
- -E2 is a Hardware Update Effect.

## Barrier-ordered-before

An Effect E1 is Barrier-ordered-before an Effect E2 if one of the following applies:

- All of the following apply:
- -One of the following applies:
- -E1 is an Explicit Memory Effect.
- -E1 is an Implicit Tag Memory Read Effect.
- -E1 appears in program order before E3.
- -E3 is a DMB FULL Effect.
- -E3 appears in program order before E2.
- -One of the following applies:
- -E2 is an Explicit Memory Effect.
- -E2 is an Implicit Tag Memory Read Effect.
- -E2 is an MMU Fault Effect.
- All of the following apply:
- -E1 is an Explicit Memory Effect.
- -E1 appears in program order before E3.
- -E3 is a DMB FULL Effect.
- -E3 appears in program order before E2.
- -E2 is a DC CVAU Effect.
- All of the following apply:
- -E1 is a DC CVAU Effect.
- -E1 appears in program order before E3.
- -E3 is a DMB FULL Effect.
- -E3 appears in program order before E2.
- -E2 is an Explicit Memory Effect.
- All of the following apply:
- -E1 is a DC CVAU Effect.
- -E1 appears in program order before E3.
- -E3 is a DMB FULL Effect.
- -E3 appears in program order before E2.
- -E2 is a DC CVAU Effect.
- All of the following apply:
- -One of the following applies:
- -All of the following apply:
- ꞏ E1 is an Explicit Effect.
- ꞏ E1 is a Memory Read Effect.
- ꞏ It is not the case that E1 is generated by an instruction whose destination register is WZR or XZR.

- -E1 is an Implicit Tag Memory Read Effect.
- -E1 appears in program order before E3.
- -E3 is a DMB LD Effect.
- -E3 appears in program order before E2.
- -One of the following applies:
- -E2 is an Explicit Memory Effect.
- -E2 is an Implicit Tag Memory Read Effect.
- -E2 is an MMU Fault Effect.
- All of the following apply:
- -E1 is an Explicit Memory Write Effect.
- -E1 appears in program order before E3.
- -E3 is a DMB ST Effect.
- -E3 appears in program order before E2.
- -One of the following applies:
- -E2 is an Explicit Memory Write Effect.
- -E2 is an MMU Fault Effect.
- All of the following apply:
- -One of the following applies:
- -E1 is an Explicit Memory Write Effect with Release semantics.
- -E1 is a Fault Effect with Release semantics.
- -E3 and E1 are generated by an atomic instruction.
- -E3 is an Explicit Memory Read Effect with Acquire semantics.
- -E1 appears in program order before E2.
- -One of the following applies:
- -E2 is an Explicit Memory Effect.
- -E2 is an Implicit Tag Memory Read Effect.
- -E2 is an MMU Fault Effect.
- All of the following apply:
- -One of the following applies:
- -E1 is an Explicit Memory Write Effect with Release semantics.
- -E1 is a Fault Effect with Release semantics.
- -E1 appears in program order before E2.
- -E2 is an Explicit Memory Read Effect with Acquire semantics.
- All of the following apply:
- -One of the following applies:
- -E1 is an Explicit Memory Read Effect with Acquire semantics.
- -E1 is an Explicit Memory Read Effect with AcquirePC semantics.
- -E1 appears in program order before E2.
- -One of the following applies:
- -E2 is an Explicit Memory Effect.
- -E2 is an Implicit Tag Memory Read Effect.
- -E2 is an MMU Fault Effect.
- All of the following apply:
- -One of the following applies:
- -E1 is an Explicit Memory Read Effect with Acquire semantics.
- -E1 is an Explicit Memory Read Effect with AcquirePC semantics.
- -There is an Intrinsic Order Dependency from E1 to E2.
- -One of the following applies:
- -E2 is an Explicit Memory Effect.
- -E2 is an Implicit Tag Memory Read Effect.
- -E2 is an MMU Fault Effect.
- All of the following apply:
- -One of the following applies:
- -E1 is an Explicit Memory Effect.

## Locally-ordered-before

An Effect E1 is Locally-ordered-before an Effect E2 if one of the following applies:

- E1 is Tag-check-intrinsically-before E2.
- E1 is Translation-intrinsically-before E2.
- E1 is Fetch-intrinsically-before E2.
- E1 is ETS-ordered-before E2.
- E1 is Fetch-ordered-before E2.
- E1 is Same-Cache-Line-ordered-before E2.
- E1 is DSB-ordered-before E2.
- E1 is Instruction-fetch-barrier-ordered-before E2.
- E2 is a Local memory write successor of E1.
- All of the following apply:
- -E3 is a Local memory write successor of E1.
- -E3 belongs to the same single-copy-atomic grouping as E2.
- E2 is a Local MMU Fault successor of E1.
- E1 is Dependency-ordered-before E2.
- E1 is Pick-ordered-before E2.
- E1 is Atomic-ordered-before E2.
- E1 is Barrier-ordered-before E2.
- All of the following apply:
- -E1 is Locally-ordered-before E3.
- -E3 is Locally-ordered-before E2.

## Pick-locally-ordered-before

An Effect E1 is Pick-locally-ordered-before an Effect E2 if all of the following apply:

- There is a Pick dependency from E1 to E3.
- E3 is Locally-ordered-before E2.
- E2 is an Explicit Memory Write Effect.

## Locally-hardware-required-ordered-before

An Effect E1 is Locally-hardware-required-ordered-before an Effect E2 if one of the following applies:

- E1 is Locally-ordered-before E2.
- E1 is Pick-locally-ordered-before E2.
- All of the following apply:
- -E1 is Locally-hardware-required-ordered-before E3.
- -E3 is Locally-hardware-required-ordered-before E2.

## Hardware-required-ordered-before

An Effect E1 is Hardware-required-ordered-before an Effect E2 if one of the following applies:

- -E1 is an Implicit Tag Memory Read Effect.
- -E1 appears in program order before E2.
- -One of the following applies:
- -E2 is an Explicit Memory Write Effect with Release semantics.
- -E2 is a Fault Effect with Release semantics.
- All of the following apply:
- -One of the following applies:
- -E1 is an Explicit Memory Effect.
- -E1 is an Implicit Tag Memory Read Effect.
- -There is an Intrinsic Order Dependency from E1 to E2.
- -One of the following applies:
- -E2 is an Explicit Memory Write Effect with Release semantics.
- -E2 is a Fault Effect with Release semantics.

- E1 is Locally-hardware-required-ordered-before E2.
- E1 is Hazard-ordered-before E2.

## B2.3.8 Observation relations

## Explicit-Observed-by

An Effect E1 is Explicit-Observed-by an Effect E2 if one of the following applies:

- All of the following apply:
- -E1 is an Explicit Memory Effect.
- -E2 Reads-from-memory E1.
- -E1 and E2 are from different Processing Elements.
- -E2 is an Explicit Memory Effect.
- All of the following apply:
- -E1 is an Explicit Memory Effect.
- -E1 is Coherence-before E2.
- -E1 and E2 are from different Processing Elements.
- -E2 is an Explicit Memory Effect.

## Tag-Observed-by

An Effect E1 is Tag-Observed-by an Effect E2 if one of the following applies:

- All of the following apply:
- -E1 is an Explicit Memory Write Effect.
- -E2 Reads-from-memory E1.
- -E1 and E2 are from different Processing Elements.
- -E2 is an Implicit Tag Memory Read Effect.
- All of the following apply:
- -E1 is an Implicit Tag Memory Read Effect.
- -E1 is Coherence-before E2.
- -E1 and E2 are from different Processing Elements.
- -E2 is an Explicit Memory Write Effect.

## TLBuncacheable-coherence-before

An Effect E1 is TLBUncacheable-coherence-before an Effect E2 if all of the following apply:

- E1 is an Implicit TTD Memory Read Effect.
- E1 is Translation-intrinsically-before E3.
- E3 is a TLBUncacheable Fault Effect.
- E1 is Coherence-before E2.
- One of the following applies:
- -E2 is an Explicit Memory Write Effect.
- -E2 is a Hardware Update Effect.

## Hardware-Update-coherence-before

An Effect E1 is Hardware-Update-coherence-before an Effect E2 if all of the following apply:

- E1 is an Explicit Memory Read Effect.
- E1 is Coherence-before E2.
- E2 is a Hardware Update Effect.

## TLBI-coherence-before

An Effect E1 is TLBI-coherence-before an Effect E2 if all of the following apply:

- E1 is a TLBI Effect.

- E1 is TLBI-before E3.
- E3 is an Implicit TTD Memory Read Effect.
- E3 is Coherence-before E2.
- E2 is a Memory Write Effect.

## TTD-Observed-by

An Effect E1 is TTD-Observed-by an Effect E2 if one of the following applies:

- All of the following apply:
- -E1 is an Implicit TTD Memory Effect.
- -E2 Reads-from-memory E1.
- All of the following apply:
- -E2 Reads-from-memory E1.
- -E2 is an Implicit TTD Memory Effect.
- E1 is TLBUncacheable-coherence-before E2.
- E1 is Hardware-Update-coherence-before E2.
- All of the following apply:
- -E1 is a Hardware Update Effect.
- -E1 is Coherence-before E2.
- -E2 is a Memory Write Effect.
- All of the following apply:
- -E1 is a Memory Write Effect.
- -E1 is Coherence-before E2.
- -E2 is a Hardware Update Effect.
- E1 is TLBI-coherence-before E2.

## IC-Coherence-before

An Effect E1 is IC-coherence-before an Effect E2 if one of the following applies:

- All of the following apply:
- -it is not the case that DIC is implemented and it is not the case that IDC is implemented.
- -E1 is an IC Effect.
- -E1 is IC-before E3.
- -E3 is an Implicit Instruction Memory Read Effect.
- -E3 is Coherence-before E4.
- -E4 is a Memory Write Effect.
- -E4 is DC-before E2.
- -E2 is a DC CVAU Effect.
- All of the following apply:
- -it is not the case that DIC is implemented and IDC is implemented.
- -E1 is an IC Effect.
- -E1 is IC-before E3.
- -E3 is an Implicit Instruction Memory Read Effect.
- -E3 is Coherence-before E2.
- -E2 is a Memory Write Effect.
- All of the following apply:
- -DIC is implemented and IDC is implemented.
- -E1 is an Implicit Instruction Memory Read Effect.
- -E1 is Coherence-before E2.
- -E2 is a Memory Write Effect.

## Instruction-Observed-by

An Effect E1 is Instruction-Observed-by an Effect E2 if one of the following applies:

- All of the following apply:

## Observed-by

- -E2 Reads-from-memory E1.
- -E2 is an Implicit Instruction Memory Read Effect.
- E1 is IC-before E2.
- All of the following apply:
- -E1 is a DC CVAU Effect.
- -E1 is DC-before E2.
- -E2 is a Memory Write Effect.
- All of the following apply:
- -E1 is a Memory Write Effect.
- -E1 is DC-before E2.
- -E2 is a DC CVAU Effect.
- E1 is IC-coherence-before E2.

An Effect E1 is Observed-by an Effect E2 if one of the following applies:

- E1 is Explicit-Observed-by either E2 or an Effect which belongs to the same single-copy-atomic grouping as E2.
- E1 is Tag-Observed-by either E2 or an Effect which belongs to the same single-copy-atomic grouping as E2.
- E1 is TTD-Observed-by E2.
- E1 is Instruction-Observed-by E2.

## B2.3.9 Definition of an Architecturally Allowed Execution

An Architecturally Allowed Execution must satisfy the External visibility requirement , which is formulated in terms of an ordering relation called Ordered-before . An execution that does not satisfy the external visibility requirement is an Architecturally Forbidden Execution.

## Ordered-before

An Effect E1 is Ordered-before an Effect E2 if one of the following applies:

- E1 is Hardware-required-ordered-before E2.
- E1 is Observed-by E2.
- All of the following apply:
- -E1 is Ordered-before E3.
- -E3 is Ordered-before E2.

## External visibility requirement

The external visibility requirement is defined as follows: an Architecturally Allowed Execution must not exhibit a cycle in the Ordered-before relation.

In particular, for an Effect E1 that is Ordered-before an Effect E2, the External visibility requirement requires that E2 is not Observed-by E1.

## B2.3.10 Alternative formulations of the External visibility requirement for Explicit Memory Effects

## B2.3.10.1 Additional ordering relations

## Single-copy-atomic-ordered-before

AMemory Read Effect E1 is single-copy-atomic-ordered-before another Memory Read Effect E2 if all the following apply:

- E1 belongs to the same single-copy-atomic grouping as E2.
- E1 Reads-from-memory a Memory Write Effect E3.
- E1 and E3 are from different Processing Elements.

- E2 Reads-from-memory a Memory Write Effect E4.
- E2 and E4 are from the same Processing Element.

## B2.3.10.2 External completion requirement for Explicit Memory Effects

The External completion requirement for Explicit Memory Effects is an alternative way of formulating the External visibility requirement, in the context of Explicit Memory Effects only.

The Completes-before order is a total order that corresponds to the order in which Memory Effects complete within the system. Effects E1 and E2 constitute a single entry in the Completes-before order, if any of the following applies:

- All of the following apply:
- -E1 is a Memory Write Effect.
- -E2 is a Memory Write Effect.
- -E1 belongs to the same single-copy-atomic grouping as E2.
- All of the following apply:
- -E1 is a Memory Read Effect.
- -E2 is a Memory Read Effect.
- -E1 belongs to the same single-copy-atomic grouping as E2.
- -E1 Reads-from-memory a Memory Write Effect E3.
- -E1 and E3 are from different Processing Elements.
- -E2 Reads-from-memory a Memory Write Effect E4.
- -E2 and E4 are from different Processing Elements.
- All of the following apply:
- -E1 is a Memory Read Effect.
- -E2 is a Memory Read Effect.
- -E1 belongs to the same single-copy-atomic grouping as E2.
- -E1 Reads-from-memory a Memory Write Effect E3.
- -E1 and E3 are from the same Processing Element.
- -E2 Reads-from-memory a Memory Write Effect E4.
- -E2 and E4 are from the same Processing Element.
- -E3 belongs to the same single-copy-atomic grouping as E4.

All other Memory Read Effects constitute distinct entries in the Completes-before order.

## Completes-before

AMemory Read or Write Effect E1 completes-before a Memory Read or Write Effect E2 if E1 appears in the Completes-before order before E2.

## Deriving Reads-from-memory and Coherence order from the Completes-before order

The Reads-from-memory relation can be derived from the Completes-before order by specifying which Memory Write Effect every Memory Read Effect gets its value from. Specifically, for a Memory Read Effect E1 one of the following must apply:

- If all of the following apply:
- -There is a Memory Write Effect E2.
- -E1 is a Local memory read successor of E2.
- -E1 Completes-before E2.
- -There is no Memory Write Effect E3 to the Same Location in the Completes-before order between E2 and an Explicit Memory Read Effect E4 to the Same Location that appears in program order before E1.

then it must be that E1 Reads-from-memory E2.

- If all of the following apply:
- -There is a Memory Write Effect E2 (possibly representing the writing of the initial value to the Location).
- -E2 and E1 are to the Same Location.

- -E2 Completes-before E1.
- -It is not the case that E2 Completes-before a Memory Write Effect E3 and E1 is the Local memory read successor of E3.
- -There is no Memory Write Effect E4 to the Same Location in the Completes-before order between E2 and E1.
- -There is no Memory Write Effect E5 to the Same Location in the Completes-before order between E2 and a Memory Read Effect E6 to the Same Location that appears in program order before E1.

then it must be that E1 Reads-from-memory E2.

The Coherence order can be derived from the Completes-before order by letting the Coherence order of Memory Write Effects to a memory location be the order in which those Memory Write Effects appear in the Completes-before order. The final value of each memory location is therefore determined by the final Memory Write Effect to each Location in the Completes-before order. If no such Memory Write Effect exists for a given Location, the final value is the initial value of that Location.

## External completion requirement for Explicit Memory Effects

The External completion requirement for Explicit Memory Effects requires that an Memory Effect E1 Completes-before a Memory Effect E2 if any of the following statements are true:

- E1 is Locally-hardware-required-ordered-before E2.
- E1 is a Memory Read Effect, E2 is a Memory Read Effect, and E1 is single-copy-atomic-ordered-before E2.

## B2.3.10.3 External global completion requirement for Explicit Memory Effects

The External global completion requirement for Explicit Memory Effects is an alternative way of formulating the External visibility requirement, in the context of Explicit Memory Effects only.

The Globally-completes-before order is a total order that corresponds to the order in which Memory Effects complete within the system. Effects E1 and E2 constitute a single entry in the Globally-completes-before order, if any of the following applies:

- All of the following apply:
- -E1 is a Memory Write Effect.
- -E2 is a Memory Write Effect.
- -E1 belongs to the same single-copy-atomic grouping as E2.
- All of the following apply:
- -E1 is a Memory Read Effect.
- -E2 is a Memory Read Effect.
- -E1 belongs to the same single-copy-atomic grouping as E2.
- -E1 Reads-from-memory a Memory Write Effect E3.
- -E1 and E3 are from different Processing Elements.
- -E2 Reads-from-memory a Memory Write Effect E4.
- -E2 and E4 are from different Processing Elements.
- All of the following apply:
- -E1 is a Memory Read Effect.
- -E2 is a Memory Read Effect.
- -E1 belongs to the same single-copy-atomic grouping as E2.
- -E1 Reads-from-memory a Memory Write Effect E3.
- -E1 and E3 are from the same Processing Element.
- -E2 Reads-from-memory a Memory Write Effect E4.
- -E2 and E4 are from the same Processing Element.
- -E3 belongs to the same single-copy-atomic grouping as E4.

All other Memory Read Effects constitute distinct entries in the Globally-completes-before order.

## Globally-completes-before

AMemory Read or Write Effect E1 Globally-completes-before a Memory Read or Write Effect E2 if E1 appears in the Globally-completes-before order before E2.

## Deriving Reads-from-memory and Coherence order from the Globally-completes-before order

The Reads-from-memory relation can be derived from the Globally-completes-before order by specifying which Memory Write Effect every Memory Read Effect gets its value from. Specifically, for a Memory Read Effect E1 it must be that if all of the following applies:

- There is Memory Write Effect E2 (possibly representing the writing of the initial value to the Location).
- E2 Globally-completes-before E1.
- E1 and E2 are to the Same Location.
- There is no Memory Write Effect E3 to the Same Location in the Globally-completes-before order between E2 and E1.
- There is no Memory Write Effect E4 to the Same Location in the Globally-completes-before order between E2 and an Explicit Memory Read Effect E5 to the Same Location that appears in program order before E1.

then it must be that E1 Reads-from-memory E2.

The Coherence order can be derived from the Globally-completes-before order by letting the Coherence order of Memory Write Effects to a memory location be the order in which those Memory Write Effects appear in the Globally-completes-before order. The final value of each memory location is therefore determined by the final Memory Write Effect to each Location in the Globally-completes-before order. If no such Memory Write Effect exists for a given Location, the final value is the initial value of that Location.

## External global completion requirement

The External global completion requirement requires that a Memory Effect E1 Globally-completes-before a Memory Effect E2 if any of the following statements are true:

- E1 is Locally-hardware-required-ordered-before E2 and one of the following applies:
- -E1 is a Memory Write Effect.
- -E1 is a Memory Read Effect, and one of the following applies:
- -E1 Reads-from-memory a Memory Write Effect E3, and E1 and E3 are from different Processing Elements, or.
- -E1 Reads-from-memory a Memory Write Effect E3, E1, and E3 are from the same Processing Element, and E3 is Locally-hardware-required-ordered-before E2.
- E1 is a Memory Read Effect, E2 is a Memory Read Effect, and E1 is single-copy-atomic-ordered before E2.