## F5.1.237 STREX

Store Register Exclusive calculates an address from a base register value and an immediate offset, stores a word from a register to the calculated address if the PE has exclusive access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.

For more information about support for shared memory see Synchronization and semaphores. For information about memory accesses see Memory accesses.

It has encodings from the following instruction sets: A32 (A1) and T32 (T1).

A1

<!-- image -->

## Encoding

```
STREX{<c>}{<q>} <Rd>, <Rt>, [<Rn> {, {#}<imm>}]
```

## Decode for this encoding

```
constant integer d = UInt(Rd); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(32) imm32 = Zeros(32); // Zero offset if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; if d == n || d == t then UNPREDICTABLE;
```

## CONSTRAINED UNPREDICTABLE behavior

If d == t , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The store instruction executes but the value stored is UNKNOWN.

If d == n , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The instruction performs the store to an UNKNOWN address.

T1

<!-- image -->

## Encoding

```
STREX{<c>}{<q>} <Rd>, <Rt>, [<Rn> {, #<imm>}]
```

## Decode for this encoding

```
ZeroExtend(imm8:'00', 32); UNPREDICTABLE;
```

```
constant integer d = UInt(Rd); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(32) imm32 = // Armv8-A removes UNPREDICTABLE for R13 if d == 15 || t == 15 || n == 15 then if d == n || d == t then UNPREDICTABLE;
```

## CONSTRAINED UNPREDICTABLE behavior

If d == t , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The store instruction executes but the value stored is UNKNOWN.

If d == n , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The instruction performs the store to an UNKNOWN address.

For more information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors.

## Assembler Symbols

&lt;c&gt;

See Standard assembler syntax fields.

See Standard assembler syntax fields.

Is the destination general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rd' field. The value returned is:

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

Is the general-purpose register to be transferred, encoded in the 'Rt' field.

&lt;q&gt;

## &lt;Rd&gt;

## &lt;Rt&gt;

## &lt;Rn&gt;

Is the general-purpose base register, encoded in the 'Rn' field.

## &lt;imm&gt;

For the 'A1' variant: the immediate offset added to the value of &lt;Rn&gt; to calculate the address. &lt;imm&gt; can only be 0 or omitted.

For the 'T1' variant: the immediate offset added to the value of &lt;Rn&gt; to calculate the address. &lt;imm&gt; can be omitted, meaning an offset of 0. Values are multiples of 4 in the range 0-1020.

Aborts and alignment

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Rd&gt; is not updated.

Anon word-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject to the following rules:

- If AArch32.ExclusiveMonitorsPass() returns TRUE , the exception is generated.
- Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch32.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
if ConditionPassed() then EncodingSpecificOperations(); constant bits(32) address = R[n] + imm32; if AArch32.ExclusiveMonitorsPass(address,4) then MemA[address,4] = R[t]; R[d] = ZeroExtend('0', 32); else R[d] = ZeroExtend('1', 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About the DIT bit.