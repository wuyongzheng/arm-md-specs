## B1.5 Software control features and EL0

The following sections describe the EL0 view of the software control features:

- Exception handling.
- Wait for Interrupt and Wait for Event.
- The YIELD instruction.
- Application level cache management.
- Instructions relating to Debug.
- About PSTATE.DIT.

## B1.5.1 Exception handling

In the Arm architecture, an exception causes a change of program flow. Execution of an exception handler starts, at an Exception level higher than EL0, from a defined vector that relates to the exception taken.

Exceptions include:

- Interrupts.
- Memory system aborts.
- Exceptions generated by attempting to execute an instruction that is UNDEFINED.
- System calls.
- Secure monitor or Hypervisor traps.
- Debug exceptions.

Most details of exception handling are not visible to application level software, and are described in The AArch64 System Level Programmers' Model.

The SVC instruction causes a Supervisor Call exception. This provides a mechanism for unprivileged software to make a system call to an operating system.

The BRK instruction generates a Breakpoint Instruction exception. This provides a mechanism for debugging software using debugger executing on the same PE, see Breakpoint Instruction exceptions.

Note

The BRK instruction is supported only in the A64 instruction set. The equivalent instruction in the T32 and A32 instruction sets is BKPT .

## B1.5.2 Wait for Interrupt and Wait for Event

Issuing a WFI instruction indicates that no further execution is required until a WFI wakeup event occurs, see Wait for Interrupt mechanism. This permits entry to a low-power state.

Issuing a WFE instruction indicates that no further execution is required until a WFE wakeup event occurs, see Wait for Event. This permits entry to a low-power state.

## B1.5.3 The YIELD instruction

The YIELD instruction provides a hint that the task performed by a thread is of low importance so that it could yield, see YIELD. This mechanism can be used to improve overall performance in a Symmetric Multithreading (SMT) or Symmetric Multiprocessing (SMP) system.

Examples of when the YIELD instruction might be used include a thread that is sitting in a spin-lock, or where the arbitration priority of the snoop bit in an SMP system is modified. The YIELD instruction permits binary compatibility between SMT and SMP systems.

The YIELD instruction is a NOP hint instruction.

The YIELD instruction has no effect in a single-threaded system, but developers of such systems can use the instruction to flag its intended use for future migration to a multiprocessor or multithreading system. Operating systems can use YIELD in places where a yield hint is wanted, knowing that it will be treated as a NOP if there is no implementation benefit.

## B1.5.4 Application level cache management

Asmall number of cache maintenance instructions can be enabled at EL0 from higher levels of privilege using the SCTLR\_EL1 System register. Any access from EL0 to an operation without access permission causes the instruction to be trapped.

About the available operations, see Application level access to functionality related to caches.

## B1.5.5 Instructions relating to Debug

Exception handling refers to the BRK instruction, which generates a Breakpoint Instruction exception. In addition, in AArch64 state and AArch32 state, the HLT instruction causes the PE to halt execution and enter Debug state. This provides a mechanism for debugging software using a debugger that is external to the PE, see About External Debug.

Note

In AArch32 state, previous versions of the architecture defined the DBG instruction, which could provide a hint to the debug system. This instruction executes as a NOP . Arm deprecates the use of the DBG instruction.

## B1.5.6 About PSTATE.DIT

A data-independent-time sequence of code is the sequence of instructions executed from the first instruction executed after a change of PSTATE.DIT from 0 to 1 through the last instruction executed before a change of PSTATE.DIT from 1 to 0, inclusive. Instructions speculatively executed between the change of PSTATE.DIT from 0 to 1 and the change of PSTATE.DIT from 1 to 0 are considered part of the data-independent-time sequence of code.

A data-independent-time resource is any of:

- Ageneral-purpose register other than the zero register (ZR)
- Stack Pointer register
- SIMD&amp;FP register
- If FEAT\_SVE or FEAT\_SME is implemented, SVE scalable vector register
- If FEAT\_SME is implemented, ZA register
- If FEAT\_SME2 is implemented, ZT0 register
- SPSR\_ELx.NZCV
- PSTATE.NZCV

Note

The collections of PSTATE.NZCV and SPSR\_ELx.NZCV are each considered a single data-independent-time resource.

A data-independent-time instruction is an instruction that is required to honor the data-independent timing behaviors described in this section.

A data-independent-time value is any of:

- Any given value (V) read from memory by the Explicit Memory Read Effect of a data-independent-time instruction (I1) that is executed within a data-independent-time sequence of code (C), where V is not consumed by any other instruction (I2) for which any of the following apply:
- -I2 is not a data-independent-time instruction
- -I2 is not executed in C
- -Vis used to form the address or Logical Address Tag of a Memory Effect generated by I2
- -If I2 is an SME instruction, V is used as the slice index register or vector select register for I2

- Any given value (V) written to a data-independent-time resource by a data-independent-time instruction (I1) that is executed within a data-independent-time sequence of code (C), where V is not consumed by any other instruction (I2) for which any of the following apply:
- -I2 is not a data-independent-time instruction
- -I2 is not executed in C
- -Vis used to form the address or Logical Address Tag of a Memory Effect generated by I2
- -If I2 is an SME instruction, V is used as the slice index register or vector select register for I2
- Any given value (V) read from a data-independent-time resource by a data-independent-time instruction (I1) that is executed within a data-independent-time sequence of code (C) and none of the following apply:
- -Vwas produced by another instruction (I0) and any of the following apply:
- -I0 is not a data-independent-time instruction
- -I0 is not executed in C
- -Vis used to form the address or Logical Address Tag of a Memory Effect produced by I1.
- -Vis not consumed by any other instruction (I2) for which any of the following apply:
- -I2 is not a data-independent-time instruction
- -I2 is not executed in C
- -Vis used to form the address or Logical Address Tag of a Memory Effect generated by I2
- -If I2 is an SME instruction, V is used as the slice index register or vector select register for I2
- Any given value (V) written to memory by the Explicit Memory Write Effect of a data-independent-time instruction (I1) that is executed within a data-independent-time sequence of code (C) and none of the following apply:
- -Vwas produced by another instruction (I0) and any of the following apply:
- -I0 is not a data-independent-time instruction
- -I0 is not executed in C
- -Vis used to form the address or Logical Address Tag of a Memory Effect produced by I1.
- -Vwas sourced from the zero register.
- -Vis not consumed by any other instruction (I2) for which any of the following apply:
- -I2 is not a data-independent-time instruction
- -I2 is not executed in C
- -Vis used to form the address or Logical Address Tag of a Memory Effect generated by I2
- -If I2 is an SME instruction, V is used as the slice index register or vector select register for I2
- Any given value (V) speculatively read from memory at a Location (L) as the result of executing a data-independent-time sequence of code, where L is not explicitly read by the data-independent-time sequence of code. Examples of this include:
- -Reading additional bytes from memory while reading the bytes required by an Explicit Memory Read Effect
- -Hardware-generated prefetches
- -Prefetch memory instructions

The execution time of a given data-independent-time sequence of code must be independent of all data-independent-time values.

The execution time of a data-independent-time instruction (I1) executed within a data-independent-time sequence of code must be independent of all data-independent-time values consumed or produced by I1.

The time to respond to an asynchronous exception taken from within a data-independent-time sequence of code must be independent of all data-independent-time values.

The execution of a data-independent-time sequence of code (C1) must not cause an irreversible change in microarchitectural state of the PE that would permit a sequence of code (C2) that is executed after C1 to determine any data-independent-time value accessed during the execution of C1. For the purposes of this requirement, a data-independent-time value written by an Explicit Memory Write Effect that is held in caches is not considered an irreversible change in microarchitectural state.

The execution of a data-independent-time sequence of code (C1) must not alter the state of PMU counters in a way that allows a sequence of code (C2) that is executed after C1 to determine any data-independent-time value accessed during C1.

Note

In cases where an instruction is architecturally required to only read or write a subset of a data-independent-time resource, the entire data-independent-time resource is considered to have been read or written for the sake of these requirements.

Note

The architecture does not guarantee that the execution time of a data-independent-time sequence of code is independent of data-independent-time values if those values are read-from or written-to a peripheral.

Note

The classification of a value being a data-independent-time value due to having been read from a memory location (L) by an Explicit Memory Read Effect or written to L by an Explicit Memory Write Effect is based on the particular Effect generated by a data-independent-time instruction executed from within a data-independent-time sequence of code. The value held in L is not itself considered a data-independent-time value. As a result, it is possible for the execution time of a data-independent-time sequence of code to vary based on the value held in L if L is accessed via any of the following:

- Outside the data-independent-time sequence of codeÍ¾ either architecturally or speculatively
- Within a data-independent-time sequence of code but not as a data-independent-time value

Note

- The Operational information section of an instruction description indicates whether or not that instruction is a data-independent-time instruction. If the Operational information section of an instruction description does not mention data-independent-time or if the section does not exist, then the instruction is not a data-independent-time instruction.
- The use of value prediction for data-independent-time values, is not compatible with the requirement that the timing is insensitive to the data value being loaded.
- Arm recommends that the FEAT\_PAuth instructions do not have their timing dependent on the key value used in the pointer authentication, regardless of whether the instruction is executed in a data-independent-time sequence of code.
- The architecture makes no statement about the timing properties of any instructions executed outside of a dataindependent-time sequence of code. However, it is likely that these instructions have timing that is invariant of the data in many situations.
- For SVE and SME predicated instructions, it is the programmer's responsibility to use a Governing predicate that does not reflect the values of the data being operated on.

Acorresponding DIT bit is added to PSTATE in AArch64 state, and to CPSR in AArch32 state.

On an exception that is taken from AArch64 state to AArch64 state, PSTATE.DIT is copied to SPSR\_ELx.DIT.

On an exception that is taken from AArch32 state to AArch64 state, CPSR.DIT is copied to SPSR\_ELx.DIT.

On an exception return from AArch64 state:

- SPSR\_ELx.DIT is copied to PSTATE.DIT, when the target Exception level is in AArch64 state.
- SPSR\_ELx.DIT is copied to CPSR.DIT, when the target Exception level is in AArch32 state.

PSTATE.DIT can be written and read at all Exception levels.

Note

- PSTATE.DIT is unchanged on entry into Debug state.
- PSTATE.DIT is not guaranteed to have any effect in Debug state.
- Software is advised to ensure that no indirect branch is executed while secret data is held in registers.
- Software is advised to ensure that no direct branches target non-constant-time code while secret data is held in registers.

## Chapter B2 The AArch64 Application Level Memory Model

This chapter gives an application level view of the memory model. It contains the following sections:

- About the Arm memory model.
- Atomicity in the Arm architecture.
- Ordering requirements defined by the formal concurrency model.
- Additional ordering requirements outside of the scope of the formal concurrency model
- Restrictions on the effects of speculation.
- Memory barriers.
- Caches and memory hierarchy.
- Alignment support.
- Endian support.
- Memory types and attributes.
- Mismatched memory attributes.
- Synchronization and semaphores.

Note

In this chapter, System register names usually link to the description of the register in AArch64 System Register Descriptions, for example. SCTLR\_EL1.