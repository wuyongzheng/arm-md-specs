## D14.3 Common event numbers

The event numbers of the common architectural and microarchitectural events are reserved for the specified events. Each of these event numbers must either:

- Be used for its assigned event.
- Not be used.

However, see Required events.

When an implementation supports monitoring of an event that is assigned a common architectural or microarchitectural event number, Arm strongly recommends that it uses that number for the event. However, software might encounter implementations where an event assigned a number in this range is monitored using an event number from an IMPLEMENTATION DEFINED range.

Note

Arm might define other common architectural and microarchitectural event numbers. This is one reason why software must not assume that an event with an assigned common architectural or microarchitectural event number is never monitored using an event number from the IMPLEMENTATION DEFINED range.

It is IMPLEMENTATION DEFINED which events, including Common events, are generated by IMPLEMENTATION DEFINED extensions to the architecture, including accesses to IMPLEMENTATION DEFINED System registers and IMPLEMENTATION DEFINED System instructions. However, the functionality of the IMPLEMENTATION DEFINED extension must be appropriate for the generated events.

The common events are described in the following sections:

- Common architectural events.
- Common microarchitectural events.

The supported common architectural and microarchitectural events in the ranges 0x0000 -0x003F and 0x4000 -0x403F are discoverable to software through:

- The PMCEID0\_EL0 and PMCEID1\_EL0 registers in AArch64 state.
- The PMCEID0, PMCEID1, PMCEID2, and PMCEID3 registers in AArch32 state.

Arm recommends that the value of 0 is used for the PMCEID0\_EL0 or PMCEID1\_EL0 bit corresponding to any event that an implementation never generates, even if the implementation is considered to support but never count the event.

Note

- For example, if an implementation never generates the L1D\_CACHE\_ALLOCATE event, event 31, Arm recommends that PMCEID0\_EL0[31] is RAZ.
- In an implementation that supports both Execution states, each bit in the AArch64 PMCEID0\_EL0 and PMCEID1\_EL0 registers corresponds to a single bit in the AArch32 PMCEID0, PMCEID1, PMCEID2, and PMCEID3 registers, and corresponding bits must have the same behavior.

However, for some implementations, an event in the common events range might be generated by the system, meaning behavior can vary between systems. In such a case, the corresponding PMCEID n \_EL0 bit might be RAO.

Event numbers that Table D14-2 shows as allocated for common architectural and microarchitectural events that are not described in Common architectural events and Common microarchitectural events are reserved. Future revisions of this Manual, or of the architecture, might assign these reserved values to additional common events. Events that do not require additional features in the PMU can be implemented retrospectively, meaning an implementation of a particular version of the PMU specification might support common events that are first defined in a later version of the PMU specification.

Note

The requirement that an event that is implemented retrospectively does not require additional features in the PMU means that it must be possible to represent the event n the PMEVTYPER&lt;n&gt;\_EL0.evtCount field. This means, for example, that an implementation with a 10-bit PMEVTYPER&lt;n&gt;\_EL0.evtCount field can only implement events with event numbers 0x0000 -0x03FF .

## D14.3.1 Common architectural events

The Common architectural events are:

## 0x0000 , SW\_INCR, Instruction architecturally executed, Condition code check pass, software increment

The counter counts each write to the PMSWINC\_EL0 and PMSWINC register, for each implemented event counter &lt;n&gt;:

- In AArch64 state, if PMEVTYPER&lt;n&gt;\_EL0.evtCount is 0x0000 then the counter counts each MSR write to PMSWINC\_EL0 with bit [n] set to 1.
- In AArch32 state, if PMEVTYPER&lt;n&gt;.evtCount is 0x0000 then the counter counts each MCR write to PMSWINC with bit [n] set to 1.

If the PE performs two architecturally executed writes to the PMSWINC\_EL0 or PMSWINC register without an intervening Context synchronization event, then the counter is incremented twice.

Note

In a multithreaded implementation, if the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT is 1, then the counter counts writes by all PEs that have the same affinity at level 1 and above.

PMCEID0\_EL0[0] reads as 1 if this event is implemented and 0 otherwise.

## 0x0006 , LD\_RETIRED, Instruction architecturally executed, Condition code check pass, load

The counter counts each architecturally-executed memory-reading instruction counted by INST\_RETIRED.

It is IMPLEMENTATION DEFINED whether the prefetch instructions counted by PRF\_RETIRED are counted as Memory-reading instructions:

- If the prefetch instructions are counted as Memory-reading instructions, then they are counted by LD\_RETIRED and LD\_ANY\_RETIRED.
- Otherwise, if the prefetch instructions are not counted as Memory-reading instructions by LD\_RETIRED, then it is further IMPLEMENTATION DEFINED which one of the following applies:
- They are counted as data-processing instructions.
- They are counted by LDST\_ANY\_RETIRED.

Arm recommends that if a prefetch instruction is not implemented as a NOP and the PRF\_RETIRED event is not implemented, then the instruction is counted as a Memory-reading instruction.

PMCEID0\_EL0[6] reads as 1 if this event is implemented and 0 otherwise.

## 0x0007 , ST\_RETIRED, Instruction architecturally executed, Condition code check pass, store

The counter counts each architecturally-executed memory-writing instruction counted by INST\_RETIRED.

The counter does not count a Store-Exclusive instruction that fails.

PMCEID0\_EL0[7] reads as 1 if this event is implemented and 0 otherwise.

## 0x0008 , INST\_RETIRED, Instruction architecturally executed

The counter counts each architecturally-executed instruction.

If FEAT\_PMUv3p9 is implemented, then the counter counts architecturally-executed MOVPRFX instructions.

Otherwise, it is IMPLEMENTATION DEFINED whether the counter counts architecturally-executed MOVPRFX instructions.

PMCEID0\_EL0[8] reads as 1 if this event is implemented and 0 otherwise.

## 0x0009 , EXC\_TAKEN, Exception taken

The counter counts each exception taken.

Note

The counter counts the PE exceptions described in:

- For exceptions taken to an Exception level using AArch64, Exception entry.

- For exceptions taken to an Exception level using AArch32, AArch32 state exception descriptions.

PMCEID0\_EL0[9] reads as 1 if this event is implemented and 0 otherwise.

## 0x000A , EXC\_RETURN, Instruction architecturally executed, Condition code check pass, exception return

The counter counts each architecturally-executed exception return instruction.

Instructions defined in the following sections are counted as exception return instructions:

- For an exception return from an Exception level using AArch64, Exception return.
- For an exception return from an Exception level using AArch32, Exception return instructions.

It is CONSTRAINED UNPREDICTABLE whether the execution of an exception return instruction is counted if any of the following apply:

- Execution of the instruction is, itself, CONSTRAINED UNPREDICTABLE.
- Execution of the instruction sets PSTATE.IL and does not generate an exception return.

## Note

- Examples of when an exception return instruction is CONSTRAINED UNPREDICTABLE are if the instruction is executed in AArch32 state at EL0 or in System mode.
- A particular consequence of this CONSTRAINED UNPREDICTABLE behavior is that an implementation that does not support AArch32 state at EL1 or higher does not have to count AArch32 MOVS PC, LR , and related instructions, as exception return instructions.

PMCEID0\_EL0[10] reads as 1 if this event is implemented and 0 otherwise.

## 0x000B , CID\_WRITE\_RETIRED, Instruction architecturally executed, Condition code check pass, write to CONTEXTIDR

The counter counts each MSR write to CONTEXTIDR\_EL1 and MCR write to CONTEXTIDR.

If the PE performs two architecturally-executed writes to CONTEXTIDR without an intervening Context synchronization event, it is CONSTRAINED UNPREDICTABLE whether the first write is counted.

The counter counts only writes to these named registers. For example:

- When FEAT\_VHE or FEAT\_Debugv8p2 is implemented, the counter does not count writes using the register name CONTEXTIDR\_EL2.
- When FEAT\_VHE is implemented, the counter:
- Counts each write using the register name CONTEXTIDR\_EL1, including when executing at EL2 and the Effective value of HCR\_EL2.E2H is 1.
- Does not count writes using the register name CONTEXTIDR\_EL12.
- When FEAT\_NV2 is implemented, the counter counts writes using the register name CONTEXTIDR\_EL1, including when executing at EL1 and the Effective value of HCR\_EL2.{NV2, NV1, NV} is {1, 1, 1}.

PMCEID0\_EL0[11] reads as 1 if this event is implemented and 0 otherwise.

## 0x000C , PC\_WRITE\_RETIRED, Instruction architecturally executed, Condition code check pass, Software change of the PC

The counter counts each architecturally-executed Software change of the PC that is taken.

This includes all:

- Branch instructions.
- Memory-reading instructions that explicitly write to the PC.
- Data-processing instructions that explicitly write to the PC.
- Exception return instructions.

Note

Conditional branches are only counted if the branch is taken.

If FEAT\_PMUv3p9 is implemented, then the following instructions are not included as a Software change of the PC:

- A BRK or BKPT instruction.
- An UNDEFINED instruction that generates an exception.
- An exception-generating instruction, SVC , HVC , or SMC , that generates an exception.
- AContext synchronization barrier instruction, ISB .

If FEAT\_PMUv3p9 is not implemented, then it is IMPLEMENTATION DEFINED whether any of these instructions are included as a Software change of the PC.

The counter does not increment for exceptions other than those explicitly identified in these lists.

If PC\_WRITE\_RETIRED and BR\_SKIP\_RETIRED are both implemented, the PE must treat the following types of instruction in the same way for both events:

- BRK and BKPT instructions.
- UNDEFINED instructions.
- The exception-generating instructions, SVC , HVC , and SMC .
- Context synchronization barrier instructions.

From Armv8.6, if BR\_RETIRED is also implemented, the PE must also treat these types of instruction in the same way for the BR\_RETIRED, PC\_WRITE\_RETIRED, and BR\_SKIP\_RETIRED events.

PMCEID0\_EL0[12] reads as 1 if this event is implemented and 0 otherwise.

## 0x000D , BR\_IMMED\_RETIRED, Branch instruction architecturally executed, immediate

The counter counts each architecturally-executed immediate branch instruction.

The following instructions are counted as immediate branch instructions:

- For AArch32 state, the following instructions:
- B{&lt;c&gt;} &lt;label&gt; .
- BL{&lt;c&gt;} &lt;label&gt; .
- BLX{&lt;c&gt;} &lt;label&gt; .
- CBZ &lt;Rn&gt;, &lt;label&gt; .
- CBNZ &lt;label&gt; .
- For AArch64 state, the following instructions:
- B &lt;label&gt; .
- B.cond &lt;label&gt; .
- BL &lt;label&gt; .
- CBZ &lt;Rn&gt;, &lt;label&gt; .
- CBNZ &lt;Rn&gt;, &lt;label&gt; .
- TBZ &lt;Rn&gt;, &lt;label&gt; .
- TBNZ &lt;Rn&gt;, &lt;label&gt; .
- BC.cond &lt;label&gt; .
- CB&lt;cc&gt; &lt;Rn&gt;, #&lt;imm&gt;, &lt;label&gt; .

- CB&lt;cc&gt; &lt;Rn&gt;, #&lt;Rm&gt;, &lt;label&gt; . · CBB&lt;cc&gt; &lt;Rn&gt;, #&lt;Rm&gt;, &lt;label&gt; . · CBH&lt;cc&gt; &lt;Rn&gt;, #&lt;Rm&gt;, &lt;label&gt; .

## Note

Conditional branches are always counted, regardless of whether the branch is taken or not taken.

If the Context synchronization barrier instruction ISB is counted as a Software change of the PC instruction by PC\_WRITE\_RETIRED, then it is IMPLEMENTATION DEFINED whether ISB is counted as an immediate branch instruction.

PMCEID0\_EL0[13] reads as 1 if this event is implemented and 0 otherwise.

## 0x000E , BR\_RETURN\_RETIRED, Branch instruction architecturally executed, procedure return, taken

The counter counts each architecturally executed procedure return instruction.

The following instructions are counted as procedure return instructions:

- For AArch32 state, the following instructions:
- BX R14 .
- MOV PC, LR .
- POP {..., PC} .
- LDR PC, [SP], #offset .
- For AArch64 state, the following instructions:
- RET .
- If FEAT\_PAuth is implemented, RETAA and RETAB .
- If FEAT\_PAuth\_LR is implemented, RETAASPPC , RETABSPPC , RETAASPPCR , and RETABSPPCR .

## Note

The counter counts only the listed instructions as procedure returns. For example, it does not count the following AArch32 instructions as procedure return instructions:

- BX R0 , because Rm != R14.
- MOV PC, R0 , because Rm != R14.
- LDM SP, {..., PC} , because writeback is not specified.
- LDR PC, [SP, #offset] , because this specifies the wrong addressing mode.

PMCEID0\_EL0[14] reads as 1 if this event is implemented and 0 otherwise.

## 0x000F , UNALIGNED\_LDST\_RETIRED, Instruction architecturally executed, Condition code check pass, unaligned load or store

The counter counts each memory-reading instruction or memory-writing instruction access that would generate an Alignment fault when Alignment fault checking is enabled.

The counter does not count accesses that would generate an SP alignment fault exception if the applicable stack pointer alignment check is enabled, unless that access would also generate an Alignment fault Data Abort exception if Alignment fault checking is enabled.

It is IMPLEMENTATION DEFINED and might be UNPREDICTABLE whether this event counts accesses that generate an exception, including accesses that do generate Alignment fault Data Abort exceptions.

PMCEID0\_EL0[15] reads as 1 if this event is implemented and 0 otherwise.

0x001C , TTBR\_WRITE\_RETIRED, Instruction architecturally executed, Condition code check pass, write to TTBR

The counter counts each MSR write to TTBR0\_EL1 and TTBR1\_EL1 in AArch64 state and MCR and MCRR write to TTBR0 and TTBR1 in AArch32 state.

If the PE executes two writes to the same TTBR, without an intervening Context synchronization event, it is CONSTRAINED UNPREDICTABLE whether the first write to the TTBR, is counted.

The counter counts only writes to these registers by name. For example:

- If EL3 is implemented, the counter does not count writes using the register name TTBR0\_EL3. However, when EL3 is using AArch32, the counter counts writes to either banked copy of TTBR0 and TTBR1.
- If EL2 is implemented, the counter does not count writes using the register names TTBR0\_EL2, VTTBR\_EL2, HTTBR, and VTTBR.
- When FEAT\_VHE is implemented, the counter:
- Counts each write using the register names TTBR0\_EL1 and TTBR1\_EL1, including when executing at EL2 and the Effective value of HCR\_EL2.E2H is 1.
- Does not count writes using the register names TTBR1\_EL2, TTBR0\_EL12, and TTBR1\_EL12.
- When FEAT\_NV2 is implemented, the counter counts each write using the register names TTBR0\_EL1 and TTBR1\_EL1, including when executing at EL1 and the Effective value of HCR\_EL2.{NV2, NV1, NV} is {1, 1, 1}.

PMCEID0\_EL0[28] reads as 1 if this event is implemented and 0 otherwise.

## 0x001E , CHAIN, Chain a pair of event counters

Even-numbered counters never increment as a result of this event.

For an odd-numbered counter &lt;n+1&gt;, the counter increments when an event increments the preceding even-numbered counter &lt;n&gt; on the same PE causing unsigned overflow of bits [31:0] of the event counter &lt;n&gt;, and any of the following are true:

- FEAT\_PMUv3p5 is not implemented.
- EL2 is not implemented and PMCR.LP is 0.
- EL2 is implemented, &lt;n&gt; is less than the Effective value of HDCR.HPMN, and PMCR.LP is 0.
- EL2 is implemented, &lt;n&gt; is greater than or equal to the Effective value of HDCR.HPMN, and HDCR.HLP is 0.

This means the CHAIN event can be used to link the odd-numbered counter with the preceding even-numbered counter to provide a 64-bit counter.

If EL2 is implemented and &lt;n+1&gt; is equal to the Effective value of HDCR.HPMN, then it is UNPREDICTABLE whether the counter counts.

If FEAT\_PMUv3\_EXTPMN is implemented and &lt;n+1&gt; is equal to the Effective value of PMCCR.EPMN, then it is UNPREDICTABLE whether the counter counts.

## Note

- When FEAT\_PMUv3p5 is not implemented, the CHAIN event allows software to use the N event counters as N 32-bit counters, N÷2 64-bit counters, or a mixture of 32-bit counters and 64-bit counters.
- The CHAIN event only counts overflows from the preceding even-numbered counter on the same PE. This means it ignores the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.
- The architecture does not provide atomic access to a pair of counters.

To filter the Exception levels and Security states in which the event is counted, software:

- Programs PMEVTYPER&lt;n&gt;\_EL0 to count the event in the required conditions.
- Programs PMEVTYPER&lt;n+1&gt;\_EL0 to count the CHAIN event in all Exception levels and states.

The PE might ignore the filter settings for the CHAIN event and behave as if they are set to count in all Exception levels and states. If software does not program the event in this way, the count becomes UNPREDICTABLE.

The architecture does not define the latency between the low counter overflowing and the high counter incrementing the CHAIN event. There is no requirement for updates to occur synchronously, but software reading or enabling the counter pair by reading the low counter first and the high counter second, with an intervening Context synchronization event, will not observe the low counter incrementing and overflowing for the event and the high counter not incrementing for

the resulting CHAIN event. This means that the ISB executed after reading the low counter ensures the completion of the update of the high counter by the CHAIN event.

PMCEID0\_EL0[30] reads as 1 if this event is implemented and 0 otherwise.

## 0x0021 , BR\_RETIRED, Instruction architecturally executed, branch

The counter counts each branch instruction on the architecturally executed path that would incur cost if mispredicted.

If FEAT\_PMUv3p9 is implemented:

- Unconditional direct branch instructions are counted.
- Exception return instructions are counted.
- Exception-generating instructions are not counted.
- Context synchronization instructions are not counted.

If FEAT\_PMUv3p9 is not implemented, then it is IMPLEMENTATION DEFINED whether the counter increments for any of these instructions.

The counter counts all other branch instructions, memory-reading instructions and data-processing instructions that explicitly write to the PC, at retirement.

Note

Conditional branches are always counted, regardless of whether the branch is taken.

Arm recommends that BR\_RETIRED counts Unconditional direct branch instructions and Exception return instructions.

From Armv8.6, if PC\_WRITE\_RETIRED and BR\_RETIRED are both implemented, the PE must treat the following types of instruction in the same way for both events:

- BRK and BKPT instructions.
- UNDEFINED instructions.
- The exception-generating instructions, SVC , HVC , and SMC .
- Context synchronization barrier instructions.

PMCEID1\_EL0[1] reads as 1 if this event is implemented and 0 otherwise.

## 0x0081 , EXC\_UNDEF, Exception taken, other synchronous

The counter counts each exception counted by EXC\_TAKEN that is Taken locally and is not counted as any of the following:

- Exception taken, Supervisor Call (EXC\_SVC).
- Exception taken, Secure Monitor Call (EXC\_SMC).
- Exception taken, Hypervisor Call (EXC\_HVC).
- Exception taken, Instruction Abort (EXC\_PABORT).
- Exception taken, Data Abort or SError (EXC\_DABORT).
- Exception taken, IRQ (EXC\_IRQ).
- Exception taken, FIQ (EXC\_FIQ).

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0082 , EXC\_SVC, Exception taken, Supervisor Call

The counter counts each Supervisor Call exception counted by EXC\_TAKEN that is Taken locally.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0083 , EXC\_PABORT, Exception taken, Instruction Abort

The counter counts each Instruction Abort exception counted by EXC\_TAKEN that is Taken locally.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0084 , EXC\_DABORT, Exception taken, Data Abort or SError

The counter counts each Guarded control stack Data Check Exception, Data Abort, SError interrupt, or virtual SError interrupt exception counted by EXC\_TAKEN that is Taken locally.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0086 , EXC\_IRQ, Exception taken, IRQ

The counter counts each IRQ or virtual IRQ exception counted by EXC\_TAKEN that is Taken locally.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0087 , EXC\_FIQ, Exception taken, FIQ

The counter counts each FIQ or virtual FIQ exception counted by EXC\_TAKEN that is Taken locally.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0088 , EXC\_SMC, Exception taken, Secure Monitor Call

The counter counts each Secure Monitor Call exception counted by EXC\_TAKEN.

The counter does not count SMC instructions that generate other exceptions, including Trap exceptions and Undefined Instruction exceptions.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x008A , EXC\_HVC, Exception taken, Hypervisor Call

The counter counts each Hypervisor Call exception counted by EXC\_TAKEN.

The counter does not count HVC instructions that are UNDEFINED.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x008B , EXC\_TRAP\_PABORT, Exception taken, Instruction Abort not Taken locally

The counter counts each Instruction Abort exception counted by EXC\_TAKEN that is not Taken locally.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x008C , EXC\_TRAP\_DABORT, Exception taken, Data Abort or SError not Taken locally

The counter counts each Guarded control stack Data Check Exception, Data Abort, SError interrupt, or virtual SError interrupt exception counted by EXC\_TAKEN, that is not Taken locally.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x008D , EXC\_TRAP\_OTHER, Exception taken, other traps not Taken locally

The counter counts each exception counted by EXC\_TAKEN that is not Taken locally and not counted as any of the following:

- Exception taken, Secure Monitor Call (EXC\_SMC).
- Exception taken, Hypervisor Call (EXC\_HVC).
- Exception taken, Instruction Abort not Taken locally (EXC\_TRAP\_PABORT).
- Exception taken, Data Abort or SError not Taken locally (EXC\_TRAP\_DABORT).
- Exception taken, IRQ not Taken locally (EXC\_TRAP\_IRQ).
- Exception taken, FIQ not Taken locally (EXC\_TRAP\_FIQ).

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x008E , EXC\_TRAP\_IRQ, Exception taken, IRQ not Taken locally

The counter counts each IRQ or virtual IRQ exception counted by EXC\_TAKEN that is not Taken locally.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x008F , EXC\_TRAP\_FIQ, Exception taken, FIQ not Taken locally

The counter counts each FIQ or virtual FIQ exception counted by EXC\_TAKEN that is not Taken locally.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x400C , TRB\_WRAP, Trace buffer current write pointer wrapped

The counter counts each write made by the Trace Buffer Unit to the trace buffer that causes the trace buffer current write pointer to wrap to the trace buffer base pointer.

PMCEID0\_EL0[44] reads as 1 if this event is implemented and 0 otherwise.

## 0x400D , PMU\_OVFS, PMU overflow, counters accessible to EL1 and EL0

The counter counts each unsigned overflow of a PMU counter due to any of the following:

- An event is counted by an event counter &lt;n&gt; and all of the following are true:
- PMINTENSET\_EL1[n] is 1.
- One of the following is true:
- Counting the event causes unsigned overflow of PMEVCNTR&lt;n&gt;\_EL0[31:0], and either FEAT\_PMUv3p5 is not implemented or PMCR\_EL0.LP is 0.
- Counting the event causes unsigned overflow of PMEVCNTR&lt;n&gt;\_EL0[63:0], FEAT\_PMUv3p5 is implemented, and PMCR\_EL0.LP is 1.
- The event counter &lt;n&gt; is in the first range.
- Acycle is counted by PMCCNTR\_EL0, PMINTENSET\_EL1[31] is 1, and one of the following is true:
- Counting the cycle causes unsigned overflow of PMCCNTR\_EL0[31:0] and PMCR\_EL0.LC is 0.
- Counting the cycle causes unsigned overflow of PMCCNTR\_EL0[63:0] and PMCR\_EL0.LC is 1.
- FEAT\_PMUv3\_ICNTR is implemented, an instruction is counted by PMICNTR\_EL0, PMINTENSET\_EL1.F0 is 1, and counting the instruction causes unsigned overflow of PMICNTR\_EL0[63:0].

This event cannot be counted by the PMU. PMCEID0\_EL0[45] reads as 0.

## 0x400E , TRB\_TRIG, Trace buffer Trigger Event

The counter counts each trace buffer Trigger Event.

It is IMPLEMENTATION DEFINED whether this event can be counted by the PMU.

PMCEID0\_EL0[46] reads as 1 if this event is implemented and can be counted by the PMU, and 0 otherwise.

## 0x400F , PMU\_HOVFS, PMU overflow, counters reserved for use by EL2

The counter counts each unsigned overflow of a PMU counter due to an event counted by an event counter &lt;n&gt; when all of the following are true:

- EL2 is implemented.
- PMINTENSET\_EL1[n] is 1.
- One of the following is true:
- Counting the event causes unsigned overflow of PMEVCNTR&lt;n&gt;\_EL0[31:0], and either FEAT\_PMUv3p5 is not implemented or MDCR\_EL2.HLP is 0.
- Counting the event causes unsigned overflow of PMEVCNTR&lt;n&gt;\_EL0[63:0], FEAT\_PMUv3p5 is implemented, and MDCR\_EL2.HLP is 1.
- The event counter &lt;n&gt; is in the second range.

The event is not transmitted to a trace unit if SelfHostedTraceEnabled() is TRUE and TRFCR\_EL2.E2TRE is 0.

Note

This is in addition to the rules for the export of all events to a trace unit. See Controls to prohibit trace at Exception levels.

This event cannot be counted by the PMU. PMCEID0\_EL0[47] reads as 0.

## 0x8000 , SIMD\_INST\_RETIRED, Instruction architecturally executed, SIMD

The counter counts each architecturally executed SIMD instruction.

It is IMPLEMENTATION DEFINED which architecturally executed SIMD instructions are counted in AArch32 state.

When Armv9.5 is not implemented, it is IMPLEMENTATION DEFINED whether scalar loads and stores to SIMD&amp;FP registers other than those listed above are counted.

When Armv9.5 is implemented, other scalar loads and stores to SIMD&amp;FP registers are not counted.

## 0x8001 , ASE\_INST\_RETIRED, Instruction architecturally executed, Advanced SIMD

The counter counts each architecturally executed instruction counted by ASE\_SVE\_INST\_RETIRED that is classified as an Advanced SIMD instruction.

The following instructions are counted as Advanced SIMD instructions:

- For AArch64 state:
- The SIMD operations listed in Data processing - SIMD and floating-point.
- If FEAT\_Crypto is implemented, the Advanced SIMD Cryptographic instructions. See The Cryptographic Extension in AArch64 state.
- Advanced SIMD loads and stores.
- For AArch32 state:
- Instructions from Advanced SIMD data-processing instructions.
- If FEAT\_Crypto is implemented, the Advanced SIMD Cryptographic instructions. See The Cryptographic Extension in AArch32 state.
- Advanced SIMD loads and stores.

This includes all instructions that operate on the SIMD&amp;FP registers, except those that are counted as one of the following:

- Integer data-processing instructions.
- Scalar floating-point data-processing instructions.

If FEAT\_PMUv3p9 is implemented, Advanced SIMD scalar instructions are not counted as Advanced SIMD instructions. Otherwise, it is IMPLEMENTATION DEFINED whether Advanced SIMD scalar instructions are counted as Advanced SIMD instructions. This includes Advanced SIMD scalar instructions which operate on floating-point values.

## 0x8002 , SVE\_INST\_RETIRED, Instruction architecturally executed, SVE

The counter counts each architecturally executed instruction counted by ASE\_SVE\_INST\_RETIRED that is classified as an SVE instruction.

An SVE instruction is any instruction that operates on the SVE scalable vector and predicate registers that is not any of the following:

- When FEAT\_SME is implemented, an instruction counted by SME\_SPEC as an SME instruction.
- If FEAT\_PMUv3p9 is implemented, a non-SIMD SVE instruction.

If FEAT\_PMUv3p9 is not implemented, it is IMPLEMENTATION DEFINED whether the counter counts non-SIMD instructions.

Instructions defined by FEAT\_SME which involve the SVE registers but do not involve any ZA or ZT registers are counted as SVE instructions.

## 0x8003 , ASE\_SVE\_INST\_RETIRED, Instruction architecturally executed, Advanced SIMD or SVE

The counter counts each architecturally executed instruction counted by SE\_INST\_RETIRED that is classified as an Advanced SIMD instruction or an SVE instruction.

See ASE\_INST\_RETIRED and SVE\_INST\_RETIRED for these classifications.

## 0x8107 , BR\_SKIP\_RETIRED, Branch instruction architecturally executed, not taken

The counter counts each conditional Software change of the PC instruction that is not taken.

This includes all:

- Conditional branch instructions.
- Conditional memory-reading instructions that explicitly write to the PC.
- Conditional data-processing instructions that explicitly write to the PC.
- Conditional exception return instructions.

These are the same instructions which, if unconditional, or conditional and taken, are counted by the PC\_WRITE\_RETIRED event.

If FEAT\_PMUv3p9 is implemented, then the following instructions are not included as a Software change of the PC:

- Aconditional UNDEFINED instruction that does not generate an exception.
- Aconditional exception-generating instruction, SVC , HVC , or SMC , that does not generate an exception.
- Aconditional Context synchronization barrier instruction, ISB , that fails its condition code check.

If FEAT\_PMUv3p9 is not implemented, then it is IMPLEMENTATION DEFINED whether these instructions are included as a Software change of the PC.

Note

Many of these instructions can only be conditional in the AArch32 instruction sets.

The counter does not increment for exceptions other than those explicitly identified in these lists.

If PC\_WRITE\_RETIRED and BR\_SKIP\_RETIRED are both implemented, the PE must treat the following types of instruction in the same way for both events:

- BRK and BKPT instructions.
- UNDEFINED instructions.
- The exception-generating instructions, SVC , HVC , and SMC .
- Context synchronization barrier instructions.

From Armv8.6, if BR\_RETIRED is also implemented, the PE must also treat these types of instruction in the same way for the BR\_RETIRED event.

## 0x8108 , BR\_IMMED\_TAKEN\_RETIRED, Branch instruction architecturally executed, immediate, taken

The counter counts each instruction counted by both BR\_IMMED\_RETIRED and PC\_WRITE\_RETIRED.

These are all direct branch instructions on the architecturally executed path, where the branch is taken.

## 0x8109 , BR\_IMMED\_SKIP\_RETIRED, Branch instruction architecturally executed, immediate, not taken

The counter counts each instruction counted by both BR\_IMMED\_RETIRED and BR\_SKIP\_RETIRED.

These are all direct branch instructions on the architecturally executed path, where the branch is not taken.

## 0x810A , BR\_IND\_TAKEN\_RETIRED, Branch instruction architecturally executed, indirect, taken

The counter counts each instruction counted by both BR\_IND\_RETIRED and PC\_WRITE\_RETIRED.

These are all indirect branch instructions, including return instructions, on the architecturally executed path, where the branch is taken.

## 0x810B , BR\_IND\_SKIP\_RETIRED, Branch instruction architecturally executed, indirect, not taken

The counter counts each instruction counted by both BR\_IND\_RETIRED and BR\_SKIP\_RETIRED.

These are all indirect branch instructions, including return instructions, on the architecturally executed path, where the branch is not taken.

## 0x810C , BR\_INDNR\_TAKEN\_RETIRED,Branchinstruction architecturally executed, indirect excluding procedure return, taken

The counter counts each instruction counted by both BR\_IND\_RETIRED and PC\_WRITE\_RETIRED, that is not counted by BR\_RETURN\_RETIRED.

These are all indirect branch instructions, excluding return instructions, on the architecturally executed path, where the branch is taken.

## 0x810D , BR\_INDNR\_SKIP\_RETIRED, Branch instruction architecturally executed, indirect excluding procedure return, not taken

The counter counts each instruction counted by both BR\_INDNR\_RETIRED and BR\_SKIP\_RETIRED.

These are all indirect branch instructions, excluding return instructions, on the architecturally executed path, where the branch is not taken.

## 0x810E , BR\_RETURN\_ANY\_RETIRED, Branch instruction architecturally executed, procedure return

The counter counts each instruction counted by BR\_IND\_RETIRED where if taken, the branch would be counted by BR\_RETURN\_RETIRED.

These are all return instructions on the architecturally executed path.

## 0x810F , BR\_RETURN\_SKIP\_RETIRED, Branch instruction architecturally executed, procedure return, not taken

The counter counts each instruction counted by both BR\_RETURN\_ANY\_RETIRED and BR\_SKIP\_RETIRED.

These are all return instructions on the architecturally executed path, where the branch is not taken.

## 0x811D , BR\_IND\_RETIRED, Instruction architecturally executed, indirect branch

The counter counts each architecturally executed indirect branch instruction.

Indirect branch instructions are Software change of the PC instructions other than exception-generating instructions and immediate branch instructions. Software change of the PC has the same definition as for the PC\_WRITE\_RETIRED and BR\_SKIP\_RETIRED events. Immediate branch instructions are defined by the BR\_IMMED\_RETIRED event.

Note

Conditional branches are always counted, regardless of whether the branch is taken.

## 0x811E , BR\_INDNR\_RETIRED, Branch instruction architecturally executed, indirect excluding procedure return

The counter counts each instruction counted by BR\_IND\_RETIRED that is not counted by BR\_RETURN\_ANY\_RETIRED.

These are all indirect branch instructions, excluding return instructions, on the architecturally executed path.

## 0x811F , BRB\_FILTRATE, Branch Record captured

The counter counts each valid Branch record captured in the branch record buffer.

Branch records that are not captured because they are removed by filtering are not counted.

When BRB\_FILTRATE is generated for an exception or an exception return, it is an Exception-related event.

It is CONSTRAINED UNPREDICTABLE whether the counter counts Branch records injected by a BRB INJ instruction.

If counting this event causes unsigned overflow of the event counter counting the event and this in turn causes a BRBE freeze event then:

- The Branch record for the operation that generated the event will be generated and captured in the Branch record buffer.
- It is CONSTRAINED UNPREDICTABLE whether the Branch Record Buffer Extension generates Branch records for other operations in program order after the operation that generated the event that would otherwise be generated when generation of Branch records is not Paused.

Arm recommends that implementations minimize capture of additional branches.

## 0x8179 , BRNL\_INDNR\_TAKEN\_RETIRED, Branch instruction architecturally executed, indirect branch without link excluding procedure return, taken

The counter counts each branch counted by BRNL\_IND\_TAKEN\_RETIRED that is not counted by BR\_RETURN\_RETIRED.

These are all indirect branch without link excluding procedure return instructions on the architecturally executed path, where the branch is taken.

## 0x817A , BL\_TAKEN\_RETIRED, Branch instruction architecturally executed, branch with link, taken

The counter counts each Software change of the PC counted by PC\_WRITE\_RETIRED that calls a subroutine and sets LR to return address.

These are all branch with link instructions on the architecturally executed path, where the branch is taken.

## 0x817B , BRNL\_TAKEN\_RETIRED, Branch instruction architecturally executed, branch without link, taken

The counter counts each Software change of the PC counted by PC\_WRITE\_RETIRED that is not counted by BL\_TAKEN\_RETIRED.

These are all branch without link instructions on the architecturally executed path, where the branch is taken.

## 0x817C , BL\_IND\_TAKEN\_RETIRED, Branch instruction architecturally executed, indirect branch with link, taken

The counter counts each branch counted by both BL\_TAKEN\_RETIRED and BR\_IND\_TAKEN\_RETIRED.

These are all indirect branch with link instructions on the architecturally executed path, where the branch is taken.

## 0x817D , BRNL\_IND\_TAKEN\_RETIRED, Branch instruction architecturally executed, indirect branch without link, taken

The counter counts each branch counted by both BRNL\_TAKEN\_RETIRED and BR\_IND\_TAKEN\_RETIRED.

These are all indirect branch without link instructions on the architecturally executed path, where the branch is taken.

## 0x817E , BL\_IMMED\_TAKEN\_RETIRED, Branch instruction architecturally executed, direct branch with link, taken

The counter counts each branch counted by both BL\_TAKEN\_RETIRED and BR\_IMMED\_TAKEN\_RETIRED.

These are all direct branch with link instructions on the architecturally executed path, where the branch is taken.

## 0x817F , BRNL\_IMMED\_TAKEN\_RETIRED, Branch instruction architecturally executed, direct branch without link, taken

The counter counts each branch counted by both BRNL\_TAKEN\_RETIRED and BR\_IMMED\_TAKEN\_RETIRED.

These are all direct branch without link instructions on the architecturally executed path, where the branch is taken.

## 0x8180 , BR\_UNCOND\_RETIRED, Branch instruction architecturally executed, unconditional branch

The counter counts each Software change of the PC counted by BR\_RETIRED that is not counted by BR\_COND\_RETIRED.

These are all unconditional branch instructions on the architecturally executed path.

## 0x8181 , BR\_COND\_RETIRED, Branch instruction architecturally executed, conditional branch

The counter counts each Software change of the PC counted by BR\_RETIRED that is a conditional branch.

These are all conditional branch instructions on the architecturally executed path.

In the A64 instruction set, conditional branches are:

- B.cond , CBNZ , CBZ , TBNZ , and TBZ .
- If FEAT\_HBC is implemented, BC.cond .
- If FEAT\_CMPBR is implemented, CB&lt;cc&gt; , CBB&lt;cc&gt; , and CBH&lt;cc&gt; .

This includes conditional branch instructions with the AL or NV condition code.

In the A32 instruction set, conditional branches are Software change of the PC instructions that have bits [31:29] of the instruction opcode not equal to 0b111 .

In the T32 instruction set, conditional branches are B&lt;c&gt; , B&lt;c&gt;.W , Software change of the PC instructions executed in an IT block, CBNZ , and CBZ . Branch instruction encodings, including B{&lt;c&gt;} and B{&lt;c&gt;}.W , where &lt;c&gt; is either omitted or AL are only considered conditional branches when they are the last instruction in an IT block.

## 0x8182 , BR\_COND\_TAKEN\_RETIRED, Branch instruction architecturally executed, conditional branch, taken

The counter counts each Software change of the PC counted by both BR\_COND\_RETIRED and PC\_WRITE\_RETIRED.

These are all conditional branch instructions on the architecturally executed path, where the branch is taken.

## 0x8183 , BR\_HINT\_COND\_RETIRED, Branch instruction architecturally executed, hinted conditional

The counter counts each branch counted by BR\_COND\_RETIRED that is a hinted conditional branch.

These are all hinted conditional branch instructions on the architecturally executed path.

The hinted conditional branch instruction is BC.cond .

## 0x82A4 , ASE\_SVE\_RETIRED, Instruction architecturally executed, Advanced SIMD data processing or SVE data processing

The counter counts each architecturally executed instruction counted by INST\_RETIRED that is classified as an Advanced SIMD data-processing instruction or an SVE data-processing instruction.

See ASE\_RETIRED and SVE\_RETIRED for these classifications.

## 0x82A8 , LD\_ANY\_RETIRED, Instruction architecturally executed, load

The counter counts each architecturally executed instruction counted by LDST\_ANY\_RETIRED that is classified as a Memory-reading instruction.

It is IMPLEMENTATION DEFINED whether the prefetch instructions counted by PRF\_RETIRED are counted as Memory-reading instructions:

- If the prefetch instructions are counted as Memory-reading instructions, then they are counted by LD\_RETIRED and LD\_ANY\_RETIRED.
- Otherwise, if the prefetch instructions are not counted as Memory-reading instructions by LD\_ANY\_RETIRED, then it is further IMPLEMENTATION DEFINED which one of the following applies:
- They are counted as data-processing instructions.
- They are counted by LDST\_ANY\_RETIRED.

Arm recommends that if a prefetch instruction is not implemented as a NOP and the PRF\_RETIRED event is not implemented, then the instruction is counted as a Memory-reading instruction.

## 0x82A9 , ST\_ANY\_RETIRED, Instruction architecturally executed, store

The counter counts each architecturally executed instruction counted by LDST\_ANY\_RETIRED that is classified as a Memory-writing instruction.

## 0x82AA , LDST\_ANY\_RETIRED, Instruction architecturally executed, load or store

The counter counts each architecturally executed instruction counted by INST\_RETIRED that is classified as a Memory-reading instruction or a Memory-writing instruction.

See LD\_ANY\_RETIRED and ST\_ANY\_RETIRED for these classifications.

If the PRF\_RETIRED event is implemented and the prefetch instructions counted by PRF\_RETIRED are not counted as Memory-reading instructions by LD\_RETIRED and LD\_ANY\_RETIRED, then it is IMPLEMENTATION DEFINED whether these instructions are counted by LDST\_ANY\_RETIRED. Arm recommends that these instructions are counted by LDST\_ANY\_RETIRED.

## 0x82AB , DP\_RETIRED, Instruction architecturally executed, integer data processing

The counter counts each architecturally executed instruction counted by INST\_RETIRED that is classified as an integer data-processing instruction.

An integer data-processing instruction is any instruction that is not counted as any of the following:

- Aload or store instruction, counted by LD\_RETIRED or ST\_RETIRED.
- ASoftware change of PC instruction, counted by PC\_WRITE\_RETIRED.
- Ascalar floating-point data processing instruction, counted by VFP\_RETIRED.
- An Advanced SIMD, SVE or SME data processing instruction, counted by SE\_RETIRED.
- Acryptographic instruction, counted by CRYPTO\_RETIRED.

That is, the following instructions are counted as integer data-processing instructions:

- In AArch64 state:
- Instructions from Data processing - immediate.
- Instructions from Data processing - register.
- Instructions from System register instructions.
- Instructions from 'Instructions with register argument'.
- Instructions from System instructions other than Memory-writing instructions.
- Instructions from Hint instructions.
- Instructions from Floating-point move (register) that transfer data between a general-purpose register and a SIMD&amp;FP register without conversion: FMOV (general).
- Instructions from SIMD move that transfer data between a general-purpose register and an element or elements in a SIMD&amp;FP register: DUP (general), SMOV , UMOV , and INS (general). This includes the aliases MOV (from general) and MOV (to general).
- When FEAT\_SVE is implemented, non-SIMD SVE instructions.
- In AArch32 state:
- Instructions from Data-processing instructions.
- Instructions from PSTATE and banked register access instructions.
- Instructions from Banked register access instructions.
- Instructions from Miscellaneous instructions other than ISB and prefetches.
- Instructions from System register access instructions other than LDC and STC instructions.
- VDUP (general-purpose register).
- All VMOV instructions that transfer data between a general-purpose register and a SIMD&amp;FP register.
- VMRS and VMSR .

## 0x82AC , ASE\_RETIRED, Instruction architecturally executed, Advanced SIMD data processing

The counter counts each architecturally executed instruction counted by ASE\_SVE\_RETIRED that is classified as an Advanced SIMD data-processing instruction.

The following instructions are counted as Advanced SIMD data-processing instructions:

- For AArch64 state:
- The SIMD operations listed in Data processing - SIMD and floating-point.
- Advanced SIMD scalar instructions, including those which operate on floating-point values.
- If FEAT\_Crypto is implemented, the Advanced SIMD PMULL and PMULL2 (1Q variants) instructions. See The Cryptographic Extension in AArch64 state.
- For AArch32 state:
- Instructions from Advanced SIMD data-processing instructions.
- Advanced SIMD scalar instructions, including those which operate on floating-point values.
- If FEAT\_Crypto is implemented, the Advanced SIMD VMULL (P64 variant) instruction. See The Cryptographic Extension in AArch32 state.

This includes all instructions that operate on the SIMD&amp;FP registers, except those that are counted as one of the following:

- Integer data-processing instructions.
- Scalar floating-point data-processing instructions.
- Load or store instructions.
- Cryptographic data-processing instructions counted by CRYPTO\_RETIRED. CRYPTO\_RETIRED does not count the Cryptographic data-processing instructions included above.

## 0x82AD , VFP\_RETIRED, Instruction architecturally executed, scalar floating-point data processing

The counter counts each architecturally executed instruction counted by INST\_RETIRED that is classified as a scalar floating-point instruction.

The following instructions are counted as scalar floating-point data-processing instructions:

- In AArch64 state:

- The scalar floating-point instructions from Data processing - SIMD and floating-point. Only the scalar instructions are counted. SIMD floating-point instructions are not counted.
- Instructions that take both an integer register and a floating-point register argument and perform a type conversion (to/from integer or to/from fixed-point): FCVT{&lt;mode&gt;} , UCVTF , and SCVTF .
- In AArch32 state:
- Instructions from Floating-point data-processing instructions.
- Instructions that take both an integer register and a floating-point register argument and perform a type conversion (to/from integer or to/from fixed-point): VCVT&lt;mode&gt; (floating-point), VCVT , VCVTT , and VCVTB .

This includes all scalar instructions that operate on the SIMD&amp;FP registers as floating-point values, except those that are counted as one of the following:

- SIMD scalar instructions.
- Integer data-processing instructions.
- Load or store instructions.

## 0x82AE , SVE\_RETIRED, Instruction architecturally executed, SVE data processing

The counter counts each architecturally executed instruction counted by ASE\_SVE\_RETIRED that is classified as an SVE data-processing instruction.

An SVE data-processing instruction is any instruction that operates on the SVE scalable vector and predicate registers that is not any of the following:

- Aload or store instruction. These are counted by SVE\_INST\_RETIRED.
- If the Cryptographic Extension is implemented, an instruction counted by CRYPTO\_RETIRED as a Cryptographic data-processing instruction.
- When FEAT\_SME is implemented, an instruction counted by SME\_SPEC as an SME data-processing instruction.
- Anon-SIMD SVE instruction.

If the Cryptographic Extension and FEAT\_SVE2 are implemented, the SVE PMULLB and PMULLT (Q variants) instructions are not counted by CRYPTO\_SPEC and are counted as SVE data-processing instructions.

Data-processing instructions defined by FEAT\_SME which involve the SVE registers but do not involve any ZA or ZT registers are counted as SVE data-processing instructions.

## 0x82AF , CRYPTO\_RETIRED, Instruction architecturally executed, cryptographic data processing

The counter counts each architecturally executed instruction counted by INST\_RETIRED that is classified as a cryptographic instruction.

The following instructions are counted as cryptographic data-processing instructions:

- In AArch64 state, instructions from the following sections:
- The Cryptographic Extension in AArch64 state other than the Advanced SIMD PMULL and PMULL2 (1Q variants) instructions.
- If FEAT\_SVE2 is implemented, SVE2 Crypto Extensions other than the SVE PMULLB and PMULLT (Q variants) instructions.
- In AArch32 state, instructions from The Cryptographic Extension in AArch32 state other than VMULL (P64 variant).

## 0x82B3 , PRF\_RETIRED, Instruction architecturally executed, prefetch

The counter counts each architecturally executed prefetch instruction counted by INST\_RETIRED.

## 0x8358 , SME\_RETIRED, Instruction architecturally executed, SME data processing

The counter counts each architecturally executed instruction counted by SE\_RETIRED that is classified as an SME data-processing instruction.

An SME data-processing instruction is any instruction that operates on the ZA or ZT registers that is not any of the following:

- Aload or store instruction. These are counted by SME\_INST\_RETIRED.
- Anon-SIMD SME instruction.

Data-processing instructions defined by FEAT\_SME which involve the SVE registers but do not involve any ZA or ZT registers are counted as SVE data-processing instructions.

## 0x8359 , SE\_RETIRED, Instruction architecturally executed, Advanced SIMD, SVE, or SME data processing

The counter counts each architecturally executed instruction counted by INST\_RETIRED that is classified as an Advanced SIMD, SVE, or SME data-processing instruction.

See ASE\_SVE\_RETIRED and SME\_RETIRED for these classifications.

## 0x835A , SME\_INST\_RETIRED, Instruction architecturally executed, SME

The counter counts each architecturally executed instruction counted by SE\_INST\_RETIRED that is classified as an SMEinstruction.

An SME instruction is any instruction that operates on the ZA or ZT registers that is not any of the following:

- Anon-SIMD SME instruction.

Instructions defined by FEAT\_SME which involve the SVE registers but do not involve any ZA or ZT registers are counted as SVE instructions.

## 0x835B , SE\_INST\_RETIRED, Instruction architecturally executed, Advanced SIMD, SVE, or SME

The counter counts each architecturally executed instruction counted by INST\_RETIRED that is classified as an Advanced SIMD, SVE, or SME instruction.

See ASE\_SVE\_INST\_RETIRED and SME\_INST\_RETIRED for these classifications.

## D14.3.2 Common microarchitectural events

The Common microarchitectural events are:

## 0x0001 , L1I\_CACHE\_REFILL, Level 1 instruction cache refill

The counter counts each access counted by L1I\_CACHE that causes a refill of the Level 1 instruction or unified cache from outside of the Level 1 instruction or unified cache.

Arefill includes any access that causes data to be fetched from outside of the Level 1 caches, even if the data is ultimately not allocated into the Level 1 instruction cache. For example, data might be fetched into a buffer but then discarded, rather than being allocated into a cache. These buffers are treated as part of the cache.

For example, the counter counts accesses to the Level 1 instruction cache that cause a refill that is satisfied by fetching data from memory, a Level 2 cache, or a Level 1 cache of another PE.

The counter does not count accesses that miss in the cache but are satisfied by the refill of a previous miss and do not cause a new refill, even if that previous refill is not complete at the time of the miss.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID0\_EL0[1] reads as 1 if this event is implemented and 0 otherwise.

## 0x0002 , L1I\_TLB\_REFILL, Level 1 instruction TLB refill

The counter counts each Instruction memory access counted by L1I\_TLB that causes a TLB refill of the Level 1 instruction TLB.

This includes each Instruction memory access that causes a memory access due to a translation table walk or an access to another level of TLB caching.

The counter does not count the access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if any of the following are true:

- The access misses in the TLB and generates a translation table walk, but the result is not allocated into the TLB for any reason other than a Translation fault.
- The access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID0\_EL0[2] reads as 1 if this event is implemented and 0 otherwise.

## 0x0003 , L1D\_CACHE\_REFILL, Level 1 data cache refill

The counter counts each access counted by L1D\_CACHE that causes a refill of the Level 1 data or unified cache from outside of the Level 1 data or unified cache.

Arefill includes any access that causes data to be fetched from outside of the Level 1 caches, even if the data is ultimately not allocated into the Level 1 data cache. For example, data might be fetched into a buffer but then discarded, rather than being allocated into a cache. These buffers are treated as part of the cache.

For example, the counter counts accesses to the Level 1 data cache that cause a refill that is satisfier by fetching data from memory, a Level 2 cache, or a Level 1 cache of another PE.

The counter does not count accesses that:

- Miss in the cache but are satisfied by the refill of a previous miss and do not cause a new refill, even if that previous refill is not complete at the time of the miss.
- Miss in the cache but do not generate a refill, such as a write through the cache.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID0\_EL0[3] reads as 1 if this event is implemented and 0 otherwise.

## 0x0004 , L1D\_CACHE, Level 1 data cache access

The counter counts each Memory-read operation or Memory-write operation that causes a cache access to at least the Level 1 data or unified cache.

Each access to a cache line is counted including the multiple accesses caused by single instructions such as LDM or STM . Each access to other Level 1 data or unified memory structures, for example refill buffers, write buffers, and write-back buffers, is also counted.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If FEAT\_PMUv3p4 is implemented, accesses that only update the cache status information for a cache entry without accessing the content of the cache entry are not counted.

If FEAT\_PMUv3p4 is not implemented, it is IMPLEMENTATION DEFINED whether accesses that only update the cache status information for a cache entry without accessing the content of the cache entry are counted.

An example of cache status information is whether the cached data is held in an exclusive or shared state.

When the L1D\_CACHE\_RW event is implemented:

- If the L1D\_CACHE\_PRFM event is implemented, accesses to the Level 1 data cache due to a prefetch instruction are counted. Otherwise, these accesses are not counted.
- If the L1D\_CACHE\_HWPRF event is implemented, accesses to the Level 1 data cache due to a hardware prefetcher are counted. Otherwise these accesses are not counted.

When the L1D\_CACHE\_RW event is not implemented, it IMPLEMENTATION DEFINED whether accesses to the Level 1 data cache due to prefetch instructions or due to a hardware prefetcher are counted.

When FEAT\_GCS is implemented:

- If the L1GCS\_CACHE event is implemented, GCS data read operations and GCS data write operations are not counted.
- Otherwise, GCS data read operations and data write operations are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID0\_EL0[4] reads as 1 if this event is implemented and 0 otherwise.

## 0x0005 , L1D\_TLB\_REFILL, Level 1 data TLB refill

The counter counts each access counted by L1D\_TLB that causes a TLB refill of the Level 1 data or unified TLB.

This includes each access that causes a memory access due to a translation table walk or an access to another level of TLB caching.

The counter does not count the access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if any of the following are true:

- The access misses in the TLB and generates a translation table walk, but the result is not allocated into the TLB for any reason other than a Translation fault.
- The access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID0\_EL0[5] reads as 1 if this event is implemented and 0 otherwise.

## 0x0010 , BR\_MIS\_PRED, Branch instruction speculatively executed, mispredicted or not predicted

The counter counts each correction to the predicted program flow that occurs because of a misprediction from, or no prediction from, the branch prediction resources and that relates to instructions that the branch prediction resources are capable of predicting.

If no program-flow prediction resources are implemented, Arm recommends that the counter counts all branches that are not taken.

PMCEID0\_EL0[16] reads as 1 if this event is implemented and 0 otherwise.

## 0x0011 , CPU\_CYCLES, Cycle

The counter increments on every cycle.

All counters are subject to changes in clock frequency, including when a WFI or WFE instruction stops the clock. If FEAT\_PMUv3p9 is implemented, then CPU\_CYCLES does not increment when the clocks are stopped by WFI and WFE instructions. Otherwise, it is CONSTRAINED UNPREDICTABLE whether or not CPU\_CYCLES continues to increment when the clocks are stopped by WFI and WFE instructions.

Note

Unlike PMCCNTR or PMCCNTR\_EL0, this count is not affected by the cycle counter controls:

- The counter is not incremented in prohibited regions, so is not affected by PMCR.DP or PMCR\_EL0.DP.
- The counter increments on every cycle, regardless of the value of PMCR.D or PMCR\_EL0.D.
- The counter is reset when event counters are reset by PMCR.P and PMCR\_EL0.P, never by PMCR.C or PMCR\_EL0.C.
- If FEAT\_PMUv3p5 is implemented, the counter ignores SDCR.SCCD, MDCR\_EL3.SCCD, HDCR.HCCD, and MDCR\_EL2.HCCD.

In a multithreaded implementation:

- If the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the event counter is 0, then the counter counts each Processor cycle when the counting PE is active.
- If the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the event counter is 1, then the counter counts each Processor cycle.

PMCEID0\_EL0[17] reads as 1 if this event is implemented and 0 otherwise.

## 0x0012 , BR\_PRED, Predictable branch instruction speculatively executed

The counter counts each branch or other change in the program flow that the branch prediction resources are capable of predicting.

If all branches are subject to prediction, for example a BTB or BTAC, then all branches are predictable branches.

If branches are decoded before the predictor, so that the branch prediction logic dynamically predicts only some branches, for example conditional and indirect branches, then it is IMPLEMENTATION DEFINED whether other branches are counted as predictable branches. Arm recommends that all branches are counted.

An implementation might include other structures that predict branches, such as a loop buffer that predicts short backwards direct branches as taken. Each execution of such a branch is a predictable branch. Terminating the loop might generate a misprediction event that is counted by BR\_MIS\_PRED.

If no program-flow prediction resources are implemented, this event is optional, but Arm recommends that BR\_PRED counts all branches.

It is IMPLEMENTATION DEFINED when the branch is counted. Arm recommends that it is counted when the branch is resolved, that is, at the same point in the instruction pipeline as when the BR\_MIS\_PRED event would be counted if the branch resolves as mispredicted. This means that (BR\_PRED - BR\_MIS\_PRED) is the number of correctly predicted branches and the ratio (BR\_MIS\_PRED ÷ BR\_PRED) can be calculated in a meaningful way.

PMCEID0\_EL0[18] reads as 1 if this event is implemented and 0 otherwise.

## 0x0013 , MEM\_ACCESS, Data memory access

The counter counts each Memory-read operation or Memory-write operation that the PE makes.

The counter increments whether the access results in an access to a Level 1 data or unified cache, a Level 2 data or unified cache, or neither of these.

The number of accesses generated by each instruction is IMPLEMENTATION DEFINED.

The counter does not count:

- Instruction memory accesses.
- Translation table walks.
- Write-back from any cache.
- Refilling of any cache.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

PMCEID0\_EL0[19] reads as 1 if this event is implemented and 0 otherwise.

## 0x0014 , L1I\_CACHE, Level 1 instruction cache access

The counter counts each Instruction memory access to at least the Level 1 instruction or unified cache.

Each Instruction memory access to other Level 1 instruction or unified memory structures, such as refill buffers, is also counted.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If FEAT\_PMUv3p4 is implemented, accesses that only update the cache status information for a cache entry without accessing the content of the cache entry are not counted.

If FEAT\_PMUv3p4 is not implemented, it is IMPLEMENTATION DEFINED whether accesses that only update the cache status information for a cache entry without accessing the content of the cache entry are counted.

An example of cache status information is whether the cached data is held in an exclusive or shared state.

When the L1I\_CACHE\_RD event is implemented:

- If the L1I\_CACHE\_PRFM event is implemented, accesses to the Level 1 instruction cache due to a prefetch instruction are counted. Otherwise, these are not counted.
- If the L1I\_CACHE\_HWPRF event is implemented, accesses to the Level 1 instruction cache due to a hardware prefetcher are counted. Otherwise these events are not counted.

When the L1I\_CACHE\_RD event is not implemented, it IMPLEMENTATION DEFINED whether accesses to the Level 1 instruction cache due to prefetch instructions or due to a hardware prefetcher are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID0\_EL0[20] reads as 1 if this event is implemented and 0 otherwise.

## 0x0015 , L1D\_CACHE\_WB, Level 1 data cache write-back

The counter counts each write-back of data from the Level 1 data or unified cache to outside of the Level 1 caches.

For example:

- Awrite-back of a dirty cache line to a Level 2 cache or memory.
- Awrite-back of a recently fetched cache line that has not been allocated to the Level 1 data cache.

Each write-back is counted once, even if multiple accesses are required to complete the write-back.

It is IMPLEMENTATION DEFINED whether the counter counts:

- Atransfer of a dirty cache line from the Level 1 data cache to outside of Level 1 caches made as a result of a coherency request.
- Write-backs made as a result of cache maintenance instructions.

The counter does not count:

- The invalidation of a cache line without any write-back to outside of the Level 1 caches or memory.
- Writes that write through the Level 1 data cache to outside of the Level 1 caches.

Awrite-back is attributable to the agent that generated the request that caused the write-back. This might not be the same agent that caused the data being written back to be allocated into the cache.

An Unattributable write-back event occurs when a requestor outside of the PE makes a coherency request that results in write-back. If the cache is shared, then an Unattributable write-back event is not counted. If the cache is not shared, then the event is counted.

It is IMPLEMENTATION DEFINED whether a write of a whole cache line that is not the result of the eviction of a line from the cache, is counted. For example, this applies when the PE determines software is streaming writes to memory and does not allocate lines to the cache, or by a DC ZVA operation.

PMCEID0\_EL0[21] reads as 1 if this event is implemented and 0 otherwise.

## 0x0016 , L2D\_CACHE, Level 2 data cache access

The counter counts each Memory-read operation or Memory-write operation that causes a cache access to at least the Level 2 data or unified cache.

Each access to a cache line is counted including refills of and write-backs from other caches. Each access to other Level 2 data or unified memory structures, for example refill buffers, write buffers, and write-back buffers, is also counted.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If FEAT\_PMUv3p4 is implemented, accesses that only update the cache status information for a cache entry without accessing the content of the cache entry are not counted.

If FEAT\_PMUv3p4 is not implemented, it is IMPLEMENTATION DEFINED whether accesses that only update the cache status information for a cache entry without accessing the content of the cache entry are counted.

An example of cache status information is whether the cached data is held in an exclusive or shared state.

When the L2D\_CACHE\_RW event is implemented:

- If the L2D\_CACHE\_PRFM event is implemented, accesses to the Level 2 data cache due to a prefetch instruction are counted. Otherwise, these accesses are not counted.
- If the L2D\_CACHE\_HWPRF event is implemented, accesses to the Level 2 data cache due to a hardware prefetcher are counted. Otherwise these accesses are not counted.

When the L2D\_CACHE\_RW event is not implemented, it IMPLEMENTATION DEFINED whether accesses to the Level 2 data cache due to prefetch instructions or due to a hardware prefetcher are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID0\_EL0[22] reads as 1 if this event is implemented and 0 otherwise.

## 0x0017 , L2D\_CACHE\_REFILL, Level 2 data cache refill

The counter counts each access counted by L2D\_CACHE that causes a refill of the Level 2 data or unified cache, or any Level 1 data, instruction, or unified cache of this PE, from outside of those caches.

Arefill includes any access that causes data to be fetched from outside of the Level 1 and Level 2 caches, even if the data is ultimately not allocated into the Level 2 data cache. For example, data might be fetched into a buffer but then discarded, rather than being allocated into a cache. These buffers are treated as part of the cache.

For example, the counter counts:

- Accesses to the Level 2 data cache that cause a refill that is satisfier by fetching data from memory, a Level 3 cache, or a Level 2 cache of another PE.
- Refills of and write-backs from any Level 1 data, instruction, or unified cache of this PE that cause a refill from outside of the Level 1 and Level 2 caches of this PE.
- Accesses to the Level 2 data cache that cause a refill of a Level 1 cache of this PE from outside of the Level 1 and Level 2 caches of this PE, even if there is no refill of the Level 2 data cache.

The counter does not count accesses that:

- Miss in the cache but are satisfied by the refill of a previous miss and do not cause a new refill, even if that previous refill is not complete at the time of the miss.
- Miss in the cache but do not generate a refill, such as a write through the cache.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID0\_EL0[23] reads as 1 if this event is implemented and 0 otherwise.

## 0x0018 , L2D\_CACHE\_WB, Level 2 data cache write-back

The counter counts each write-back of data from the Level 2 data or unified cache to outside of the Level 1 and Level 2 caches.

For example:

- Awrite-back of a dirty cache line to a Level 3 cache or memory.
- Awrite-back of a recently fetched cache line that has not been allocated to the Level 2 data cache.

Each write-back is counted once, even if multiple accesses are required to complete the write-back.

It is IMPLEMENTATION DEFINED whether the counter counts:

- Atransfer of a dirty cache line from the Level 2 data cache to outside of Level 1 and Level 2 caches made as a result of a coherency request.
- Write-backs made as a result of cache maintenance instructions.

The counter does not count:

- The invalidation of a cache line without any write-back to outside of the Level 1 and Level 2 caches or memory.
- Writes that write through the Level 2 data cache to outside of the Level 1 and Level 2 caches.
- Transfers of data from the Level 2 data cache to a Level 1 cache to satisfy a refill of the other cache.

Awrite-back is attributable to the agent that generated the request that caused the write-back. This might not be the same agent that caused the data being written back to be allocated into the cache.

An Unattributable write-back event occurs when a requestor outside of the PE makes a coherency request that results in write-back. If the cache is shared, then an Unattributable write-back event is not counted. If the cache is not shared, then the event is counted.

It is IMPLEMENTATION DEFINED whether a write of a whole cache line that is not the result of the eviction of a line from the cache, is counted. For example, this applies when the PE determines software is streaming writes to memory and does not allocate lines to the cache, or by a DC ZVA operation.

PMCEID0\_EL0[24] reads as 1 if this event is implemented and 0 otherwise.

## 0x0019 , BUS\_ACCESS, Bus access

The counter counts each Memory-read operation or Memory-write operation that accesses outside of the boundary of the PE and its closely-coupled caches.

Where this boundary lies with respect to any implemented caches is IMPLEMENTATION DEFINED. Where an implementation has multiple buses at this boundary, this event counts the sum of accesses across all buses.

Abus access is part of a bus transaction. The exact nature of a bus transaction is IMPLEMENTATION DEFINED, but for the purposes of event monitoring consists of a single access comprising one or more cycles, or beats, when the transaction occupies the bus. The BUS\_ACCESS event counts each beat of each transaction. That is, each bus cycle counted by BUS\_CYCLES for which the bus is active.

Bus transactions include refills of and write-backs from data, instruction, and unified caches. Whether bus transactions include operations that use the bus but do not explicitly transfer data is IMPLEMENTATION DEFINED.

An Unattributable bus transaction occurs when a requestor outside the PE makes a request that results in a bus access, for example, a coherency request.

If a bus supports multiple accesses per cycle, for example through multiple channels, the counter increments once for each channel that is active on a cycle, and so it might increment by more than one in any given cycle.

The maximum increment in any given cycle is IMPLEMENTATION DEFINED.

PMCEID0\_EL0[25] reads as 1 if this event is implemented and 0 otherwise.

## 0x001A , MEMORY\_ERROR, Local memory error

The counter counts each occurrence of a memory error signaled by a memory closely coupled to this PE.

The definition of local memories is IMPLEMENTATION DEFINED but includes caches, tightly-coupled memories, and TLB arrays.

Memory error refers to a physical error detected by the hardware, such as a parity or ECC error. It includes errors that are correctable and those that are not. It does not include errors as defined in the architecture, such as MMU faults.

PMCEID0\_EL0[26] reads as 1 if this event is implemented and 0 otherwise.

## 0x001B , INST\_SPEC, Operation speculatively executed

The counter counts each speculatively executed instruction.

This includes instructions that are subsequently not architecturally executed.

PMCEID0\_EL0[27] reads as 1 if this event is implemented and 0 otherwise.

## 0x001D , BUS\_CYCLES, Bus cycle

The counter increments on every cycle of the interface at the boundary of the PE and its closely-coupled caches. Where this boundary lies with respect to any implemented caches is IMPLEMENTATION DEFINED.

Note

If the implementation clocks the external memory interface at the same rate as the processor hardware, then the counter counts every cycle.

PMCEID0\_EL0[29] reads as 1 if this event is implemented and 0 otherwise.

## 0x001F , L1D\_CACHE\_ALLOCATE, Level 1 data cache allocation without refill

The counter counts each Memory-write operation that writes an entire line into the Level 1 data or unified cache without fetching data from outside the Level 1 data or unified cache.

These are allocations of cache lines in the Level 1 data or unified cache that are not refills counted by L1D\_CACHE\_REFILL. For example:

- Awrite of an entire cache line from a coalescing write buffer.
- An operation such as DC ZVA .

The counter counts only Memory-write operations Attributable to the PE counting the event, and, if the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, other PEs in the multithreaded implementation.

PMCEID0\_EL0[31] reads as 1 if this event is implemented and 0 otherwise.

## 0x0020 , L2D\_CACHE\_ALLOCATE, Level 2 data cache allocation without refill

The counter counts each Memory-write operation that writes an entire line into the Level 2 data or unified cache without fetching data from outside the Level 2 data or unified cache.

These are allocations of cache lines in the Level 2 data or unified cache that are not refills counted by L2D\_CACHE\_REFILL. For example:

- Awrite-back of an entire cache line from a Level 1 cache to the Level 2 data cache.
- Awrite of an entire cache line from a coalescing write buffer.
- An operation such as DC ZVA .

The counter counts only Memory-write operations Attributable to the PE counting the event, and, if the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, other PEs in the multithreaded implementation.

PMCEID1\_EL0[0] reads as 1 if this event is implemented and 0 otherwise.

## 0x0022 , BR\_MIS\_PRED\_RETIRED, Branch instruction architecturally executed, mispredicted

The counter counts each branch instruction counted by BR\_RETIRED that was not correctly predicted.

If no program-flow prediction resources are implemented, this event counts all retired not-taken branches.

PMCEID1\_EL0[2] reads as 1 if this event is implemented and 0 otherwise.

## 0x0023 , STALL\_FRONTEND, No operation sent for execution due to the frontend

The counter counts each cycle counted by CPU\_CYCLES where no Attributable instruction or operation was sent for execution and there was no Attributable instruction or operation available to dispatch for the PE from the frontend.

The division between frontend and backend is IMPLEMENTATION DEFINED. All STALL events are counted at the same point in the pipeline.

Note

- For a simplified pipeline model of Fetch-Decode-Issue-Execute-Retire, Arm recommends that the events are counted when instructions are dispatched from Decode to Issue.
- In a single cycle, both the STALL\_BACKEND and STALL\_FRONTEND events might be counted, if both the backend is unable to accept any operations and there are no operations available to issue from the frontend.

PMCEID1\_EL0[3] reads as 1 if this event is implemented and 0 otherwise.

## 0x0024 , STALL\_BACKEND, No operation sent for execution due to the backend

The counter counts each cycle counted by CPU\_CYCLES where Attributable instructions or operations for the PE are available to dispatch from the frontend to the backend, but no Attributable instruction or operation is sent for execution because the backend is unable to accept any of the instructions or operations available for the PE.

For example, the backend might be unable to accept operations because of a resource conflict or non-availability.

It is IMPLEMENTATION DEFINED whether the counter also counts each cycle counted by CPU\_CYCLES where no Attributable instructions or operations for the PE are available to dispatch from the frontend and the backend is unable to accept any instructions or operations for the PE.

The division between frontend and backend is IMPLEMENTATION DEFINED. For more information, see STALL\_FRONTEND. All STALL events are counted at the same point in the pipeline.

Note

In a single cycle, both the STALL\_BACKEND and STALL\_FRONTEND events might be counted, if both the backend is unable to accept any operations and there are no operations available to issue from the frontend.

PMCEID1\_EL0[4] reads as 1 if this event is implemented and 0 otherwise.

## 0x0025 , L1D\_TLB, Level 1 data TLB access

The counter counts each Memory-read operation or Memory-write operation that causes a TLB access to at least the Level 1 data or unified TLB.

Each access to a TLB entry is counted including multiple accesses caused by single instructions such as LDM or STM.

When FEAT\_GCS is implemented:

- If the L1GCS\_TLB event is implemented, GCS data read operations and GCS data write operations that causes a TLB access to at least a Level 1 TLB are not counted.
- Otherwise, GCS data read operations and data write operations that causes a TLB access to at least a Level 1 TLB are counted.

The counter does not count the access if the access is due to a TLB maintenance instruction.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[5] reads as 1 if this event is implemented and 0 otherwise.

## 0x0026 , L1I\_TLB, Level 1 instruction TLB access

The counter counts each Instruction memory access that causes a TLB access to at least the Level 1 instruction TLB.

The counter does not count the access if the access is due to a TLB maintenance instruction.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[6] reads as 1 if this event is implemented and 0 otherwise.

## 0x0027 , L2I\_CACHE, Level 2 instruction cache access

The counter counts each Instruction memory access to at least the Level 2 instruction or unified cache.

Each Instruction memory access to other Level 2 instruction or unified memory structures, such as refill buffers, is also counted.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If FEAT\_PMUv3p4 is implemented, accesses that only update the cache status information for a cache entry without accessing the content of the cache entry are not counted.

If FEAT\_PMUv3p4 is not implemented, it is IMPLEMENTATION DEFINED whether accesses that only update the cache status information for a cache entry without accessing the content of the cache entry are counted.

An example of cache status information is whether the cached data is held in an exclusive or shared state.

When the L2I\_CACHE\_RD event is implemented:

- If the L2I\_CACHE\_PRFM event is implemented, accesses to the Level 2 instruction cache due to a prefetch instruction are counted. Otherwise, these are not counted.
- If the L2I\_CACHE\_HWPRF event is implemented, accesses to the Level 2 instruction cache due to a hardware prefetcher are counted. Otherwise these events are not counted.

When the L2I\_CACHE\_RD event is not implemented, it IMPLEMENTATION DEFINED whether accesses to the Level 2 instruction cache due to prefetch instructions or due to a hardware prefetcher are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[7] reads as 1 if this event is implemented and 0 otherwise.

## 0x0028 , L2I\_CACHE\_REFILL, Level 2 instruction cache refill

The counter counts each access counted by L2I\_CACHE that causes a refill of the Level 2 instruction or unified cache, or any Level 1 data, instruction, or unified cache of this PE, from outside of those caches.

Arefill includes any access that causes data to be fetched from outside of the Level 1 and Level 2 caches, even if the data is ultimately not allocated into the Level 2 instruction cache. For example, data might be fetched into a buffer but then discarded, rather than being allocated into a cache. These buffers are treated as part of the cache.

For example, the counter counts:

- Accesses to the Level 2 instruction cache that cause a refill that is satisfied by fetching data from memory, a Level 3 cache, or a Level 2 cache of another PE.
- Refills of any Level 1 instruction or unified cache of this PE that cause a refill from outside of the Level 1 and Level 2 caches of this PE.
- Accesses to the Level 2 instruction cache that cause a refill of a Level 1 cache of this PE from outside of the Level 1 and Level 2 caches of this PE, even if there is no refill of the Level 2 instruction cache.

The counter does not count accesses that miss in the cache but are satisfied by the refill of a previous miss and do not cause a new refill, even if that previous refill is not complete at the time of the miss.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[8] reads as 1 if this event is implemented and 0 otherwise.

## 0x0029 , L3D\_CACHE\_ALLOCATE, Level 3 data cache allocation without refill

The counter counts each Memory-write operation that writes an entire line into the Level 3 data or unified cache without fetching data from outside the Level 3 data or unified cache.

These are allocations of cache lines in the Level 3 data or unified cache that are not refills counted by L3D\_CACHE\_REFILL. For example:

- Awrite-back of an entire cache line from a Level 2 cache to the Level 3 data cache.
- Awrite of an entire cache line from a coalescing write buffer.
- An operation such as DC ZVA .

The counter counts only Memory-write operations Attributable to the PE counting the event, and, if the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, other PEs in the multithreaded implementation.

PMCEID1\_EL0[9] reads as 1 if this event is implemented and 0 otherwise.

## 0x002A , L3D\_CACHE\_REFILL, Level 3 data cache refill

The counter counts each access counted by L3D\_CACHE that causes a refill of the Level 3 data or unified cache, or any Level 1 or Level 2 data, instruction, or unified cache of this PE, from outside of those caches.

Arefill includes any access that causes data to be fetched from outside of the Level 1 to Level 3 caches, even if the data is ultimately not allocated into the Level 3 data cache. For example, data might be fetched into a buffer but then discarded, rather than being allocated into a cache. These buffers are treated as part of the cache.

For example, the counter counts:

- Accesses to the Level 3 data cache that cause a refill that is satisfier by fetching data from memory, a lower level cache, or a Level 3 cache of another PE.
- Refills of and write-backs from any Level 1 or Level 2 data, instruction, or unified caches of this PE that cause a refill from outside of the Level 1 to Level 3 caches of this PE.
- Accesses to the Level 3 data cache that cause a refill of a Level 2 cache of this PE from outside of the Level 1 to Level 3 caches of this PE, even if there is no refill of the Level 3 data cache.

The counter does not count accesses that:

- Miss in the cache but are satisfied by the refill of a previous miss and do not cause a new refill, even if that previous refill is not complete at the time of the miss.
- Miss in the cache but do not generate a refill, such as a write through the cache.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[10] reads as 1 if this event is implemented and 0 otherwise.

## 0x002B , L3D\_CACHE, Level 3 data cache access

The counter counts each Memory-read operation or Memory-write operation that causes a cache access to at least the Level 3 data or unified cache.

Each access to a cache line is counted including refills of and write-backs from other caches. Each access to other Level 3 data or unified memory structures, for example refill buffers, write buffers, and write-back buffers, is also counted.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If FEAT\_PMUv3p4 is implemented, accesses that only update the cache status information for a cache entry without accessing the content of the cache entry are not counted.

If FEAT\_PMUv3p4 is not implemented, it is IMPLEMENTATION DEFINED whether accesses that only update the cache status information for a cache entry without accessing the content of the cache entry are counted.

An example of cache status information is whether the cached data is held in an exclusive or shared state.

When the L3D\_CACHE\_RW event is implemented:

- If the L3D\_CACHE\_PRFM event is implemented, accesses to the Level 3 data cache due to a prefetch instruction are counted. Otherwise, these accesses are not counted.
- If the L3D\_CACHE\_HWPRF event is implemented, accesses to the Level 3 data cache due to a hardware prefetcher are counted. Otherwise these accesses are not counted.

When the L3D\_CACHE\_RW event is not implemented, it IMPLEMENTATION DEFINED whether accesses to the Level 3 data cache due to prefetch instructions or due to a hardware prefetcher are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[11] reads as 1 if this event is implemented and 0 otherwise.

## 0x002C , L3D\_CACHE\_WB, Level 3 data cache write-back

The counter counts each write-back of data from the Level 3 data or unified cache to outside of the Level 1 to Level 3 caches.

For example:

- Awrite-back of a dirty cache line to a lower level cache or memory.
- Awrite-back of a recently fetched cache line that has not been allocated to the Level 3 data cache.

Each write-back is counted once, even if multiple accesses are required to complete the write-back.

It is IMPLEMENTATION DEFINED whether the counter counts:

- Atransfer of a dirty cache line from the Level 3 data cache to outside of Level 1 to Level 3 caches made as a result of a coherency request.
- Write-backs made as a result of cache maintenance instructions.

The counter does not count:

- The invalidation of a cache line without any write-back to outside of the Level 1 to Level 3 caches or memory.
- Writes that write through the Level 3 data cache to outside of the Level 1 to Level 3 caches.
- Transfers of data from the Level 3 data cache to a Level 1 or Level 2 cache to satisfy a refill of the other cache.

Awrite-back is attributable to the agent that generated the request that caused the write-back. This might not be the same agent that caused the data being written back to be allocated into the cache.

An Unattributable write-back event occurs when a requestor outside of the PE makes a coherency request that results in write-back. If the cache is shared, then an Unattributable write-back event is not counted. If the cache is not shared, then the event is counted.

It is IMPLEMENTATION DEFINED whether a write of a whole cache line that is not the result of the eviction of a line from the cache, is counted. For example, this applies when the PE determines software is streaming writes to memory and does not allocate lines to the cache, or by a DC ZVA operation.

PMCEID1\_EL0[12] reads as 1 if this event is implemented and 0 otherwise.

## 0x002D , L2D\_TLB\_REFILL, Level 2 data TLB refill

The counter counts each access counted by L2D\_TLB that causes a TLB refill of the Level 2 data or unified TLB, or any Level 1 data, instruction, or unified TLBs of this PE.

This includes each access that causes a memory access due to a translation table walk or an access to another level of TLB caching.

The counter does not count the access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if any of the following are true:

- The access misses in the TLB and generates a translation table walk, but the result is not allocated into the TLB for any reason other than a Translation fault.
- The access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[13] reads as 1 if this event is implemented and 0 otherwise.

## 0x002E , L2I\_TLB\_REFILL, Level 2 instruction TLB refill

The counter counts each Instruction memory access counted by L2I\_TLB that causes a TLB refill of the Level 2 instruction TLB, or any Level 1 data, instruction, or unified TLBs of this PE.

This includes each Instruction memory access that causes a memory access due to a translation table walk or an access to another level of TLB caching.

The counter does not count the access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if any of the following are true:

- The access misses in the TLB and generates a translation table walk, but the result is not allocated into the TLB for any reason other than a Translation fault.
- The access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[14] reads as 1 if this event is implemented and 0 otherwise.

## 0x002F , L2D\_TLB, Level 2 data TLB access

The counter counts each Memory-read operation or Memory-write operation that causes a TLB access to at least the Level 2 data or unified TLB.

Each access to a TLB entry is counted including refills of Level 1 TLBs.

The counter does not count the access if the access is due to a TLB maintenance instruction.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[15] reads as 1 if this event is implemented and 0 otherwise.

## 0x0030 , L2I\_TLB, Level 2 instruction TLB access

The counter counts each Instruction memory access that causes a TLB access to at least the Level 2 instruction TLB.

The counter does not count the access if the access is due to a TLB maintenance instruction.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[16] reads as 1 if this event is implemented and 0 otherwise.

## 0x0031 , REMOTE\_ACCESS, Access to a remote device

The counter counts each Memory-read operation or Memory-write operation that causes an access to a remote device.

That is, a socket that does not contain the PE.

System topology is IMPLEMENTATION DEFINED. This means that it is IMPLEMENTATION DEFINED which systems are defined as multi-socket systems, and, in systems defined as multi-socket systems, which components are defined as being in the same or different sockets. Arm recommends that devices where an access through that device incurs a significant latency penalty compared to other accesses are treated as being in a different socket.

For example, in a system comprising multiple integrated circuits in a multi-chip module, an access to a different integrated circuit in the same module might be treated as an access to another socket, even though the multi-chip module is physically connected to a single socket at the motherboard. However, in another system with many such multi-chip modules, an access to a different integrated system in the same module might be treated as an access to the same socket because an access to an integrated circuit on a different module has much higher latency.

The count includes all accesses to external memory counted by REMOTE\_MEM. For more information, see REMOTE\_MEM.

It is IMPLEMENTATION DEFINED whether an access that causes a snoop into a different socket but does not return data from or pass data to the remote socket is counted.

PMCEID1\_EL0[17] reads as 1 if this event is implemented and 0 otherwise.

## 0x0032 , LL\_CACHE, Last level cache access

The counter counts each Memory-read operation or Memory-write operation that causes a cache access to at least the Last level cache.

Each access to a cache line is counted including refills of and write-backs from other caches. Each access to other Last level data or unified memory structures, for example refill buffers, write buffers, and write-back buffers, is also counted.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If FEAT\_PMUv3p4 is implemented, accesses that only update the cache status information for a cache entry without accessing the content of the cache entry are not counted.

If FEAT\_PMUv3p4 is not implemented, it is IMPLEMENTATION DEFINED whether accesses that only update the cache status information for a cache entry without accessing the content of the cache entry are counted.

An example of cache status information is whether the cached data is held in an exclusive or shared state.

When the LL\_CACHE\_RW event is implemented:

- If the LL\_CACHE\_PRFM event is implemented, accesses to the Last level cache due to a prefetch instruction are counted. Otherwise, these accesses are not counted.
- If the LL\_CACHE\_HWPRF event is implemented, accesses to the Last level cache due to a hardware prefetcher are counted. Otherwise these accesses are not counted.

When the LL\_CACHE\_RW event is not implemented, it IMPLEMENTATION DEFINED whether accesses to the Last level cache due to prefetch instructions or due to a hardware prefetcher are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[18] reads as 1 if this event is implemented and 0 otherwise.

## 0x0033 , LL\_CACHE\_MISS, Last level cache miss

If the LL\_CACHE\_RW event is implemented, the counter counts each access counted by LL\_CACHE\_RW that is not completed by the Last level cache.

If the LL\_CACHE\_RW event is not implemented, the counter counts each access counted by LL\_CACHE that is not completed by the Last level cache.

That is, the access is one of the following:

- AMemory-read operation that does not return data from the Last level cache.
- AMemory-write operation that does not update the Last level cache.

The counter does not count operations that are completed by a cache above the Last level cache.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[19] reads as 1 if this event is implemented and 0 otherwise.

## 0x0034 , DTLB\_WALK, Data TLB access with at least one translation table walk

The counter counts each access counted by L1D\_TLB that causes a refill of a data or unified TLB involving at least one translation table walk access.

This includes each complete or partial translation table walk that causes an access to memory, including to data or translation table walk caches.

If Armv8.7 is not implemented, it is IMPLEMENTATION DEFINED whether accesses that cause an update of an existing TLB entry involving at least one translation table walk access are counted. If Armv8.7 is implemented, these accesses are counted.

The counter does not count the access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[20] reads as 1 if this event is implemented and 0 otherwise.

## 0x0035 , ITLB\_WALK, Instruction TLB access with at least one translation table walk

The counter counts each access counted by L1I\_TLB that causes a refill of an instruction TLB involving at least one translation table walk access.

This includes each complete or partial translation table walk that causes an access to memory, including to data or translation table walk caches.

If Armv8.7 is not implemented, it is IMPLEMENTATION DEFINED whether accesses that cause an update of an existing TLB entry involving at least one translation table walk access are counted. If Armv8.7 is implemented, these accesses are counted.

The counter does not count the access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[21] reads as 1 if this event is implemented and 0 otherwise.

## 0x0036 , LL\_CACHE\_RD, Last level cache access, read

If the LL\_CACHE\_RW event is implemented, the counter counts each access counted by LL\_CACHE\_RW that is a Memory-read operation.

If the LL\_CACHE\_RW event is not implemented, the counter counts each access counted by LL\_CACHE that is a Memory-read operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[22] reads as 1 if this event is implemented and 0 otherwise.

## 0x0037 , LL\_CACHE\_MISS\_RD, Last level cache miss, read

The counter counts each access counted by both LL\_CACHE\_MISS and LL\_CACHE\_RD.

That is, every miss of the Last level cache counted by LL\_CACHE\_MISS that is caused by a Memory-read operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[23] reads as 1 if this event is implemented and 0 otherwise.

## 0x0038 , REMOTE\_ACCESS\_RD, Access to a remote device, read

The counter counts each access counted by REMOTE\_ACCESS that is a Memory-read operation.

PMCEID1\_EL0[24] reads as 1 if this event is implemented and 0 otherwise.

## 0x0039 , L1D\_CACHE\_LMISS\_RD, Level 1 data cache long-latency read miss

The counter counts each Memory-read operation to the Level 1 data or unified cache counted by L1D\_CACHE that incurs additional latency because it returns data from outside of the Level 1 data or unified cache of this PE.

The event indicates to software that the access missed in the Level 1 data or unified cache and might have a significant performance impact due to the additional latency compared to the latency of an access that hits in the Level 1 data or unified cache.

The counter does not count:

- Accesses where the additional latency is unlikely to be significantly performance-impacting. For example, if the access hits in another cache in the same local cluster, and the additional latency is small when compared to a miss in all Level 1 caches that the access looks up in and results in an access being made to a Level 2 cache or elsewhere beyond the Level 1 data or unified cache.
- Amiss that does not cause a new cache refill but is satisfied from a previous miss.

An implementation is not required to measure the latency, nor to track the access to determine whether the additional latency caused a performance impact. An implementation can extend the definition of this event with additional scenarios where an access might have a significant performance impact due to additional latency for the access.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance operations are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID1\_EL0[25] reads as 1 if this event is implemented and 0 otherwise.

## 0x003A , OP\_RETIRED, Micro-operation architecturally executed

The counter counts each operation counted by OP\_SPEC that would be executed in a Simple sequential execution of the program.

PMCEID1\_EL0[26] reads as 1 if this event is implemented and 0 otherwise.

## 0x003B , OP\_SPEC, Micro-operation speculatively executed

The counter counts each operation speculatively executed executed by the PE.

This includes operations that would not be executed in a Simple sequential execution of the program.

PMCEID1\_EL0[27] reads as 1 if this event is implemented and 0 otherwise.

## 0x003C , STALL, No operation sent for execution

The counter counts each cycle counted by CPU\_CYCLES where no operation was sent for execution.

On a multithreaded implementation:

- If the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT is 0, then the counter counts cycles when the PE is active and no operation for the PE is sent for execution, even if operations Attributable to other PEs in the multithreaded implementation are sent for execution in that cycle. The counter does not count cycles when the PE is not active.
- If the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT is 1, then the counter counts all cycles when no instructions or operations for any PE in the multithreaded implementation were sent for execution.

All STALL events are counted at the same point in the pipeline.

PMCEID1\_EL0[28] reads as 1 if this event is implemented and 0 otherwise.

## 0x003D , STALL\_SLOT\_BACKEND, No operation sent for execution on a Slot due to the backend

The counter counts each Slot counted by STALL\_SLOT where an Attributable instruction or operation for the PE is available on the Slot to dispatch from the frontend to the backend, but is not sent for execution because the backend is unable to accept the available instruction or operation for the PE.

It is IMPLEMENTATION DEFINED whether the counter also counts each Slot counted by STALL\_SLOT where no Attributable instruction or operation for the PE is available on the Slot to dispatch from the frontend and the backend is unable to accept any instruction or operation for the PE.

The division between frontend and backend is IMPLEMENTATION DEFINED. For more information, see STALL\_FRONTEND. All STALL events are counted at the same point in the pipeline. The maximum value by which STALL\_SLOT\_BACKEND can count in a single cycle is an IMPLEMENTATION DEFINED fixed value, slots .For more information, see STALL\_SLOT.

Note

In a single cycle, the sum of values counted by STALL\_SLOT\_BACKEND and STALL\_SLOT\_FRONTEND might be greater-than slots , if both the backend is unable to accept some operations and there are fewer-than slots operations available to dispatch from the frontend.

PMCEID1\_EL0[29] reads as 1 if this event is implemented and 0 otherwise.

## 0x003E , STALL\_SLOT\_FRONTEND, No operation sent for execution on a Slot due to the frontend

The counter counts each Slot counted by STALL\_SLOT where no Attributable instruction or operation was sent for execution and there was no Attributable instruction or operation available to dispatch for the PE from the frontend for the Slot.

The division between frontend and backend is IMPLEMENTATION DEFINED. For more information, see STALL\_FRONTEND. All STALL events are counted at the same point in the pipeline. The maximum value by which STALL\_SLOT\_FRONTEND can count in a single cycle is an IMPLEMENTATION DEFINED fixed value, slots .For more information, see STALL\_SLOT.

Note

In a single cycle, the sum of values counted by STALL\_SLOT\_BACKEND and STALL\_SLOT\_FRONTEND might be greater-than slots , if both the backend is unable to accept some operations and there are fewer-than slots operations available to dispatch from the frontend.

PMCEID1\_EL0[30] reads as 1 if this event is implemented and 0 otherwise.

## 0x003F , STALL\_SLOT, No operation sent for execution on a Slot

The counter increments by the number of instruction or operation Slots that were not occupied by an instruction or operation Attributable to the PE on each cycle.

All STALL events are counted at the same point in the pipeline. The maximum value by which STALL\_SLOT can count in a single cycle is an IMPLEMENTATION DEFINED fixed value, slots . The definition of a Slot is IMPLEMENTATION DEFINED. The formula STALL\_SLOT÷(CPU\_CYCLES × slots ) gives the utilization of the Slots of the processor by Attributable instruction or operations of this PE. Each Slot holds at most one instruction or operation each cycle.

On a multithreaded implementation:

- If the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT is 0, then the counter counts Slots occupied by an instruction or operation Attributable to other PEs of the multithreaded implementation only when the PE was active in that cycle. The counter does not count Slots on cycles when the PE was not active.
- If the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT is 1, then, for every cycle, the counter counts all Slots not occupied by any instruction or operation for any PE of the multithreaded implementation.

PMCEID1\_EL0[31] reads as 1 if this event is implemented and 0 otherwise.

## 0x0040 , L1D\_CACHE\_RD, Level 1 data cache access, read

If the L1D\_CACHE\_RW event is implemented, the counter counts each access counted by L1D\_CACHE\_RW that is a Memory-read operation.

If the L1D\_CACHE\_RW event is not implemented, the counter counts each access counted by L1D\_CACHE that is a Memory-read operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0041 , L1D\_CACHE\_WR, Level 1 data cache access, write

If the L1D\_CACHE\_RW event is implemented, the counter counts each access counted by L1D\_CACHE\_RW that is a Memory-write operation.

If the L1D\_CACHE\_RW event is not implemented, the counter counts each access counted by L1D\_CACHE that is a Memory-write operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0042 , L1D\_CACHE\_REFILL\_RD, Level 1 data cache refill, read

The counter counts each access counted by both L1D\_CACHE\_RD and L1D\_CACHE\_REFILL.

That is, every refill of the Level 1 data or unified cache counted by L1D\_CACHE\_REFILL that is caused by a Memory-read operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0043 , L1D\_CACHE\_REFILL\_WR, Level 1 data cache refill, write

The counter counts each access counted by both L1D\_CACHE\_REFILL and L1D\_CACHE\_WR.

That is, every refill of the Level 1 data or unified cache counted by L1D\_CACHE\_REFILL that is caused by a Memory-write operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0044 , L1D\_CACHE\_REFILL\_INNER, Level 1 data cache refill, inner

The counter counts each access counted by L1D\_CACHE\_REFILL that generates a refill satisfied by transfer from another cache inside of the immediate cluster.

Note

The boundary between inner and outer is IMPLEMENTATION DEFINED, and it is not necessarily linked to other similar boundaries, such as the boundary between Inner Cacheable and Outer Cacheable or the boundary between Inner Shareable and Outer Shareable.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other

cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0045 , L1D\_CACHE\_REFILL\_OUTER, Level 1 data cache refill, outer

The counter counts each access counted by L1D\_CACHE\_REFILL that generates a refill satisfied by transfer from outside of the immediate cluster.

Note

The boundary between inner and outer is IMPLEMENTATION DEFINED, and it is not necessarily linked to other similar boundaries, such as the boundary between Inner Cacheable and Outer Cacheable or the boundary between Inner Shareable and Outer Shareable.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0046 , L1D\_CACHE\_WB\_VICTIM, Level 1 data cache write-back, victim

The counter counts each write-back counted by L1D\_CACHE\_WB that occurs because the line is allocated for an access made by the PE.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0047 , L1D\_CACHE\_WB\_CLEAN, Level 1 data cache write-back, cleaning and coherency

The counter counts each write-back counted by L1D\_CACHE\_WB that occurs because of a coherency operation made by another PE or, optionally, the execution of a cache maintenance instruction.

Whether write-backs that are caused by the execution of a cache maintenance instruction are counted is IMPLEMENTATION DEFINED.

Note

The transfer of a dirty cache line from the Level 1 data cache of this PE to the data cache of another PE due to a hardware coherency operation is not counted unless the dirty cache line is also written back to a Level 2 cache or memory.

If a coherency request from a requestor outside of the PE results in a write-back, it is an Unattributable event.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0048 , L1D\_CACHE\_INVAL, Level 1 data cache invalidate

The counter counts each invalidation of a cache line in the Level 1 data or unified cache. For example:

- Invalidation of a cache line because of a cache maintenance operation.
- Transfer of ownership of a cache line to another cache because of a coherency or refill request.

The counter does not count events if a cache refill of the Level 1 data or unified cache invalidates a line in the Level 1 data or unified cache.

If FEAT\_PMUv3p4 is not implemented, the counter does not count locally-executed cache maintenance instructions that operate by set/way.

If FEAT\_PMUv3p4 is implemented, it is IMPLEMENTATION DEFINED whether the counter counts locally-executed cache maintenance instructions that operate by set/way.

Note

Software that uses this event must know whether the Level 1 data cache is shared with other PEs. This event does not follow the general rule of Level 1 data cache events of only counting Attributable events.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x004C , L1D\_TLB\_REFILL\_RD, Level 1 data TLB refill, read

The counter counts each access counted by both L1D\_TLB\_RD and L1D\_TLB\_REFILL.

The counter does not count the access if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x004D , L1D\_TLB\_REFILL\_WR, Level 1 data TLB refill, write

The counter counts each access counted by both L1D\_TLB\_REFILL and L1D\_TLB\_WR.

The counter does not count the access if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x004E , L1D\_TLB\_RD, Level 1 data TLB access, read

If the L1D\_TLB\_RW event is implemented, the counter counts each access counted by L1D\_TLB\_RW that is a Memory-read operation.

If the L1D\_TLB\_RW event is not implemented, the counter counts each access counted by L1D\_TLB that is a Memory-read operation.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x004F , L1D\_TLB\_WR, Level 1 data TLB access, write

If the L1D\_TLB\_RW event is implemented, the counter counts each access counted by L1D\_TLB\_RW that is a Memory-write operation.

If the L1D\_TLB\_RW event is not implemented, the counter counts each access counted by L1D\_TLB that is a Memory-write operation.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0050 , L2D\_CACHE\_RD, Level 2 data cache access, read

If the L2D\_CACHE\_RW event is implemented, the counter counts each access counted by L2D\_CACHE\_RW that is a Memory-read operation.

If the L2D\_CACHE\_RW event is not implemented, the counter counts each access counted by L2D\_CACHE that is a Memory-read operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0051 , L2D\_CACHE\_WR, Level 2 data cache access, write

If the L2D\_CACHE\_RW event is implemented, the counter counts each access counted by L2D\_CACHE\_RW that is a Memory-write operation.

If the L2D\_CACHE\_RW event is not implemented, the counter counts each access counted by L2D\_CACHE that is a Memory-write operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0052 , L2D\_CACHE\_REFILL\_RD, Level 2 data cache refill, read

The counter counts each access counted by both L2D\_CACHE\_RD and L2D\_CACHE\_REFILL.

That is, every refill of the Level 2 data or unified cache counted by L2D\_CACHE\_REFILL that is caused by a Memory-read operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0053 , L2D\_CACHE\_REFILL\_WR, Level 2 data cache refill, write

The counter counts each access counted by both L2D\_CACHE\_REFILL and L2D\_CACHE\_WR.

That is, every refill of the Level 2 data or unified cache counted by L2D\_CACHE\_REFILL that is caused by a Memory-write operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0056 , L2D\_CACHE\_WB\_VICTIM, Level 2 data cache write-back, victim

The counter counts each write-back counted by L2D\_CACHE\_WB that occurs because the line is allocated for an access made by the PE.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0057 , L2D\_CACHE\_WB\_CLEAN, Level 2 data cache write-back, cleaning and coherency

The counter counts each write-back counted by L2D\_CACHE\_WB that occurs because of a coherency operation made by another PE or, optionally, the execution of a cache maintenance instruction.

Whether write-backs that are caused by the execution of a cache maintenance instruction are counted is IMPLEMENTATION DEFINED.

Note

The transfer of a dirty cache line from the Level 2 data cache of this PE to the data cache of another PE due to a hardware coherency operation is not counted unless the dirty cache line is also written back to a Level 3 cache or memory.

If a coherency request from a requestor outside of the PE results in a write-back, it is an Unattributable event.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0058 , L2D\_CACHE\_INVAL, Level 2 data cache invalidate

The counter counts each invalidation of a cache line in the Level 2 data or unified cache. For example:

- Invalidation of a cache line because of a cache maintenance operation.
- Transfer of ownership of a cache line to another cache because of a coherency or refill request.

The counter does not count events if a cache refill of the Level 2 data or unified cache invalidates a line in the Level 2 data or unified cache.

If FEAT\_PMUv3p4 is not implemented, the counter does not count locally-executed cache maintenance instructions that operate by set/way.

If FEAT\_PMUv3p4 is implemented, it is IMPLEMENTATION DEFINED whether the counter counts locally-executed cache maintenance instructions that operate by set/way.

Note

Software that uses this event must know whether the Level 2 data cache is shared with other PEs. This event does not follow the general rule of Level 2 data cache events of only counting Attributable events.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x005C , L2D\_TLB\_REFILL\_RD, Level 2 data TLB refill, read

The counter counts each access counted by both L2D\_TLB\_RD and L2D\_TLB\_REFILL.

The counter does not count the access if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x005D , L2D\_TLB\_REFILL\_WR, Level 2 data TLB refill, write

The counter counts each access counted by both L2D\_TLB\_REFILL and L2D\_TLB\_WR.

The counter does not count the access if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x005E , L2D\_TLB\_RD, Level 2 data TLB access, read

The counter counts each access counted by L2D\_TLB that is a Memory-read operation.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x005F , L2D\_TLB\_WR, Level 2 data TLB access, write

The counter counts each access counted by L2D\_TLB that is a Memory-write operation.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0060 , BUS\_ACCESS\_RD, Bus access, read

The counter counts each access counted by BUS\_ACCESS that is a Memory-read operation.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0061 , BUS\_ACCESS\_WR, Bus access, write

The counter counts each access counted by BUS\_ACCESS that is a Memory-write operation.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0062 , BUS\_ACCESS\_SHARED, Bus access, Normal, Cacheable, Shareable

The counter counts each access counted by BUS\_ACCESS that is Normal, Cacheable, Shareable.

Note

It is IMPLEMENTATION DEFINED how the PE translates the attributes from the translation table entry for a region to the attributes on the bus.

In particular, a region of memory designated as Normal, Cacheable, Inner Shareable, Not Outer Shareable by a translation table entry, might be marked as either shareable or Non-shareable at the boundary of the PE and its closely-coupled caches. This depends on where the IMPLEMENTATION DEFINED boundary lies, between Inner and Outer Shareable.

If the Inner Shareable extends beyond the PE boundary, and the bus indicates the distinction between Inner and Outer Shareable, then either is counted as shareable for the purposes of defining this event.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0063 , BUS\_ACCESS\_NOT\_SHARED, Bus access, not Normal, Cacheable, Shareable

The counter counts each access counted by BUS\_ACCESS that is not counted by BUS\_ACCESS\_SHARED.

For example, the counter counts accesses marked as:

- Normal, Cacheable, Non-shareable.
- Normal, Non-cacheable.
- Device.

Note

It is IMPLEMENTATION DEFINED, how the PE translates the attributes from the translation table entries for a region to the attributes on the bus.

In particular, a region of memory designated as Normal, Cacheable, Inner Shareable, Not Outer Shareable by a translation table entry, might be marked as either shareable or Non-shareable at the boundary of the PE and its closely-coupled caches. This depends on where the IMPLEMENTATION DEFINED boundary lies, between Inner and Outer Shareable.

If the Inner Shareable extends beyond the PE boundary, and the bus indicates the distinction between Inner and Outer Shareable, then either is counted as shareable for the purposes of defining this event.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0064 , BUS\_ACCESS\_NORMAL, Bus access, normal

The counter counts each access counted by BUS\_ACCESS that is to Normal or bulk memory.

For example, the counter counts Normal, Cacheable and Normal, Non-cacheable accesses but does not count Device accesses.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0065 , BUS\_ACCESS\_PERIPH, Bus access, peripheral

The counter counts each access counted by BUS\_ACCESS that is not counted by BUS\_ACCESS\_NORMAL.

For example, the counter counts accesses to Device memory.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0066 , MEM\_ACCESS\_RD, Data memory access, read

If the MEM\_ACCESS\_RW event is implemented, the counter counts each access counted by MEM\_ACCESS\_RW that is a Memory-read operation.

If the MEM\_ACCESS\_RW event is not implemented, the counter counts each access counted by MEM\_ACCESS that is a Memory-read operation.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0067 , MEM\_ACCESS\_WR, Data memory access, write

If the MEM\_ACCESS\_RW event is implemented, the counter counts each access counted by MEM\_ACCESS\_RW that is a Memory-write operation.

If the MEM\_ACCESS\_RW event is not implemented, the counter counts each access counted by MEM\_ACCESS that is a Memory-write operation.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0068 , UNALIGNED\_LD\_SPEC, Unaligned access, read

The counter counts each unaligned access counted by UNALIGNED\_LDST\_SPEC that is a Memory-read operation.

The unaligned access is counted even if it is subsequently transformed into multiple aligned accesses.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0069 , UNALIGNED\_ST\_SPEC, Unaligned access, write

The counter counts each unaligned access counted by UNALIGNED\_LDST\_SPEC that is a Memory-write operation.

The unaligned access is counted even if it is subsequently transformed into multiple aligned accesses.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x006A , UNALIGNED\_LDST\_SPEC, Unaligned access

The counter counts each access counted by MEM\_ACCESS that is an unaligned Memory-read operation or unaligned Memory-write operation.

The unaligned access is counted even if it is subsequently transformed into multiple aligned accesses.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x006C , LDREX\_SPEC, Exclusive operation speculatively executed, Load-Exclusive

The counter counts each speculatively executed Load-Exclusive instruction.

The definition of speculatively executed is IMPLEMENTATION DEFINED but must be the same as for the STREX\_SPEC event.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x006D , STREX\_PASS\_SPEC, Exclusive operation speculatively executed, Store-Exclusive pass

The counter counts each speculatively executed Store-Exclusive instruction counted by STREX\_SPEC that completed a write.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x006E , STREX\_FAIL\_SPEC, Exclusive operation speculatively executed, Store-Exclusive fail

The counter counts each speculatively executed Store-Exclusive instruction counted by STREX\_SPEC that fails to complete a write.

It is within the IMPLEMENTATION DEFINED definition of speculatively executed whether this includes conditional instructions that fail the condition code check.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x006F , STREX\_SPEC, Exclusive operation speculatively executed, Store-Exclusive

The counter counts each speculatively executed Store-Exclusive instruction.

The definition of speculatively executed is IMPLEMENTATION DEFINED but it must be the same as for the LDREX\_SPEC event.

Arm recommends that this event is implemented if it is not possible to implement the exclusive operation speculatively executed, Store-Exclusive pass, and exclusive operation speculatively executed, Store-Exclusive fail, events with the same degree of speculation as the LDREX\_SPEC event.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0070 , LD\_SPEC, Operation speculatively executed, load

The counter counts each operation counted by LDST\_SPEC that is a load operation.

Operations due to Memory-reading instructions are counted as load operations.

It is IMPLEMENTATION DEFINED whether operations due to the prefetch instructions counted by PRF\_SPEC are counted as load operations:

- If operations due to the prefetch instructions are counted as load operations, then they are counted by LD\_SPEC.
- Otherwise, if operations due to the prefetch instructions are not counted as load operations by LD\_SPEC, then it is further IMPLEMENTATION DEFINED which one of the following applies:
- They are counted as data-processing operations.
- They are counted by LDST\_SPEC.

Arm recommends that if a prefetch operation is not implemented as a NOP and the PRF\_SPEC event is not implemented, then the operation is counted as a load operation.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0071 , ST\_SPEC, Operation speculatively executed, store

The counter counts each operation counted by LDST\_SPEC that is a store operation.

Operations due to Memory-writing instructions are counted as store operations.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0072 , LDST\_SPEC, Operation speculatively executed, load or store

The counter counts each operation counted by INST\_SPEC that is a load operation or a store operation.

See LD\_SPEC and ST\_SPEC for these classifications.

If the PRF\_SPEC event is implemented and operations due to the prefetch instructions counted by PRF\_SPEC are not counted as load operations by LD\_SPEC, then it is IMPLEMENTATION DEFINED whether these operations are counted by LDST\_SPEC. Arm recommends that these operations are counted by LDST\_SPEC.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0073 , DP\_SPEC, Operation speculatively executed, integer data processing

The counter counts each operation counted by INST\_SPEC that is an integer data-processing operation.

An integer data-processing operation is any operation that is not counted as any of the following:

- Aload or store operation, counted by LDST\_SPEC.
- ASoftware change of PC operation, counted by PC\_WRITE\_SPEC.
- Ascalar floating-point data processing operation, counted by VFP\_SPEC.
- An Advanced SIMD, SVE or SME data processing operation, counted by SE\_SPEC.
- Acryptographic operation, counted by CRYPTO\_SPEC.

That is, operations due to the following instructions are counted as integer data-processing operations:

- In AArch64 state instructions from the following sections:
- Data processing - immediate.
- Data processing - register.
- System register instructions.
- 'Instructions with register argument'.
- System instructions other than Memory-writing instructions.
- Hint instructions.
- When FEAT\_SVE is implemented and the SVE\_SPEC event is implemented, non-SIMD SVE instructions.
- In AArch32 state instructions from the following sections:
- Data-processing instructions.
- PSTATE and banked register access instructions.
- Banked register access instructions.
- Miscellaneous instructions other than ISB and prefetches.
- System register access instructions other than LDC and STC instructions.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0074 , ASE\_SPEC, Operation speculatively executed, Advanced SIMD data processing

The counter counts each operation counted by ASE\_SVE\_SPEC that is an Advanced SIMD data-processing operation.

Operations due to the following instructions are counted as Advanced SIMD data-processing operations:

- For AArch64 state:
- The SIMD operations listed in Data processing - SIMD and floating-point.
- Advanced SIMD scalar instructions, including those which operate on floating-point values.
- If FEAT\_Crypto is implemented, the Advanced SIMD PMULL and PMULL2 (1Q variants) instructions. See The Cryptographic Extension in AArch64 state.
- For AArch32 state:
- Instructions from Advanced SIMD data-processing instructions.
- Advanced SIMD scalar instructions, including those which operate on floating-point values.
- If FEAT\_Crypto is implemented, the Advanced SIMD VMULL (P64 variant) instruction. See The Cryptographic Extension in AArch32 state.

This includes all operations that operate on the SIMD&amp;FP registers, except those that are counted as one of the following:

- Integer data-processing operations.
- Scalar floating-point data-processing operations.
- Load or store operations.
- Cryptographic data-processing operations counted by CRYPTO\_SPEC. CRYPTO\_SPEC does not count the Cryptographic data-processing operations included above.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0075 , VFP\_SPEC, Operation speculatively executed, scalar floating-point data processing

The counter counts each operation counted by INST\_SPEC that is a scalar floating-point operation.

Operations due to the following instructions are counted as scalar floating-point data-processing operations:

- In AArch64 state:
- The scalar floating-point operations from Data processing - SIMD and floating-point. Only the scalar operations are counted. SIMD floating-point operations are not counted.
- Operations that take both an integer register and a floating-point register argument and perform a type conversion (to/from integer or to/from fixed-point): FCVT{&lt;mode&gt;} , UCVTF , and SCVTF .
- In AArch32 state:
- Instructions from Floating-point data-processing instructions.
- Operations that take both an integer register and a floating-point register argument and perform a type conversion (to/from integer or to/from fixed-point): VCVT&lt;mode&gt; (floating-point), VCVT , VCVTT , and VCVTB .

This includes all scalar operations that operate on the SIMD&amp;FP registers as floating-point values, except those that are counted as one of the following:

- SIMD scalar operations.
- Integer data-processing operations.
- Load or store operations.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0076 , PC\_WRITE\_SPEC, Operation speculatively executed, Software change of the PC

The counter counts each operation counted by INST\_SPEC that is a Software change of the PC.

Software change of the PC operations are defined by the PC\_WRITE\_RETIRED event.

When FEAT\_PMUv3p8 is implemented, the counter counts the operation even if the branch is not taken. Otherwise, it is IMPLEMENTATION DEFINED whether the counter counts the operation when the branch is not taken.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0077 , CRYPTO\_SPEC, Operation speculatively executed, cryptographic data processing

The counter counts each operation counted by INST\_SPEC that is a cryptographic operation.

Operations due to the following instructions are counted as cryptographic data-processing operations:

- In AArch64 state, instructions from the following sections:
- The Cryptographic Extension in AArch64 state other than the Advanced SIMD PMULL and PMULL2 (1Q variants) instructions.
- If FEAT\_SVE2 is implemented, SVE2 Crypto Extensions other than the SVE PMULLB and PMULLT (Q variants) instructions.
- In AArch32 state, instructions from The Cryptographic Extension in AArch32 state other than VMULL (P64 variant).

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0078 , BR\_IMMED\_SPEC, Branch speculatively executed, immediate branch

The counter counts each speculatively executed immediate branch instruction.

Operations due to the following instructions are counted as speculatively executed immediate branch instructions:

- For AArch32 state, the following instructions:
- B{&lt;c&gt;} &lt;label&gt; .
- BL{&lt;c&gt;} &lt;label&gt; .
- BLX{&lt;c&gt;} &lt;label&gt; .
- CBZ &lt;Rn&gt;, &lt;label&gt; .
- CBNZ &lt;label&gt; .
- For AArch64 state, the following instructions:
- B &lt;label&gt; .
- B.cond &lt;label&gt; .
- BL &lt;label&gt; .
- CBZ &lt;Rn&gt;, &lt;label&gt; .
- CBNZ &lt;Rn&gt;, &lt;label&gt; .
- TBZ &lt;Rn&gt;, &lt;label&gt; .
- TBNZ &lt;Rn&gt;, &lt;label&gt; .
- BC.cond &lt;label&gt; .
- CB&lt;cc&gt; &lt;Rn&gt;, #&lt;imm&gt;, &lt;label&gt; .
- CB&lt;cc&gt; &lt;Rn&gt;, #&lt;Rm&gt;, &lt;label&gt; .
- CBB&lt;cc&gt; &lt;Rn&gt;, #&lt;Rm&gt;, &lt;label&gt; .
- CBH&lt;cc&gt; &lt;Rn&gt;, #&lt;Rm&gt;, &lt;label&gt; .

## Note

Conditional branches are always counted, regardless of whether the branch is taken or not taken.

If the Context synchronization barrier instruction ISB is counted as a Software change of the PC instruction by PC\_WRITE\_SPEC, then it is IMPLEMENTATION DEFINED whether ISB is counted as a speculatively executed immediate branch instruction.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0079 , BR\_RETURN\_SPEC, Branch speculatively executed, procedure return

The counter counts each speculatively executed procedure return instruction.

Operations due to the following instructions are counted as speculatively executed procedure return instructions:

- For AArch32 state, the following instructions:
- BX R14 .
- MOV PC, LR .
- POP {..., PC} .

- LDR PC, [SP], #offset .
- For AArch64 state, the following instructions:
- RET .
- If FEAT\_PAuth is implemented, RETAA and RETAB .
- If FEAT\_PAuth\_LR is implemented, RETAASPPC , RETABSPPC , RETAASPPCR , and RETABSPPCR .

## Note

The counter counts only the listed instructions as procedure returns. For example, it does not count the following AArch32 instructions as procedure return instructions:

- BX R0 , because Rm != R14.
- MOV PC, R0 , because Rm != R14.
- LDM SP, {..., PC} , because writeback is not specified.
- LDR PC, [SP, #offset] , because this specifies the wrong addressing mode.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x007A , BR\_INDIRECT\_SPEC, Branch speculatively executed, indirect branch

The counter counts each speculatively executed indirect branch instruction.

Indirect branch instructions are Software change of the PC instructions other than exception-generating instructions and immediate branch instructions. Software change of the PC has the same definition as for the PC\_WRITE\_SPEC event. Immediate branch instructions are defined by the BR\_IMMED\_SPEC event.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x007C , ISB\_SPEC, Barrier speculatively executed, ISB

The counter counts each speculatively executed Instruction Synchronization Barrier instruction.

This includes the CP15ISB instruction.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x007D , DSB\_SPEC, Barrier speculatively executed, DSB

The counter counts each speculatively executed data synchronization and speculative load barrier instruction.

This includes the CP15DSB , SSBB , and PSSBB instructions.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x007E , DMB\_SPEC, Barrier speculatively executed, DMB

The counter counts each speculatively executed data memory barrier instruction.

This includes the CP15DSB instruction.

This does not include the implied barrier operations of load/store operations with release consistency semantics.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x007F , CSDB\_SPEC, Barrier speculatively executed, CSDB

The counter counts each speculatively executed control speculation barrier instruction.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0090 , RC\_LD\_SPEC, Release consistency operation speculatively executed, Load-Acquire

The counter counts each speculatively executed Memory-read operation with acquire or acquirepc semantics.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0091 , RC\_ST\_SPEC, Release consistency operation speculatively executed, Store-Release

The counter counts each speculatively executed Memory-write operation with release semantics.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x0092 , L3D\_CACHE\_HIT\_WR\_FEXT\_PROP, Level 3 data cache demand access first hit, write, fetched by external propagating transaction

The counter counts each demand access first hit counted by L3D\_CACHE\_HIT\_RW\_FEXT\_PROP due to a demand Memory-write operation.

## 0x00A0 , L3D\_CACHE\_RD, Level 3 data cache access, read

If the L3D\_CACHE\_RW event is implemented, the counter counts each access counted by L3D\_CACHE\_RW that is a Memory-read operation.

If the L3D\_CACHE\_RW event is not implemented, the counter counts each access counted by L3D\_CACHE that is a Memory-read operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x00A1 , L3D\_CACHE\_WR, Level 3 data cache access, write

If the L3D\_CACHE\_RW event is implemented, the counter counts each access counted by L3D\_CACHE\_RW that is a Memory-write operation.

If the L3D\_CACHE\_RW event is not implemented, the counter counts each access counted by L3D\_CACHE that is a Memory-write operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x00A2 , L3D\_CACHE\_REFILL\_RD, Level 3 data cache refill, read

The counter counts each access counted by both L3D\_CACHE\_RD and L3D\_CACHE\_REFILL.

That is, every refill of the Level 3 data or unified cache counted by L3D\_CACHE\_REFILL that is caused by a Memory-read operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other

cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x00A3 , L3D\_CACHE\_REFILL\_WR, Level 3 data cache refill, write

The counter counts each access counted by both L3D\_CACHE\_REFILL and L3D\_CACHE\_WR.

That is, every refill of the Level 3 data or unified cache counted by L3D\_CACHE\_REFILL that is caused by a Memory-write operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x00A6 , L3D\_CACHE\_WB\_VICTIM, Level 3 data cache write-back, victim

The counter counts each write-back counted by L3D\_CACHE\_WB that occurs because the line is allocated for an access made by the PE.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x00A7 , L3D\_CACHE\_WB\_CLEAN, Level 3 data cache write-back, cleaning and coherency

The counter counts each write-back counted by L3D\_CACHE\_WB that occurs because of a coherency operation made by another PE or, optionally, the execution of a cache maintenance instruction.

Whether write-backs that are caused by the execution of a cache maintenance instruction are counted is IMPLEMENTATION DEFINED.

Note

The transfer of a dirty cache line from the Level 3 data cache of this PE to the data cache of another PE due to a hardware coherency operation is not counted unless the dirty cache line is also written back to a lower level cache or memory.

If a coherency request from a requestor outside of the PE results in a write-back, it is an Unattributable event.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x00A8 , L3D\_CACHE\_INVAL, Level 3 data cache invalidate

The counter counts each invalidation of a cache line in the Level 3 data or unified cache. For example:

- Invalidation of a cache line because of a cache maintenance operation.
- Transfer of ownership of a cache line to another cache because of a coherency or refill request.

The counter does not count events if a cache refill of the Level 3 data or unified cache invalidates a line in the Level 3 data or unified cache.

If FEAT\_PMUv3p4 is not implemented, the counter does not count locally-executed cache maintenance instructions that operate by set/way.

If FEAT\_PMUv3p4 is implemented, it is IMPLEMENTATION DEFINED whether the counter counts locally-executed cache maintenance instructions that operate by set/way.

Note

Software that uses this event must know whether the Level 3 data cache is shared with other PEs. This event does not follow the general rule of Level 3 data cache events of only counting Attributable events.

When FEAT\_PMUv3p8 is not implemented, this is an IMPLEMENTATION DEFINED event.

## 0x00A9 , L2D\_CACHE\_HIT\_RD\_FEXT\_PROP, Level 2 data cache demand access first hit, read, fetched by external propagating transaction

The counter counts each demand access first hit counted by L2D\_CACHE\_HIT\_RW\_FEXT\_PROP due to a demand Memory-read operation.

## 0x00AA , L2D\_CACHE\_HIT\_WR\_FEXT\_PROP, Level 2 data cache demand access first hit, write, fetched by external propagating transaction

The counter counts each demand access first hit counted by L2D\_CACHE\_HIT\_RW\_FEXT\_PROP due to a demand Memory-write operation.

## 0x00AB , L2D\_CACHE\_HIT\_RW\_FEXT\_PROP,Level2datacachedemandaccessfirsthit, fetched by external propagating transaction

The counter counts each demand access first hit counted by L2D\_CACHE\_HIT\_RW where the cache line was fetched in response to an external propagating transaction.

That is, the L2D\_CACHE\_EXT\_PROP event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x00AC , L3D\_CACHE\_EXT\_PROP, Level 3 data cache allocation due to external propagating transaction

The counter counts each operation that writes into the level 3 data cache that is initiated by an external propagating transaction.

These are allocations of cache lines in the Level 3 data cache that are not refills counted by L3D\_CACHE\_REFILL. This includes allocations triggered by:

- Amemory update on another PE with an associated store shared hint.
- Astashing memory update from a device.

0x00AD , L3D\_CACHE\_EXT\_PROP\_PRFM\_IR, Level 3 data cache allocation due to external propagating transaction after prefetch with intent to read

The counter counts each access counted by L3D\_CACHE\_EXT\_PROP that happens after local PE executes a prefetch with intent to read on the location.

## 0x00AE , L3D\_CACHE\_HIT\_RW\_FEXT\_PROP,Level3datacachedemandaccessfirsthit, fetched by external propagating transaction

The counter counts each demand access first hit counted by L3D\_CACHE\_HIT\_RW where the cache line was fetched in response to an external propagating transaction.

That is, the L3D\_CACHE\_EXT\_PROP event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x00AF , L3D\_CACHE\_HIT\_RD\_FEXT\_PROP, Level 3 data cache demand access first hit, read, fetched by external propagating transaction

The counter counts each demand access first hit counted by L3D\_CACHE\_HIT\_RW\_FEXT\_PROP due to a demand Memory-read operation.

## 0x00B0 , STSHH\_SPEC, Store shared hint instruction speculatively executed

The counter counts each speculatively executed STSHH instruction.

## 0x00B1 , STSHH\_KEEP\_SPEC, Store shared hint instruction speculatively executed with KEEP policy

The counter counts each speculatively executed STSHH KEEP instruction counted by STSHH\_SPEC.

## 0x00B2 , STSHH\_STRM\_SPEC, Store shared hint instruction speculatively executed with STRM policy

The counter counts each speculatively executed STSHH STRM instruction counted by STSHH\_SPEC.

## 0x00B3 , PRFM\_IR\_SPEC, Prefetch with intent to read instruction speculatively executed

The counter counts each speculatively executed PRFM IR instruction counted by BASE\_PRF\_SPEC.

## 0x00B4 , MEM\_ACCESS\_WR\_STSHH, Memory write with store shared hint

The counter counts each access counted by MEM\_ACCESS\_WR that has an associated store shared hint.

This hint indicates that the memory update should trigger a transaction that propagates the updated location to other PEs.

## 0x00B5 , MEM\_ACCESS\_WR\_STSHH\_KEEP, Memory write with store shared hint with keep policy

The counter counts each access counted by MEM\_ACCESS\_WR\_STSHH that has an associated KEEP policy.

## 0x00B6 , MEM\_ACCESS\_WR\_STSHH\_STRM, Memory write with store shared hint with stream policy

The counter counts each access counted by MEM\_ACCESS\_WR\_STSHH that has an associated STRM policy.

## 0x00B7 , MEM\_ACCESS\_WR\_STSHH\_KEEP\_NEAR, Memory write with store shared hint with keep policy performed near

The counter counts each access counted by MEM\_ACCESS\_WR\_STSHH\_KEEP that does not initiate a transaction downstream of the local PE caches.

## 0x00B8 , MEM\_ACCESS\_WR\_STSHH\_KEEP\_FAR, Memory write with store shared hint with keep policy performed far

The counter counts each access counted by MEM\_ACCESS\_WR\_STSHH\_KEEP that initiates a transaction downstream of the local PE caches.

## 0x00B9 , L1D\_CACHE\_EXT\_PROP, Level 1 data cache allocation due to external propagating transaction

The counter counts each operation that writes into the level 1 data cache that is initiated by an external propagating transaction.

These are allocations of cache lines in the Level 1 data cache that are not refills counted by L1D\_CACHE\_REFILL. This includes allocations triggered by:

- Amemory update on another PE with an associated store shared hint.
- Astashing memory update from a device.

## 0x00BA , L1D\_CACHE\_EXT\_PROP\_PRFM\_IR, Level 1 data cache allocation due to external propagating transaction after prefetch with intent to read

The counter counts each access counted by L1D\_CACHE\_EXT\_PROP that happens after local PE executes a prefetch with intent to read on the location.

## 0x00BB , L1D\_CACHE\_HIT\_RD\_FEXT\_PROP, Level 1 data cache demand access first hit, read, fetched by external propagating transaction

The counter counts each demand access first hit counted by L1D\_CACHE\_HIT\_RW\_FEXT\_PROP due to a demand Memory-read operation.

## 0x00BC , L1D\_CACHE\_HIT\_WR\_FEXT\_PROP, Level 1 data cache demand access first hit, write, fetched by external propagating transaction

The counter counts each demand access first hit counted by L1D\_CACHE\_HIT\_RW\_FEXT\_PROP due to a demand Memory-write operation.

## 0x00BD , L1D\_CACHE\_HIT\_RW\_FEXT\_PROP,Level1datacachedemandaccessfirsthit, fetched by external propagating transaction

The counter counts each demand access first hit counted by L1D\_CACHE\_HIT\_RW where the cache line was fetched in response to an external propagating transaction.

That is, the L1D\_CACHE\_EXT\_PROP event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x00BE , L2D\_CACHE\_EXT\_PROP, Level 2 data cache allocation due to external propagating transaction

The counter counts each operation that writes into the level 2 data cache that is initiated by an external propagating transaction.

These are allocations of cache lines in the Level 2 data cache that are not refills counted by L2D\_CACHE\_REFILL. This includes allocations triggered by:

- Amemory update on another PE with an associated store shared hint.
- Astashing memory update from a device.

## 0x00BF , L2D\_CACHE\_EXT\_PROP\_PRFM\_IR, Level 2 data cache allocation due to external propagating transaction after prefetch with intent to read

The counter counts each access counted by L2D\_CACHE\_EXT\_PROP that happens after local PE executes a prefetch with intent to read on the location.

## 0x4000 , SAMPLE\_POP, Statistical Profiling sample population

The counter counts each operation that might be sampled, whether or not the operation was sampled.

The counter does not count when profiling is disabled.

PMCEID0\_EL0[32] reads as 1 if this event is implemented and 0 otherwise.

## 0x4001 , SAMPLE\_FEED, Statistical Profiling sample taken

The counter counts each time the sample interval counter reaches zero and is reloaded, and the sample does not collide with the previous sample.

Samples that are removed by filtering, or discarded, and not written to the Profiling Buffer are counted.

PMCEID0\_EL0[33] reads as 1 if this event is implemented and 0 otherwise.

## 0x4002 , SAMPLE\_FILTRATE, Statistical Profiling sample taken and not removed by filtering

The counter counts each sample counted by SAMPLE\_FEED that is not removed by filtering.

Sample records that are not removed by filtering, but are discarded before being written to the Profiling Buffer because of a Profiling Buffer management event or because Discard mode is implemented and enabled, are counted.

PMCEID0\_EL0[34] reads as 1 if this event is implemented and 0 otherwise.

## 0x4003 , SAMPLE\_COLLISION, Statistical Profiling sample collided with previous sample

The counter counts each time the sample interval counter reaches zero and is reloaded, and the sample collides with a previous sample.

For more information, see 'Sample collisions'.

PMCEID0\_EL0[35] reads as 1 if this event is implemented and 0 otherwise.

## 0x4004 , CNT\_CYCLES, Constant frequency cycles

The counter increments at a constant frequency equal to the rate of increment of the System Counter, CNTPCT\_EL0.

PMCEID0\_EL0[36] reads as 1 if this event is implemented and 0 otherwise.

## 0x4005 , STALL\_BACKEND\_MEM, Memory stall cycles

The counter counts each cycle counted by STALL\_BACKEND\_MEMBOUND where there is a demand data miss in the last level of data or unified cache within the PE clock domain.

If Armv8.7 is implemented, the counter also counts backend stall cycles when a non-cacheable data access is in progress.

If Armv8.7 is not implemented, it is IMPLEMENTATION DEFINED whether the counter counts backend stall cycles when a non-cacheable data access is in progress.

PMCEID0\_EL0[37] reads as 1 if this event is implemented and 0 otherwise.

## 0x4006 , L1I\_CACHE\_LMISS, Level 1 instruction cache long-latency miss

If the L1I\_CACHE\_RD event is implemented, the counter counts each access to the Level 1 instruction or unified cache counted by L1I\_CACHE\_RD that incurs additional latency because it returns instructions from outside of the Level 1 instruction or unified cache of this PE.

If the L1I\_CACHE\_RD event is not implemented, the counter counts each access to the Level 1 instruction or unified cache counted by L1I\_CACHE that incurs additional latency because it returns instructions from outside of the Level 1 instruction or unified cache of this PE.

The event indicates to software that the access missed in the Level 1 instruction or unified cache and might have a significant performance impact due to the additional latency compared to the latency of an access that hits in the Level 1 instruction or unified cache.

The counter does not count:

- Accesses where the additional latency is unlikely to be significantly performance-impacting. For example, if the access hits in another cache in the same local cluster, and the additional latency is small when compared to a miss in all Level 1 caches that the access looks up in and results in instructions being returned from a Level 2 cache or elsewhere beyond the Level 1 instruction or unified cache.

- Amiss that does not cause a new cache refill but is satisfied from a previous miss.

An implementation is not required to measure the latency, nor to track the access to determine whether the additional latency caused a performance impact. An implementation can extend the definition of this event with additional scenarios where an access might have a significant performance impact due to additional latency for the access.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance operations are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID0\_EL0[38] reads as 1 if this event is implemented and 0 otherwise.

## 0x4009 , L2D\_CACHE\_LMISS\_RD, Level 2 data cache long-latency read miss

The counter counts each Memory-read operation to the Level 2 data or unified cache counted by L2D\_CACHE that incurs additional latency because it returns data from outside of the Level 1 and Level 2 data or unified caches of this PE.

The event indicates to software that the access missed in the Level 2 data or unified cache and might have a significant performance impact due to the additional latency compared to the latency of an access that hits in the Level 2 data or unified cache.

The counter does not count:

- Accesses where the additional latency is unlikely to be significantly performance-impacting. For example, if the access hits in another cache in the same local cluster, and the additional latency is small when compared to a miss in all Level 2 caches that the access looks up in and results in an access being made to a Level 3 cache or elsewhere beyond the Level 2 data or unified cache. This might be counted as a Level 1 cache miss.
- Amiss that does not cause a new cache refill but is satisfied from a previous miss.

An implementation is not required to measure the latency, nor to track the access to determine whether the additional latency caused a performance impact. An implementation can extend the definition of this event with additional scenarios where an access might have a significant performance impact due to additional latency for the access.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance operations are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID0\_EL0[41] reads as 1 if this event is implemented and 0 otherwise.

## 0x400A , L2I\_CACHE\_LMISS, Level 2 instruction cache long-latency miss

If the L2I\_CACHE\_RD event is implemented, the counter counts each access to the Level 2 instruction or unified cache counted by L2I\_CACHE\_RD that incurs additional latency because it returns instructions from outside of the Level 1 and Level 2 instruction or unified caches of this PE.

If the L2I\_CACHE\_RD event is not implemented, the counter counts each access to the Level 2 instruction or unified cache counted by L2I\_CACHE that incurs additional latency because it returns instructions from outside of the Level 1 and Level 2 instruction or unified caches of this PE.

The event indicates to software that the access missed in the Level 2 instruction or unified cache and might have a significant performance impact due to the additional latency compared to the latency of an access that hits in the Level 2 instruction or unified cache.

The counter does not count:

- Accesses where the additional latency is unlikely to be significantly performance-impacting. For example, if the access hits in another cache in the same local cluster, and the additional latency is small when compared to a miss in all Level 2 caches that the access looks up in and results in instructions being returned from a Level 3 cache or elsewhere beyond the Level 2 instruction or unified cache. This might be counted as a Level 1 cache miss.
- Amiss that does not cause a new cache refill but is satisfied from a previous miss.

An implementation is not required to measure the latency, nor to track the access to determine whether the additional latency caused a performance impact. An implementation can extend the definition of this event with additional scenarios where an access might have a significant performance impact due to additional latency for the access.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance operations are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID0\_EL0[42] reads as 1 if this event is implemented and 0 otherwise.

## 0x400B , L3D\_CACHE\_LMISS\_RD, Level 3 data cache long-latency read miss

The counter counts each Memory-read operation to the Level 3 data or unified cache counted by L3D\_CACHE that incurs additional latency because it returns data from outside of the Level 1 to Level 3 data or unified caches of this PE.

The event indicates to software that the access missed in the Level 3 data or unified cache and might have a significant performance impact due to the additional latency compared to the latency of an access that hits in the Level 3 data or unified cache.

The counter does not count:

- Accesses where the additional latency is unlikely to be significantly performance-impacting. For example, if the access hits in another cache in the same local cluster, and the additional latency is small when compared to a miss in all Level 3 caches that the access looks up in and results in an access being made to a lower level cache or elsewhere beyond the Level 3 data or unified cache. This might be counted as a Level 2 cache miss.
- Amiss that does not cause a new cache refill but is satisfied from a previous miss.

An implementation is not required to measure the latency, nor to track the access to determine whether the additional latency caused a performance impact. An implementation can extend the definition of this event with additional scenarios where an access might have a significant performance impact due to additional latency for the access.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance operations are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

PMCEID0\_EL0[43] reads as 1 if this event is implemented and 0 otherwise.

## 0x4010 , TRCEXTOUT0, Trace unit external output 0

The counter counts each event signaled by the trace unit on external event 0.

It is IMPLEMENTATION DEFINED whether this event is available as an external input to the ETE.

PMCEID0\_EL0[48] reads as 1 if this event is implemented and 0 otherwise.

## 0x4011 , TRCEXTOUT1, Trace unit external output 1

The counter counts each event signaled by the trace unit on external event 1.

It is IMPLEMENTATION DEFINED whether this event is available as an external input to the ETE.

PMCEID0\_EL0[49] reads as 1 if this event is implemented and 0 otherwise.

## 0x4012 , TRCEXTOUT2, Trace unit external output 2

The counter counts each event signaled by the trace unit on external event 2.

It is IMPLEMENTATION DEFINED whether this event is available as an external input to the ETE.

PMCEID0\_EL0[50] reads as 1 if this event is implemented and 0 otherwise.

## 0x4013 , TRCEXTOUT3, Trace unit external output 3

The counter counts each event signaled by the trace unit on external event 3.

It is IMPLEMENTATION DEFINED whether this event is available as an external input to the ETE.

PMCEID0\_EL0[51] reads as 1 if this event is implemented and 0 otherwise.

## 0x4018 , CTI\_TRIGOUT4, Cross-trigger Interface output trigger 4

The counter counts each event signaled on CTI output trigger 4.

Note

CTI output triggers are input events to the PMU and trace unit.

PMCEID0\_EL0[56] reads as 1 if this event is implemented and 0 otherwise.

## 0x4019 , CTI\_TRIGOUT5, Cross-trigger Interface output trigger 5

The counter counts each event signaled on CTI output trigger 5.

Note

CTI output triggers are input events to the PMU and trace unit.

PMCEID0\_EL0[57] reads as 1 if this event is implemented and 0 otherwise.

## 0x401A , CTI\_TRIGOUT6, Cross-trigger Interface output trigger 6

The counter counts each event signaled on CTI output trigger 6.

Note

CTI output triggers are input events to the PMU and trace unit.

PMCEID0\_EL0[58] reads as 1 if this event is implemented and 0 otherwise.

## 0x401B , CTI\_TRIGOUT7, Cross-trigger Interface output trigger 7

The counter counts each event signaled on CTI output trigger 7.

Note

CTI output triggers are input events to the PMU and trace unit.

PMCEID0\_EL0[59] reads as 1 if this event is implemented and 0 otherwise.

## 0x4020 , LDST\_ALIGN\_LAT, Access with additional latency from alignment

The counter counts each access counted by MEM\_ACCESS that incurred additional latency due to the alignment of the address and size of data being accessed.

PMCEID1\_EL0[32] reads as 1 if this event is implemented and 0 otherwise.

## 0x4021 , LD\_ALIGN\_LAT, Load with additional latency from alignment

The counter counts each Memory-read operation counted by LDST\_ALIGN\_LAT.

PMCEID1\_EL0[33] reads as 1 if this event is implemented and 0 otherwise.

## 0x4022 , ST\_ALIGN\_LAT, Store with additional latency from alignment

The counter counts each Memory-write operation counted by LDST\_ALIGN\_LAT.

PMCEID1\_EL0[34] reads as 1 if this event is implemented and 0 otherwise.

## 0x4024 , MEM\_ACCESS\_CHECKED, Checked data memory access

The counter counts each memory access counted by MEM\_ACCESS that accesses an Allocation Tag due to a Tag Check operation.

It is IMPLEMENTATION DEFINED whether the counter increments on a Tag Checked access made when Tag Check Faults are configured to be ignored by SCTLR\_ELx.TCF or SCTLR\_ELx.TCF0.

PMCEID1\_EL0[36] reads as 1 if this event is implemented and 0 otherwise.

## 0x4025 , MEM\_ACCESS\_CHECKED\_RD, Checked data memory access, read

The counter counts each Memory-read operation counted by MEM\_ACCESS\_CHECKED.

It is IMPLEMENTATION DEFINED whether the counter increments on a Tag Checked access made when Tag Check Faults are configured to be ignored by SCTLR\_ELx.TCF or SCTLR\_ELx.TCF0.

PMCEID1\_EL0[37] reads as 1 if this event is implemented and 0 otherwise.

## 0x4026 , MEM\_ACCESS\_CHECKED\_WR, Checked data memory access, write

The counter counts each Memory-write operation counted by MEM\_ACCESS\_CHECKED.

It is IMPLEMENTATION DEFINED whether the counter increments on a Tag Checked access made when Tag Check Faults are configured to be ignored by SCTLR\_ELx.TCF or SCTLR\_ELx.TCF0.

PMCEID1\_EL0[38] reads as 1 if this event is implemented and 0 otherwise.

## 0x8004 , SIMD\_INST\_SPEC, Operation speculatively executed, SIMD

The counter counts each speculatively executed operation due to any of:

- An Advanced SIMD, SVE, or SME SIMD data-processing operation. Non-SIMD data-processing operations are not counted.
- Astructure load/store of one or more SIMD&amp;FP registers.
- Aload and replicate to one or more SIMD&amp;FP registers.
- Ascalar load/store of a SIMD&amp;FP Q register or pair of Q registers.
- An SVE or SME load/store.

It is IMPLEMENTATION DEFINED which Advanced SIMD operations are counted in AArch32 state.

When Armv9.5 is not implemented, it is IMPLEMENTATION DEFINED whether scalar loads and stores to SIMD&amp;FP registers other than those listed above are counted.

When Armv9.5 is implemented, other scalar loads and stores to SIMD&amp;FP registers are not counted.

## 0x8005 , ASE\_INST\_SPEC, Operation speculatively executed, Advanced SIMD

The counter counts each speculatively executed operation counted by ASE\_SVE\_INST\_SPEC that is classified as an Advanced SIMD operation.

Operations due to the following instructions are counted as Advanced SIMD operations:

- For AArch64 state:
- The SIMD operations listed in Data processing - SIMD and floating-point.
- If FEAT\_Crypto is implemented, the Advanced SIMD Cryptographic instructions. See The Cryptographic Extension in AArch64 state.
- Advanced SIMD loads and stores.
- For AArch32 state:
- Instructions from Advanced SIMD data-processing instructions.
- If FEAT\_Crypto is implemented, the Advanced SIMD Cryptographic instructions. See The Cryptographic Extension in AArch32 state.
- Advanced SIMD loads and stores.

This includes all operations that operate on the SIMD&amp;FP registers, except those that are counted as one of the following:

- Integer data-processing operations.
- Scalar floating-point data-processing operations.

It is IMPLEMENTATION DEFINED whether Advanced SIMD scalar operations are counted as Advanced SIMD operations. This includes Advanced SIMD scalar instructions which operate on floating-point values.

## 0x8006 , SVE\_INST\_SPEC, Operation speculatively executed, SVE

The counter counts each speculatively executed operation that is classified as an SVE operation.

An SVE operation is any operation due to an instruction that operates on the SVE scalable vector and predicate registers that is not any of the following:

- When FEAT\_SME is implemented, an operation counted by SME\_SPEC as an SME operation.

It is IMPLEMENTATION DEFINED whether the counter counts operations due to non-SIMD instructions.

Operations due to instructions defined by FEAT\_SME which involve the SVE registers but do not involve any ZA or ZT registers are counted as SVE operations.

## 0x8007 , ASE\_SVE\_INST\_SPEC, Operation speculatively executed, Advanced SIMD or SVE

The counter counts each speculatively executed operation counted by SE\_INST\_SPEC that is classified as an Advanced SIMD operation or an SVE operation.

See ASE\_INST\_SPEC and SVE\_INST\_SPEC for these classifications.

## 0x8008 , UOP\_SPEC, Microarchitectural operation speculatively executed

The counter counts each speculatively executed microarchitectural operation.

## 0x8009 , ASE\_UOP\_SPEC, Microarchitectural operation speculatively executed, Advanced SIMD

The counter counts each speculatively executed microarchitectural operation counted by ASE\_SVE\_UOP\_SPEC due to an A64 Advanced SIMD instruction.

It is IMPLEMENTATION DEFINED whether the counter counts microarchitectural operations due to Advanced SIMD scalar instructions.

It is IMPLEMENTATION DEFINED which Advanced SIMD microarchitectural operations are counted in AArch32 state.

## 0x800A , SVE\_UOP\_SPEC, Microarchitectural operation speculatively executed, SVE

The counter counts each speculatively executed microarchitectural operation counted by ASE\_SVE\_UOP\_SPEC due to an SVE instruction.

It is IMPLEMENTATION DEFINED whether the counter counts microarchitectural operations due to non-SIMD SVE instructions.

## 0x800B , ASE\_SVE\_UOP\_SPEC, Microarchitectural operation speculatively executed, Advanced SIMD or SVE

The counter counts each speculatively executed microarchitectural operation counted by UOP\_SPEC due to an A64 Advanced SIMD or SVE instruction.

It is IMPLEMENTATION DEFINED whether the counter counts microarchitecural operations due to Advanced SIMD scalar and non-SIMD SVE instructions.

It is IMPLEMENTATION DEFINED which Advanced SIMD microarchitectural operations are counted in AArch32 state.

## 0x800C , SIMD\_UOP\_SPEC, Microarchitectural operation speculatively executed, SIMD

The counter counts each speculatively executed microarchitectural operation counted by UOP\_SPEC due to any of:

- An SVE instruction other than non-SIMD SVE instructions.
- An A64 Advanced SIMD instruction other than an Advanced SIMD scalar instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD microarchitectural operations are counted in AArch32 state.

## 0x800E , SVE\_MATH\_SPEC, Operation speculatively executed, SVE math accelerator

The counter counts each speculatively executed math function operation due to any of the following instructions:

- SVE: FEXPA, FTMAD, FTSMUL, or FTSSEL.

## 0x8010 , FP\_SPEC, Floating-point operation speculatively executed, including SIMD

The counter counts each speculatively executed floating-point data-processing operation due to any of:

- An A64 scalar instruction.
- An A64 Advanced SIMD instruction.
- An SVE instruction.
- An SME instruction.

From Armv9.5, if FEAT\_AFP is implemented, then the counter counts any operation due to any of the following instructions:

- Scalar: FABS , or FNEG (scalar) .
- Advanced SIMD: FABS , FNEG (vector) , FRECPE , or FRSQRTE .
- SVE: FABS , FEXPA , FNEG , FRECPE , FRSQRTE , or FTSSEL .

Otherwise, it is IMPLEMENTATION DEFINED whether the counter counts any operation due to the above instructions.

It is IMPLEMENTATION DEFINED whether the counter counts any operations due to the following instructions:

- Data movement instructions which move data without carrying out any operations on the data. This includes identity data-processing operations.
- Conditional select instructions.
- Floating-point conversion instructions.

Any operation counted by INT\_SPEC is not counted.

It is IMPLEMENTATION DEFINED which floating-point data-processing operations are counted in AArch32 state.

Arm recommends that if FP\_CVT\_SPEC is implemented, FP\_SPEC counts operations due to convert instructions.

Note

This event differs from the VFP\_SPEC event which does not count SIMD operations.

## 0x8011 , ASE\_FP\_SPEC, Floating-point operation speculatively executed, Advanced SIMD

The counter counts each speculatively executed floating-point operation counted by ASE\_SVE\_FP\_SPEC due to an A64 Advanced SIMD instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD floating-point operations are counted in AArch32 state.

## 0x8012 , SVE\_FP\_SPEC, Floating-point operation speculatively executed, SVE

The counter counts each speculatively executed floating-point operation counted by ASE\_SVE\_FP\_SPEC due to an SVE instruction.

## 0x8013 , ASE\_SVE\_FP\_SPEC, Floating-point operation speculatively executed, Advanced SIMD or SVE

The counter counts each speculatively executed floating-point operation counted by SE\_FP\_SPEC due to an A64 Advanced SIMD or SVE instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD floating-point operations are counted in AArch32 state.

## 0x8014 , FP\_HP\_SPEC, Floating-point operation speculatively executed, half-precision

The counter counts each speculatively executed floating-point operation counted by FP\_SPEC where the largest type is half-precision.

## 0x8015 , ASE\_FP\_HP\_SPEC, Floating-point operation speculatively executed, Advanced SIMD half-precision, dataprocessing

The counter counts each speculatively executed half-precision floating-point data-processing operation counted by ASE\_SVE\_FP\_HP\_SPEC due to an Advanced SIMD instruction.

## 0x8016 , SVE\_FP\_HP\_SPEC, Floating-point operation speculatively executed, SVE half-precision, data-processing

The counter counts each speculatively executed half-precision floating-point data-processing operation counted by ASE\_SVE\_FP\_HP\_SPEC due to an SVE instruction.

## 0x8017 , ASE\_SVE\_FP\_HP\_SPEC,Floating-point operation speculatively executed, Advanced SIMD or SVE half-precision

The counter counts each speculatively executed half-precision floating-point operation counted by FP\_HP\_SPEC due to an Advanced SIMD or SVE instruction.

## 0x8018 , FP\_SP\_SPEC, Floating-point operation speculatively executed, single-precision

The counter counts each speculatively executed floating-point operation counted by FP\_SPEC where the largest type is single-precision.

## 0x8019 , ASE\_FP\_SP\_SPEC, Floating-point operation speculatively executed, Advanced SIMD single-precision, dataprocessing

The counter counts each speculatively executed single-precision floating-point data-processing operation counted by ASE\_SVE\_FP\_SP\_SPEC due to an Advanced SIMD instruction.

## 0x801A , SVE\_FP\_SP\_SPEC, Floating-point operation speculatively executed, SVE single-precision, data-processing

The counter counts each speculatively executed single-precision floating-point data-processing operation counted by ASE\_SVE\_FP\_SP\_SPEC due to an SVE instruction.

## 0x801B , ASE\_SVE\_FP\_SP\_SPEC, Floating-point operation speculatively executed, Advanced SIMD or SVE singleprecision, data-processing

The counter counts each speculatively executed single-precision floating-point data-processing operation counted by FP\_SP\_SPEC due to an Advanced SIMD or SVE instruction.

## 0x801C , FP\_DP\_SPEC, Floating-point operation speculatively executed, double-precision, data-processing

The counter counts each speculatively executed floating-point data-processing operation counted by FP\_SPEC where the largest type is double-precision.

## 0x801D , ASE\_FP\_DP\_SPEC, Floating-point operation speculatively executed, Advanced SIMD double-precision, dataprocessing

The counter counts each speculatively executed double-precision floating-point data-processing operation counted by ASE\_SVE\_FP\_DP\_SPEC due to an Advanced SIMD instruction.

## 0x801E , SVE\_FP\_DP\_SPEC, Floating-point operation speculatively executed, SVE double-precision, data-processing

The counter counts each speculatively executed double-precision floating-point data-processing operation counted by ASE\_SVE\_FP\_DP\_SPEC due to an SVE instruction.

## 0x801F , ASE\_SVE\_FP\_DP\_SPEC, Floating-point operation speculatively executed, Advanced SIMD or SVE doubleprecision, data-processing

The counter counts each speculatively executed double-precision floating-point data-processing operation due to an Advanced SIMD or SVE instruction.

## 0x8020 , FP\_DIV\_SPEC, Floating-point operation speculatively executed, divide

The counter counts each speculatively executed floating-point divide operation counted by FP\_SPEC due to any of the following A64 instructions:

- Scalar: FDIV.

- Advanced SIMD: FDIV.

- SVE: FDIV or FDIVR.

It is IMPLEMENTATION DEFINED which floating-point divide operations are counted in AArch32 state.

## 0x8021 , ASE\_FP\_DIV\_SPEC, Floating-point operation speculatively executed, Advanced SIMD divide

The counter counts each speculatively executed floating-point divide operation counted by ASE\_SVE\_FP\_DIV\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FDIV.

It is IMPLEMENTATION DEFINED which floating-point divide operations are counted in AArch32 state.

## 0x8022 , SVE\_FP\_DIV\_SPEC, Floating-point operation speculatively executed, SVE divide

The counter counts each speculatively executed floating-point divide operation counted by ASE\_SVE\_FP\_DIV\_SPEC due to any of the following instructions:

- SVE: FDIV or FDIVR.

## 0x8023 , ASE\_SVE\_FP\_DIV\_SPEC, Floating-point operation speculatively executed, Advanced SIMD or SVE divide

The counter counts each speculatively executed floating-point divide operation counted by FP\_DIV\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FDIV.
- SVE: FDIV or FDIVR.

It is IMPLEMENTATION DEFINED which floating-point divide operations are counted in AArch32 state.

## 0x8024 , FP\_SQRT\_SPEC, Floating-point operation speculatively executed, square root

The counter counts each speculatively executed floating-point square-root operation counted by FP\_SPEC due to any of the following A64 instructions:

- Scalar: FSQRT.
- Advanced SIMD: FSQRT.
- SVE: FSQRT.

It is IMPLEMENTATION DEFINED which floating-point square-root operations are counted in AArch32 state.

## 0x8025 , ASE\_FP\_SQRT\_SPEC, Floating-point operation speculatively executed, Advanced SIMD square root

The counter counts each speculatively executed floating-point square-root operation counted by ASE\_SVE\_FP\_SQRT\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FSQRT.

It is IMPLEMENTATION DEFINED which floating-point square-root operations are counted in AArch32 state.

## 0x8026 , SVE\_FP\_SQRT\_SPEC, Floating-point operation speculatively executed, SVE square root

The counter counts each speculatively executed floating-point square-root operation counted by ASE\_SVE\_FP\_SQRT\_SPEC due to any of the following instructions:

- SVE: FSQRT.

## 0x8027 , ASE\_SVE\_FP\_SQRT\_SPEC, Floating-point operation speculatively executed, Advanced SIMD or SVE squareroot

The counter counts each speculatively executed floating-point square-root operation counted by FP\_SQRT\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FSQRT.
- SVE: FSQRT.

It is IMPLEMENTATION DEFINED which floating-point square-root operations are counted in AArch32 state.

## 0x8028 , FP\_FMA\_SPEC, Floating-point operation speculatively executed, FMA

The counter counts each speculatively executed floating-point fused multiply-add or multiply-subtract operation counted by FP\_SPEC due to any of the following A64 instructions:

- Scalar: FMADD, FMSUB, FNMADD, or FNMSUB.
- Advanced SIMD: FMLA or FMLS.
- When FEAT\_BF16 is implemented, Advanced SIMD: BFMLALB or BFMLALT.
- When FEAT\_FCMA is implemented, Advanced SIMD: FCMLA.
- When FEAT\_FP8FMA is implemented, Advanced SIMD: FMLALB, FMLALLBB, FMLALLBT, FMLALLTB, FMLALLTT, or FMLALT.
- When FEAT\_FHM is implemented, Advanced SIMD: FMLAL, FMLAL2, FMLSL, or FMLSL2.
- SVE: BFMLALB, BFMLALT, FCMLA, FMAD, FMLA, FMLS, FMSB, FNMAD, FNMLA, FNMLS, FNMSB, or FTMAD.
- SVE2: BFMLA, BFMLS, BFMLSLB, BFMLSLT, FMLALB, FMLALLBB, FMLALLBT, FMLALLTB, FMLALLTT, FMLALT, FMLSLB, or FMLSLT.
- SME2: BFMLA, BFMLAL, BFMLS, BFMLSL, FMLA, FMLAL, FMLALL, FMLS, or FMLSL.

It is IMPLEMENTATION DEFINED which floating-point fused multiply-add or multiply-subtract operations are counted in AArch32 state.

## 0x8029 , ASE\_FP\_FMA\_SPEC, Floating-point operation speculatively executed, Advanced SIMD FMA

The counter counts each speculatively executed floating-point fused multiply-add or multiply-subtract operation counted by ASE\_SVE\_FP\_FMA\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FMLA or FMLS.
- When FEAT\_BF16 is implemented, Advanced SIMD: BFMLALB or BFMLALT.
- When FEAT\_FCMA is implemented, Advanced SIMD: FCMLA.
- When FEAT\_FP8FMA is implemented, Advanced SIMD: FMLALB, FMLALLBB, FMLALLBT, FMLALLTB, FMLALLTT, or FMLALT.
- When FEAT\_FHM is implemented, Advanced SIMD: FMLAL, FMLAL2, FMLSL, or FMLSL2.

It is IMPLEMENTATION DEFINED which floating-point fused multiply-add or multiply-subtract operations are counted in AArch32 state.

## 0x802A , SVE\_FP\_FMA\_SPEC, Floating-point operation speculatively executed, SVE FMA

The counter counts each speculatively executed floating-point fused multiply-add or multiply-subtract operation counted by ASE\_SVE\_FP\_FMA\_SPEC due to any of the following instructions:

- SVE: BFMLALB, BFMLALT, FCMLA, FMAD, FMLA, FMLS, FMSB, FNMAD, FNMLA, FNMLS, FNMSB, or FTMAD.
- SVE2: BFMLA, BFMLS, BFMLSLB, BFMLSLT, FMLALB, FMLALLBB, FMLALLBT, FMLALLTB, FMLALLTT, FMLALT, FMLSLB, or FMLSLT.

## 0x802B , ASE\_SVE\_FP\_FMA\_SPEC, Floating-point operation speculatively executed, Advanced SIMD or SVE FMA

The counter counts each speculatively executed floating-point fused multiply-add or multiply-subtract operation counted by FP\_FMA\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FMLA or FMLS.
- When FEAT\_BF16 is implemented, Advanced SIMD: BFMLALB or BFMLALT.
- When FEAT\_FCMA is implemented, Advanced SIMD: FCMLA.
- When FEAT\_FP8FMA is implemented, Advanced SIMD: FMLALB, FMLALLBB, FMLALLBT, FMLALLTB, FMLALLTT, or FMLALT.
- When FEAT\_FHM is implemented, Advanced SIMD: FMLAL, FMLAL2, FMLSL, or FMLSL2.
- SVE: BFMLALB, BFMLALT, FCMLA, FMAD, FMLA, FMLS, FMSB, FNMAD, FNMLA, FNMLS, FNMSB, or FTMAD.
- SVE2: BFMLA, BFMLS, BFMLSLB, BFMLSLT, FMLALB, FMLALLBB, FMLALLBT, FMLALLTB, FMLALLTT, FMLALT, FMLSLB, or FMLSLT.

It is IMPLEMENTATION DEFINED which floating-point fused multiply-add or multiply-subtract operations are counted in AArch32 state.

## 0x802C , FP\_MUL\_SPEC, Floating-point operation speculatively executed, multiply

The counter counts each speculatively executed floating-point multiply operation counted by FP\_SPEC due to any of the following A64 instructions:

- Scalar: FMUL or FMULX.
- Advanced SIMD: FMUL or FMULX.
- SVE: FMUL, FMULX, or FTSMUL.
- SVE2: BFMUL.

It is IMPLEMENTATION DEFINED which floating-point multiply operations are counted in AArch32 state.

## 0x802D , ASE\_FP\_MUL\_SPEC, Floating-point operation speculatively executed, Advanced SIMD multiply

The counter counts each speculatively executed floating-point multiply operation counted by ASE\_SVE\_FP\_MUL\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FMUL or FMULX.

It is IMPLEMENTATION DEFINED which floating-point multiply operations are counted in AArch32 state.

## 0x802E , SVE\_FP\_MUL\_SPEC, Floating-point operation speculatively executed, SVE multiply

The counter counts each speculatively executed floating-point multiply operation counted by ASE\_SVE\_FP\_MUL\_SPEC due to any of the following instructions:

- SVE: FMUL, FMULX, or FTSMUL.
- SVE2: BFMUL.

## 0x802F , ASE\_SVE\_FP\_MUL\_SPEC, Floating-point operation speculatively executed, Advanced SIMD or SVE multiply

The counter counts each speculatively executed floating-point fused multiply-add or multiply-subtract operation counted by FP\_MUL\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FMUL or FMULX.
- SVE: FMUL, FMULX, or FTSMUL.
- SVE2: BFMUL.

It is IMPLEMENTATION DEFINED which floating-point fused multiply-add or multiply-subtract operations are counted in AArch32 state.

## 0x8030 , FP\_ADDSUB\_SPEC, Floating-point operation speculatively executed, add or subtract

The counter counts each speculatively executed floating-point add or subtract operation counted by FP\_SPEC due to any of the following A64 instructions:

- Scalar: FADD or FSUB.
- Advanced SIMD: FABD, FADD, or FSUB.
- SVE: FABD, FADD, FSUB, or FSUBR.
- SVE2: BFADD or BFSUB.
- SME2: BFADD, BFSUB, FADD, or FSUB.

It is IMPLEMENTATION DEFINED which floating-point add or subtract operations are counted in AArch32 state.

## 0x8031 , ASE\_FP\_ADDSUB\_SPEC, Floating-point operation speculatively executed, Advanced SIMD add or subtract

The counter counts each speculatively executed floating-point add or subtract operation counted by ASE\_SVE\_FP\_ADDSUB\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FABD, FADD, or FSUB.

It is IMPLEMENTATION DEFINED which floating-point add or subtract operations are counted in AArch32 state.

## 0x8032 , SVE\_FP\_ADDSUB\_SPEC, Floating-point operation speculatively executed, SVE add or subtract

The counter counts each speculatively executed floating-point add or subtract operation counted by ASE\_SVE\_FP\_ADDSUB\_SPEC due to any of the following instructions:

- SVE: FABD, FADD, FSUB, or FSUBR.
- SVE2: BFADD or BFSUB.

## 0x8033 , ASE\_SVE\_FP\_ADDSUB\_SPEC, Floating-point operation speculatively executed, Advanced SIMD or SVE add or subtract

The counter counts each speculatively executed floating-point add or subtract operation counted by FP\_ADDSUB\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FABD, FADD, or FSUB.
- SVE: FABD, FADD, FSUB, or FSUBR.
- SVE2: BFADD or BFSUB.

It is IMPLEMENTATION DEFINED which floating-point add or subtract operations are counted in AArch32 state.

## 0x8034 , FP\_RECPE\_SPEC, Floating-point operation speculatively executed, reciprocal estimate

The counter counts each speculatively executed floating-point reciprocal estimate operation counted by FP\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FRECPE or FRSQRTE.
- SVE: FRECPE or FRSQRTE.

It is IMPLEMENTATION DEFINED which floating-point reciprocal estimate operations are counted in AArch32 state.

## 0x8035 , ASE\_FP\_RECPE\_SPEC, Floating-point operation speculatively executed, Advanced SIMD reciprocal estimate

The counter counts each speculatively executed floating-point reciprocal estimate operation counted by ASE\_SVE\_FP\_RECPE\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FRECPE or FRSQRTE.

It is IMPLEMENTATION DEFINED which floating-point reciprocal estimate operations are counted in AArch32 state.

## 0x8036 , SVE\_FP\_RECPE\_SPEC, Floating-point operation speculatively executed, SVE reciprocal estimate

The counter counts each speculatively executed floating-point reciprocal estimate operation counted by ASE\_SVE\_FP\_RECPE\_SPEC due to any of the following instructions:

- SVE: FRECPE or FRSQRTE.

## 0x8037 , ASE\_SVE\_FP\_RECPE\_SPEC,Floating-point operation speculatively executed, Advanced SIMD or SVE reciprocal estimate

The counter counts each speculatively executed floating-point reciprocal estimate operation counted by FP\_RECPE\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FRECPE or FRSQRTE.
- SVE: FRECPE or FRSQRTE.

It is IMPLEMENTATION DEFINED which floating-point reciprocal estimate operations are counted in AArch32 state.

## 0x8038 , FP\_CVT\_SPEC, Floating-point operation speculatively executed, convert

The counter counts each speculatively executed floating-point convert operation due to any of:

- An A64 scalar floating-point conversion instruction.
- An Advanced SIMD floating-point conversion instruction.
- An SVE register targeting floating-point conversion instruction.

This includes both conversions between floating-point types, and conversions between integer and floating-point types.

It is IMPLEMENTATION DEFINED which floating-point convert operations are counted in AArch32 state.

## 0x8039 , ASE\_FP\_CVT\_SPEC, Floating-point operation speculatively executed, Advanced SIMD convert

The counter counts each speculatively executed floating-point convert operation counted by ASE\_SVE\_FP\_CVT\_SPEC due to an A64 Advanced SIMD instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD floating-point convert operations are counted in AArch32 state.

## 0x803A , SVE\_FP\_CVT\_SPEC, Floating-point operation speculatively executed, SVE convert

The counter counts each speculatively executed floating-point convert operation counted by ASE\_SVE\_FP\_CVT\_SPEC due to an SVE instruction.

## 0x803B , ASE\_SVE\_FP\_CVT\_SPEC, Floating-point operation speculatively executed, Advanced SIMD or SVE convert

The counter counts each speculatively executed floating-point convert operation counted by FP\_CVT\_SPEC due to an A64 Advanced SIMD instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD floating-point convert operations are counted in AArch32 state.

## 0x803C , SVE\_FP\_AREDUCE\_SPEC, Floating-point operation speculatively executed, SVE accumulating reduction

The counter counts each speculatively executed floating-point accumulating reduction operation counted by SVE\_FP\_SPEC due to any of the following instructions:

- SVE: FADDA.

## 0x803D , ASE\_FP\_PREDUCE\_SPEC,Floating-point operation speculatively executed, Advanced SIMD pairwise add step or pairwise reduce step

The counter counts each speculatively executed floating-point pairwise add step or pairwise reduce step operation counted by ASE\_FP\_VREDUCE\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FADDP, FMAXNMP, FMAXP, FMINNMP, or FMINP.

It is IMPLEMENTATION DEFINED which floating-point pairwise add step or pairwise reduce step operations are counted in AArch32 state.

## 0x803E , SVE\_FP\_VREDUCE\_SPEC, Floating-point operation speculatively executed, SVE pairwise or reduction

The counter counts each speculatively executed floating-point treewise reduction or pairwise operations counted by ASE\_SVE\_FP\_VREDUCE\_SPEC due to any of the following instructions:

- SVE: FADDV, FMAXNMV, FMAXV, FMINNMV, or FMINV.
- SVE2: FADDP, FADDQV, FMAXNMP, FMAXNMQV, FMAXP, FMAXQV, FMINNMP, FMINNMQV, FMINP, or FMINQV.

Note

Treewise reduction instructions might be executed and counted as multiple pairwise operations.

## 0x803F , ASE\_SVE\_FP\_VREDUCE\_SPEC, Floating-point operation speculatively executed, Advanced SIMD or SVE vector reduction

The counter counts each speculatively executed floating-point reduction operation counted by ASE\_SVE\_FP\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FADDP, FMAXNMP, FMAXNMV, FMAXP, FMAXV, FMINNMP, FMINNMV, FMINP, or FMINV.
- SVE: FADDV, FMAXNMV, FMAXV, FMINNMV, or FMINV.
- SVE2: FADDP, FADDQV, FMAXNMP, FMAXNMQV, FMAXP, FMAXQV, FMINNMP, FMINNMQV, FMINP, or FMINQV.

It is IMPLEMENTATION DEFINED which floating-point reduction operations are counted in AArch32 state.

## 0x8040 , INT\_SPEC, Integer operation speculatively executed

The counter counts each speculatively executed integer arithmetic operation due to any of:

- An A64 scalar data-processing instruction.
- An Advanced SIMD instruction.
- An SVE data-processing instruction.
- An SME data-processing instruction.

It is IMPLEMENTATION DEFINED whether the counter counts any operation due to the following instructions:

- Scalar: FABS , FNEG (scalar) .
- Advanced SIMD: FABS , FNEG (vector) , FRECPE , FRSQRTE .
- SVE: FABS , FEXPA , FNEG , FRECPE , FRSQRTE , FTSSEL .
- Data movement instructions which move data without carrying out any operations on the data. This includes identity data-processing operations.
- Conditional select instructions.
- Floating-point conversion instructions.

Any operation counted by FP\_SPEC is not counted.

It is IMPLEMENTATION DEFINED which integer arithmetic operations are counted in AArch32 state.

## 0x8041 , ASE\_INT\_SPEC, Integer operation speculatively executed, Advanced SIMD

The counter counts each speculatively executed integer operation counted by ASE\_SVE\_INT\_SPEC due to an A64 Advanced SIMD instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD integer operations are counted in AArch32 state.

## 0x8042 , SVE\_INT\_SPEC, Integer operation speculatively executed, SVE

The counter counts each speculatively executed integer operation counted by ASE\_SVE\_INT\_SPEC due to an SVE instruction.

## 0x8043 , ASE\_SVE\_INT\_SPEC, Integer operation speculatively executed, Advanced SIMD or SVE

The counter counts each speculatively executed integer arithmetic operation counted by SE\_INT\_SPEC due to an A64 Advanced SIMD or SVE instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD integer operations are counted in AArch32 state.

## 0x8044 , INT\_DIV\_SPEC, Integer operation speculatively executed, divide

The counter counts each speculatively executed integer divide operation counted by INT\_SPEC due to any of the following A64 instructions:

- Scalar: SDIV or UDIV.
- SVE: SDIV, SDIVR, UDIV, or UDIVR.

It is IMPLEMENTATION DEFINED which integer divide operations are counted in AArch32 state.

## 0x8045 , INT\_DIV64\_SPEC, Integer operation speculatively executed, 64-bit divide

The counter counts each speculatively executed integer divide operation counted by INT\_SPEC due to any of the following A64 instructions:

- Scalar: SDIV or UDIV.
- SVE: SDIV, SDIVR, UDIV, or UDIVR.

The counter only counts operations with 64-bit operands or vector elements.

## 0x8046 , SVE\_INT\_DIV\_SPEC, Integer operation speculatively executed, SVE divide

The counter counts each speculatively executed integer divide operation counted by INT\_DIV\_SPEC due to any of the following instructions:

- SVE: SDIV, SDIVR, UDIV, or UDIVR.

## 0x8047 , SVE\_INT\_DIV64\_SPEC, Integer operation speculatively executed, SVE 64-bit divide

The counter counts each speculatively executed integer 64-bit divide operation counted by INT\_DIV64\_SPEC due to any of the following instructions:

- SVE: SDIV, SDIVR, UDIV, or UDIVR.

The counter only counts operations with 64-bit operands or vector elements.

## 0x8048 , INT\_MUL\_SPEC, Integer operation speculatively executed, multiply

The counter counts each speculatively executed integer multiply or multiply-accumulate operation counted by INT\_SPEC due to any of the following A64 instructions:

- Scalar: MADD, MSUB, MUL, SMADDL, SMULH, UMADDL, or UMULH.
- Advanced SIMD: MLA, MLS, MUL, PMUL, PMULL, PMULL2, SMLAL, SMLAL2, SMLSL, SMLSL2, SMULL, SMULL2, SQDMLAL, SQDMLAL2, SQDMLSL, SQDMLSL2, SQDMULH, SQDMULL, SQDMULL2, SQRDMULH, UMLAL, UMLAL2, UMLSL, UMLSL2, UMULL, or UMULL2.
- When FEAT\_RDM is implemented, Advanced SIMD: SQRDMLAH or SQRDMLSH.
- SVE: MAD, MLA (vectors), MLS (vectors), MSB, MUL, SMULH (predicated), or UMULH (predicated).
- SVE2: CMLA, MLA (indexed), MLS (indexed), MUL, PMUL, SMLALB, SMLALT, SMLSLB, SMLSLT, SMULH(unpredicated), SMULLB, SMULLT, SQDMLALB, SQDMLALBT, SQDMLALT, SQDMLSLB, SQDMLSLBT, SQDMLSLT, SQDMULH, SQDMULLB, SQDMULLT, SQRDCMLAH, SQRDMLAH, SQRDMLSH, SQRDMULH, UMLALB, UMLALT, UMLSLB, UMLSLT, UMULH (unpredicated), UMULLB, or UMULLT.
- SME2: SMLAL, SMLALL, SMLSL, SMLSLL, SUMLALL, UMLAL, UMLALL, UMLSL, UMLSLL, or USMLALL.

It is IMPLEMENTATION DEFINED which integer multiply or multiply-accumulate operations are counted in AArch32 state.

## 0x8049 , ASE\_INT\_MUL\_SPEC, Integer operation speculatively executed, Advanced SIMD multiply

The counter counts each speculatively executed integer multiply or multiply-accumulate operation counted by ASE\_SVE\_INT\_MUL\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: MLA, MLS, MUL, PMUL, PMULL, PMULL2, SMLAL, SMLAL2, SMLSL, SMLSL2, SMULL, SMULL2, SQDMLAL, SQDMLAL2, SQDMLSL, SQDMLSL2, SQDMULH, SQDMULL, SQDMULL2, SQRDMULH, UMLAL, UMLAL2, UMLSL, UMLSL2, UMULL, or UMULL2.
- When FEAT\_RDM is implemented, Advanced SIMD: SQRDMLAH or SQRDMLSH.

It is IMPLEMENTATION DEFINED which integer multiply or multiply-accumulate operations are counted in AArch32 state.

## 0x804A , SVE\_INT\_MUL\_SPEC, Integer operation speculatively executed, SVE multiply

The counter counts each speculatively executed integer multiply or multiply-accumulate operation counted by ASE\_SVE\_INT\_MUL\_SPEC due to any of the following instructions:

- SVE: MAD, MLA (vectors), MLS (vectors), MSB, MUL, SMULH (predicated), or UMULH (predicated).
- SVE2: CMLA, MLA (indexed), MLS (indexed), MUL, PMUL, SMLALB, SMLALT, SMLSLB, SMLSLT, SMULH(unpredicated), SMULLB, SMULLT, SQDMLALB, SQDMLALBT, SQDMLALT, SQDMLSLB, SQDMLSLBT, SQDMLSLT, SQDMULH, SQDMULLB, SQDMULLT, SQRDCMLAH, SQRDMLAH, SQRDMLSH, SQRDMULH, UMLALB, UMLALT, UMLSLB, UMLSLT, UMULH (unpredicated), UMULLB, or UMULLT.

## 0x804B , ASE\_SVE\_INT\_MUL\_SPEC, Integer operation speculatively executed, Advanced SIMD or SVE multiply

The counter counts each speculatively executed integer multiply or multiply-accumulate operation counted by INT\_MUL\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: MLA, MLS, MUL, PMUL, PMULL, PMULL2, SMLAL, SMLAL2, SMLSL, SMLSL2, SMULL, SMULL2, SQDMLAL, SQDMLAL2, SQDMLSL, SQDMLSL2, SQDMULH, SQDMULL, SQDMULL2, SQRDMULH, UMLAL, UMLAL2, UMLSL, UMLSL2, UMULL, or UMULL2.
- When FEAT\_RDM is implemented, Advanced SIMD: SQRDMLAH or SQRDMLSH.
- SVE: MAD, MLA (vectors), MLS (vectors), MSB, MUL, SMULH (predicated), or UMULH (predicated).
- SVE2: CMLA, MLA (indexed), MLS (indexed), MUL, PMUL, SMLALB, SMLALT, SMLSLB, SMLSLT, SMULH(unpredicated), SMULLB, SMULLT, SQDMLALB, SQDMLALBT, SQDMLALT, SQDMLSLB, SQDMLSLBT, SQDMLSLT, SQDMULH, SQDMULLB, SQDMULLT, SQRDCMLAH, SQRDMLAH, SQRDMLSH, SQRDMULH, UMLALB, UMLALT, UMLSLB, UMLSLT, UMULH (unpredicated), UMULLB, or UMULLT.

It is IMPLEMENTATION DEFINED which integer multiply or multiply-accumulate operations are counted in AArch32 state.

## 0x804C , INT\_MUL64\_SPEC, Integer operation speculatively executed, 64 × 64 multiply

The counter counts each speculatively executed 64 × 64 integer multiply operation counted by INT\_SPEC due to any of the following A64 instructions:

- Scalar: MADD, MSUB, MUL, SMULH, or UMULH.
- SVE: MAD, MLA (vectors), MLS (vectors), MSB, MUL (vectors, predicated), SMULH (predicated), or UMULH (predicated).
- SVE2: CMLA (vectors), MLA (indexed), MLS (indexed), MUL, SMULH (unpredicated), SQDMULH, SQRDCMLAH(vectors), SQRDMLAH, SQRDMLSH, SQRDMULH, or UMULH (unpredicated).

The counter only counts operations that perform a 64-bit × 64-bit integer multiply operations.

## 0x804D , SVE\_INT\_MUL64\_SPEC, Integer operation speculatively executed, SVE 64 × 64 multiply

The counter counts each speculatively executed 64 × 64 integer multiply operation counted by INT\_MUL64\_SPEC due to any of the following instructions:

- SVE: MAD, MLA (vectors), MLS (vectors), MSB, MUL (vectors, predicated), SMULH (predicated), or UMULH (predicated).
- SVE2: CMLA (vectors), MLA (indexed), MLS (indexed), MUL, SMULH (unpredicated), SQDMULH, SQRDCMLAH(vectors), SQRDMLAH, SQRDMLSH, SQRDMULH, or UMULH (unpredicated).

The counter only counts operations that perform a 64-bit × 64-bit integer multiply operations.

## 0x804E , INT\_MULH64\_SPEC, Integer operation speculatively executed, 64 × 64 multiply returning high part

The counter counts each speculatively executed widening 64 × 64 integer multiply operation counted by INT\_SPEC due to any of the following A64 instructions:

- Scalar: SMULH or UMULH.
- SVE: SMULH (predicated) or UMULH (predicated).
- SVE2: SMULH (unpredicated), SQDMULH, SQRDMULH, or UMULH (unpredicated).

These instructions perform 64-bit × 64-bit integer multiply operations.

## 0x804F , SVE\_INT\_MULH64\_SPEC, Integer operation speculatively executed, SVE 64 × 64 multiply high part

The counter counts each speculatively executed 64 × 64 integer multiply returning high part operation counted by INT\_MULH64\_SPEC due to any of the following instructions:

- SVE: SMULH (predicated) or UMULH (predicated).
- SVE2: SMULH (unpredicated), SQDMULH, SQRDMULH, or UMULH (unpredicated).

## 0x8051 , ASE\_FP\_BF16\_SPEC, Floating-point operation speculatively executed, Advanced SIMD BFloat16, data-processing

The counter counts each speculatively executed BFloat16 floating-point data-processing operation counted by ASE\_SVE\_FP\_BF16\_SPEC due to an Advanced SIMD instruction.

## 0x8052 , SVE\_FP\_BF16\_SPEC, Floating-point operation speculatively executed, SVE BFloat16, data-processing

The counter counts each speculatively executed BFloat16 floating-point data-processing operation counted by ASE\_SVE\_FP\_BF16\_SPEC due to an SVE instruction.

## 0x8053 , ASE\_SVE\_FP\_BF16\_SPEC, Floating-point operation speculatively executed, SVE or Advanced SIMD BFloat16, data-processing

The counter counts each speculatively executed BFloat16 floating-point data-processing operation counted by FP\_BF16\_SPEC due to an Advanced SIMD or SVE instruction.

## 0x8054 , FP\_BF16\_SPEC, Floating-point operation speculatively executed, BFloat16, data-processing

The counter counts each speculatively executed floating-point data-processing operation counted by FP\_SPEC where the largest type is BFloat16.

## 0x8056 , SVE\_SPEC, Operation speculatively executed, SVE data processing

The counter counts each operation counted by ASE\_SVE\_SPEC that is an SVE data-processing operation.

An SVE data-processing operation is any operation due to an instruction that operates on the SVE scalable vector and predicate registers that is not any of the following:

- Aload or store operation. These are counted by SVE\_INST\_SPEC.
- If the Cryptographic Extension is implemented, an operation counted by CRYPTO\_SPEC as a Cryptographic data-processing operation.
- When FEAT\_SME is implemented, an operation counted by SME\_SPEC as an SME data-processing operation.

If the Cryptographic Extension and FEAT\_SVE2 are implemented, operations due to the SVE PMULLB and PMULLT (Q variants) instructions are not counted by CRYPTO\_SPEC and are counted as SVE data-processing operations.

Operations due to data-processing instructions defined by FEAT\_SME which involve the SVE registers but do not involve any ZA or ZT registers are counted as SVE data-processing operations.

## 0x8057 , ASE\_SVE\_SPEC, Operation speculatively executed, Advanced SIMD data processing or SVE data processing

The counter counts each operation counted by INST\_SPEC that is an Advanced SIMD data-processing operation or an SVE data-processing operation.

See ASE\_SPEC and SVE\_SPEC for these classifications.

## 0x8058 , NONFP\_SPEC, Non-floating-point operation speculatively executed

The counter counts each speculatively executed data-processing operation due to any of:

- Ascalar instruction that would be counted by the DP\_SPEC event.
- An A64 Advanced SIMD data processing instruction defined in the section Data processing - SIMD and floating-point that would not be counted by FP\_SPEC.
- An SVE instruction with vector source or destination registers that would not be counted by FP\_SPEC.
- An SME instruction that would not be counted by FP\_SPEC.

It is IMPLEMENTATION DEFINED which non-floating-point data-processing operations are counted in AArch32 state.

## 0x8059 , ASE\_NONFP\_SPEC, Non-floating-point operation speculatively executed, Advanced SIMD

The counter counts each speculatively executed non-floating-point operation counted by ASE\_SVE\_NONFP\_SPEC due to an A64 Advanced SIMD instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD non-floating-point data-processing operations are counted in AArch32 state.

## 0x805A , SVE\_NONFP\_SPEC, Non-floating-point operation speculatively executed, SVE

The counter counts each speculatively executed non-floating-point operation counted by ASE\_SVE\_NONFP\_SPEC due to an SVE instruction.

## 0x805B , ASE\_SVE\_NONFP\_SPEC, Non-floating-point operation speculatively executed, Advanced SIMD or SVE

The counter counts each speculatively executed non-floating-point operation counted by NONFP\_SPEC due to an A64 Advanced SIMD or SVE instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD non-floating-point data-processing operations are counted in AArch32 state.

## 0x805D , ASE\_INT\_VREDUCE\_SPEC, Integer operation speculatively executed, Advanced SIMD reduction

The counter counts each speculatively executed across-vector and pairwise integer reduction operation counted by ASE\_SVE\_INT\_VREDUCE\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: ADDP, ADDV, SADALP, SADDLP, SADDLV, SMAXP, SMAXV, SMINP, SMINV, UADALP, UADDLP, UADDLV, UMAXP, UMAXV, UMINP, or UMINV.

It is IMPLEMENTATION DEFINED which across-vector and pairwise integer reduction operations are counted in AArch32 state.

## 0x805E , SVE\_INT\_VREDUCE\_SPEC, Integer operation speculatively executed, SVE reduction

The counter counts each speculatively executed across-vector and pairwise integer reduction operation counted by ASE\_SVE\_INT\_VREDUCE\_SPEC due to any of the following instructions:

- SVE: ANDV, EORV, ORV, SADDV, SMAXV, SMINV, UADDV, UMAXV, or UMINV.
- SVE2: ADDP, ADDQV, ANDQV, EORQV, ORQV, SADALP, SMAXP, SMAXQV, SMINP, SMINQV, UADALP, UMAXP, UMAXQV, UMINP, or UMINQV.

## 0x805F , ASE\_SVE\_INT\_VREDUCE\_SPEC, Integer operation speculatively executed, Advanced SIMD or SVE reduction

The counter counts each speculatively executed across-vector and pairwise integer reduction operation counted by INT\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: ADDP, ADDV, SADALP, SADDLP, SADDLV, SMAXP, SMAXV, SMINP, SMINV, UADALP, UADDLP, UADDLV, UMAXP, UMAXV, UMINP, or UMINV.
- SVE: ANDV, EORV, ORV, SADDV, SMAXV, SMINV, UADDV, UMAXV, or UMINV.
- SVE2: ADDP, ADDQV, ANDQV, EORQV, ORQV, SADALP, SMAXP, SMAXQV, SMINP, SMINQV, UADALP, UMAXP, UMAXQV, UMINP, or UMINQV.

It is IMPLEMENTATION DEFINED which across-vector and pairwise integer reduction operations are counted in AArch32 state.

## 0x8060 , SVE\_PERM\_SPEC, Operation speculatively executed, SVE permute

The counter counts each speculatively executed vector or predicate permute operation due to any of the following instructions:

- SVE: CLASTA, CLASTB, COMPACT, CPY (SIMD&amp;FP scalar), CPY (scalar), DUP (indexed), DUP (scalar), EXT, INSR, LASTA, LASTB, PUNPKHI, PUNPKLO, REV (vector), REVB, REVH, REVW, SPLICE, SUNPKHI, SUNPKLO, TBL, TRN1, TRN2, UUNPKHI, UUNPKLO, UZP1, UZP2, ZIP1, or ZIP2.
- SVE2: EXPAND, REVD, TBX, or TBXQ.

## 0x8061 , SVE\_PERM\_IGRANULE\_SPEC, Operation speculatively executed, SVE intra-granule permute

The counter counts each speculatively executed vector or predicate permute operation within a 128-bit vector granule or 16-bit predicate granule due to any of the following instructions:

- SVE: REVB, REVH, REVW, TRN1 (vectors), or TRN2 (vectors).
- SVE2: REVD.

## 0x8062 , SVE\_PERM\_XGRANULE\_SPEC, Operation speculatively executed, SVE cross-granule permute

The counter counts each speculatively executed vector or predicate permute operation that can cross between 128-bit vector granules or 16-bit predicate granules due to any of the following instructions:

- SVE: CLASTA, CLASTB, COMPACT, CPY (SIMD&amp;FP scalar), CPY (scalar), DUP (indexed), DUP (scalar), EXT, INSR, LASTA, LASTB, PUNPKHI, PUNPKLO, REV (vector), SPLICE, SUNPKHI, SUNPKLO, TBL, TRN1 (predicates), TRN2 (predicates), UUNPKHI, UUNPKLO, UZP1, UZP2, ZIP1, or ZIP2.
- SVE2: EXPAND, TBX, or TBXQ.

## 0x8063 , SVE\_PERM\_VARIABLE\_SPEC, Operation speculatively executed, SVE programmable permute

The counter counts each speculatively executed variable vector permute operation due to any of the following instructions:

- SVE: CLASTA, CLASTB, COMPACT, LASTA, LASTB, SPLICE, or TBL.
- SVE2: EXPAND.

## 0x8064 , SVE\_XPIPE\_SPEC, Operation speculatively executed, SVE cross-pipe

The counter counts each speculatively executed cross-pipeline transfer operation due to any of the following instructions:

- SVE: CLASTA (scalar), CLASTB (scalar), CNTP (predicate), CPY (scalar), DECP (scalar), DUP (scalar), INCP (scalar), INDEX (immediate, scalar), INDEX (scalar, immediate), INDEX (scalars), INSR (scalar), LASTA (scalar), LASTB (scalar), SQDECP (scalar), SQINCP (scalar), UQDECP (scalar), UQINCP (scalar), WHILELE (predicate), WHILELO (predicate), WHILELS (predicate), or WHILELT (predicate).
- SVE2: CNTP (predicate as counter), FIRSTP, LASTP, PSEL, WHILEGE, WHILEGT, WHILEHI, WHILEHS, WHILELE, WHILELO, WHILELS, WHILELT, WHILERW, or WHILEWR.

## 0x8065 , SVE\_XPIPE\_Z2R\_SPEC, Operation speculatively executed, SVE vector to scalar cross-pipe

The counter counts each speculatively executed vector to general-purpose scalar cross-pipeline transfer operation counted by SVE\_XPIPE\_SPEC due to any of the following instructions:

- SVE: CLASTA (scalar), CLASTB (scalar), CNTP (predicate), DECP (scalar), INCP (scalar), LASTA (scalar), LASTB (scalar), SQDECP (scalar), SQINCP (scalar), UQDECP (scalar), or UQINCP (scalar).
- SVE2: CNTP (predicate as counter), FIRSTP, or LASTP.

## 0x8066 , SVE\_XPIPE\_R2Z\_SPEC, Operation speculatively executed, SVE scalar to vector cross-pipe

The counter counts each speculatively executed general-purpose scalar to vector cross-pipeline transfer operation counted by SVE\_XPIPE\_SPEC due to any of the following instructions:

- SVE: CPY (scalar), DUP (scalar), INDEX (immediate, scalar), INDEX (scalar, immediate), INDEX (scalars), INSR (scalar), WHILELE (predicate), WHILELO (predicate), WHILELS (predicate), or WHILELT (predicate).
- SVE2: PSEL, WHILEGE, WHILEGT, WHILEHI, WHILEHS, WHILELE, WHILELO, WHILELS, WHILELT, WHILERW, or WHILEWR.

## 0x8067 , SVE\_PGEN\_NVEC\_SPEC, Operation speculatively executed, SVE predicate-only

The counter counts each speculatively executed predicate-generating operation that does not read vector registers due to any of the following instructions:

- SVE: AND (predicates), ANDS, BIC (predicates), BICS, BRKA, BRKAS, BRKB, BRKBS, BRKN, BRKNS, BRKPA, BRKPAS, BRKPB, BRKPBS, EOR (predicates), EORS, NAND, NANDS, NOR, NORS, ORN (predicates), ORNS, ORR (predicates), ORRS, PFALSE, PFIRST, PNEXT, PTRUE (predicate), PTRUES, PUNPKHI, PUNPKLO, RDFFR, RDFFRS, REV (predicate), SEL (predicates), TRN1 (predicates), TRN2 (predicates), UZP1 (predicates), UZP2 (predicates), ZIP1 (predicates), or ZIP2 (predicates).
- SVE2: PEXT or PTRUE (predicate as counter).

## 0x8068 , SVE\_PGEN\_SPEC, Operation speculatively executed, SVE predicate generating

The counter counts each speculatively executed predicate-generating operation due to any of the following instructions:

- SVE: AND (predicates), ANDS, BIC (predicates), BICS, BRKA, BRKAS, BRKB, BRKBS, BRKN, BRKNS, BRKPA, BRKPAS, BRKPB, BRKPBS, CMP&lt;cc&gt;, EOR (predicates), EORS, FAC&lt;cc&gt;, FCM&lt;cc&gt;, NAND, NANDS, NOR, NORS, ORN (predicates), ORNS, ORR (predicates), ORRS, PFALSE, PFIRST, PNEXT, PTRUE (predicate), PTRUES, PUNPKHI, PUNPKLO, RDFFR, RDFFRS, REV (predicate), SEL (predicates), TRN1 (predicates), TRN2 (predicates), UZP1 (predicates), UZP2 (predicates), WHILELE (predicate), WHILELO (predicate), WHILELS (predicate), WHILELT (predicate), ZIP1 (predicates), or ZIP2 (predicates).
- SVE2: MATCH, NMATCH, PEXT, PMOV (to predicate), PSEL, PTRUE (predicate as counter), WHILEGE, WHILEGT, WHILEHI, WHILEHS, WHILELE, WHILELO, WHILELS, WHILELT, WHILERW, or WHILEWR.

## 0x8069 , SVE\_PGEN\_FLG\_SPEC, Operation speculatively executed, SVE predicate flag setting

The counter counts each speculatively executed predicate-generating operation that sets condition flags due to any of the following instructions:

- SVE: ANDS, BICS, BRKAS, BRKBS, BRKNS, BRKPAS, BRKPBS, CMP&lt;cc&gt;, EORS, NANDS, NORS, ORNS, ORRS, PFIRST, PNEXT, PTRUES, RDFFRS, WHILELE (predicate), WHILELO (predicate), WHILELS (predicate), or WHILELT (predicate).
- SVE2: MATCH, NMATCH, WHILEGE, WHILEGT, WHILEHI, WHILEHS, WHILELE, WHILELO, WHILELS, WHILELT, WHILERW, or WHILEWR.

## 0x806A , SVE\_PGEN\_CMP\_SPEC, Operation speculatively executed, SVE vector compare

The counter counts each speculatively executed vector compare operation due to any of the following instructions:

- SVE: CMP&lt;cc&gt;, FAC&lt;cc&gt;, or FCM&lt;cc&gt;

## 0x806B , SVE\_PGEN\_FCM\_SPEC, Floating-point operation speculatively executed, SVE vector compare

The counter counts each speculatively executed vector floating-point compare operation due to any of the following instructions:

- SVE: FAC&lt;cc&gt; or FCM&lt;cc&gt;

## 0x806C , SVE\_PGEN\_LOGIC\_SPEC, Operation speculatively executed, SVE predicate logical

The counter counts each speculatively executed predicate logical operation due to any of the following instructions:

- SVE: AND (predicates), ANDS, BIC (predicates), BICS, EOR (predicates), EORS, NAND, NANDS, NOR, NORS, ORN (predicates), ORNS, ORR (predicates), or ORRS.

## 0x806D , SVE\_PPERM\_SPEC, Operation speculatively executed, SVE predicate permute

The counter counts each speculatively executed predicate permute operation due to any of the following instructions:

- SVE: PUNPKHI, PUNPKLO, REV (predicate), TRN1 (predicates), TRN2 (predicates), UZP1 (predicates), UZP2 (predicates), ZIP1 (predicates), or ZIP2 (predicates).

## 0x806E , SVE\_PSCAN\_SPEC, Operation speculatively executed, SVE predicate scan

The counter counts each speculatively executed predicate scanning and generation operation due to any of the following instructions:

- SVE: BRKA, BRKAS, BRKB, BRKBS, BRKN, BRKNS, BRKPA, BRKPAS, BRKPB, BRKPBS, PFIRST, or PNEXT.

## 0x806F , SVE\_PCNT\_SPEC, Operation speculatively executed, SVE predicate count

The counter counts each speculatively executed predicate population count operation due to any of the following instructions:

- SVE: CNTP (predicate), DECP, INCP, SQDECP, SQINCP, UQDECP, or UQINCP.
- SVE2: CNTP (predicate as counter).

## 0x8070 , SVE\_PLOOP\_WHILE\_SPEC, Operation speculatively executed, SVE predicate loop while

The counter counts each speculatively executed counted predicate generation operation due to any of the following instructions:

- SVE: WHILELE (predicate), WHILELO (predicate), WHILELS (predicate), or WHILELT (predicate).
- SVE2: WHILEGE, WHILEGT, WHILEHI, WHILEHS, WHILELE, WHILELO, WHILELS, or WHILELT.

## 0x8071 , SVE\_PLOOP\_TEST\_SPEC, Operation speculatively executed, SVE predicate loop test

The counter counts each speculatively executed loop predicate test operation due to any of the following instructions:

- SVE: BRKAS, BRKBS, BRKNS, BRKPAS, BRKPBS, WHILELE (predicate), WHILELO (predicate), WHILELS (predicate), or WHILELT (predicate).
- SVE2: WHILEGE, WHILEGT, WHILEHI, WHILEHS, WHILELE, WHILELO, WHILELS, or WHILELT.

## 0x8072 , SVE\_PLOOP\_ELTS\_SPEC, Operation speculatively executed, SVE predicate loop elements

The counter counts each speculatively executed loop predicate generation operation due to any of the following instructions:

- SVE: WHILELE (predicate), WHILELO (predicate), WHILELS (predicate), or WHILELT (predicate).
- SVE2: WHILEGE, WHILEGT, WHILEHI, WHILEHS, WHILELE, WHILELO, WHILELS, or WHILELT.

The counter increments by (128 ÷ CSIZE).

Note

Multiplying the counter value by (VL ÷ 128) determines the number of vector elements speculatively processed by while loops.

## 0x8073 , SVE\_PLOOP\_TERM\_SPEC, Operation speculatively executed, SVE predicate loop termination

The counter counts each speculatively executed loop-terminating predicate generation operation due to any of:

- An SVE WHILELE , WHILELO , WHILELS , or WHILELT instruction which sets PSTATE.N to 0.
- An SVE BRKAS , BRKBS , BRKNS , BRKPAS , or BRKPBS instruction which sets PSTATE.C to 1.
- An SVE CTERMEQ or CTERMNE instruction which sets PSTATE.N to 1 and PSTATE.V to 0.
- An SVE2 WHILEGE , WHILEGT , WHILEHI , or WHILEHS instruction which sets PSTATE.N to 0.

## 0x8074 , SVE\_PRED\_SPEC, Operation speculatively executed, SIMD predicated

The counter counts each speculatively executed predicated SIMD operation.

All of the following SVE operations are counted as predicated SIMD operations:

- Data-processing or load operations that write to one or more SVE Z vector destination registers under a Governing predicate using either zeroing or merging predication.
- Predicated stores of one or more SVE Z vector registers.

It is IMPLEMENTATION DEFINED whether data-processing operations due to instructions with a single Governing predicate operand that determines the Active elements which do not write to any SVE Z vector destination registers using either zeroing or merging predication are counted. For example, INCP.

When FEAT\_SPE is implemented, Arm recommends this event is implemented consistently with the PRED field in the SVE data-processing format Operation Type packet.

All speculatively executed SME operations due to instructions with at least one Governing predicate operand that determines the Active elements are counted as predicated SIMD operations.

Note

For outer product instructions which are widening, predication is considered with respect to the input element size.

## 0x8075 , SVE\_PRED\_EMPTY\_SPEC, Operation speculatively executed, SIMD predicated with no active elements

The counter counts each speculatively executed predicated SIMD operation counted by SVE\_PRED\_NOT\_FULL\_SPEC where all elements are Inactive.

That is, all elements in the Governing predicate or predicates are FALSE.

When FEAT\_SME is implemented, both SVE and SME operations with at least one Governing predicate operand are counted.

Note

For outer product instructions which are widening, predication is considered with respect to the input element size.

## 0x8076 , SVE\_PRED\_FULL\_SPEC, Operation speculatively executed, SIMD predicated with all active elements

The counter counts each speculatively executed predicated SIMD operation counted by SVE\_PRED\_SPEC where all elements are Active.

That is, all elements in the Governing predicate or predicates are all TRUE.

When FEAT\_SME is implemented, both SVE and SME operations with at least one Governing predicate operand are counted.

Note

For outer product instructions which are widening, predication is considered with respect to the input element size.

## 0x8077 , SVE\_PRED\_PARTIAL\_SPEC, Operation speculatively executed, SIMD predicated with partially active elements

The counter counts each speculatively executed predicated SIMD operation counted by SVE\_PRED\_NOT\_FULL\_SPEC where neither all elements are Active nor all elements are Inactive.

That is, all elements in the Governing predicate or predicates are neither all TRUE nor all FALSE.

When FEAT\_SME is implemented, both SVE and SME operations with at least one Governing predicate operand are counted.

Note

For outer product instructions which are widening, predication is considered with respect to the input element size.

## 0x8078 , SVE\_UNPRED\_SPEC, Operation speculatively executed, SVE unpredicated

The counter counts each speculatively executed SIMD operation due to any of:

- An SVE instruction without a Governing predicate operand.
- An SME instruction without any Governing predicate operand.

If FEAT\_SME is implemented, both operations due to SVE instructions and operations due to SME instructions with at least one Governing predicate operand that determines the Active elements are counted.

## 0x8079 , SVE\_PRED\_NOT\_FULL\_SPEC, Operation speculatively executed, SVE predicated with at least one inactive element

The counter counts each speculatively executed predicated SIMD data-processing, load, or store operation counted by SVE\_PRED\_SPEC where at least one element is Inactive.

That is, at least one element in the Governing predicate or predicates is FALSE.

When FEAT\_SME is implemented, both SVE and SME operations with at least one Governing predicate operand are counted.

Note

For outer product instructions which are widening, predication is considered with respect to the input element size.

## 0x807C , SVE\_MOVPRFX\_SPEC, Operation speculatively executed, SVE MOVPRFX

The counter counts each speculatively executed operation due to any of the following instructions:

- SVE: MOVPRFX.

The instruction is counted whether or not it is fused with the prefixed instruction.

## 0x807D , SVE\_MOVPRFX\_Z\_SPEC, Operation speculatively executed, SVE MOVPRFX zeroing predication

The counter counts each speculatively executed operation counted by SVE\_MOVPRFX\_SPEC where the operation uses zeroing predication.

## 0x807E , SVE\_MOVPRFX\_M\_SPEC, Operation speculatively executed, SVE MOVPRFX merging predication

The counter counts each speculatively executed operation counted by SVE\_MOVPRFX\_SPEC where the operation uses merging predication.

## 0x807F , SVE\_MOVPRFX\_U\_SPEC, Operation speculatively executed, SVE MOVPRFX unfused

The counter counts each speculatively executed operation counted by SVE\_MOVPRFX\_SPEC where the MOVPRFX is not fused with the prefixed instruction.

## 0x8080 , SVE\_LDST\_SPEC, Operation speculatively executed, SVE load, store, or prefetch

The counter counts each speculatively executed operation that reads from or writes to memory counted by ASE\_SVE\_LDST\_SPEC due to an SVE load, store, or prefetch instruction.

The following are classified as SVE load, store and prefetch instructions:

- Any load which reads from an SVE register.
- Any store which writes to an SVE register.
- Any of the following prefetch instructions which accept a Governing predicate:
- PRFB .
- PRFD .
- PRFH .
- PRFW .

When FEAT\_SME is implemented, this includes SME loads and stores of the SVE Z vectors. SME loads and stores of the ZA and ZT registers are not counted.

## 0x8081 , SVE\_LD\_SPEC, Operation speculatively executed, SVE load

The counter counts each speculatively executed operation that reads from memory counted by SVE\_LDST\_SPEC due to an SVE load instruction.

## 0x8082 , SVE\_ST\_SPEC, Operation speculatively executed, SVE store

The counter counts each speculatively executed operation that writes to memory counted by SVE\_LDST\_SPEC due to an SVE store instruction.

## 0x8083 , SVE\_PRF\_SPEC, Operation speculatively executed, SVE prefetch

The counter counts each speculatively executed prefetch operation counted by SVE\_LDST\_SPEC due to any of the following instructions:

- SVE: PRFB, PRFD, PRFH, or PRFW.

## 0x8084 , ASE\_SVE\_LDST\_SPEC, Operation speculatively executed, Advanced SIMD or SVE load or store

The counter counts each speculatively executed operation that reads from or writes to memory due to an A64 Advanced SIMD or SVE load, store, or prefetch instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD load or store operations are counted in AArch32 state.

## 0x8085 , ASE\_SVE\_LD\_SPEC, Operation speculatively executed, Advanced SIMD or SVE load

The counter counts each speculatively executed operation that reads from memory counted by ASE\_SVE\_LDST\_SPEC due to an A64 Advanced SIMD or SVE load instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD load operations are counted in AArch32 state.

## 0x8086 , ASE\_SVE\_ST\_SPEC, Operation speculatively executed, Advanced SIMD or SVE store

The counter counts each speculatively executed operation that writes to memory counted by ASE\_SVE\_LDST\_SPEC due to an A64 Advanced SIMD or SVE store instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD store operations are counted in AArch32 state.

## 0x8087 , PRF\_SPEC, Operation speculatively executed, prefetch

The counter counts each speculatively executed prefetch operation due to any of the following A64 instructions:

- Scalar: PRFM, PRFUM, or RPRFM.
- SVE: PRFB, PRFD, PRFH, or PRFW.

It is IMPLEMENTATION DEFINED which prefetch operations are counted in AArch32 state.

## 0x8088 , BASE\_LDST\_REG\_SPEC, Operation speculatively executed, general-purpose register load, store, or prefetch

The counter counts each speculatively executed operation that reads from or writes to memory due to a general-purpose register load, store, or prefetch instruction.

It is IMPLEMENTATION DEFINED which load, store, and prefetch operations are counted in AArch32 state.

## 0x8089 , BASE\_LD\_REG\_SPEC, Operation speculatively executed, general-purpose register load

The counter counts each speculatively executed operation that reads from memory counted by BASE\_LDST\_REG\_SPEC due to a general-purpose register load instruction.

It is IMPLEMENTATION DEFINED which load operations are counted in AArch32 state.

## 0x808A , BASE\_ST\_REG\_SPEC, Operation speculatively executed, general-purpose register store

The counter counts each speculatively executed operation that writes to memory counted by BASE\_LDST\_REG\_SPEC due to a general-purpose register store instruction.

It is IMPLEMENTATION DEFINED whether the counter counts operations due to DC ZVA instructions.

It is IMPLEMENTATION DEFINED which store operations are counted in AArch32 state.

## 0x808B , BASE\_PRF\_SPEC, Operation speculatively executed, general-purpose register prefetch

The counter counts each speculatively executed prefetch operation counted by BASE\_LDST\_REG\_SPEC due to any of the following A64 instructions:

- Scalar: PRFM, PRFUM, or RPRFM.

It is IMPLEMENTATION DEFINED which prefetch operations are counted in AArch32 state.

## 0x808C , FPASE\_LDST\_REG\_SPEC, Operation speculatively executed, SIMD&amp;FP register load or store

The counter counts each speculatively executed operation that reads from or writes to memory due to any of the following A64 instructions:

- Scalar: LDP (SIMD&amp;FP), LDR (SIMD&amp;FP), STP (SIMD&amp;FP), or STR (SIMD&amp;FP).
- Advanced SIMD: LD1, LD1R, LDNP, LDP, LDR, LDUR, ST1, STNP, STP, STR, or STUR.
- When FEAT\_LRCPC3 is implemented, Advanced SIMD: LDAP1, LDAPUR, STL1, or STLUR.

It is IMPLEMENTATION DEFINED which load and store operations are counted in AArch32 state.

## 0x808D , FPASE\_LD\_REG\_SPEC, Operation speculatively executed, SIMD&amp;FP register load

The counter counts each speculatively executed operation that reads from memory counted by FPASE\_LDST\_REG\_SPEC due to any of the following A64 instructions:

- Scalar: LDP (SIMD&amp;FP) or LDR (SIMD&amp;FP).
- Advanced SIMD: LD1, LD1R, LDNP, LDP, LDR, or LDUR.
- When FEAT\_LRCPC3 is implemented, Advanced SIMD: LDAP1 or LDAPUR.

It is IMPLEMENTATION DEFINED which load operations are counted in AArch32 state.

## 0x808E , FPASE\_ST\_REG\_SPEC, Operation speculatively executed, SIMD&amp;FP register store

The counter counts each speculatively executed operation that writes to memory counted by FPASE\_LDST\_REG\_SPEC due to any of the following A64 instructions:

- Scalar: STP (SIMD&amp;FP) or STR (SIMD&amp;FP).
- Advanced SIMD: ST1, STNP, STP, STR, or STUR.
- When FEAT\_LRCPC3 is implemented, Advanced SIMD: STL1 or STLUR.

It is IMPLEMENTATION DEFINED which store operations are counted in AArch32 state.

## 0x8090 , SVE\_LDST\_REG\_SPEC, Operation speculatively executed, SVE unpredicated load or store register

The counter counts each speculatively executed SVE register load or store operation due to any of the following instructions:

- SVE: LDR or STR.

## 0x8091 , SVE\_LDR\_REG\_SPEC, Operation speculatively executed, SVE unpredicated load register

The counter counts each speculatively executed operation that reads from memory counted by SVE\_LDST\_REG\_SPEC due to any of the following instructions:

- SVE: LDR.

## 0x8092 , SVE\_STR\_REG\_SPEC, Operation speculatively executed, SVE unpredicated store register

The counter counts each speculatively executed operation that writes to memory counted by SVE\_LDST\_REG\_SPEC due to any of the following instructions:

- SVE: STR.

## 0x8094 , SVE\_LDST\_PREG\_SPEC, Operation speculatively executed, SVE load or store predicate register

The counter counts each speculatively executed SVE predicate register load or store operation due to any of the following instructions:

- SVE: LDR (predicate) or STR (predicate).

## 0x8095 , SVE\_LDR\_PREG\_SPEC, Operation speculatively executed, SVE load predicate register

The counter counts each speculatively executed operation that reads from memory counted by SVE\_LDST\_PREG\_SPEC due to any of the following instructions:

- SVE: LDR (predicate).

## 0x8096 , SVE\_STR\_PREG\_SPEC, Operation speculatively executed, SVE store predicate register

The counter counts each speculatively executed operation that writes to memory counted by SVE\_LDST\_PREG\_SPEC due to any of the following instructions:

- SVE: STR (predicate).

## 0x8098 , SVE\_LDST\_ZREG\_SPEC, Operation speculatively executed, SVE load or store vector register

The counter counts each speculatively executed SVE vector register load or store operation due to any of the following instructions:

- SVE: LDR (vector) or STR (vector).

## 0x8099 , SVE\_LDR\_ZREG\_SPEC, Operation speculatively executed, SVE load vector register

The counter counts each speculatively executed operation that reads from memory counted by SVE\_LDST\_ZREG\_SPEC due to any of the following instructions:

- SVE: LDR (vector).

## 0x809A , SVE\_STR\_ZREG\_SPEC, Operation speculatively executed, SVE store vector register

The counter counts each speculatively executed operation that writes to memory counted by SVE\_LDST\_ZREG\_SPEC due to any of the following instructions:

- SVE: STR (vector).

## 0x809C , SVE\_LDST\_CONTIG\_SPEC,Operation speculatively executed, SVE contiguous load, store, or prefetch element

The counter counts each speculatively executed SVE predictated single vector contiguous element load, store, or prefetch operation due to any of:

- Apredicated single vector contiguous load or store instruction operating on the SVE registers.
- An SVE load and replicate LD1R or LD1RQ instruction.

When FEAT\_SME is implemented, this includes the following instructions:

- SME: LD1B , LD1D , LD1H , LD1Q , LD1W , LDNT1B , LDNT1D , LDNT1H , LDNT1Q , ST1B , ST1D , ST1H , ST1Q , ST1W , STNT1B , STNT1D , or STNT1H .

## 0x809D , SVE\_LD\_CONTIG\_SPEC, Operation speculatively executed, SVE single vector contiguous load element

The counter counts each speculatively executed operation that reads from memory counted by SVE\_LDST\_CONTIG\_SPEC due to any of:

- Apredicated single vector contiguous load instruction operating on the SVE registers.
- An SVE load and replicate LD1R or LD1RQ instruction.

When FEAT\_SME is implemented, this includes the following instructions:

- SME: LD1B , LD1D , LD1H , LD1Q , LD1W , LDNT1B , LDNT1D , or LDNT1H .

## 0x809E , SVE\_ST\_CONTIG\_SPEC, Operation speculatively executed, SVE contiguous store element

The counter counts each speculatively executed operation that writes to memory counted by SVE\_LDST\_CONTIG\_SPEC due to any of:

- Apredicated single vector contiguous store instruction operating on the SVE registers.

When FEAT\_SME is implemented, this includes the following instructions:

- SME: ST1B , ST1D , ST1H , ST1Q , ST1W , STNT1B , STNT1D , STNT1H , and STNT1Q .

## 0x809F , SVE\_PRF\_CONTIG\_SPEC, Operation speculatively executed, SVE contiguous prefetch element

The counter counts each speculatively executed operation counted by SVE\_LDST\_CONTIG\_SPEC due to an SVE predicated single contiguous element prefetch instruction.

## 0x80A0 , SVE\_LDSTNT\_CONTIG\_SPEC, Operation speculatively executed, SVE non-temporal contiguous load or store element

The counter counts each speculatively executed SVE non-temporal contiguous element load or store operation.

## 0x80A1 , SVE\_LDNT\_CONTIG\_SPEC, Operation speculatively executed, SVE non-temporal contiguous load element

The counter counts each speculatively executed operation that reads from memory with a non-temporal hint counted by SVE\_LDSTNT\_CONTIG\_SPEC due to an SVE non-temporal contiguous element load instruction.

When FEAT\_SME is implemented, this includes operations due to SME non-temporal contiguous element load instructions operating on the SVE registers.

## 0x80A2 , SVE\_STNT\_CONTIG\_SPEC, Operation speculatively executed, SVE non-temporal contiguous store element

The counter counts each speculatively executed operation that writes to memory with a non-temporal hint counted by SVE\_LDSTNT\_CONTIG\_SPEC due to an SVE non-temporal contiguous element store instruction.

When FEAT\_SME is implemented, this includes operations due to SME non-temporal contiguous element store instructions operating on the SVE registers.

## 0x80A4 , ASE\_SVE\_LDST\_MULTI\_SPEC, Operation speculatively executed, Advanced SIMD or SVE contiguous load or store multiple vector

The counter counts each speculatively executed operation due to an A64 Advanced SIMD or SVE multiple vector contiguous structure load or store instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD contiguous structure load or store operations are counted in AArch32 state.

## 0x80A5 , ASE\_SVE\_LD\_MULTI\_SPEC,Operation speculatively executed, Advanced SIMD or SVE contiguous load multiple vector

The counter counts each speculatively executed operation that reads from memory counted by ASE\_SVE\_LDST\_MULTI\_SPEC due to an A64 Advanced SIMD or SVE multiple vector contiguous structure load instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD contiguous structure load operations are counted in AArch32 state.

## 0x80A6 , ASE\_SVE\_ST\_MULTI\_SPEC, Operation speculatively executed, Advanced SIMD or SVE contiguous store multiple vector

The counter counts each speculatively executed operation that writes to memory counted by ASE\_SVE\_LDST\_MULTI\_SPEC due to an A64 Advanced SIMD or SVE multiple vector contiguous structure store instruction.

It is IMPLEMENTATION DEFINED which Advanced SIMD contiguous structure store operations are counted in AArch32 state.

## 0x80A8 , SVE\_LDST\_MULTI\_SPEC, Operation speculatively executed, SVE contiguous load or store multiple vector

The counter counts each speculatively executed operation that reads from or writes to memory due to an SVE multiple vector contiguous structure load or store instruction.

## 0x80A9 , SVE\_LD\_MULTI\_SPEC, Operation speculatively executed, SVE contiguous load multiple vector

The counter counts each speculatively executed operation that reads from memory counted by SVE\_LDST\_MULTI\_SPEC due to an SVE multiple vector contiguous structure load instruction.

When FEAT\_SME is implemented, this includes operations due to SME multiple vector contiguous load instructions operating on the SVE registers.

## 0x80AA , SVE\_ST\_MULTI\_SPEC, Operation speculatively executed, SVE contiguous store multiple vector

The counter counts each speculatively executed operation that writes to memory counted by SVE\_LDST\_MULTI\_SPEC due to an SVE multiple vector contiguous structure store instruction.

When FEAT\_SME is implemented, this includes operations due to SME multiple vector contiguous store instructions operating on the SVE registers.

## 0x80AC , SVE\_LDST\_NONCONTIG\_SPEC,Operationspeculatively executed, SVE non-contiguous load, store, or prefetch

The counter counts each speculatively executed operation that reads from or writes to memory due to an SVE non-contiguous gather-load, scatter-store, or gather-prefetch instruction.

## 0x80AD , SVE\_LD\_GATHER\_SPEC, Operation speculatively executed, SVE gather-load

The counter counts each speculatively executed operation that reads from memory counted by SVE\_LDST\_NONCONTIG\_SPEC due to an SVE non-contiguous gather-load instruction.

## 0x80AE , SVE\_ST\_SCATTER\_SPEC, Operation speculatively executed, SVE scatter-store

The counter counts each speculatively executed operation that writes to memory counted by SVE\_LDST\_NONCONTIG\_SPEC due to an SVE non-contiguous scatter-store instruction.

## 0x80AF , SVE\_PRF\_GATHER\_SPEC, Operation speculatively executed, SVE gather-prefetch

The counter counts each speculatively executed prefetch operation counted by SVE\_LDST\_NONCONTIG\_SPEC due to an SVE non-contiguous gather-prefetch instruction.

## 0x80B0 , SVE\_LDST64\_NONCONTIG\_SPEC, Operation speculatively executed, SVE 64-bit non-contiguous load, store, or prefetch

The counter counts each speculatively executed operation that reads from or writes to memory due to an SVE non-continguous gather-load, scatter-store, or gather-prefetch operation with 64-bit vector elements in the address.

## 0x80B1 , SVE\_LD64\_GATHER\_SPEC, Operation speculatively executed, SVE 64-bit gather-load

The counter counts each speculatively executed operation that reads from memory counted by SVE\_LDST64\_NONCONTIG\_SPEC due to an SVE non-contiguous gather-load instruction with 64-bit vector elements in the address.

## 0x80B2 , SVE\_ST64\_SCATTER\_SPEC, Operation speculatively executed, SVE 64-bit scatter-store

The counter counts each speculatively executed operation that writes to memory counted by SVE\_LDST64\_NONCONTIG\_SPEC due to an SVE non-contiguous scatter-store instruction with 64-bit vector elements in the address.

## 0x80B3 , SVE\_PRF64\_GATHER\_SPEC, Operation speculatively executed, SVE 64-bit gather-prefetch

The counter counts each speculatively executed prefetch operation counted by SVE\_LDST64\_NONCONTIG\_SPEC due to an SVE non-contiguous gather-prefetch instruction with 64-bit vector elements in the address.

## 0x80B4 , ASE\_SVE\_UNALIGNED\_LDST\_SPEC, Advanced SIMD or SVE unaligned access

The counter counts each speculatively executed A64 Advanced SIMD or SVE load or store instruction where either:

- Acontiguous vector address is not aligned to the minimum of the in-memory size of the vector and the cache line size, in bytes.
- Agather, scatter, or single element address is not aligned to the memory element access size, in bytes.

The unaligned access is counted even if it is subsequently converted into multiple aligned accesses.

It is IMPLEMENTATION DEFINED which unaligned Advanced SIMD load or store operations are counted in AArch32 state.

## 0x80B5 , ASE\_SVE\_UNALIGNED\_LD\_SPEC, Advanced SIMD or SVE unaligned read

The counter counts each unaligned memory access counted by ASE\_SVE\_UNALIGNED\_LDST\_SPEC due to an A64 Advanced SIMD or SVE load instruction.

The unaligned access is counted even if it is subsequently converted into multiple aligned accesses.

It is IMPLEMENTATION DEFINED which unaligned Advanced SIMD load operations are counted in AArch32 state.

## 0x80B6 , ASE\_SVE\_UNALIGNED\_ST\_SPEC, Advanced SIMD or SVE unaligned write

The counter counts each unaligned memory access counted by ASE\_SVE\_UNALIGNED\_LDST\_SPEC due to an A64 Advanced SIMD or SVE store instruction.

The unaligned access is counted even if it is subsequently converted into multiple aligned accesses.

It is IMPLEMENTATION DEFINED which unaligned Advanced SIMD store operations are counted in AArch32 state.

## 0x80B8 , ASE\_SVE\_UNALIGNED\_CONTIG\_LDST\_SPEC, Advanced SIMD or SVE unaligned contiguous access

The counter counts each speculatively executed Advanced SIMD or SVE contiguous load or store operation where the address is not aligned to the minimum of the in-memory size of the vector and the cache line size, in bytes.

The unaligned access is counted even if it is subsequently converted into multiple aligned accesses.

It is IMPLEMENTATION DEFINED which unaligned contiguous Advanced SIMD load or store operations are counted in AArch32 state.

## 0x80B9 , ASE\_SVE\_UNALIGNED\_CONTIG\_LD\_SPEC, Advanced SIMD or SVE unaligned contiguous read

The counter counts each unaligned memory access counted by ASE\_SVE\_UNALIGNED\_CONTIG\_LDST\_SPEC due to an A64 Advanced SIMD or SVE load instruction.

The unaligned access is counted even if it is subsequently converted into multiple aligned accesses.

It is IMPLEMENTATION DEFINED which unaligned contiguous Advanced SIMD load operations are counted in AArch32 state.

## 0x80BA , ASE\_SVE\_UNALIGNED\_CONTIG\_ST\_SPEC, Advanced SIMD or SVE unaligned contiguous write

The counter counts each unaligned memory access counted by ASE\_SVE\_UNALIGNED\_CONTIG\_LDST\_SPEC due to a A64 Advanced SIMD or SVE store instruction.

The unaligned access is counted even if it is subsequently converted into multiple aligned accesses.

It is IMPLEMENTATION DEFINED which unaligned contiguous Advanced SIMD store operations are counted in AArch32 state.

## 0x80BC , SVE\_LDFF\_SPEC, Operation speculatively executed, SVE first-fault load

The counter counts each speculatively executed Memory-read operation counted by SVE\_LD\_SPEC due to an SVE First-fault or Non-fault load instruction.

## 0x80BD , SVE\_LDFF\_FAULT\_SPEC, Operation speculatively executed, SVE first-fault load which set FFR bit to 0

The counter counts each speculatively executed Memory-read operation counted by SVE\_LDFF\_SPEC due to an SVE First-fault or Non-fault load instruction that writes 0 to at least one bit in FFR.

## 0x80C0 , FP\_SCALE\_OPS\_SPEC, Scalable element arithmetic operations speculatively executed, floating-point

The counter increments by v for each speculatively executed scalable element arithmetic operation, due to an instruction where the type was floating-point.

Where v is a value such that (v × (VL÷128)) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x80C1 , FP\_FIXED\_OPS\_SPEC, Non-scalable element arithmetic operations speculatively executed, floating-point

The counter increments by v for each speculatively executed non-scalable element arithmetic operation, due to an instruction where the type was floating-point.

Where v is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_SCALE\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x80C2 , FP\_HP\_SCALE\_OPS\_SPEC, Scalable element arithmetic operations speculatively executed, largest type is half-precision floating-point

The counter increments by v for each speculatively executed scalable element arithmetic operation, due to an instruction where the largest type was half-precision floating-point.

Where v is a value such that (v × (VL÷128)) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x80C3 , FP\_HP\_FIXED\_OPS\_SPEC, Non-scalable element arithmetic operations speculatively executed, largest type is half-precision floating-point

The counter increments by v for each speculatively executed non-scalable element arithmetic operation, due to an instruction where the largest type was half-precision floating-point.

Where v is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_SCALE\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x80C4 , FP\_SP\_SCALE\_OPS\_SPEC, Scalable element arithmetic operations speculatively executed, largest type is single-precision floating-point

The counter increments by v for each speculatively executed scalable element arithmetic operation, due to an instruction where the largest type was single-precision floating-point.

Where v is a value such that (v × (VL÷128)) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x80C5 , FP\_SP\_FIXED\_OPS\_SPEC, Non-scalable element arithmetic operations speculatively executed, largest type is single-precision floating-point

The counter increments by v for each speculatively executed non-scalable element arithmetic operation, due to an instruction where the largest type was single-precision floating-point.

Where v is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_SCALE\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x80C6 , FP\_DP\_SCALE\_OPS\_SPEC, Scalable element arithmetic operations speculatively executed, largest type is double-precision floating-point

The counter increments by v for each speculatively executed scalable element arithmetic operation, due to an instruction where the largest type was double-precision floating-point.

Where v is a value such that (v × (VL÷128)) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x80C7 , FP\_DP\_FIXED\_OPS\_SPEC, Non-scalable element arithmetic operations speculatively executed, largest type is double-precision floating-point

The counter increments by v for each speculatively executed non-scalable element arithmetic operation, due to an instruction where the largest type was double-precision floating-point.

Where v is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_SCALE\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x80C8 , INT\_SCALE\_OPS\_SPEC, Scalable element arithmetic operations speculatively executed, integer

The counter increments by v for each speculatively executed scalable element arithmetic operation, due to an instruction where the type was integer.

Where v is a value such that (v × (VL÷128)) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x80C9 , INT\_FIXED\_OPS\_SPEC, Non-scalable element arithmetic operations speculatively executed, integer

The counter increments by v for each speculatively executed non-scalable element arithmetic operation, due to an instruction where the type was integer.

Where v is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_SCALE\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x80CA , LDST\_SCALE\_OPS\_SPEC, Scalable load or store element operations speculatively executed

The counter counts each speculatively executed Memory-read operation or Memory-write operation due to any of:

- An SVE vector load or store instruction other than a load and replicate instruction.
- An SME vector load or store instruction.

SVE non-vector load or store instructions and SVE vector load and replicate instructions are counted by the LDST\_FIXED\_OPS\_SPEC event.

See SIMD SVE and SME instructions for information on the counter increment for different types of instruction.

The counter does not count tag loads or tag stores.

## 0x80CB , LDST\_FIXED\_OPS\_SPEC, Non-scalable load or store element operations speculatively executed

The counter counts each speculatively executed Memory-read operation or Memory-write operation due to any of:

- Any load, store, or atomic operation, other than loads and stores of the SVE P and Z registers, and the SME ZA registers.
- Any SVE non-vector load or store operation.
- An SVE load and replicate instruction, including: LD1R , LD1RB , LD1RD , LD1RH , LD1RO , LD1ROB , LD1ROD , LD1ROH , LD1ROW , LD1RQ , LD1RQB , LD1RQD , LD1RQH , LD1RQW , LD1RSB , LD1RSH , or LD1RSW .

For each instruction, the counter is incremented by the number of operations specified by the instruction. For example, the counter counts operations as follows:

- Load and store of a single register instructions, other than SVE and SME vector loads and stores, increment the counter by 1.
- Load and store of a pair of registers instructions, other than SVE and SME vector loads and stores, increment the counter by 2.
- AArch32 load and store multiple registers instructions increment the counter by the number of registers transferred.
- Atomic store instructions increment the counter by 1. These are instructions that atomically update a value in memory without returning a value to a register.
- Atomic load, compare and swap of a single register, and swap instructions increment the counter by 2. Atomic load instructions are instructions that atomically update a value in memory, returning a value to a register.
- Compare and swap of a pair of registers increment the counter by 4.
- SVE and Advanced SIMD LD1R instructions increment the counter by 1.
- SVE LD1RQ instructions increment the counter by (128 ÷ CSIZE).
- SVE LD1RO instructions increment the counter by (256 ÷ CSIZE).
- Advanced SIMD LD[1-4] and ST[1-4] instructions increment the counter by the number of elements transferred per vector multiplied by the number of transferred registers.
- DC ZVA and DC GZVA instructions increment by an IMPLEMENTATION DEFINED amount.
- LDR (table) and STR (table) instructions increment the counter by 1.
- LD64B and ST64B increment the counter by 8.

## Note

When a replicating load instruction loads data of the same size as the vector length, which causes no replication to occur, the instruction is counted.

## 0x80CC , LD\_SCALE\_OPS\_SPEC, Scalable load element operations speculatively executed

The counter counts each speculatively executed Memory-read operation counted by LDST\_SCALE\_OPS\_SPEC due to any of:

- An SVE vector load instruction other than a replicating LD1R , LD1RQ , or LD1RO instruction.
- An SME vector load instruction.

See SIMD SVE and SME instructions for information on the counter increment for different types of instruction.

The counter does not count tag loads.

## 0x80CD , LD\_FIXED\_OPS\_SPEC, Non-scalable load element operations speculatively executed

The counter counts each speculatively executed Memory-read operation counted by LDST\_FIXED\_OPS\_SPEC.

For each instruction, the counter is incremented by the number of operations specified by the instruction. That is, the counter is incremented by:

- Half the value that the LDST\_FIXED\_OPS\_SPEC event counts if the operation is a load atomic, compare and swap, or swap operation.
- The same as for LDST\_FIXED\_OPS\_SPEC if the operation is any other load operation.

## 0x80CE , ST\_SCALE\_OPS\_SPEC, Scalable store element operations speculatively executed

The counter counts each speculatively executed Memory-write operation counted by LDST\_SCALE\_OPS\_SPEC due to any of:

- An SVE predicated vector store instruction.
- An SME vector store instruction.

See SIMD SVE and SME instructions for information on the counter increment for different types of instruction.

The counter does not count tag stores.

## 0x80CF , ST\_FIXED\_OPS\_SPEC, Non-scalable store element operations speculatively executed

The counter counts each Memory-write operation counted by LDST\_FIXED\_OPS\_SPEC.

For each instruction, the counter is incremented by the number of operations specified by the instruction. That is, the counter is incremented by:

- Half the value that the LDST\_FIXED\_OPS\_SPEC event counts if the operation is a store atomic, compare and swap, or swap operation.
- The same as for LDST\_FIXED\_OPS\_SPEC if the operation is any other store operation.

## 0x80D0 , FP\_SCALE2\_OPS\_SPEC, Scalable tile arithmetic operations speculatively executed, floating-point

The counter increments by v for each speculatively executed scalable tile arithmetic operation, due to an instruction where the type was floating-point.

Where v is a value such that (v × (VL÷128)²) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE\_OPS\_SPEC.

## 0x80D2 , FP\_HP\_SCALE2\_OPS\_SPEC, Scalable tile arithmetic operations speculatively executed, largest type is halfprecision floating-point

The counter increments by v for each speculatively executed scalable tile arithmetic operation, due to an instruction where the largest type was half-precision floating-point.

Where v is a value such that (v × (VL÷128)²) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE\_OPS\_SPEC.

## 0x80D3 , FP\_BF16\_SCALE2\_OPS\_SPEC, Scalable tile arithmetic operations speculatively executed, largest type is BFloat16 floating-point

The counter increments by v for each speculatively executed scalable tile arithmetic operation, due to an instruction where the largest type was BFloat16 floating-point.

Where v is a value such that (v × (VL÷128)²) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE\_OPS\_SPEC.

## 0x80D4 , FP\_SP\_SCALE2\_OPS\_SPEC, Scalable tile arithmetic operations speculatively executed, largest type is singleprecision floating-point

The counter increments by v for each speculatively executed scalable tile arithmetic operation, due to an instruction where the largest type was single-precision floating-point.

Where v is a value such that (v × (VL÷128)²) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE\_OPS\_SPEC.

## 0x80D6 , FP\_DP\_SCALE2\_OPS\_SPEC,Scalable tile arithmetic operations speculatively executed, largest type is doubleprecision floating-point

The counter increments by v for each speculatively executed scalable tile arithmetic operation, due to an instruction where the largest type was double-precision floating-point.

Where v is a value such that (v × (VL÷128)²) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE\_OPS\_SPEC.

## 0x80D8 , INT\_SCALE2\_OPS\_SPEC, Scalable tile arithmetic operations speculatively executed, integer

The counter increments by v for each speculatively executed scalable tile arithmetic operation, due to an instruction where the type was integer.

Where v is a value such that (v × (VL÷128)²) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE\_OPS\_SPEC.

## 0x80DA , LDST\_SCALE\_BYTES\_SPEC, Scalable load and store bytes speculatively executed

The counter counts each byte speculatively read or written due to any of:

- An SVE vector load or store instruction other than a load and replicate instruction.
- An SME vector load or store instruction.

For each instruction, the counter is incremented by (16 ÷ (CSIZE ÷ MSIZE)), multiplied by the number of transferred vector registers.

SVE non-vector load or store instructions and SVE vector load and replicate instructions are counted by the LDST\_FIXED\_BYTES\_SPEC event.

## 0x80DB , LDST\_FIXED\_BYTES\_SPEC, Non-scalable load and store bytes speculatively executed

The counter counts each byte speculatively read or written due to any of:

- Any load, store, or atomic operation, other than loads and stores of the SVE P and Z registers, and the SME ZA registers.
- Any SVE non-vector load or store operation.
- An SVE load and replicate instruction, including: LD1R , LD1RB , LD1RD , LD1RH , LD1RO , LD1ROB , LD1ROD , LD1ROH , LD1ROW , LD1RQ , LD1RQB , LD1RQD , LD1RQH , LD1RQW , LD1RSB , LD1RSH , or LD1RSW .

For each instruction, the counter is incremented by the number of bytes transferred per register multiplied by the number of registers transferred multiplied by the number of transfers made per register. For example, the counter counts bytes as follows:

- Load and store of a single register instructions, other than SVE and SME vector loads and stores, increment the counter by (MSIZE ÷ 8).

- Load and store of a pair of registers instructions, other than SVE and SME vector loads and stores, increment the counter by 2 × (MSIZE ÷ 8).
- AArch32 load and store multiple registers instructions increment the counter by the number of registers transferred multiplied by (MSIZE ÷ 8).
- Atomic store instructions increment the counter by (MSIZE ÷ 8). These are instructions that atomically update a value in memory without returning a value to a register.
- Atomic load, compare and swap of a single register, and swap instructions increment the counter by 2 × (MSIZE ÷ 8). Atomic load instructions are instructions that atomically update a value in memory, returning a value to a register.
- Compare and swap of a pair of registers increment the counter by 4 × (MSIZE ÷ 8).
- SVE and Advanced SIMD LD1R instructions increment the counter by (MSIZE ÷ 8).
- SVE LD1RQ instructions increment the counter by 16.
- SVE LD1RO instructions increment the counter by 32.
- Advanced SIMD LD[1-4] and ST[1-4] instructions increment the counter by the number of registers transferred multiplied by the number of bytes being transferred per register.
- DC ZVA and DC GZVA instructions increment by the counter by 2 (DCZID\_EL0.BS) .
- LDR (table) and STR (table) instructions increment the counter by 64.
- LD64B and ST64B increment the counter by 64.

## 0x80DC , LD\_SCALE\_BYTES\_SPEC, Scalable load bytes speculatively executed

The counter counts each speculatively read byte due to any of:

- An SVE vector load instruction other than a replicating LD1R , LD1RQ , or LD1RO instruction.
- An SME vector load instruction.

For each instruction, the counter is incremented by (16 ÷ (CSIZE ÷ MSIZE)), multiplied by the number of transferred vector registers.

## 0x80DD , LD\_FIXED\_BYTES\_SPEC, Non-scalable load bytes speculatively executed

The counter counts each speculatively read byte counted by LDST\_FIXED\_BYTES\_SPEC.

For each instruction, the counter is incremented by the number of bytes transferred per register multiplied by the number of registers transferred. That is, the counter is incremented by:

- Half the value that the LDST\_FIXED\_BYTES\_SPEC event counts if the operation is a load atomic, compare and swap, or swap operation.
- The same as for LDST\_FIXED\_BYTES\_SPEC if the operation is any other load operation.

## 0x80DE , ST\_SCALE\_BYTES\_SPEC, Scalable store bytes speculatively executed

The counter counts each speculatively written byte due to any of:

- An SVE vector store instruction.
- An SME vector store instruction.

For each instruction, the counter is incremented by (16 ÷ (CSIZE ÷ MSIZE)), multiplied by the number of transferred vector registers.

## 0x80DF , ST\_FIXED\_BYTES\_SPEC, Non-scalable store bytes speculatively executed

The counter counts each speculatively written byte counted by LDST\_FIXED\_BYTES\_SPEC.

For each instruction, the counter is incremented by the number of bytes transferred per register multiplied by the number of registers transferred. That is, the counter is incremented by:

- Half the value that the LDST\_FIXED\_BYTES\_SPEC event counts if the operation is a swap, or compare and swap operation.

- The same as for LDST\_FIXED\_BYTES\_SPEC if the operation is any other store operation, including an atomic store operation.

## 0x80E1 , ASE\_INT8\_SPEC, Integer operation speculatively executed, Advanced SIMD 8-bit

The counter counts each operation counted by ASE\_SVE\_INT8\_SPEC that is an Advanced SIMD operation.

## 0x80E2 , SVE\_INT8\_SPEC, Integer operation speculatively executed, SVE 8-bit

The counter counts each operation counted by ASE\_SVE\_INT8\_SPEC that is an SVE operation.

## 0x80E3 , ASE\_SVE\_INT8\_SPEC, Integer operation speculatively executed, Advanced SIMD or SVE 8-bit

The counter counts each operation counted by ASE\_SVE\_INT\_SPEC where the largest type is 8-bit integer.

## 0x80E5 , ASE\_INT16\_SPEC, Integer operation speculatively executed, Advanced SIMD 16-bit

The counter counts each operation counted by ASE\_SVE\_INT16\_SPEC that is an Advanced SIMD operation.

## 0x80E6 , SVE\_INT16\_SPEC, Integer operation speculatively executed, SVE 16-bit

The counter counts each operation counted by ASE\_SVE\_INT16\_SPEC that is an SVE operation.

## 0x80E7 , ASE\_SVE\_INT16\_SPEC, Integer operation speculatively executed, Advanced SIMD or SVE 16-bit

The counter counts each operation counted by ASE\_SVE\_INT\_SPEC where the largest type is 16-bit integer.

## 0x80E8 , FP\_BF16\_SCALE\_OPS\_SPEC, Scalable element arithmetic operations speculatively executed, largest type is BFloat16 floating-point

The counter increments by v for each speculatively executed scalable element arithmetic operation, due to an instruction where the largest type was BFloat16 floating-point.

Where v is a value such that (v × (VL÷128)) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x80E9 , ASE\_INT32\_SPEC, Integer operation speculatively executed, Advanced SIMD 32-bit

The counter counts each operation counted by ASE\_SVE\_INT32\_SPEC that is an Advanced SIMD operation.

## 0x80EA , SVE\_INT32\_SPEC, Integer operation speculatively executed, SVE 32-bit

The counter counts each operation counted by ASE\_SVE\_INT32\_SPEC that is an SVE operation.

## 0x80EB , ASE\_SVE\_INT32\_SPEC, Integer operation speculatively executed, Advanced SIMD or SVE 32-bit

The counter counts each operation counted by ASE\_SVE\_INT\_SPEC where the largest type is 32-bit integer.

## 0x80ED , ASE\_INT64\_SPEC, Integer operation speculatively executed, Advanced SIMD 64-bit

The counter counts each operation counted by ASE\_SVE\_INT64\_SPEC that is an Advanced SIMD operation.

## 0x80EE , SVE\_INT64\_SPEC, Integer operation speculatively executed, SVE 64-bit

The counter counts each operation counted by ASE\_SVE\_INT64\_SPEC that is an SVE operation.

## 0x80EF , ASE\_SVE\_INT64\_SPEC, Integer operation speculatively executed, Advanced SIMD or SVE 64-bit

The counter counts each operation counted by ASE\_SVE\_INT\_SPEC where the largest type is 64-bit integer.

## 0x80F1 , ASE\_FP\_DOT\_SPEC, Floating-point operation speculatively executed, Advanced SIMD dot-product

The counter counts each dot-product operation counted by ASE\_SVE\_FP\_DOT\_SPEC due to any of the following A64 instructions:

- When FEAT\_BF16 is implemented, Advanced SIMD: BFDOT.
- When FEAT\_FP8DOT2 is implemented, Advanced SIMD: FDOT (2-way, by element) or FDOT (2-way, vector).
- When FEAT\_FP8DOT4 is implemented, Advanced SIMD: FDOT (4-way, by element) or FDOT (4-way, vector).

It is IMPLEMENTATION DEFINED which dot-product operations are counted in AArch32 state.

## 0x80F2 , SVE\_FP\_DOT\_SPEC, Floating-point operation speculatively executed, SVE dot-product

The counter counts each dot-product operation counted by ASE\_SVE\_FP\_DOT\_SPEC due to any of the following instructions:

- SVE: BFDOT.

- SVE2: FDOT.

## 0x80F3 , ASE\_SVE\_FP\_DOT\_SPEC,Floating-point operation speculatively executed, Advanced SIMD or SVE dot-product

The counter counts each dot-product operation counted by FP\_SPEC due to any of the following A64 instructions:

- When FEAT\_BF16 is implemented, Advanced SIMD: BFDOT.
- When FEAT\_FP8DOT2 is implemented, Advanced SIMD: FDOT (2-way, by element) or FDOT (2-way, vector).
- When FEAT\_FP8DOT4 is implemented, Advanced SIMD: FDOT (4-way, by element) or FDOT (4-way, vector).
- SVE: BFDOT.
- SVE2: FDOT.

It is IMPLEMENTATION DEFINED which dot-product operations are counted in AArch32 state.

## 0x80F5 , ASE\_FP\_MMLA\_SPEC, Floating-point operation speculatively executed, Advanced SIMD matrix multiply

The counter counts each floating-point matrix multiply operation counted by ASE\_SVE\_FP\_MMLA\_SPEC due to any of the following A64 instructions:

- When FEAT\_BF16 is implemented, Advanced SIMD: BFMMLA.
- When FEAT\_F8F16MM is implemented, Advanced SIMD: FMMLA (8-bit floating-point to half-precision) or FMMLA(8-bit floating-point to single-precision).

It is IMPLEMENTATION DEFINED which floating-point matrix multiply operations are counted in AArch32 state.

## 0x80F6 , SVE\_FP\_MMLA\_SPEC, Floating-point operation speculatively executed, SVE matrix multiply

The counter counts each floating-point matrix multiply operation counted by ASE\_SVE\_FP\_MMLA\_SPEC due to any of the following instructions:

- SVE: BFMMLA (widening) or FMMLA (non-widening).
- SVE2: FMMLA.

## 0x80F7 , ASE\_SVE\_FP\_MMLA\_SPEC, Floating-point operation speculatively executed, Advanced SIMD or SVE matrix multiply

The counter counts each floating-point matrix multiply operation counted by FP\_SPEC due to any of the following A64 instructions:

- When FEAT\_BF16 is implemented, Advanced SIMD: BFMMLA.
- When FEAT\_F8F16MM is implemented, Advanced SIMD: FMMLA (8-bit floating-point to half-precision) or FMMLA(8-bit floating-point to single-precision).
- SVE: BFMMLA (widening) or FMMLA (non-widening).
- SVE2: FMMLA.

It is IMPLEMENTATION DEFINED which floating-point matrix multiply operations are counted in AArch32 state.

## 0x80F9 , ASE\_INT\_DOT\_SPEC, Operation speculatively executed, Advanced SIMD integer dot-product

The counter counts each integer dot product operation counted by ASE\_SVE\_INT\_DOT\_SPEC due to any of the following A64 instructions:

- When FEAT\_DotProd is implemented, Advanced SIMD: SDOT or UDOT.
- When FEAT\_I8MM is implemented, Advanced SIMD: SUDOT (by element) or USDOT.

It is IMPLEMENTATION DEFINED which integer dot product operations are counted in AArch32 state.

## 0x80FA , SVE\_INT\_DOT\_SPEC, Integer operation speculatively executed, SVE dot-product

The counter counts each integer dot product operation counted by ASE\_SVE\_INT\_DOT\_SPEC due to any of the following instructions:

- SVE: SDOT, SUDOT, UDOT, or USDOT.
- SVE2: CDOT, SDOT, or UDOT.

## 0x80FB , ASE\_SVE\_INT\_DOT\_SPEC, Integer operation speculatively executed, Advanced SIMD or SVE dot-product

The counter counts each integer dot product operation counted by INT\_SPEC due to any of the following A64 instructions:

- When FEAT\_DotProd is implemented, Advanced SIMD: SDOT or UDOT.
- When FEAT\_I8MM is implemented, Advanced SIMD: SUDOT (by element) or USDOT.
- SVE: SDOT, SUDOT, UDOT, or USDOT.
- SVE2: CDOT, SDOT, or UDOT.

It is IMPLEMENTATION DEFINED which integer dot product operations are counted in AArch32 state.

## 0x80FD , ASE\_INT\_MMLA\_SPEC, Integer operation speculatively executed, Advanced SIMD matrix multiply

The counter counts each integer matrix multiply operation counted by ASE\_SVE\_INT\_MMLA\_SPEC due to any of the following A64 instructions:

- When FEAT\_I8MM is implemented, Advanced SIMD: SMMLA (vector), UMMLA (vector), or USMMLA (vector).

It is IMPLEMENTATION DEFINED which integer matrix multiply operations are counted in AArch32 state.

## 0x80FE , SVE\_INT\_MMLA\_SPEC, Integer operation speculatively executed, SVE matrix multiply

The counter counts each integer matrix multiply operation counted by ASE\_SVE\_INT\_MMLA\_SPEC due to any of the following instructions:

- SVE: SMMLA, UMMLA, or USMMLA.

## 0x80FF , ASE\_SVE\_INT\_MMLA\_SPEC, Integer operation speculatively executed, Advanced SIMD or SVE matrix multiply

The counter counts each integer matrix multiply operation counted by INT\_SPEC due to any of the following A64 instructions:

- When FEAT\_I8MM is implemented, Advanced SIMD: SMMLA (vector), UMMLA (vector), or USMMLA (vector).
- SVE: SMMLA, UMMLA, or USMMLA.

It is IMPLEMENTATION DEFINED which integer matrix multiply operations are counted in AArch32 state.

## 0x8110 , BR\_IMMED\_PRED\_RETIRED, Branch instruction architecturally executed, predicted immediate

The counter counts each instruction counted by both BR\_IMMED\_RETIRED and BR\_PRED\_RETIRED.

These are all direct branch instructions on the architecturally executed path, where the branch is correctly predicted.

## 0x8111 , BR\_IMMED\_MIS\_PRED\_RETIRED, Branch instruction architecturally executed, mispredicted immediate

The counter counts each instruction counted by both BR\_IMMED\_RETIRED and BR\_MIS\_PRED\_RETIRED.

These are all direct branch instructions on the architecturally executed path, where the branch is mispredicted.

## 0x8112 , BR\_IND\_PRED\_RETIRED, Branch instruction architecturally executed, predicted indirect

The counter counts each instruction counted by both BR\_IND\_RETIRED and BR\_PRED\_RETIRED.

These are all indirect branch instructions, including return instructions, on the architecturally executed path, where the branch is correctly predicted.

## 0x8113 , BR\_IND\_MIS\_PRED\_RETIRED, Branch instruction architecturally executed, mispredicted indirect

The counter counts each instruction counted by both BR\_IND\_RETIRED and BR\_MIS\_PRED\_RETIRED.

These are all indirect branch instructions, including return instructions, on the architecturally executed path, where the branch is mispredicted.

## 0x8114 , BR\_RETURN\_PRED\_RETIRED, Branch instruction architecturally executed, predicted procedure return

The counter counts each instruction counted by BR\_IND\_PRED\_RETIRED where if taken, the branch would be counted by BR\_RETURN\_RETIRED.

These are all return instructions on the architecturally executed path, where the branch is correctly predicted.

## 0x8115 , BR\_RETURN\_MIS\_PRED\_RETIRED,Branchinstruction architecturally executed, mispredicted procedure return

The counter counts each instruction counted by BR\_IND\_MIS\_PRED\_RETIRED where if taken, the branch would also be counted by BR\_RETURN\_RETIRED.

These are all return instructions on the architecturally executed path, where the branch is mispredicted.

## 0x8116 , BR\_INDNR\_PRED\_RETIRED,Branchinstruction architecturally executed, predicted indirect excluding procedure return

The counter counts each instruction counted by BR\_IND\_PRED\_RETIRED where if taken, the branch would not be counted by BR\_RETURN\_RETIRED.

These are all indirect branch instructions, excluding return instructions, on the architecturally executed path, where the branch is correctly predicted.

## 0x8117 , BR\_INDNR\_MIS\_PRED\_RETIRED,Branchinstruction architecturally executed, mispredicted indirect excluding procedure return

The counter counts each instruction counted by BR\_IND\_MIS\_PRED\_RETIRED where if taken, the branch would not be counted by BR\_RETURN\_RETIRED.

These are all indirect branch instructions, excluding return instructions, on the architecturally executed path, where the branch is mispredicted.

## 0x8118 , BR\_TAKEN\_PRED\_RETIRED, Branch instruction architecturally executed, predicted branch, taken

The counter counts each instruction counted by both BR\_PRED\_RETIRED and PC\_WRITE\_RETIRED.

These are all branch instructions on the architecturally executed path, where the branch is correctly predicted and taken.

## 0x8119 , BR\_TAKEN\_MIS\_PRED\_RETIRED, Branch instruction architecturally executed, mispredicted branch, taken

The counter counts each instruction counted by both BR\_MIS\_PRED\_RETIRED and PC\_WRITE\_RETIRED.

These are all branch instructions on the architecturally executed path, where the branch is mispredicted and taken.

## 0x811A , BR\_SKIP\_PRED\_RETIRED, Branch instruction architecturally executed, predicted branch, not taken

The counter counts each instruction counted by both BR\_PRED\_RETIRED and BR\_SKIP\_RETIRED.

These are all branch instructions on the architecturally executed path, where the branch is correctly predicted and not taken.

## 0x811B , BR\_SKIP\_MIS\_PRED\_RETIRED, Branch instruction architecturally executed, mispredicted branch, not taken

The counter counts each instruction counted by both BR\_MIS\_PRED\_RETIRED and BR\_SKIP\_RETIRED.

These are all branch instructions on the architecturally executed path, where the branch is mispredicted and not taken.

## 0x811C , BR\_PRED\_RETIRED, Branch instruction architecturally executed, predicted branch

The counter counts each instruction counted by BR\_RETIRED that is not counted by BR\_MIS\_PRED\_RETIRED.

These are all branch instructions on the architecturally executed path, where the branch is correctly predicted.

## 0x8120 , INST\_FETCH\_PERCYC, Instruction fetches in progress

The counter increments by the number of instruction fetches counted by INST\_FETCH in progress on each Processor cycle.

The ratio INST\_FETCH\_PERCYC ÷ INST\_FETCH is the mean duration of instruction fetches in Processor cycles.

## 0x8121 , MEM\_ACCESS\_RD\_PERCYC, Data memory reads in progress

The counter increments by the number of data memory reads counted by MEM\_ACCESS\_RD in progress on each Processor cycle.

The ratio MEM\_ACCESS\_RD\_PERCYC ÷ MEM\_ACCESS\_RD is the mean duration of data memory reads in Processor cycles.

## 0x8122 , SAMPLE\_FEED\_DS, Statistical Profiling sample taken, selected Data Source

The counter counts each SPE sample that is a load operations where PMSDSFR\_EL1[ S ] is 1 and S is bits [5:0] of the sampled Data Source.

The values of PMSFCR\_EL1.FDS are ignored when generating this event.

Samples that are removed by filtering, or discarded, and not written to the Profiling Buffer are counted.

## 0x8123 , SAMPLE\_BUFFER\_FULL, Profiling Buffer full

The counter counts each Profiling Buffer full management event.

## 0x8124 , INST\_FETCH, Instruction memory access

The counter counts each Instruction memory access.

The counter increments whether the access results in an access to a Level 1 instruction cache, a Level 2 instruction, data or unified cache, or none of these.

The counter does not increment as a result of:

- Data memory accesses.
- Translation table walks.
- Refilling of any cache.
- Accesses that result from cache maintenance instructions.

## 0x8125 , BUS\_REQ\_RD\_PERCYC, Bus read transactions in progress

The counter increments by the number of bus read transactions counted by BUS\_REQ\_RD in progress on each Processor cycle.

The ratio BUS\_REQ\_RD\_PERCYC ÷ BUS\_REQ\_RD is the mean duration of bus read transactions in Processor cycles.

Abus read transaction is in progress between the transaction starting and it completing. This includes cycles when the transaction is not occupying the bus.

If the bus is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the bus is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8126 , BUS\_REQ\_WR\_PERCYC, Bus write transactions in progress

The counter increments by the number of bus write transactions counted by BUS\_REQ\_WR in progress on each Processor cycle.

The ratio BUS\_REQ\_WR\_PERCYC ÷ BUS\_REQ\_WR is the mean duration of bus write transactions in Processor cycles.

Abus write transaction is in progress between the transaction starting and it completing. This includes cycles when the transaction is not occupying the bus.

Amean duration value calculated using this event only measures the latency from the perspective of the bus. This is not necessarily the same as the latency for the write to be Complete, as the write might be completed on the bus before reaching its endpoint.

For some bus implementations, writes are posted, meaning that, from the perspective of the bus, the write completes immediately. There is no response when the write reaches its Completion endpoint. This event is not included for such implementations.

If the bus is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the bus is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8127 , PMU\_SNAPSHOT, Successful PMU capture event

The counter counts each PMU snapshot Capture event that was successful, that is, PMSSCR\_EL1.NC is set to 0.

It is CONSTRAINED UNPREDICTABLE whether the counter counts successful Capture events when the PE is in Debug state.

## 0x8128 , DTLB\_WALK\_PERCYC, Data translation table walks in progress

The counter increments by the number of data translation table walks counted by DTLB\_WALK in progress on each Processor cycle.

The ratio DTLB\_WALK\_PERCYC ÷ DTLB\_WALK is the mean duration of data translation table walks in Processor cycles.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8129 , ITLB\_WALK\_PERCYC, Instruction translation table walks in progress

The counter increments by the number of instruction translation table walks counted by ITLB\_WALK in progress on each Processor cycle.

The ratio ITLB\_WALK\_PERCYC ÷ ITLB\_WALK is the mean duration of instruction translation table walks in Processor cycles.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x812A , SAMPLE\_FEED\_BR, Statistical Profiling sample taken, branch

The counter counts each sample counted by SAMPLE\_FEED that is a branch operation.

The values of PMSFCR\_EL1.{B,FT} and, if FEAT\_SPE\_EFT is implemented, PMSFCR\_EL1.Bm, are ignored when generating this event.

Samples that are removed by filtering, or discarded, and not written to the Profiling Buffer are counted.

## 0x812B , SAMPLE\_FEED\_LD, Statistical Profiling sample taken, load

The counter counts each sample counted by SAMPLE\_FEED that is a load or load atomic operation.

The values of PMSFCR\_EL1.{LD,FT} and, if FEAT\_SPE\_EFT is implemented, PMSFCR\_EL1.LDm, are ignored when generating this event.

Samples that are removed by filtering, or discarded, and not written to the Profiling Buffer are counted.

## 0x812C , SAMPLE\_FEED\_ST, Statistical Profiling sample taken, store

The counter counts each sample counted by SAMPLE\_FEED that is a store or atomic operation, including load atomic operations.

The values of PMSFCR\_EL1.{ST,FT} and, if FEAT\_SPE\_EFT is implemented, PMSFCR\_EL1.STm, are ignored when generating this event.

Samples that are removed by filtering, or discarded, and not written to the Profiling Buffer are counted.

## 0x812D , SAMPLE\_FEED\_OP, Statistical Profiling sample taken, matching type

The counter counts each sample counted by SAMPLE\_FEED that meets the sample type filter constraints.

The sample type filter constraints are specified by PMSFCR\_EL1.TYPE and, if FEAT\_SPE\_EFT is implemented, PMSFCR\_EL1.TYPEm.

The value of PMSFCR\_EL1.FT is ignored when generating this event.

No event is generated if the type filter constraint controls are all zero.

Samples that are removed by filtering, or discarded, and not written to the Profiling Buffer are counted.

## 0x812E , SAMPLE\_FEED\_EVENT, Statistical Profiling sample taken, matching events

The counter counts each sample counted by SAMPLE\_FEED that meets the Events packet filter constraints.

That is, each sample with all the events in the filter sets defined by PMSEVFR\_EL1 and, if implemented, PMSNEVFR\_EL1 are counted. The values of PMSFCR\_EL1.{FnE,FE} are ignored when generating this event.

Samples that are removed by filtering, or discarded, and not written to the Profiling Buffer are counted.

## 0x812F , SAMPLE\_FEED\_LAT, Statistical Profiling sample taken, exceeding minimum latency

The counter counts each sample counted by SAMPLE\_FEED that meets the sample latency filter constraints.

That is, each sample with a total latency greater than or equal to the minimum latency defined by PMSLATFR\_EL1.MINLAT are counted. The value of PMSFCR\_EL1.FL is ignored when generating this event.

Samples that are removed by filtering, or discarded, and not written to the Profiling Buffer are counted.

## 0x8130 , L1D\_TLB\_RW, Level 1 data TLB access, demand access

The counter counts each access counted by L1D\_TLB that is due to a demand Memory-read operation or demand Memory-write operation.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

Arm recommends that this event is implemented if event L1D\_TLB\_PRFM is implemented.

## 0x8131 , L1I\_TLB\_RD, Level 1 instruction TLB access, demand access

The counter counts each access counted by L1I\_TLB that is due to a demand Instruction memory access.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

Arm recommends that this event is implemented if event L1I\_TLB\_PRFM is implemented.

## 0x8132 , L1D\_TLB\_PRFM, Level 1 data TLB access, software prefetch

The counter counts each access counted by L1D\_TLB\_PRF that is due to a prefetch instruction.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

Arm recommends that this event is implemented if event L1D\_TLB\_RW is implemented.

## 0x8133 , L1I\_TLB\_PRFM, Level 1 instruction TLB access, software prefetch

The counter counts each access counted by L1I\_TLB\_PRF that is due to a prefetch instruction.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

Arm recommends that this event is implemented if event L1I\_TLB\_RD is implemented.

## 0x8134 , DTLB\_HWUPD, Data TLB hardware update of translation table

The counter counts each access counted by L1D\_TLB that causes a hardware update of a translation table entry.

Each attempted hardware update of a translation table entry is counted once. If the PE requires multiple translation table walk accesses to perform an update, this counts as a single update. If the update fails because it would not be atomic and has to be retried, each retry is counted.

The counter does not count the access if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- The access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8135 , ITLB\_HWUPD, Instruction TLB hardware update of translation table

The counter counts each access counted by L1I\_TLB that causes a hardware update of a translation table entry.

Each attempted hardware update of a translation table entry is counted once. If the PE requires multiple translation table walk accesses to perform an update, this counts as a single update. If the update fails because it would not be atomic and has to be retried, each retry is counted.

The counter does not count the access if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- The access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8136 , DTLB\_STEP, Data TLB translation table walk, step

The counter counts each translation table walk access due to a refill of the data or unified TLB.

The event is Attributable to the access that missed in the TLB and caused the walk, not to the owner of the translation tables being accessed. For example, this means that if an EL0 access causes a translation table walk consisting of accesses to both stage 1 and stage 2 translation tables, all accesses are counted if event counting is allowed at EL0, regardless of whether event counting is allowed at EL1 and/or EL2.

The counter does not count the translation table walk access if any of the following are true:

- The access causing the refill generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- The access causing the refill is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access causing the refill is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the translation table walk access if the access causing the refill generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8137 , ITLB\_STEP, Instruction TLB translation table walk, step

The counter counts each translation table walk access due to a refill of the instruction TLB.

The event is Attributable to the access that missed in the TLB and caused the walk, not to the owner of the translation tables being accessed. For example, this means that if an EL0 access causes a translation table walk consisting of accesses to both stage 1 and stage 2 translation tables, all accesses are counted if event counting is allowed at EL0, regardless of whether event counting is allowed at EL1 and/or EL2.

The counter does not count the translation table walk access if any of the following are true:

- The access causing the refill generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- The access causing the refill is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the translation table walk access if the access causing the refill generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8138 , DTLB\_WALK\_LARGE, Data TLB large page translation table walk

The counter counts each translation table walk counted by DTLB\_WALK where the result of the walk yields a large page size.

The set of large page sizes is the complement of the set of small page sizes defined by the DTLB\_WALK\_SMALL event. For example, these translations might cached by dedicated TLB resources. This set is IMPLEMENTATION DEFINED and might differ between instruction and data TLBs.

The counter does not count the walk if the access generates a Translation fault.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8139 , ITLB\_WALK\_LARGE, Instruction TLB large page translation table walk

The counter counts each translation table walk counted by ITLB\_WALK where the result of the walk yields a large page size.

The set of large page sizes is the complement of the set of small page sizes defined by the ITLB\_WALK\_SMALL event. For example, these translations might cached by dedicated TLB resources. This set is IMPLEMENTATION DEFINED and might differ between instruction and data TLBs.

The counter does not count the walk if the access generates a Translation fault.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x813A , DTLB\_WALK\_SMALL, Data TLB small page translation table walk

The counter counts each translation table walk counted by DTLB\_WALK where the result of the walk yields a small page size.

The set of small page sizes is the complement of the set of large page sizes defined by the DTLB\_WALK\_LARGE event. For example, these translations might cached by dedicated TLB resources. This set is IMPLEMENTATION DEFINED and might differ between instruction and data TLBs.

The counter does not count the walk if the access generates a Translation fault.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x813B , ITLB\_WALK\_SMALL, Instruction TLB small page translation table walk

The counter counts each translation table walk counted by ITLB\_WALK where the result of the walk yields a small page size.

The set of small page sizes is the complement of the set of large page sizes defined by the ITLB\_WALK\_LARGE event. For example, these translations might cached by dedicated TLB resources. This set is IMPLEMENTATION DEFINED and might differ between instruction and data TLBs.

The counter does not count the walk if the access generates a Translation fault.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x813C , DTLB\_WALK\_RW, Data TLB demand access, with at least one translation table walk

The counter counts each demand access counted by L1D\_TLB\_RW that causes a refill or update of a data or unified TLB involving at least one translation table walk access.

The counter does not count the demand access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the demand access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x813D , ITLB\_WALK\_RD, Instruction TLB demand access, with at least one translation table walk

The counter counts each demand access counted by L1I\_TLB\_RD that causes a refill or update of an instruction TLB involving at least one translation table walk access.

The counter does not count the demand access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the demand access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x813E , DTLB\_WALK\_PRFM, Data TLB software prefetch, with at least one translation table walk

The counter counts each software prefetch access counted by L1D\_TLB\_PRFM that causes a refill or update of a data or unified TLB involving at least one translation table walk access.

The counter does not count the software prefetch access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the software prefetch access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x813F , ITLB\_WALK\_PRFM, Instruction TLB software prefetch, with at least one translation table walk

The counter counts each software prefetch access counted by L1I\_TLB\_PRFM that causes a refill or update of an instruction TLB involving at least one translation table walk access.

The counter does not count the software prefetch access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the software prefetch access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8140 , L1D\_CACHE\_RW, Level 1 data cache demand access

The counter counts each access counted by L1D\_CACHE that is due to a demand Memory-read operation or demand Memory-write operation.

This includes accesses made by speculatively executed instructions.

Arm recommends that this event is implemented if any of the following are true:

- Event L1D\_CACHE\_PRFM is implemented.
- Event L1D\_CACHE\_HWPRF is implemented.

## 0x8141 , L1I\_CACHE\_RD, Level 1 instruction cache demand fetch

The counter counts each access counted by L1I\_CACHE that is due to a demand Instruction memory access.

This includes instruction prefetches made by the PE for speculatively executed instructions.

Arm recommends that this event is implemented if any of the following are true:

- Event L1I\_CACHE\_PRFM is implemented.
- Event L1I\_CACHE\_HWPRF is implemented.

## 0x8142 , L1D\_CACHE\_PRFM, Level 1 data cache software prefetch

The counter counts each access counted by L1D\_CACHE\_PRF that is due to a prefetch instruction.

Arm recommends that this event is implemented if event L1D\_CACHE\_RW is implemented.

## 0x8143 , L1I\_CACHE\_PRFM, Level 1 instruction cache software prefetch

The counter counts each access counted by L1I\_CACHE\_PRF that is due to a prefetch instruction.

Arm recommends that this event is implemented if event L1I\_CACHE\_RD is implemented.

## 0x8144 , L1D\_CACHE\_MISS, Level 1 data cache demand access miss

The counter counts each demand access counted by L1D\_CACHE\_RW that misses in the Level 1 data or unified cache, causing an access to outside of the Level 1 caches of this PE.

## 0x8145 , L1I\_CACHE\_HWPRF, Level 1 instruction cache hardware prefetch

The counter counts each access counted by L1I\_CACHE\_PRF that is due to a hardware prefetch.

The hardware prefetch is generated by a hardware prefetcher at the Level 1 instruction or unified cache.

The PE might prefetch instructions as part of instruction pipelining, and might do so for speculatively executed instruction paths. PE instruction prefetching is not counted as hardware prefetching. Unlike PE instruction prefetching, a hardware prefetch only allocates instructions into the cache.

## 0x8146 , L1D\_CACHE\_REFILL\_PRFM, Level 1 data cache refill, software prefetch

The counter counts each access counted by L1D\_CACHE\_PRFM that causes a refill of the Level 1 data or unified cache from outside of the Level 1 data or unified cache.

## 0x8147 , L1I\_CACHE\_REFILL\_PRFM, Level 1 instruction cache refill, software prefetch

The counter counts each access counted by L1I\_CACHE\_PRFM that causes a refill of the Level 1 instruction or unified cache from outside of the Level 1 instruction or unified cache.

## 0x8148 , L2D\_CACHE\_RW, Level 2 data cache demand access

The counter counts each access counted by L2D\_CACHE that is due to a demand Memory-read operation or demand Memory-write operation.

This includes:

- Accesses made by speculatively executed instructions.
- Accesses to the Level 2 data or unified cache due to a refill of another cache caused by a demand Memory-read operation or demand Memory-write operation.

Arm recommends that this event is implemented if any of the following are true:

- Event L2D\_CACHE\_PRFM is implemented.
- Event L2D\_CACHE\_HWPRF is implemented.

## 0x8149 , L2I\_CACHE\_RD, Level 2 instruction cache demand fetch

The counter counts each access counted by L2I\_CACHE that is due to a demand Instruction memory access.

This includes:

- Instruction prefetches made by the PE for speculatively executed instructions.
- Accesses to the Level 2 instruction or unified cache due to a refill of another cache caused by a demand Instruction memory access.

Arm recommends that this event is implemented if any of the following are true:

- Event L2I\_CACHE\_PRFM is implemented.
- Event L2I\_CACHE\_HWPRF is implemented.

## 0x814A , L2D\_CACHE\_PRFM, Level 2 data cache software prefetch

The counter counts each access counted by L2D\_CACHE\_PRF that is due to a prefetch instruction.

This includes accesses to the Level 2 data or unified cache due to a refill of another cache caused by a prefetch instruction.

Arm recommends that this event is implemented if event L2D\_CACHE\_RW is implemented.

## 0x814B , L2I\_CACHE\_PRFM, Level 2 instruction cache software prefetch

The counter counts each access counted by L2I\_CACHE\_PRF that is due to a prefetch instruction.

This includes accesses to the Level 2 instruction or unified cache due to a refill of another cache caused by a prefetch instruction.

Arm recommends that this event is implemented if event L2I\_CACHE\_RD is implemented.

## 0x814C , L2D\_CACHE\_MISS, Level 2 data cache demand access miss

The counter counts each demand access counted by L2D\_CACHE\_RW that misses in the Level 1 and Level 2 data or unified caches, causing an access to outside of the Level 1 and Level 2 caches of this PE.

## 0x814D , L2I\_CACHE\_HWPRF, Level 2 instruction cache hardware prefetch

The counter counts each access counted by L2I\_CACHE\_PRF that is due to a hardware prefetch.

The hardware prefetch is generated by a hardware prefetcher at the Level 2 instruction or unified cache.

## 0x814E , L2D\_CACHE\_REFILL\_PRFM, Level 2 data cache refill, software prefetch

The counter counts each access counted by L2D\_CACHE\_PRFM that causes a refill of the Level 2 data or unified cache, or any Level 1 data, instruction, or unified cache of this PE, from outside of those caches.

## 0x814F , L2I\_CACHE\_REFILL\_PRFM, Level 2 instruction cache refill, software prefetch

The counter counts each access counted by L2I\_CACHE\_PRFM that causes a refill of the Level 2 instruction or unified cache, or any Level 1 data, instruction, or unified cache of this PE, from outside of those caches.

## 0x8150 , L3D\_CACHE\_RW, Level 3 data cache demand access

The counter counts each access counted by L3D\_CACHE that is due to a demand Memory-read operation or demand Memory-write operation.

This includes:

- Accesses made by speculatively executed instructions.
- Accesses to the Level 3 data or unified cache due to a refill of another cache caused by a demand Memory-read operation or demand Memory-write operation.

Arm recommends that this event is implemented if any of the following are true:

- Event L3D\_CACHE\_PRFM is implemented.
- Event L3D\_CACHE\_HWPRF is implemented.

## 0x8151 , L3D\_CACHE\_PRFM, Level 3 data cache software prefetch

The counter counts each access counted by L3D\_CACHE\_PRF that is due to a prefetch instruction.

This includes accesses to the Level 3 data or unified cache due to a refill of another cache caused by a prefetch instruction.

Arm recommends that this event is implemented if event L3D\_CACHE\_RW is implemented.

## 0x8152 , L3D\_CACHE\_MISS, Level 3 data cache demand access miss

The counter counts each demand access counted by L3D\_CACHE\_RW that misses in the Level 1 to Level 3 data or unified caches, causing an access to outside of the Level 1 to Level 3 caches of this PE.

## 0x8153 , L3D\_CACHE\_REFILL\_PRFM, Level 3 data cache refill, software prefetch

The counter counts each access counted by L3D\_CACHE\_PRFM that causes a refill of the Level 3 data or unified cache, or any Level 1 or Level 2 data, instruction, or unified cache of this PE, from outside of those caches.

## 0x8154 , L1D\_CACHE\_HWPRF, Level 1 data cache hardware prefetch

The counter counts each access counted by L1D\_CACHE\_PRF that is due to a hardware prefetch.

The hardware prefetch is generated by a hardware prefetcher at the Level 1 data or unified cache.

## 0x8155 , L2D\_CACHE\_HWPRF, Level 2 data cache hardware prefetch

The counter counts each access counted by L2D\_CACHE\_PRF that is due to a hardware prefetch.

The hardware prefetch is generated by a hardware prefetcher at the Level 2 data or unified cache.

## 0x8156 , L3D\_CACHE\_HWPRF, Level 3 data cache hardware prefetch

The counter counts each access counted by L3D\_CACHE\_PRF that is due to a hardware prefetch.

The hardware prefetch is generated by a hardware prefetcher at the Level 3 data or unified cache.

## 0x8157 , LL\_CACHE\_HWPRF, Last level cache hardware prefetch

The counter counts each access counted by LL\_CACHE\_PRF that is due to a hardware prefetch.

The hardware prefetch is generated by a hardware prefetcher at the Last level cache.

## 0x8158 , STALL\_FRONTEND\_MEMBOUND, Frontend stall cycles, memory bound

The counter counts each cycle counted by STALL\_FRONTEND when no instructions are delivered from the memory system.

The counter counts each stall that occurs when the frontend interface to memory is busy or stalled.

This includes the stalls counted by STALL\_FRONTEND\_L1I, STALL\_FRONTEND\_L2I, STALL\_FRONTEND\_MEM, and STALL\_FRONTEND\_TLB, and any other IMPLEMENTATION DEFINED memory stalls.

It does not include stalls that are counted by STALL\_FRONTEND\_CPUBOUND. However both events will count the same cycle counted by STALL\_FRONTEND if there are both memory and processor-resource stall conditions active.

## 0x8159 , STALL\_FRONTEND\_L1I, Frontend stall cycles, level 1 instruction cache

The counter counts each cycle counted by STALL\_FRONTEND\_MEMBOUND when there is a demand instruction miss in the first level of instruction cache.

The counter does not count the cycle if any of the following are true:

- The STALL\_FRONTEND\_L2I event is implemented and there is a demand instruction miss in the second level of instruction cache, meaning the STALL\_FRONTEND\_L2I event counts the cycle.
- There is a demand instruction miss in the last level of instruction cache within the PE clock domain, meaning the STALL\_FRONTEND\_MEM event counts the cycle.

## 0x815A , STALL\_FRONTEND\_L2I, Frontend stall cycles, level 2 instruction cache

The counter counts each cycle counted by STALL\_FRONTEND\_MEMBOUND when there is a demand instruction miss in the second level of instruction or unified cache.

The counter does not count the cycle if there is a demand instruction miss in the last level of instruction cache within the PE clock domain, meaning the STALL\_FRONTEND\_MEM event counts the cycle.

## 0x815B , STALL\_FRONTEND\_MEM, Frontend stall cycles, last level PE cache or memory

The counter counts each cycle counted by STALL\_FRONTEND\_MEMBOUND when there is a demand instruction miss in the last level of instruction or unified cache within the PE clock domain or a non-cacheable instruction fetch in progress.

## 0x815C , STALL\_FRONTEND\_TLB, Frontend stall cycles, TLB

The counter counts each cycle counted by STALL\_FRONTEND\_MEMBOUND when there is a demand instruction miss in the instruction or unified TLB.

## 0x815D , STALL\_BACKEND\_BUSY\_SMCU, Backend stall cycles, SMCU busy

The counter counts each cycle counted by CPU\_CYCLES when the backend is not able to accept an operation because the SMCU is busy, for any reason.

For example:

- The PE is stalled awaiting allocation of processing resources on an SMCU.
- The PE has been allocated processing resources on an SMCU. However, the SMCU cannot process operations at the rate at which they are issued by the PE in Streaming SVE mode.

## 0x815E , STALL\_BACKEND\_BUSY\_SMCU\_UNALL, Backend stall cycles, awaiting SMCU allocation

The counter counts each cycle counted by STALL\_BACKEND\_BUSY\_SMCU when the backend is stalled awaiting allocation of processing resources on an SMCU.

## 0x8160 , STALL\_FRONTEND\_CPUBOUND, Frontend stall cycles, processor bound

The counter counts each cycle counted by STALL\_FRONTEND when the frontend is stalled on a frontend processor resource, not including memory.

The counter counts each stall that occurs when a frontend processor resource is busy.

This includes the stalls counted by STALL\_FRONTEND\_FLOW, STALL\_FRONTEND\_FLUSH, and STALL\_FRONTEND\_RENAME, and any other IMPLEMENTATION DEFINED processor resource stalls.

It does not include stalls that are counted by STALL\_FRONTEND\_MEMBOUND. However both events will count the same cycle counted by STALL\_FRONTEND if there are both memory and processor-resource stall conditions active.

## 0x8161 , STALL\_FRONTEND\_FLOW, Frontend stall cycles, flow control

The counter counts each cycle counted by STALL\_FRONTEND\_CPUBOUND when the frontend is stalled on unavailability of prediction flow resources.

Note

This event is not counting stalls due to mispredictions, but rather stalls when the frontend is unable to make a prediction.

## 0x8162 , STALL\_FRONTEND\_FLUSH, Frontend stall cycles, flush recovery

The counter counts each cycle counted by STALL\_FRONTEND\_CPUBOUND when the frontend is recovering from a pipeline flush.

The situations where the frontend is flushed are IMPLEMENTATION DEFINED. For example, the frontend might be flushed on a branch misprediction or on a Context synchronization event.

## 0x8163 , STALL\_FRONTEND\_RENAME, Frontend stall cycles, rename full

The counter counts each cycle counted by STALL\_FRONTEND\_CPUBOUND when operations are available from the frontend but at least one is not ready to be sent to the backend because no rename register is available.

If this event is implemented and counts such stalls then the STALL\_BACKEND\_RENAME event counts as zero.

## 0x8164 , STALL\_BACKEND\_MEMBOUND, Backend stall cycles, memory bound

The counter counts each cycle counted by STALL\_BACKEND when the backend is waiting for a memory access to complete.

The counter counts each stall that occurs when the backend interface to memory is busy or stalled.

This includes the stalls counted by: STALL\_BACKEND\_ATOMIC, STALL\_BACKEND\_L1D, STALL\_BACKEND\_L2D, STALL\_BACKEND\_MEM, STALL\_BACKEND\_MEMCPYSET, STALL\_BACKEND\_ST, STALL\_BACKEND\_TLB, and any other IMPLEMENTATION DEFINED memory stall events.

It does not include stalls that are counted by STALL\_BACKEND\_CPUBOUND, although both events might count on the same cycle counted by STALL\_BACKEND if there are both memory and processor-resource stall conditions active.

## 0x8165 , STALL\_BACKEND\_L1D, Backend stall cycles, level 1 data cache

The counter counts each cycle counted by STALL\_BACKEND\_MEMBOUND when there is a demand data miss in the first level of data or unified cache.

The counter does not count the cycle if any of the following are true:

- The STALL\_BACKEND\_L2D event is implemented and there is a demand data miss in the second level of data or unified cache, meaning the STALL\_BACKEND\_L2D event counts the cycle.
- There is a demand data miss in the last level of data or unified cache within the PE clock domain, meaning the STALL\_BACKEND\_MEM event counts the cycle.

## 0x8166 , STALL\_BACKEND\_L2D, Backend stall cycles, level 2 data cache

The counter counts each cycle counted by STALL\_BACKEND\_MEMBOUND when there is a demand data miss in the second level of data or unified cache.

The counter does not count the cycle if there is a demand data miss in the last level of data or unified cache within the PE clock domain, meaning the STALL\_BACKEND\_MEM event counts the cycle.

## 0x8167 , STALL\_BACKEND\_TLB, Backend stall cycles, TLB

The counter counts each cycle counted by STALL\_BACKEND\_MEMBOUND when there is a demand data miss in the data or unified TLB.

## 0x8168 , STALL\_BACKEND\_ST, Backend stall cycles, store

The counter counts each cycle counted by STALL\_BACKEND\_MEMBOUND when the backend is stalled waiting for a store.

## 0x816A , STALL\_BACKEND\_CPUBOUND, Backend stall cycles, processor bound

The counter counts each cycle counted by STALL\_BACKEND when the backend is stalled on a processor resource, not including memory.

The counter counts each stall that occurs when a backend processor resource is busy. This includes the stalls counted by STALL\_BACKEND\_RENAME, and any other IMPLEMENTATION DEFINED processor resource stalls.

It does not include stalls that are counted by STALL\_BACKEND\_MEMBOUND, although both events might count on the same cycle counted by STALL\_BACKEND if there are both memory and processor-resource stall conditions active.

## 0x816B , STALL\_BACKEND\_BUSY, Backend stall cycles, backend busy

The counter counts each cycle counted by STALL\_BACKEND when operations are available from the frontend but the backend is not able to accept an operation because an execution unit is busy.

For example a complex operation unit such as a divider is executing a previous operation and cannot accept a new operation.

## 0x816C , STALL\_BACKEND\_ILOCK, Backend stall cycles, input dependency

The counter counts each cycle counted by STALL\_BACKEND when operations are available from the frontend but at least one is not ready to be sent to the backend because of an input dependency.

## 0x816D , STALL\_BACKEND\_RENAME, Backend stall cycles, rename full

The counter counts each cycle counted by STALL\_BACKEND\_CPUBOUND when operations are available from the frontend but at least one is not ready to be sent to the backend because no rename register is available.

If this event is implemented and counts such stalls then the STALL\_FRONTEND\_RENAME event counts as zero.

## 0x816E , STALL\_BACKEND\_ATOMIC, Backend stall cycles, atomic operation

The counter counts each cycle counted by STALL\_BACKEND\_MEMBOUND when the backend is processing an Atomic operation.

## 0x816F , STALL\_BACKEND\_MEMCPYSET, Backend stall cycles, Memory Copy or Set operation

The counter counts each cycle counted by STALL\_BACKEND\_MEMBOUND when the backend is processing an Memory Copy or Set instruction.

The Memory Copy instructions are CPY and CPYF. The Memory Set instructions are SET and SETG.

## 0x8170 , CAS\_NEAR\_FAIL, Atomic memory Operation speculatively executed, Compare and Swap fail

The counter counts each Compare and Swap operation counted by CAS\_NEAR\_SPEC that does not update the location accessed.

## 0x8171 , CAS\_NEAR\_PASS, Atomic memory Operation speculatively executed, Compare and Swap pass

The counter counts each Compare and Swap operation counted by CAS\_NEAR\_SPEC that updates the location accessed.

## 0x8172 , CAS\_NEAR\_SPEC, Atomic memory Operation speculatively executed, Compare and Swap near

The counter counts each Compare and Swap operation counted by CAS\_SPEC that executes locally to the PE.

The definition of locally is IMPLEMENTATION DEFINED. Operations counted by CAS\_NEAR\_SPEC also generate one of the CAS\_NEAR\_PASS or CAS\_NEAR\_FAIL events.

## 0x8173 , CAS\_FAR\_SPEC, Atomic memory Operation speculatively executed, Compare and Swap far

The counter counts each Compare and Swap operation counted by CAS\_SPEC that does not execute locally to the PE.

The definition of locally is IMPLEMENTATION DEFINED. Operations counted by CAS\_FAR\_SPEC do not generate CAS\_NEAR\_PASS or CAS\_NEAR\_FAIL events.

## 0x8174 , CAS\_SPEC, Atomic memory Operation speculatively executed, Compare and Swap

The counter counts each Compare and Swap operation.

## 0x8175 , LSE\_LD\_SPEC, Atomic memory Operation speculatively executed, load

The counter counts each Atomic memory operation counted by LSE\_LDST\_SPEC that returns a value to the PE, including Swap and Compare-and-Swap operations.

## 0x8176 , LSE\_ST\_SPEC, Atomic memory Operation speculatively executed, store

The counter counts each Atomic memory operation counted by LSE\_LDST\_SPEC that does not return a value to the PE.

## 0x8177 , LSE\_LDST\_SPEC, Atomic memory Operation speculatively executed, load or store

The counter counts each operation counted by LDST\_SPEC that is an Atomic memory operation.

## 0x8178 , REMOTE\_ACCESS\_WR, Access to a remote device, write

The counter counts each access counted by REMOTE\_ACCESS that is a Memory-write operation.

## 0x8184 , BR\_HINT\_COND\_PRED\_RETIRED, Branch instruction architecturally executed, predicted hinted conditional

The counter counts each branch counted by both BR\_HINT\_COND\_RETIRED and BR\_PRED\_RETIRED.

These are all hinted conditional branch instructions on the architecturally executed path, where the branch is correctly predicted.

## 0x8185 , BR\_HINT\_COND\_MIS\_PRED\_RETIRED,Branchinstruction architecturally executed, mispredicted hinted conditional

The counter counts each branch counted by both BR\_HINT\_COND\_RETIRED and BR\_MIS\_PRED\_RETIRED.

These are all hinted conditional branch instructions on the architecturally executed path, where the branch is mispredicted.

## 0x8186 , UOP\_RETIRED, Micro-operation architecturally executed

The counter counts each micro-operation that would be executed in a Simple sequential execution of the program.

Unlike OP\_RETIRED, this event is not linked to the definition of OP\_SPEC, meaning it counts micro-operations that are created from other operations after those operations are counted by OP\_SPEC.

## 0x8188 , DTLB\_WALK\_BLOCK, Data TLB block translation table walk

The counter counts each translation table walk counted by DTLB\_WALK where the result of the walk yields a Block.

That is, the translation table walk ends at a Block descriptor, at other than the last level of translation table.

If two stages of translation are used and Stage 1 and Stage 2 yield different granule sizes, the counter counts the translation table walk only if both are a Block.

The counter does not count the walk if the access generates a Translation fault.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8189 , ITLB\_WALK\_BLOCK, Instruction TLB block translation table walk

The counter counts each translation table walk counted by ITLB\_WALK where the result of the walk yields a Block.

That is, the translation table walk ends at a Page descriptor, at other than the last level of translation table.

If two stages of translation are used and Stage 1 and Stage 2 yield different granule sizes, the counter counts the translation table walk only if both are a Block.

The counter does not count the walk if the access generates a Translation fault.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x818A , DTLB\_WALK\_PAGE, Data TLB page translation table walk

The counter counts each translation table walk counted by DTLB\_WALK where the result of the walk yields a Page.

That is, the translation table walk ends at a Block descriptor, at the last level of translation table.

If two stages of translation are used and Stage 1 and Stage 2 yield different granule sizes, the counter counts the translation table walk only if either is a Page.

The counter does not count the walk if the access generates a Translation fault.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x818B , ITLB\_WALK\_PAGE, Instruction TLB page translation table walk

The counter counts each translation table walk counted by ITLB\_WALK where the result of the walk yields a Page.

That is, the translation table walk ends at a Page descriptor, at the last level of translation table.

If two stages of translation are used and Stage 1 and Stage 2 yield different granule sizes, the counter counts the translation table walk only if either is a Page.

The counter does not count the walk if the access generates a Translation fault.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x818D , BUS\_REQ\_RD, Bus request, read

The counter counts each transaction counted by BUS\_REQ that is a Memory-read operation.

## 0x818E , BUS\_REQ\_WR, Bus request, write

The counter counts each transaction counted by BUS\_REQ that is a Memory-write operation.

## 0x818F , BUS\_REQ, Bus request

The counter counts each request generated by a Memory-read operation or Memory-write operation that accesses outside of the boundary of the PE and its closely-coupled caches.

Where this boundary lies with respect to any implemented caches is IMPLEMENTATION DEFINED. Where an implementation has multiple buses at this boundary, this event counts the sum of requests across all buses.

Abus request is the start of a bus transaction. The exact nature of a bus transaction is IMPLEMENTATION DEFINED, but for the purposes of event monitoring consists of a single access comprising one or more cycles, or beats, when the transaction occupies the bus. The BUS\_REQ event therefore counts the number of transactions. The BUS\_ACCESS event counts the occupancy of the transaction on the bus.

Bus transactions include refills of and write-backs from data, instruction, and unified caches. Whether bus transactions include operations that use the bus but do not explicitly transfer data is IMPLEMENTATION DEFINED. This must be the same for the BUS\_REQ and BUS\_ACCESS events.

An Unattributable bus transaction occurs when a requestor outside the PE makes a request that results in a bus transaction, for example, a coherency request.

The maximum increment in any given cycle is IMPLEMENTATION DEFINED.

If the bus is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the bus is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8190 , ISNP\_HIT\_RD, Snoop hit, demand instruction fetch

The counter counts each snoop generated by the PE in response to a demand Instruction memory access that hits in a cache outside of the cache hierarchy of this PE.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8191 , ISNP\_HIT\_NEAR\_RD, Snoop hit in near local cache, demand instruction fetch

The counter counts each snoop generated by the PE in response to a demand Instruction memory access counted by ISNP\_HIT\_RD that hits in a cache outside of the cache hierarchy of this PE in the local PE cluster.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8192 , ISNP\_HIT\_FAR\_RD, Snoop hit in far local cache, demand instruction fetch

The counter counts each snoop generated by the PE in response to a demand Instruction memory access counted by ISNP\_HIT\_RD that hits in a cache outside the local PE cluster on the same device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8193 , ISNP\_HIT\_REMOTE\_RD, Snoop hit in remote cache, demand instruction fetch

The counter counts each snoop generated by the PE in response to a demand Instruction memory access counted by ISNP\_HIT\_RD that hits in a cache on a remote device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8194 , DSNP\_HIT\_RD, Snoop hit, demand data read

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_RW that hits in a cache outside of the cache hierarchy of this PE.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8195 , DSNP\_HIT\_NEAR\_RD, Snoop hit in near local cache, demand data read

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_RD that hits in a cache outside of the cache hierarchy of this PE in the local PE cluster.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8196 , DSNP\_HIT\_FAR\_RD, Snoop hit in far local cache, demand data read

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_RD that hits in a cache outside the local PE cluster on the same device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8197 , DSNP\_HIT\_REMOTE\_RD, Snoop hit in remote cache, demand data read

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_RD that hits in a cache on a remote device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8198 , DSNP\_HIT\_WR, Snoop hit, demand data write

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_RW that hits in a cache outside of the cache hierarchy of this PE.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8199 , DSNP\_HIT\_NEAR\_WR, Snoop hit in near local cache, demand data write

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_WR that hits in a cache outside of the cache hierarchy of this PE in the local PE cluster.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x819A , DSNP\_HIT\_FAR\_WR, Snoop hit in far local cache, demand data write

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_WR that hits in a cache outside the local PE cluster on the same device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x819B , DSNP\_HIT\_REMOTE\_WR, Snoop hit in remote cache, demand data write

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_WR that hits in a cache on a remote device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x819C , DSNP\_HIT\_RW, Snoop hit, demand data access

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation that hits in a cache outside of the cache hierarchy of this PE.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x819D , DSNP\_HIT\_NEAR\_RW, Snoop hit in near local cache, demand data access

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_RW that hits in a cache outside of the cache hierarchy of this PE in the local PE cluster.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x819E , DSNP\_HIT\_FAR\_RW, Snoop hit in far local cache, demand data access

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_RW that hits in a cache outside the local PE cluster on the same device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x819F , DSNP\_HIT\_REMOTE\_RW, Snoop hit in remote cache, demand data access

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_RW that hits in a cache on a remote device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81A0 , DSNP\_HIT\_PRFM, Snoop hit, software data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction counted by DSNP\_HIT\_PRF that hits in a cache outside of the cache hierarchy of this PE.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81A1 , DSNP\_HIT\_NEAR\_PRFM, Snoop hit in near local cache, software data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction counted by DSNP\_HIT\_PRFM that hits in a cache outside of the cache hierarchy of this PE in the local PE cluster.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81A2 , DSNP\_HIT\_FAR\_PRFM, Snoop hit in far local cache, software data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction counted by DSNP\_HIT\_PRFM that hits in a cache outside the local PE cluster on the same device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81A3 , DSNP\_HIT\_REMOTE\_PRFM, Snoop hit in remote cache, software data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction counted by DSNP\_HIT\_PRFM that hits in a cache on a remote device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81A4 , DSNP\_HIT\_HWPRF, Snoop hit, hardware data prefetch

The counter counts each snoop generated by a data hardware prefetch counted by DSNP\_HIT\_PRF that hits in a cache outside of the cache hierarchy of this PE.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81A5 , DSNP\_HIT\_NEAR\_HWPRF, Snoop hit in near local cache, hardware data prefetch

The counter counts each snoop generated by a data hardware prefetch counted by DSNP\_HIT\_HWPRF that hits in a cache outside of the cache hierarchy of this PE in the local PE cluster.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81A6 , DSNP\_HIT\_FAR\_HWPRF, Snoop hit in far local cache, hardware data prefetch

The counter counts each snoop generated by a data hardware prefetch counted by DSNP\_HIT\_HWPRF that hits in a cache outside the local PE cluster on the same device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81A7 , DSNP\_HIT\_REMOTE\_HWPRF, Snoop hit in remote cache, hardware data prefetch

The counter counts each snoop generated by a data hardware prefetch counted by DSNP\_HIT\_HWPRF that hits in a cache on a remote device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81A8 , ISNP\_HIT\_PRFM, Snoop hit, software instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction counted by ISNP\_HIT\_PRF that hits in a cache outside of the cache hierarchy of this PE.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81A9 , ISNP\_HIT\_NEAR\_PRFM, Snoop hit in near local cache, software instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction counted by ISNP\_HIT\_PRFM that hits in a cache outside of the cache hierarchy of this PE in the local PE cluster.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81AA , ISNP\_HIT\_FAR\_PRFM, Snoop hit in far local cache, software instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction counted by ISNP\_HIT\_PRFM that hits in a cache outside the local PE cluster on the same device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81AB , ISNP\_HIT\_REMOTE\_PRFM, Snoop hit in remote cache, software instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction counted by ISNP\_HIT\_PRFM that hits in a cache on a remote device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81AC , ISNP\_HIT\_HWPRF, Snoop hit, hardware instruction prefetch

The counter counts each snoop generated by an instruction hardware prefetch counted by ISNP\_HIT\_PRF that hits in a cache outside of the cache hierarchy of this PE.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81AD , ISNP\_HIT\_NEAR\_HWPRF, Snoop hit in near local cache, hardware instruction prefetch

The counter counts each snoop generated by an instruction hardware prefetch counted by ISNP\_HIT\_HWPRF that hits in a cache outside of the cache hierarchy of this PE in the local PE cluster.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81AE , ISNP\_HIT\_FAR\_HWPRF, Snoop hit in far local cache, hardware instruction prefetch

The counter counts each snoop generated by an instruction hardware prefetch counted by ISNP\_HIT\_HWPRF that hits in a cache outside the local PE cluster on the same device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81AF , ISNP\_HIT\_REMOTE\_HWPRF, Snoop hit in remote cache, hardware instruction prefetch

The counter counts each snoop generated by an instruction hardware prefetch counted by ISNP\_HIT\_HWPRF that hits in a cache on a remote device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81B0 , ISNP\_HIT, Snoop hit, instruction

The counter counts each snoop that hits in a cache outside of the cache hierarchy of this PE.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81B1 , ISNP\_HIT\_NEAR, Snoop hit in near local cache, instruction access

The counter counts each snoop counted by ISNP\_HIT that hits in a cache outside of the cache hierarchy of this PE in the local PE cluster.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81B2 , ISNP\_HIT\_FAR, Snoop hit in far local cache, instruction access

The counter counts each snoop counted by ISNP\_HIT that hits in a cache outside the local PE cluster on the same device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81B3 , ISNP\_HIT\_REMOTE, Snoop hit in remote cache, instruction access

The counter counts each snoop counted by ISNP\_HIT that hits in a cache on a remote device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81B4 , DSNP\_HIT, Snoop hit, data

The counter counts each snoop that hits in a cache outside of the cache hierarchy of this PE.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81B5 , DSNP\_HIT\_NEAR, Snoop hit in near local cache, data access

The counter counts each snoop counted by DSNP\_HIT that hits in a cache outside of the cache hierarchy of this PE in the local PE cluster.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81B6 , DSNP\_HIT\_FAR, Snoop hit in far local cache, data access

The counter counts each snoop counted by DSNP\_HIT that hits in a cache outside the local PE cluster on the same device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81B7 , DSNP\_HIT\_REMOTE, Snoop hit in remote cache, data access

The counter counts each snoop counted by DSNP\_HIT that hits in a cache on a remote device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x81B8 , L1I\_CACHE\_REFILL\_HWPRF, Level 1 instruction cache refill, hardware prefetch

The counter counts each hardware prefetch counted by L1I\_CACHE\_HWPRF that causes a refill of the Level 1 instruction or unified cache from outside of the Level 1 instruction or unified cache.

## 0x81B9 , L2I\_CACHE\_REFILL\_HWPRF, Level 2 instruction cache refill, hardware prefetch

The counter counts each hardware prefetch counted by L2I\_CACHE\_HWPRF that causes a refill of the Level 2 instruction or unified cache, or any Level 1 data, instruction, or unified cache of this PE, from outside of those caches.

## 0x81BC , L1D\_CACHE\_REFILL\_HWPRF, Level 1 data cache refill, hardware prefetch

The counter counts each hardware prefetch counted by L1D\_CACHE\_HWPRF that causes a refill of the Level 1 data or unified cache from outside of the Level 1 data or unified cache.

## 0x81BD , L2D\_CACHE\_REFILL\_HWPRF, Level 2 data cache refill, hardware prefetch

The counter counts each hardware prefetch counted by L2D\_CACHE\_HWPRF that causes a refill of the Level 2 data or unified cache, or any Level 1 data, instruction, or unified cache of this PE, from outside of those caches.

## 0x81BE , L3D\_CACHE\_REFILL\_HWPRF, Level 3 data cache refill, hardware prefetch

The counter counts each hardware prefetch counted by L3D\_CACHE\_HWPRF that causes a refill of the Level 3 data or unified cache, or any Level 1 or Level 2 data, instruction, or unified cache of this PE, from outside of those caches.

## 0x81BF , LL\_CACHE\_REFILL\_HWPRF, Last level cache refill, hardware prefetch

The counter counts each hardware prefetch counted by LL\_CACHE\_HWPRF that causes a refill of the Last level cache, or any other data, instruction, or unified cache of this PE, from outside of those caches.

## 0x81C0 , L1I\_CACHE\_HIT\_RD, Level 1 instruction cache demand fetch hit

The counter counts each demand fetch counted by L1I\_CACHE\_RD that hits in the Level 1 instruction or unified cache.

## 0x81C1 , L2I\_CACHE\_HIT\_RD, Level 2 instruction cache demand fetch hit

The counter counts each demand fetch counted by L2I\_CACHE\_RD that hits in the Level 2 instruction or unified cache.

## 0x81C4 , L1D\_CACHE\_HIT\_RD, Level 1 data cache demand access hit, read

The counter counts each demand read counted by L1D\_CACHE\_RD that hits in the Level 1 data or unified cache.

## 0x81C5 , L2D\_CACHE\_HIT\_RD, Level 2 data cache demand access hit, read

The counter counts each demand read counted by L2D\_CACHE\_RD that hits in the Level 2 data or unified cache.

## 0x81C6 , L3D\_CACHE\_HIT\_RD, Level 3 data cache demand access hit, read

The counter counts each demand read counted by L3D\_CACHE\_RD that hits in the Level 3 data or unified cache.

## 0x81C7 , LL\_CACHE\_HIT\_RD, Last level cache demand access hit, read

The counter counts each demand read counted by LL\_CACHE\_RD that hits in the Last level cache.

## 0x81C8 , L1D\_CACHE\_HIT\_WR, Level 1 data cache demand access hit, write

The counter counts each demand write counted by L1D\_CACHE\_WR that hits in the Level 1 data or unified cache.

## 0x81C9 , L2D\_CACHE\_HIT\_WR, Level 2 data cache demand access hit, write

The counter counts each demand write counted by L2D\_CACHE\_WR that hits in the Level 2 data or unified cache.

## 0x81CA , L3D\_CACHE\_HIT\_WR, Level 3 data cache demand access hit, write

The counter counts each demand write counted by L3D\_CACHE\_WR that hits in the Level 3 data or unified cache.

## 0x81CB , LL\_CACHE\_HIT\_WR, Last level cache demand access hit, write

The counter counts each demand write counted by LL\_CACHE\_WR that hits in the Last level cache.

## 0x81CC , L1D\_CACHE\_HIT\_RW, Level 1 data cache demand access hit

The counter counts each demand access counted by L1D\_CACHE\_RW that hits in the Level 1 data or unified cache.

## 0x81CD , L2D\_CACHE\_HIT\_RW, Level 2 data cache demand access hit

The counter counts each demand access counted by L2D\_CACHE\_RW that hits in the Level 2 data or unified cache.

## 0x81CE , L3D\_CACHE\_HIT\_RW, Level 3 data cache demand access hit

The counter counts each demand access counted by L3D\_CACHE\_RW that hits in the Level 3 data or unified cache.

## 0x81CF , LL\_CACHE\_HIT\_RW, Last level cache demand access hit

The counter counts each demand access counted by LL\_CACHE\_RW that hits in the Last level cache.

## 0x81D0 , L1I\_CACHE\_HIT\_RD\_FPRFM, Level 1 instruction cache demand fetch first hit, fetched by software prefetch

The counter counts each demand fetch first hit counted by L1I\_CACHE\_HIT\_RD\_FPRF where the cache line was fetched in response to a prefetch instruction.

That is, the L1I\_CACHE\_REFILL\_PRFM event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81D1 , L2I\_CACHE\_HIT\_RD\_FPRFM, Level 2 instruction cache demand fetch first hit, fetched by software prefetch

The counter counts each demand fetch first hit counted by L2I\_CACHE\_HIT\_RD\_FPRF where the cache line was fetched in response to a prefetch instruction.

That is, the L2I\_CACHE\_REFILL\_PRFM event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81D4 , L1D\_CACHE\_HIT\_RD\_FPRFM, Level 1 data cache demand access first hit, read, fetched by software prefetch

The counter counts each first hit counted by L1D\_CACHE\_HIT\_RW\_FPRFM that is due to a demand Memory-read operation.

## 0x81D5 , L2D\_CACHE\_HIT\_RD\_FPRFM, Level 2 data cache demand access first hit, read, fetched by software prefetch

The counter counts each first hit counted by L2D\_CACHE\_HIT\_RW\_FPRFM that is due to a demand Memory-read operation.

## 0x81D6 , L3D\_CACHE\_HIT\_RD\_FPRFM, Level 3 data cache demand access first hit, read, fetched by software prefetch

The counter counts each first hit counted by L3D\_CACHE\_HIT\_RW\_FPRFM that is due to a demand Memory-read operation.

## 0x81D7 , LL\_CACHE\_HIT\_RD\_FPRFM, Last level cache demand access first hit, read, fetched by software prefetch

The counter counts each first hit counted by LL\_CACHE\_HIT\_RW\_FPRFM that is due to a demand Memory-read operation.

## 0x81D8 , L1D\_CACHE\_HIT\_WR\_FPRFM, Level 1 data cache demand access first hit, write, fetched by software prefetch

The counter counts each first hit counted by L1D\_CACHE\_HIT\_RW\_FPRFM that is due to a demand Memory-write operation.

## 0x81D9 , L2D\_CACHE\_HIT\_WR\_FPRFM, Level 2 data cache demand access first hit, write, fetched by software prefetch

The counter counts each first hit counted by L2D\_CACHE\_HIT\_RW\_FPRFM that is due to a demand Memory-write operation.

## 0x81DA , L3D\_CACHE\_HIT\_WR\_FPRFM, Level 3 data cache demand access first hit, write, fetched by software prefetch

The counter counts each first hit counted by L3D\_CACHE\_HIT\_RW\_FPRFM that is due to a demand Memory-write operation.

## 0x81DB , LL\_CACHE\_HIT\_WR\_FPRFM, Last level cache demand access first hit, write, fetched by software prefetch

The counter counts each first hit counted by LL\_CACHE\_HIT\_RW\_FPRFM that is due to a demand Memory-write operation.

## 0x81DC , L1D\_CACHE\_HIT\_RW\_FPRFM, Level 1 data cache demand access first hit, fetched by software prefetch

The counter counts each demand access first hit counted by L1D\_CACHE\_HIT\_RW\_FPRF where the cache line was fetched in response to a prefetch instruction.

That is, the L1D\_CACHE\_REFILL\_PRFM event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81DD , L2D\_CACHE\_HIT\_RW\_FPRFM, Level 2 data cache demand access first hit, fetched by software prefetch

The counter counts each demand access first hit counted by L2D\_CACHE\_HIT\_RW\_FPRF where the cache line was fetched in response to a prefetch instruction.

That is, the L2D\_CACHE\_REFILL\_PRFM event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81DE , L3D\_CACHE\_HIT\_RW\_FPRFM, Level 3 data cache demand access first hit, fetched by software prefetch

The counter counts each demand access first hit counted by L3D\_CACHE\_HIT\_RW\_FPRF where the cache line was fetched in response to a prefetch instruction.

That is, the L3D\_CACHE\_REFILL\_PRFM event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81DF , LL\_CACHE\_HIT\_RW\_FPRFM, Last level cache demand access first hit, fetched by software prefetch

The counter counts each demand access first hit counted by LL\_CACHE\_HIT\_RW\_FPRF where the cache line was fetched in response to a prefetch instruction.

That is, the LL\_CACHE\_REFILL\_PRFM event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81E0 , L1I\_CACHE\_HIT\_RD\_FHWPRF, Level 1 instruction cache demand fetch first hit, fetched by hardware prefetcher

The counter counts each demand fetch first hit counted by L1I\_CACHE\_HIT\_RD\_FPRF where the cache line was fetched by a hardware prefetcher.

That is, the L1I\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81E1 , L2I\_CACHE\_HIT\_RD\_FHWPRF, Level 2 instruction cache demand fetch first hit, fetched by hardware prefetcher

The counter counts each demand fetch first hit counted by L2I\_CACHE\_HIT\_RD\_FPRF where the cache line was fetched by a hardware prefetcher.

That is, the L2I\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81E4 , L1D\_CACHE\_HIT\_RD\_FHWPRF,Level1datacachedemandaccessfirsthit, read, fetched by hardware prefetcher

The counter counts each first hit counted by L1D\_CACHE\_HIT\_RW\_FHWPRF that is due to a demand Memory-read operation.

## 0x81E5 , L2D\_CACHE\_HIT\_RD\_FHWPRF,Level2datacachedemandaccessfirsthit, read, fetched by hardware prefetcher

The counter counts each first hit counted by L2D\_CACHE\_HIT\_RW\_FHWPRF that is due to a demand Memory-read operation.

## 0x81E6 , L3D\_CACHE\_HIT\_RD\_FHWPRF,Level3datacachedemandaccessfirsthit, read, fetched by hardware prefetcher

The counter counts each first hit counted by L3D\_CACHE\_HIT\_RW\_FHWPRF that is due to a demand Memory-read operation.

## 0x81E7 , LL\_CACHE\_HIT\_RD\_FHWPRF, Last level cache demand access first hit, read, fetched by hardware prefetcher

The counter counts each first hit counted by LL\_CACHE\_HIT\_RW\_FHWPRF that is due to a demand Memory-read operation.

## 0x81E8 , L1D\_CACHE\_HIT\_WR\_FHWPRF,Level1datacachedemandaccessfirsthit, write, fetched by hardware prefetcher

The counter counts each first hit counted by L1D\_CACHE\_HIT\_RW\_FHWPRF that is due to a demand Memory-write operation.

## 0x81E9 , L2D\_CACHE\_HIT\_WR\_FHWPRF,Level2datacachedemandaccessfirsthit, write, fetched by hardware prefetcher

The counter counts each first hit counted by L2D\_CACHE\_HIT\_RW\_FHWPRF that is due to a demand Memory-write operation.

## 0x81EA , L3D\_CACHE\_HIT\_WR\_FHWPRF,Level3datacachedemandaccessfirsthit, write, fetched by hardware prefetcher

The counter counts each first hit counted by L3D\_CACHE\_HIT\_RW\_FHWPRF that is due to a demand Memory-write operation.

## 0x81EB , LL\_CACHE\_HIT\_WR\_FHWPRF, Last level cache demand access first hit, write, fetched by hardware prefetcher

The counter counts each first hit counted by LL\_CACHE\_HIT\_RW\_FHWPRF that is due to a demand Memory-write operation.

## 0x81EC , L1D\_CACHE\_HIT\_RW\_FHWPRF, Level 1 data cache demand access first hit, fetched by hardware prefetcher

The counter counts each demand access first hit counted by L1D\_CACHE\_HIT\_RW\_FPRF where the cache line was fetched by a hardware prefetcher.

That is, the L1D\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81ED , L2D\_CACHE\_HIT\_RW\_FHWPRF, Level 2 data cache demand access first hit, fetched by hardware prefetcher

The counter counts each demand access first hit counted by L2D\_CACHE\_HIT\_RW\_FPRF where the cache line was fetched by a hardware prefetcher.

That is, the L2D\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81EE , L3D\_CACHE\_HIT\_RW\_FHWPRF, Level 3 data cache demand access first hit, fetched by hardware prefetcher

The counter counts each demand access first hit counted by L3D\_CACHE\_HIT\_RW\_FPRF where the cache line was fetched by a hardware prefetcher.

That is, the L3D\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81EF , LL\_CACHE\_HIT\_RW\_FHWPRF, Last level cache demand access first hit, fetched by hardware prefetcher

The counter counts each demand access first hit counted by LL\_CACHE\_HIT\_RW\_FPRF where the cache line was fetched by a hardware prefetcher.

That is, the LL\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81F0 , L1I\_CACHE\_HIT\_RD\_FPRF, Level 1 instruction cache demand fetch first hit, fetched by prefetch

The counter counts each demand fetch first hit counted by L1I\_CACHE\_HIT\_RD where the cache line was fetched in response to a prefetch instruction or by a hardware prefetcher.

That is, the L1I\_CACHE\_REFILL\_PRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81F1 , L2I\_CACHE\_HIT\_RD\_FPRF, Level 2 instruction cache demand fetch first hit, fetched by prefetch

The counter counts each demand fetch first hit counted by L2I\_CACHE\_HIT\_RD where the cache line was fetched in response to a prefetch instruction or by a hardware prefetcher.

That is, the L2I\_CACHE\_REFILL\_PRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81F4 , L1D\_CACHE\_HIT\_RD\_FPRF, Level 1 data cache demand access first hit, read, fetched by prefetch

The counter counts each first hit counted by L1D\_CACHE\_HIT\_RW\_FPRF that is due to a demand Memory-read operation.

## 0x81F5 , L2D\_CACHE\_HIT\_RD\_FPRF, Level 2 data cache demand access first hit, read, fetched by prefetch

The counter counts each first hit counted by L2D\_CACHE\_HIT\_RW\_FPRF that is due to a demand Memory-read operation.

## 0x81F6 , L3D\_CACHE\_HIT\_RD\_FPRF, Level 3 data cache demand access first hit, read, fetched by prefetch

The counter counts each first hit counted by L3D\_CACHE\_HIT\_RW\_FPRF that is due to a demand Memory-read operation.

## 0x81F7 , LL\_CACHE\_HIT\_RD\_FPRF, Last level cache demand access first hit, read, fetched by prefetch

The counter counts each first hit counted by LL\_CACHE\_HIT\_RW\_FPRF that is due to a demand Memory-read operation.

## 0x81F8 , L1D\_CACHE\_HIT\_WR\_FPRF, Level 1 data cache demand access first hit, write, fetched by prefetch

The counter counts each first hit counted by L1D\_CACHE\_HIT\_RW\_FPRF that is due to a demand Memory-write operation.

## 0x81F9 , L2D\_CACHE\_HIT\_WR\_FPRF, Level 2 data cache demand access first hit, write, fetched by prefetch

The counter counts each first hit counted by L2D\_CACHE\_HIT\_RW\_FPRF that is due to a demand Memory-write operation.

## 0x81FA , L3D\_CACHE\_HIT\_WR\_FPRF, Level 3 data cache demand access first hit, write, fetched by prefetch

The counter counts each first hit counted by L3D\_CACHE\_HIT\_RW\_FPRF that is due to a demand Memory-write operation.

## 0x81FB , LL\_CACHE\_HIT\_WR\_FPRF, Last level cache demand access first hit, write, fetched by prefetch

The counter counts each first hit counted by LL\_CACHE\_HIT\_RW\_FPRF that is due to a demand Memory-write operation.

## 0x81FC , L1D\_CACHE\_HIT\_RW\_FPRF, Level 1 data cache demand access first hit, fetched by prefetch

The counter counts each demand access first hit counted by L1D\_CACHE\_HIT\_RW where the cache line was fetched in response to a prefetch instruction or by a hardware prefetcher.

That is, the L1D\_CACHE\_REFILL\_PRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81FD , L2D\_CACHE\_HIT\_RW\_FPRF, Level 2 data cache demand access first hit, fetched by prefetch

The counter counts each demand access first hit counted by L2D\_CACHE\_HIT\_RW where the cache line was fetched in response to a prefetch instruction or by a hardware prefetcher.

That is, the L2D\_CACHE\_REFILL\_PRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81FE , L3D\_CACHE\_HIT\_RW\_FPRF, Level 3 data cache demand access first hit, fetched by prefetch

The counter counts each demand access first hit counted by L3D\_CACHE\_HIT\_RW where the cache line was fetched in response to a prefetch instruction or by a hardware prefetcher.

That is, the L3D\_CACHE\_REFILL\_PRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x81FF , LL\_CACHE\_HIT\_RW\_FPRF, Last level cache demand access first hit, fetched by prefetch

The counter counts each demand access first hit counted by LL\_CACHE\_HIT\_RW where the cache line was fetched in response to a prefetch instruction or by a hardware prefetcher.

That is, the LL\_CACHE\_REFILL\_PRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x8200 , L1I\_CACHE\_HIT, Level 1 instruction cache hit

The counter counts each access counted by L1I\_CACHE that hits in the Level 1 instruction or unified cache.

## 0x8201 , L2I\_CACHE\_HIT, Level 2 instruction cache hit

The counter counts each access counted by L2I\_CACHE that hits in the Level 2 instruction or unified cache.

## 0x8204 , L1D\_CACHE\_HIT, Level 1 data cache hit

The counter counts each access counted by L1D\_CACHE that hits in the Level 1 data or unified cache.

## 0x8205 , L2D\_CACHE\_HIT, Level 2 data cache hit

The counter counts each access counted by L2D\_CACHE that hits in the Level 2 data or unified cache.

## 0x8206 , L3D\_CACHE\_HIT, Level 3 data cache hit

The counter counts each access counted by L3D\_CACHE that hits in the Level 3 data or unified cache.

## 0x8207 , LL\_CACHE\_HIT, Last level cache hit

The counter counts each access counted by LL\_CACHE that hits in the Last level cache.

## 0x8208 , L1I\_CACHE\_HIT\_PRFM, Level 1 instruction cache software prefetch hit

The counter counts each software prefetch counted by L1I\_CACHE\_PRFM that hits in the Level 1 instruction or unified cache.

## 0x8209 , L2I\_CACHE\_HIT\_PRFM, Level 2 instruction cache software prefetch hit

The counter counts each software prefetch counted by L2I\_CACHE\_PRFM that hits in the Level 2 instruction or unified cache.

## 0x820C , L1D\_CACHE\_HIT\_PRFM, Level 1 data cache software prefetch hit

The counter counts each software prefetch counted by L1D\_CACHE\_PRFM that hits in the Level 1 data or unified cache.

## 0x820D , L2D\_CACHE\_HIT\_PRFM, Level 2 data cache software prefetch hit

The counter counts each software prefetch counted by L2D\_CACHE\_PRFM that hits in the Level 2 data or unified cache.

## 0x820E , L3D\_CACHE\_HIT\_PRFM, Level 3 data cache software prefetch hit

The counter counts each software prefetch counted by L3D\_CACHE\_PRFM that hits in the Level 3 data or unified cache.

## 0x820F , LL\_CACHE\_HIT\_PRFM, Last level cache software prefetch hit

The counter counts each software prefetch counted by LL\_CACHE\_PRFM that hits in the Last level cache.

## 0x8214 , L1D\_CACHE\_HITM\_RD, Level 1 data cache demand access hit modified, read

The counter counts each cache access counted by L1D\_CACHE\_HIT\_RD that accesses a previously modified cache location.

## 0x8215 , L2D\_CACHE\_HITM\_RD, Level 2 data cache demand access hit modified, read

The counter counts each cache access counted by L2D\_CACHE\_HIT\_RD that accesses a previously modified cache location.

## 0x8216 , L3D\_CACHE\_HITM\_RD, Level 3 data cache demand access hit modified, read

The counter counts each cache access counted by L3D\_CACHE\_HIT\_RD that accesses a previously modified cache location.

## 0x8217 , LL\_CACHE\_HITM\_RD, Last level cache demand access hit modified, read

The counter counts each cache access counted by LL\_CACHE\_HIT\_RD that accesses a previously modified cache location.

## 0x8218 , L1D\_CACHE\_HITM\_WR, Level 1 data cache demand access hit modified, write

The counter counts each cache access counted by L1D\_CACHE\_HIT\_WR that accesses a previously modified cache location.

## 0x8219 , L2D\_CACHE\_HITM\_WR, Level 2 data cache demand access hit modified, write

The counter counts each cache access counted by L2D\_CACHE\_HIT\_WR that accesses a previously modified cache location.

## 0x821A , L3D\_CACHE\_HITM\_WR, Level 3 data cache demand access hit modified, write

The counter counts each cache access counted by L3D\_CACHE\_HIT\_WR that accesses a previously modified cache location.

## 0x821B , LL\_CACHE\_HITM\_WR, Last level cache demand access hit modified, write

The counter counts each cache access counted by LL\_CACHE\_HIT\_WR that accesses a previously modified cache location.

## 0x821C , L1D\_CACHE\_HITM\_RW, Level 1 data cache demand access hit modified

The counter counts each cache access counted by L1D\_CACHE\_HIT\_RW that accesses a previously modified cache location.

## 0x821D , L2D\_CACHE\_HITM\_RW, Level 2 data cache demand access hit modified

The counter counts each cache access counted by L2D\_CACHE\_HIT\_RW that accesses a previously modified cache location.

## 0x821E , L3D\_CACHE\_HITM\_RW, Level 3 data cache demand access hit modified

The counter counts each cache access counted by L3D\_CACHE\_HIT\_RW that accesses a previously modified cache location.

## 0x821F , LL\_CACHE\_HITM\_RW, Last level cache demand access hit modified

The counter counts each cache access counted by LL\_CACHE\_HIT\_RW that accesses a previously modified cache location.

## 0x8224 , DSNP\_HITM\_RD, Snoop hit, demand data read, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_RD that accesses a previously modified cache location.

## 0x8225 , DSNP\_HITM\_NEAR\_RD, Snoop hit in near local cache, demand data read, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_NEAR\_RD that accesses a previously modified cache location.

## 0x8226 , DSNP\_HITM\_FAR\_RD, Snoop hit in far local cache, demand data read, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_FAR\_RD that accesses a previously modified cache location.

## 0x8227 , DSNP\_HITM\_REMOTE\_RD, Snoop hit in remote cache, demand data read, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_REMOTE\_RD that accesses a previously modified cache location.

## 0x8228 , DSNP\_HITM\_WR, Snoop hit, demand data write, modified

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_WR that accesses a previously modified cache location.

## 0x8229 , DSNP\_HITM\_NEAR\_WR, Snoop hit in near local cache, demand data write, modified

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_NEAR\_WR that accesses a previously modified cache location.

## 0x822A , DSNP\_HITM\_FAR\_WR, Snoop hit in far local cache, demand data write, modified

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_FAR\_WR that accesses a previously modified cache location.

## 0x822B , DSNP\_HITM\_REMOTE\_WR, Snoop hit in remote cache, demand data write, modified

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_REMOTE\_WR that accesses a previously modified cache location.

## 0x822C , DSNP\_HITM\_RW, Snoop hit, demand data access, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_RW that accesses a previously modified cache location.

## 0x822D , DSNP\_HITM\_NEAR\_RW, Snoop hit in near local cache, demand data access, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_NEAR\_RW that accesses a previously modified cache location.

## 0x822E , DSNP\_HITM\_FAR\_RW, Snoop hit in far local cache, demand data access, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_FAR\_RW that accesses a previously modified cache location.

## 0x822F , DSNP\_HITM\_REMOTE\_RW, Snoop hit in remote cache, demand data access, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_REMOTE\_RW that accesses a previously modified cache location.

## 0x8230 , LOCAL\_MEM, Access to memory attached to this device

The counter counts each Memory-read operation or Memory-write operation access to external memory attached to this device.

In a multi-socket system this means attached to the socket that contains the PE. For more information, see REMOTE\_ACCESS.

In systems where there multiple types of memory attached to this device with different performance characteristics, it is IMPLEMENTATION DEFINED whether accesses to all external memory types are counted by this event, or are classified as remote accesses and counted by REMOTE\_MEM.

For example, in a system with an expansion memory connected to the device that has significantly higher latency than the main system memory, accesses to the main system memory might be counted by this event and accesses to the expansion memory by REMOTE\_MEM.

## 0x8231 , LOCAL\_MEM\_RD, Access to memory attached to this device, demand access, read

The counter counts each access counted by LOCAL\_MEM\_RW that is a demand Memory-read operation.

## 0x8232 , LOCAL\_MEM\_WR, Access to memory attached to this device, demand access, write

The counter counts each access counted by LOCAL\_MEM\_RW that is a demand Memory-write operation.

## 0x8233 , LOCAL\_MEM\_RW, Access to memory attached to this device, demand access

The counter counts each access counted by LOCAL\_MEM that is a demand Memory-read operation or demand Memory-write operation.

It is IMPLEMENTATION DEFINED whether an access to external memory due to a prefetch to a cache is counted by LOCAL\_MEM\_RWorLOCAL\_MEM\_PRFM.

## 0x8234 , LOCAL\_MEM\_PRFM, Access to memory attached to this device, software prefetch

The counter counts each access counted by LOCAL\_MEM that is due to a prefetch instruction.

It is IMPLEMENTATION DEFINED whether an access to external memory due to a prefetch to a cache is counted by LOCAL\_MEM\_RWorLOCAL\_MEM\_PRFM.

## 0x8235 , LOCAL\_MEM\_LD\_RETIRED, Load instruction architecturally executed, access to memory attached to this device

The counter counts each architecturally executed instruction counted by LOCAL\_MEM\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x8236 , LOCAL\_MEM\_ST\_RETIRED, Store instruction architecturally executed, access to memory attached to this device

The counter counts each architecturally executed instruction counted by LOCAL\_MEM\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x8237 , LOCAL\_MEM\_LDST\_RETIRED, Load or store instruction architecturally executed, access to memory attached to this device

The counter counts each Memory-reading instruction or Memory-writing instruction architecturally executed counted by LDST\_ANY\_RETIRED that accessed external memory attached to this device.

## 0x8238 , REMOTE\_MEM, Access to memory attached to a remote device

The counter counts each Memory-read operation or Memory-write operation access counted by REMOTE\_ACCESS to external memory attached to a remote device.

The counter also counts any accesses to external memory that are not counted by LOCAL\_MEM because the implementation classifies them as remote accesses. For example, accesses to expansion memory connected to the device that has significantly higher latency than the main system memory might be classified as remote accesses. For more information, see LOCAL\_MEM.

## 0x8239 , REMOTE\_MEM\_RD, Access to memory attached to a remote device, demand access, read

The counter counts each access counted by REMOTE\_MEM\_RW that is a demand Memory-read operation.

## 0x823A , REMOTE\_MEM\_WR, Access to memory attached to a remote device, demand access, write

The counter counts each access counted by REMOTE\_MEM\_RW that is a demand Memory-write operation.

## 0x823B , REMOTE\_MEM\_RW, Access to memory attached to a remote device, demand access

The counter counts each access counted by REMOTE\_MEM that is a demand Memory-read operation or demand Memory-write operation.

## 0x823C , REMOTE\_MEM\_PRFM, Access to memory attached to a remote device, software prefetch

The counter counts each access counted by REMOTE\_MEM that is due to a prefetch instruction.

## 0x823D , REMOTE\_MEM\_LD\_RETIRED, Load instruction architecturally executed, access to memory attached to a remote device

The counter counts each architecturally executed instruction counted by REMOTE\_MEM\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x823E , REMOTE\_MEM\_ST\_RETIRED, Store instruction architecturally executed, access to memory attached to a remote device

The counter counts each architecturally executed instruction counted by REMOTE\_MEM\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x823F , REMOTE\_MEM\_LDST\_RETIRED,Loadorstoreinstruction architecturally executed, access to memory attached to a remote device

The counter counts each Memory-reading instruction or Memory-writing instruction architecturally executed counted by LDST\_ANY\_RETIRED that accessed external memory attached to a remote device.

## 0x8240 , L1I\_LFB\_HIT\_RD, Level 1 instruction cache demand fetch line-fill buffer hit

The counter counts each demand access counted by L1I\_CACHE\_HIT\_RD that hits a recently fetched line in the Level 1 instruction or unified cache.

That is, the access hits a cache line that is in the process of being loaded into the Level 1 instruction or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x8241 , L2I\_LFB\_HIT\_RD, Level 2 instruction cache demand fetch line-fill buffer hit

The counter counts each demand access counted by L2I\_CACHE\_HIT\_RD that hits a recently fetched line in the Level 2 instruction or unified cache.

That is, the access hits a cache line that is in the process of being loaded into the Level 2 instruction or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x8244 , L1D\_LFB\_HIT\_RD, Level 1 data cache demand access line-fill buffer hit, read

The counter counts each demand access counted by L1D\_CACHE\_HIT\_RD that hits a recently fetched line in the Level 1 data or unified cache.

That is, the access hits a cache line that is in the process of being loaded into the Level 1 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x8245 , L2D\_LFB\_HIT\_RD, Level 2 data cache demand access line-fill buffer hit, read

The counter counts each demand access counted by L2D\_CACHE\_HIT\_RD that hits a recently fetched line in the Level 2 data or unified cache.

That is, the access hits a cache line that is in the process of being loaded into the Level 2 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x8246 , L3D\_LFB\_HIT\_RD, Level 3 data cache demand access line-fill buffer hit, read

The counter counts each demand access counted by L3D\_CACHE\_HIT\_RD that hits a recently fetched line in the Level 3 data or unified cache.

That is, the access hits a cache line that is in the process of being loaded into the Level 3 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x8247 , LL\_LFB\_HIT\_RD, Last level cache demand access line-fill buffer hit, read

The counter counts each demand access counted by LL\_CACHE\_HIT\_RD that hits a recently fetched line in the Last level cache.

That is, the access hits a cache line that is in the process of being loaded into the Last level cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x8248 , L1D\_LFB\_HIT\_WR, Level 1 data cache demand access line-fill buffer hit, write

The counter counts each demand access counted by L1D\_CACHE\_HIT\_WR that hits a recently fetched line in the Level 1 data or unified cache.

That is, the access hits a cache line that is in the process of being loaded into the Level 1 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x8249 , L2D\_LFB\_HIT\_WR, Level 2 data cache demand access line-fill buffer hit, write

The counter counts each demand access counted by L2D\_CACHE\_HIT\_WR that hits a recently fetched line in the Level 2 data or unified cache.

That is, the access hits a cache line that is in the process of being loaded into the Level 2 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x824A , L3D\_LFB\_HIT\_WR, Level 3 data cache demand access line-fill buffer hit, write

The counter counts each demand access counted by L3D\_CACHE\_HIT\_WR that hits a recently fetched line in the Level 3 data or unified cache.

That is, the access hits a cache line that is in the process of being loaded into the Level 3 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x824B , LL\_LFB\_HIT\_WR, Last level cache demand access line-fill buffer hit, write

The counter counts each demand access counted by LL\_CACHE\_HIT\_WR that hits a recently fetched line in the Last level cache.

That is, the access hits a cache line that is in the process of being loaded into the Last level cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x824C , L1D\_LFB\_HIT\_RW, Level 1 data cache demand access line-fill buffer hit

The counter counts each demand access counted by L1D\_CACHE\_HIT\_RW that hits a recently fetched line in the Level 1 data or unified cache.

That is, the access hits a cache line that is in the process of being loaded into the Level 1 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x824D , L2D\_LFB\_HIT\_RW, Level 2 data cache demand access line-fill buffer hit

The counter counts each demand access counted by L2D\_CACHE\_HIT\_RW that hits a recently fetched line in the Level 2 data or unified cache.

That is, the access hits a cache line that is in the process of being loaded into the Level 2 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x824E , L3D\_LFB\_HIT\_RW, Level 3 data cache demand access line-fill buffer hit

The counter counts each demand access counted by L3D\_CACHE\_HIT\_RW that hits a recently fetched line in the Level 3 data or unified cache.

That is, the access hits a cache line that is in the process of being loaded into the Level 3 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x824F , LL\_LFB\_HIT\_RW, Last level cache demand access line-fill buffer hit

The counter counts each demand access counted by LL\_CACHE\_HIT\_RW that hits a recently fetched line in the Last level cache.

That is, the access hits a cache line that is in the process of being loaded into the Last level cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x8250 , L1I\_LFB\_HIT\_RD\_FPRFM, Level 1 instruction cache demand fetch line-fill buffer first hit, recently fetched by software prefetch

The counter counts each demand fetch line-fill buffer first hit counted by L1I\_LFB\_HIT\_RD\_FPRF where the cache line was fetched in response to a prefetch instruction.

That is, the fetch hits a cache line that is in the process of being loaded into the Level 1 instruction or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L1I\_CACHE\_REFILL\_PRFM event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x8251 , L2I\_LFB\_HIT\_RD\_FPRFM, Level 2 instruction cache demand fetch line-fill buffer first hit, recently fetched by software prefetch

The counter counts each demand fetch line-fill buffer first hit counted by L2I\_LFB\_HIT\_RD\_FPRF where the cache line was fetched in response to a prefetch instruction.

That is, the fetch hits a cache line that is in the process of being loaded into the Level 2 instruction or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L2I\_CACHE\_REFILL\_PRFM event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x8254 , L1D\_LFB\_HIT\_RD\_FPRFM, Level 1 data cache demand access line-fill buffer first hit, read, recently fetched by software prefetch

The counter counts each line-fill buffer first hit counted by L1D\_LFB\_HIT\_RW\_FPRFM that is due to a demand Memory-read operation.

## 0x8255 , L2D\_LFB\_HIT\_RD\_FPRFM, Level 2 data cache demand access line-fill buffer first hit, read, recently fetched by software prefetch

The counter counts each line-fill buffer first hit counted by L2D\_LFB\_HIT\_RW\_FPRFM that is due to a demand Memory-read operation.

## 0x8256 , L3D\_LFB\_HIT\_RD\_FPRFM, Level 3 data cache demand access line-fill buffer first hit, read, recently fetched by software prefetch

The counter counts each line-fill buffer first hit counted by L3D\_LFB\_HIT\_RW\_FPRFM that is due to a demand Memory-read operation.

## 0x8257 , LL\_LFB\_HIT\_RD\_FPRFM, Last level cache demand access line-fill buffer first hit, read, recently fetched by software prefetch

The counter counts each line-fill buffer first hit counted by LL\_LFB\_HIT\_RW\_FPRFM that is due to a demand Memory-read operation.

## 0x8258 , L1D\_LFB\_HIT\_WR\_FPRFM, Level 1 data cache demand access line-fill buffer first hit, write, recently fetched by software prefetch

The counter counts each line-fill buffer first hit counted by L1D\_LFB\_HIT\_RW\_FPRFM that is due to a demand Memory-write operation.

## 0x8259 , L2D\_LFB\_HIT\_WR\_FPRFM, Level 2 data cache demand access line-fill buffer first hit, write, recently fetched by software prefetch

The counter counts each line-fill buffer first hit counted by L2D\_LFB\_HIT\_RW\_FPRFM that is due to a demand Memory-write operation.

## 0x825A , L3D\_LFB\_HIT\_WR\_FPRFM, Level 3 data cache demand access line-fill buffer first hit, write, recently fetched by software prefetch

The counter counts each line-fill buffer first hit counted by L3D\_LFB\_HIT\_RW\_FPRFM that is due to a demand Memory-write operation.

## 0x825B , LL\_LFB\_HIT\_WR\_FPRFM, Last level cache demand access line-fill buffer first hit, write, recently fetched by software prefetch

The counter counts each line-fill buffer first hit counted by LL\_LFB\_HIT\_RW\_FPRFM that is due to a demand Memory-write operation.

## 0x825C , L1D\_LFB\_HIT\_RW\_FPRFM, Level 1 data cache demand access line-fill buffer first hit, recently fetched by software prefetch

The counter counts each demand access line-fill buffer first hit counted by L1D\_LFB\_HIT\_RW\_FPRF where the cache line was fetched in response to a prefetch instruction.

That is, the access hits a cache line that is in the process of being loaded into the Level 1 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L1D\_CACHE\_REFILL\_PRFM event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x825D , L2D\_LFB\_HIT\_RW\_FPRFM, Level 2 data cache demand access line-fill buffer first hit, recently fetched by software prefetch

The counter counts each demand access line-fill buffer first hit counted by L2D\_LFB\_HIT\_RW\_FPRF where the cache line was fetched in response to a prefetch instruction.

That is, the access hits a cache line that is in the process of being loaded into the Level 2 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L2D\_CACHE\_REFILL\_PRFM event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x825E , L3D\_LFB\_HIT\_RW\_FPRFM, Level 3 data cache demand access line-fill buffer first hit, recently fetched by software prefetch

The counter counts each demand access line-fill buffer first hit counted by L3D\_LFB\_HIT\_RW\_FPRF where the cache line was fetched in response to a prefetch instruction.

That is, the access hits a cache line that is in the process of being loaded into the Level 3 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L3D\_CACHE\_REFILL\_PRFM event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x825F , LL\_LFB\_HIT\_RW\_FPRFM, Last level cache demand access line-fill buffer first hit, recently fetched by software prefetch

The counter counts each demand access line-fill buffer first hit counted by LL\_LFB\_HIT\_RW\_FPRF where the cache line was fetched in response to a prefetch instruction.

That is, the access hits a cache line that is in the process of being loaded into the Last level cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the LL\_CACHE\_REFILL\_PRFM event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x8260 , L1I\_LFB\_HIT\_RD\_FHWPRF, Level 1 instruction cache demand fetch line-fill buffer first hit, recently fetched by hardware prefetcher

The counter counts each demand fetch line-fill buffer first hit counted by L1I\_LFB\_HIT\_RD\_FPRF where the cache line was fetched by a hardware prefetcher.

That is, the fetch hits a cache line that is in the process of being loaded into the Level 1 instruction or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L1I\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x8261 , L2I\_LFB\_HIT\_RD\_FHWPRF, Level 2 instruction cache demand fetch line-fill buffer first hit, recently fetched by hardware prefetcher

The counter counts each demand fetch line-fill buffer first hit counted by L2I\_LFB\_HIT\_RD\_FPRF where the cache line was fetched by a hardware prefetcher.

That is, the fetch hits a cache line that is in the process of being loaded into the Level 2 instruction or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L2I\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x8264 , L1D\_LFB\_HIT\_RD\_FHWPRF, Level 1 data cache demand access line-fill buffer first hit, read, recently fetched by hardware prefetcher

The counter counts each line-fill buffer first hit counted by L1D\_LFB\_HIT\_RW\_FHWPRF that is due to a demand Memory-read operation.

## 0x8265 , L2D\_LFB\_HIT\_RD\_FHWPRF, Level 2 data cache demand access line-fill buffer first hit, read, recently fetched by hardware prefetcher

The counter counts each line-fill buffer first hit counted by L2D\_LFB\_HIT\_RW\_FHWPRF that is due to a demand Memory-read operation.

## 0x8266 , L3D\_LFB\_HIT\_RD\_FHWPRF, Level 3 data cache demand access line-fill buffer first hit, read, recently fetched by hardware prefetcher

The counter counts each line-fill buffer first hit counted by L3D\_LFB\_HIT\_RW\_FHWPRF that is due to a demand Memory-read operation.

## 0x8267 , LL\_LFB\_HIT\_RD\_FHWPRF, Last level cache demand access line-fill buffer first hit, read, recently fetched by hardware prefetcher

The counter counts each line-fill buffer first hit counted by LL\_LFB\_HIT\_RW\_FHWPRF that is due to a demand Memory-read operation.

## 0x8268 , L1D\_LFB\_HIT\_WR\_FHWPRF, Level 1 data cache demand access line-fill buffer first hit, write, recently fetched by hardware prefetcher

The counter counts each line-fill buffer first hit counted by L1D\_LFB\_HIT\_RW\_FHWPRF that is due to a demand Memory-write operation.

## 0x8269 , L2D\_LFB\_HIT\_WR\_FHWPRF, Level 2 data cache demand access line-fill buffer first hit, write, recently fetched by hardware prefetcher

The counter counts each line-fill buffer first hit counted by L2D\_LFB\_HIT\_RW\_FHWPRF that is due to a demand Memory-write operation.

## 0x826A , L3D\_LFB\_HIT\_WR\_FHWPRF, Level 3 data cache demand access line-fill buffer first hit, write, recently fetched by hardware prefetcher

The counter counts each line-fill buffer first hit counted by L3D\_LFB\_HIT\_RW\_FHWPRF that is due to a demand Memory-write operation.

## 0x826B , LL\_LFB\_HIT\_WR\_FHWPRF, Last level cache demand access line-fill buffer first hit, write, recently fetched by hardware prefetcher

The counter counts each line-fill buffer first hit counted by LL\_LFB\_HIT\_RW\_FHWPRF that is due to a demand Memory-write operation.

## 0x826C , L1D\_LFB\_HIT\_RW\_FHWPRF, Level 1 data cache demand access line-fill buffer first hit, recently fetched by hardware prefetcher

The counter counts each demand access line-fill buffer first hit counted by L1D\_LFB\_HIT\_RW\_FPRF where the cache line was fetched by a hardware prefetcher.

That is, the access hits a cache line that is in the process of being loaded into the Level 1 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the

L1D\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x826D , L2D\_LFB\_HIT\_RW\_FHWPRF, Level 2 data cache demand access line-fill buffer first hit, recently fetched by hardware prefetcher

The counter counts each demand access line-fill buffer first hit counted by L2D\_LFB\_HIT\_RW\_FPRF where the cache line was fetched by a hardware prefetcher.

That is, the access hits a cache line that is in the process of being loaded into the Level 2 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L2D\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x826E , L3D\_LFB\_HIT\_RW\_FHWPRF, Level 3 data cache demand access line-fill buffer first hit, recently fetched by hardware prefetcher

The counter counts each demand access line-fill buffer first hit counted by L3D\_LFB\_HIT\_RW\_FPRF where the cache line was fetched by a hardware prefetcher.

That is, the access hits a cache line that is in the process of being loaded into the Level 3 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the

L3D\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x826F , LL\_LFB\_HIT\_RW\_FHWPRF,Lastlevel cache demand access line-fill buffer first hit, recently fetched by hardware prefetcher

The counter counts each demand access line-fill buffer first hit counted by LL\_LFB\_HIT\_RW\_FPRF where the cache line was fetched by a hardware prefetcher.

That is, the access hits a cache line that is in the process of being loaded into the Last level cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the LL\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x8270 , L1I\_LFB\_HIT\_RD\_FPRF, Level 1 instruction cache demand fetch line-fill buffer first hit, recently fetched by prefetch

The counter counts each demand fetch line-fill buffer first hit counted by L1I\_LFB\_HIT\_RD where the cache line was fetched in response to a prefetch instruction or by a hardware prefetcher.

That is, the fetch hits a cache line that is in the process of being loaded into the Level 1 instruction or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L1I\_CACHE\_REFILL\_PRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x8271 , L2I\_LFB\_HIT\_RD\_FPRF, Level 2 instruction cache demand fetch line-fill buffer first hit, recently fetched by prefetch

The counter counts each demand fetch line-fill buffer first hit counted by L2I\_LFB\_HIT\_RD where the cache line was fetched in response to a prefetch instruction or by a hardware prefetcher.

That is, the fetch hits a cache line that is in the process of being loaded into the Level 2 instruction or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L2I\_CACHE\_REFILL\_PRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x8274 , L1D\_LFB\_HIT\_RD\_FPRF, Level 1 data cache demand access line-fill buffer first hit, read, recently fetched by prefetch

The counter counts each line-fill buffer first hit counted by L1D\_LFB\_HIT\_RW\_FPRF that is due to a demand Memory-read operation.

## 0x8275 , L2D\_LFB\_HIT\_RD\_FPRF, Level 2 data cache demand access line-fill buffer first hit, read, recently fetched by prefetch

The counter counts each line-fill buffer first hit counted by L2D\_LFB\_HIT\_RW\_FPRF that is due to a demand Memory-read operation.

## 0x8276 , L3D\_LFB\_HIT\_RD\_FPRF, Level 3 data cache demand access line-fill buffer first hit, read, recently fetched by prefetch

The counter counts each line-fill buffer first hit counted by L3D\_LFB\_HIT\_RW\_FPRF that is due to a demand Memory-read operation.

0x8277 , LL\_LFB\_HIT\_RD\_FPRF, Last level cache demand access line-fill buffer first hit, read, recently fetched by prefetch

The counter counts each line-fill buffer first hit counted by LL\_LFB\_HIT\_RW\_FPRF that is due to a demand Memory-read operation.

0x8278 , L1D\_LFB\_HIT\_WR\_FPRF, Level 1 data cache demand access line-fill buffer first hit, write, recently fetched by prefetch

The counter counts each line-fill buffer first hit counted by L1D\_LFB\_HIT\_RW\_FPRF that is due to a demand Memory-write operation.

0x8279 , L2D\_LFB\_HIT\_WR\_FPRF, Level 2 data cache demand access line-fill buffer first hit, write, recently fetched by prefetch

The counter counts each line-fill buffer first hit counted by L2D\_LFB\_HIT\_RW\_FPRF that is due to a demand Memory-write operation.

0x827A , L3D\_LFB\_HIT\_WR\_FPRF, Level 3 data cache demand access line-fill buffer first hit, write, recently fetched by prefetch

The counter counts each line-fill buffer first hit counted by L3D\_LFB\_HIT\_RW\_FPRF that is due to a demand Memory-write operation.

0x827B , LL\_LFB\_HIT\_WR\_FPRF, Last level cache demand access line-fill buffer first hit, write, recently fetched by prefetch

The counter counts each line-fill buffer first hit counted by LL\_LFB\_HIT\_RW\_FPRF that is due to a demand Memory-write operation.

## 0x827C , L1D\_LFB\_HIT\_RW\_FPRF, Level 1 data cache demand access line-fill buffer first hit, recently fetched by prefetch

The counter counts each demand access line-fill buffer first hit counted by L1D\_LFB\_HIT\_RW where the cache line was fetched in response to a prefetch instruction or by a hardware prefetcher.

That is, the access hits a cache line that is in the process of being loaded into the Level 1 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L1D\_CACHE\_REFILL\_PRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x827D , L2D\_LFB\_HIT\_RW\_FPRF, Level 2 data cache demand access line-fill buffer first hit, recently fetched by prefetch

The counter counts each demand access line-fill buffer first hit counted by L2D\_LFB\_HIT\_RW where the cache line was fetched in response to a prefetch instruction or by a hardware prefetcher.

That is, the access hits a cache line that is in the process of being loaded into the Level 2 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L2D\_CACHE\_REFILL\_PRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x827E , L3D\_LFB\_HIT\_RW\_FPRF, Level 3 data cache demand access line-fill buffer first hit, recently fetched by prefetch

The counter counts each demand access line-fill buffer first hit counted by L3D\_LFB\_HIT\_RW where the cache line was fetched in response to a prefetch instruction or by a hardware prefetcher.

That is, the access hits a cache line that is in the process of being loaded into the Level 3 data or unified cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L3D\_CACHE\_REFILL\_PRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x827F , LL\_LFB\_HIT\_RW\_FPRF, Last level cache demand access line-fill buffer first hit, recently fetched by prefetch

The counter counts each demand access line-fill buffer first hit counted by LL\_LFB\_HIT\_RW where the cache line was fetched in response to a prefetch instruction or by a hardware prefetcher.

That is, the access hits a cache line that is in the process of being loaded into the Last level cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the LL\_CACHE\_REFILL\_PRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x8280 , L1I\_CACHE\_PRF, Level 1 instruction cache, prefetch hit

The counter counts each access counted by L1I\_CACHE that is due to a prefetch instruction, or hardware prefetch.

## 0x8281 , L2I\_CACHE\_PRF, Level 2 instruction cache, prefetch hit

The counter counts each access counted by L2I\_CACHE that is due to a prefetch instruction, or hardware prefetch.

This includes accesses to the Level 2 instruction or unified cache due to a refill of another cache caused by a prefetch instruction, or hardware prefetch.

## 0x8284 , L1D\_CACHE\_PRF, Level 1 data cache, prefetch hit

The counter counts each access counted by L1D\_CACHE that is due to a prefetch instruction, or hardware prefetch.

## 0x8285 , L2D\_CACHE\_PRF, Level 2 data cache, prefetch hit

The counter counts each access counted by L2D\_CACHE that is due to a prefetch instruction, or hardware prefetch.

This includes accesses to the Level 2 data or unified cache due to a refill of another cache caused by a prefetch instruction, or hardware prefetch.

## 0x8286 , L3D\_CACHE\_PRF, Level 3 data cache, prefetch hit

The counter counts each access counted by L3D\_CACHE that is due to a prefetch instruction, or hardware prefetch.

This includes accesses to the Level 3 data or unified cache due to a refill of another cache caused by a prefetch instruction, or hardware prefetch.

## 0x8287 , LL\_CACHE\_PRF, Last level cache, prefetch hit

The counter counts each access counted by LL\_CACHE that is due to a prefetch instruction, or hardware prefetch.

This includes accesses to the Last level cache due to a refill of another cache caused by a prefetch instruction, or hardware prefetch.

## 0x8288 , L1I\_CACHE\_REFILL\_PRF, Level 1 instruction cache refill, prefetch hit

The counter counts each access counted by L1I\_CACHE\_PRF that causes a refill of the Level 1 instruction or unified cache from outside of the Level 1 instruction or unified cache.

## 0x8289 , L2I\_CACHE\_REFILL\_PRF, Level 2 instruction cache refill, prefetch hit

The counter counts each access counted by L2I\_CACHE\_PRF that causes a refill of the Level 2 instruction or unified cache, or any Level 1 data, instruction, or unified cache of this PE, from outside of those caches.

## 0x828C , L1D\_CACHE\_REFILL\_PRF, Level 1 data cache refill, prefetch hit

The counter counts each access counted by L1D\_CACHE\_PRF that causes a refill of the Level 1 data or unified cache from outside of the Level 1 data or unified cache.

## 0x828D , L2D\_CACHE\_REFILL\_PRF, Level 2 data cache refill, prefetch hit

The counter counts each access counted by L2D\_CACHE\_PRF that causes a refill of the Level 2 data or unified cache, or any Level 1 data, instruction, or unified cache of this PE, from outside of those caches.

## 0x828E , L3D\_CACHE\_REFILL\_PRF, Level 3 data cache refill, prefetch hit

The counter counts each access counted by L3D\_CACHE\_PRF that causes a refill of the Level 3 data or unified cache, or any Level 1 or Level 2 data, instruction, or unified cache of this PE, from outside of those caches.

## 0x828F , LL\_CACHE\_REFILL\_PRF, Last level cache refill, prefetch hit

The counter counts each access counted by LL\_CACHE\_PRF that causes a refill of the Last level cache, or any other data, instruction, or unified cache of this PE, from outside of those caches.

## 0x8290 , ISNP\_HIT\_PRF, Snoop hit, instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction, or by an instruction hardware prefetch that hits in a cache outside of the cache hierarchy of this PE.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8291 , ISNP\_HIT\_NEAR\_PRF, Snoop hit in near local cache, instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction, or by an instruction hardware prefetch counted by ISNP\_HIT\_PRF that hits in a cache outside of the cache hierarchy of this PE in the local PE cluster.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8292 , ISNP\_HIT\_FAR\_PRF, Snoop hit in far local cache, instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction, or by an instruction hardware prefetch counted by ISNP\_HIT\_PRF that hits in a cache outside the local PE cluster on the same device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8293 , ISNP\_HIT\_REMOTE\_PRF, Snoop hit in remote cache, instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction, or by an instruction hardware prefetch counted by ISNP\_HIT\_PRF that hits in a cache on a remote device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8294 , DSNP\_HIT\_PRF, Snoop hit, data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction, or by a data hardware prefetch that hits in a cache outside of the cache hierarchy of this PE.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8295 , DSNP\_HIT\_NEAR\_PRF, Snoop hit in near local cache, data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction, or by a data hardware prefetch counted by DSNP\_HIT\_PRF that hits in a cache outside of the cache hierarchy of this PE in the local PE cluster.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8296 , DSNP\_HIT\_FAR\_PRF, Snoop hit in far local cache, data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction, or by a data hardware prefetch counted by DSNP\_HIT\_PRF that hits in a cache outside the local PE cluster on the same device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8297 , DSNP\_HIT\_REMOTE\_PRF, Snoop hit in remote cache, data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction, or by a data hardware prefetch counted by DSNP\_HIT\_PRF that hits in a cache on a remote device.

The event is counted by the PE generating the snoop, not the PE being snooped.

## 0x8298 , LL\_CACHE\_RW, Last level cache demand access

The counter counts each access counted by LL\_CACHE that is due to a demand Memory-read operation or demand Memory-write operation.

This includes:

- Accesses made by speculatively executed instructions.
- Accesses to the Last level cache due to a refill of another cache caused by a demand Memory-read operation or demand Memory-write operation.

Arm recommends that this event is implemented if any of the following are true:

- Event LL\_CACHE\_PRFM is implemented.
- Event LL\_CACHE\_HWPRF is implemented.

## 0x8299 , LL\_CACHE\_PRFM, Last level cache software prefetch

The counter counts each access counted by LL\_CACHE\_PRF that is due to a prefetch instruction.

This includes accesses to the Last level cache due to a refill of another cache caused by a prefetch instruction.

Arm recommends that this event is implemented if event LL\_CACHE\_RW is implemented.

## 0x829A , LL\_CACHE\_REFILL, Last level cache refill

The counter counts each access counted by LL\_CACHE that causes a refill of the Last level cache, or any other data, instruction, or unified cache of this PE, from outside of those caches.

Arefill includes any access that causes data to be fetched from outside of the Level 1 to Last level caches, even if the data is ultimately not allocated into the Last level cache. For example, data might be fetched into a buffer but then discarded, rather than being allocated into a cache. These buffers are treated as part of the cache.

For example, the counter counts:

- Accesses to the Last level cache that cause a refill that is satisfier by fetching data from memory, or a Last level cache of another PE.
- Refills of and write-backs from any other data, instruction, or unified caches of this PE that cause a refill from outside of the Level 1 to Last level caches of this PE.
- Accesses to the Last level cache that cause a refill of a higher level cache of this PE from outside of the Level 1 to Last level caches of this PE, even if there is no refill of the Last level cache.

The counter does not count accesses that:

- Miss in the cache but are satisfied by the refill of a previous miss and do not cause a new refill, even if that previous refill is not complete at the time of the miss.
- Miss in the cache but do not generate a refill, such as a write through the cache.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x829B , LL\_CACHE\_REFILL\_PRFM, Last level cache refill, software prefetch

The counter counts each access counted by LL\_CACHE\_PRFM that causes a refill of the Last level cache, or any other data, instruction, or unified cache of this PE, from outside of those caches.

## 0x829C , LL\_CACHE\_WB, Last level cache write-back

The counter counts each write-back of data from the Last level cache to outside of the Level 1 to Last level caches.

For example:

- Awrite-back of a dirty cache line to memory.
- Awrite-back of a recently fetched cache line that has not been allocated to the Last level cache.

Each write-back is counted once, even if multiple accesses are required to complete the write-back.

It is IMPLEMENTATION DEFINED whether the counter counts:

- Atransfer of a dirty cache line from the Last level cache to outside of Level 1 to Last level caches made as a result of a coherency request.
- Write-backs made as a result of cache maintenance instructions.

The counter does not count:

- The invalidation of a cache line without any write-back to outside of the Level 1 to Last level caches or memory.
- Writes that write through the Last level cache to outside of the Level 1 to Last level caches.
- Transfers of data from the Last level cache to another cache to satisfy a refill of the other cache.

Awrite-back is attributable to the agent that generated the request that caused the write-back. This might not be the same agent that caused the data being written back to be allocated into the cache.

An Unattributable write-back event occurs when a requestor outside of the PE makes a coherency request that results in write-back. If the cache is shared, then an Unattributable write-back event is not counted. If the cache is not shared, then the event is counted.

It is IMPLEMENTATION DEFINED whether a write of a whole cache line that is not the result of the eviction of a line from the cache, is counted. For example, this applies when the PE determines software is streaming writes to memory and does not allocate lines to the cache, or by a DC ZVA operation.

## 0x829D , LL\_CACHE\_WR, Last level cache access, write

If the LL\_CACHE\_RW event is implemented, the counter counts each access counted by LL\_CACHE\_RW that is a Memory-write operation.

If the LL\_CACHE\_RW event is not implemented, the counter counts each access counted by LL\_CACHE that is a Memory-write operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x829F , LL\_CACHE\_REFILL\_WR, Last level cache refill, write

The counter counts each access counted by both LL\_CACHE\_REFILL and LL\_CACHE\_WR.

That is, every refill of the Last level cache counted by LL\_CACHE\_REFILL that is caused by a Memory-write operation.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x82A0 , MEM\_ACCESS\_RW, Data memory access, demand access

The counter counts each access counted by MEM\_ACCESS that is a demand Memory-read operation or demand Memory-write operation.

This includes accesses made by speculative instructions.

## 0x82A1 , INST\_FETCH\_RD, Instruction memory access, demand fetch

The counter counts each fetch counted by INST\_FETCH that is a demand Instruction memory access.

This includes any fetch made for a speculative instruction.

## 0x82A2 , MEM\_ACCESS\_PRFM, Data memory access, software prefetch

The counter counts each access counted by MEM\_ACCESS that is due to a prefetch instruction.

## 0x82A3 , INST\_FETCH\_PRFM, Instruction memory access, software prefetch

The counter counts each fetch counted by INST\_FETCH that is due to a prefetch instruction.

## 0x82B0 , L1I\_CACHE\_MISS\_RETIRED, Instruction architecturally executed, miss in Level 1 instruction cache

The counter counts each instruction architecturally executed counted by INST\_RETIRED that missed in Level 1 instruction or unified cache when fetched.

## 0x82B1 , L2I\_CACHE\_MISS\_RETIRED, Instruction architecturally executed, miss in Level 2 instruction cache

The counter counts each instruction architecturally executed counted by INST\_RETIRED that missed in Level 2 instruction or unified cache when fetched.

## 0x82B4 , L1D\_CACHE\_MISS\_LD\_RETIRED, Load instruction architecturally executed, miss in Level 1 data cache

The counter counts each architecturally executed instruction counted by L1D\_CACHE\_MISS\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x82B5 , L2D\_CACHE\_MISS\_LD\_RETIRED, Load instruction architecturally executed, miss in Level 2 data cache

The counter counts each architecturally executed instruction counted by L2D\_CACHE\_MISS\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x82B6 , L3D\_CACHE\_MISS\_LD\_RETIRED, Load instruction architecturally executed, miss in Level 3 data cache

The counter counts each architecturally executed instruction counted by L3D\_CACHE\_MISS\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x82B7 , LL\_CACHE\_MISS\_LD\_RETIRED, Load instruction architecturally executed, miss in Last level cache

The counter counts each architecturally executed instruction counted by LL\_CACHE\_MISS\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x82B8 , L1D\_CACHE\_MISS\_ST\_RETIRED, Store instruction architecturally executed, miss in Level 1 data cache

The counter counts each architecturally executed instruction counted by L1D\_CACHE\_MISS\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x82B9 , L2D\_CACHE\_MISS\_ST\_RETIRED, Store instruction architecturally executed, miss in Level 2 data cache

The counter counts each architecturally executed instruction counted by L2D\_CACHE\_MISS\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x82BA , L3D\_CACHE\_MISS\_ST\_RETIRED, Store instruction architecturally executed, miss in Level 3 data cache

The counter counts each architecturally executed instruction counted by L3D\_CACHE\_MISS\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x82BB , LL\_CACHE\_MISS\_ST\_RETIRED, Store instruction architecturally executed, miss in Last level cache

The counter counts each architecturally executed instruction counted by LL\_CACHE\_MISS\_LDST\_RETIRED that is a Memory-writing instruction.

0x82BC , L1D\_CACHE\_MISS\_LDST\_RETIRED, Load or store instruction architecturally executed, miss in Level 1 data cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by LDST\_ANY\_RETIRED that missed in Level 1 data or unified cache.

0x82BD , L2D\_CACHE\_MISS\_LDST\_RETIRED, Load or store instruction architecturally executed, miss in Level 2 data cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by LDST\_ANY\_RETIRED that missed in Level 2 data or unified cache.

0x82BE , L3D\_CACHE\_MISS\_LDST\_RETIRED, Load or store instruction architecturally executed, miss in Level 3 data cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by LDST\_ANY\_RETIRED that missed in Level 3 data or unified cache.

0x82BF , LL\_CACHE\_MISS\_LDST\_RETIRED, Load or store instruction architecturally executed, miss in Last level cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by LDST\_ANY\_RETIRED that missed in Last level cache.

0x82C4 , L1D\_CACHE\_HITM\_LD\_RETIRED, Load instruction architecturally executed, hit modified data in Level 1 data cache

The counter counts each architecturally executed instruction counted by L1D\_CACHE\_HITM\_LDST\_RETIRED that is a Memory-reading instruction.

0x82C5 , L2D\_CACHE\_HITM\_LD\_RETIRED, Load instruction architecturally executed, hit modified data in Level 2 data cache

The counter counts each architecturally executed instruction counted by L2D\_CACHE\_HITM\_LDST\_RETIRED that is a Memory-reading instruction.

0x82C6 , L3D\_CACHE\_HITM\_LD\_RETIRED, Load instruction architecturally executed, hit modified data in Level 3 data cache

The counter counts each architecturally executed instruction counted by L3D\_CACHE\_HITM\_LDST\_RETIRED that is a Memory-reading instruction.

0x82C7 , LL\_CACHE\_HITM\_LD\_RETIRED, Load instruction architecturally executed, hit modified data in Last level cache

The counter counts each architecturally executed instruction counted by LL\_CACHE\_HITM\_LDST\_RETIRED that is a Memory-reading instruction.

0x82C8 , L1D\_CACHE\_HITM\_ST\_RETIRED, Store instruction architecturally executed, hit modified data in Level 1 data cache

The counter counts each architecturally executed instruction counted by L1D\_CACHE\_HITM\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x82C9 , L2D\_CACHE\_HITM\_ST\_RETIRED, Store instruction architecturally executed, hit modified data in Level 2 data cache

The counter counts each architecturally executed instruction counted by L2D\_CACHE\_HITM\_LDST\_RETIRED that is a Memory-writing instruction.

0x82CA , L3D\_CACHE\_HITM\_ST\_RETIRED, Store instruction architecturally executed, hit modified data in Level 3 data cache

The counter counts each architecturally executed instruction counted by L3D\_CACHE\_HITM\_LDST\_RETIRED that is a Memory-writing instruction.

0x82CB , LL\_CACHE\_HITM\_ST\_RETIRED, Store instruction architecturally executed, hit modified data in Last level cache

The counter counts each architecturally executed instruction counted by LL\_CACHE\_HITM\_LDST\_RETIRED that is a Memory-writing instruction.

0x82CC , L1D\_CACHE\_HITM\_LDST\_RETIRED, Load or store instruction architecturally executed, hit modified data in Level 1 data cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by L1D\_CACHE\_HIT\_LDST\_RETIRED that hit modified data in Level 1 data or unified cache.

0x82CD , L2D\_CACHE\_HITM\_LDST\_RETIRED, Load or store instruction architecturally executed, hit modified data in Level 2 data cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by L2D\_CACHE\_HIT\_LDST\_RETIRED that hit modified data in Level 2 data or unified cache.

0x82CE , L3D\_CACHE\_HITM\_LDST\_RETIRED, Load or store instruction architecturally executed, hit modified data in Level 3 data cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by L3D\_CACHE\_HIT\_LDST\_RETIRED that hit modified data in Level 3 data or unified cache.

## 0x82CF , LL\_CACHE\_HITM\_LDST\_RETIRED, Load or store instruction architecturally executed, hit modified data in Last level cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by LL\_CACHE\_HIT\_LDST\_RETIRED that hit modified data in Last level cache.

## 0x82D0 , L1I\_LFB\_HIT\_RETIRED, Instruction architecturally executed, line-fill buffer hit in Level 1 instruction cache

The counter counts each instruction architecturally executed counted by L1I\_CACHE\_HIT\_RETIRED that hit a recently fetched line in Level 1 instruction or unified cache when fetched.

## 0x82D1 , L2I\_LFB\_HIT\_RETIRED, Instruction architecturally executed, line-fill buffer hit in Level 2 instruction cache

The counter counts each instruction architecturally executed counted by L2I\_CACHE\_HIT\_RETIRED that hit a recently fetched line in Level 2 instruction or unified cache when fetched.

## 0x82D4 , L1D\_LFB\_HIT\_LD\_RETIRED, Load instruction architecturally executed, line-fill buffer hit in Level 1 data cache

The counter counts each architecturally executed instruction counted by L1D\_LFB\_HIT\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x82D5

- , L2D\_LFB\_HIT\_LD\_RETIRED, Load instruction architecturally executed, line-fill buffer hit in Level 2 data cache The counter counts each architecturally executed instruction counted by L2D\_LFB\_HIT\_LDST\_RETIRED that is a

Memory-reading instruction.

- 0x82D6 , L3D\_LFB\_HIT\_LD\_RETIRED, Load instruction architecturally executed, line-fill buffer hit in Level 3 data cache

The counter counts each architecturally executed instruction counted by L3D\_LFB\_HIT\_LDST\_RETIRED that is a Memory-reading instruction.

- 0x82D7 , LL\_LFB\_HIT\_LD\_RETIRED, Load instruction architecturally executed, line-fill buffer hit in Last level cache

The counter counts each architecturally executed instruction counted by LL\_LFB\_HIT\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x82D8

- , L1D\_LFB\_HIT\_ST\_RETIRED, Store instruction architecturally executed, line-fill buffer hit in Level 1 data cache The counter counts each architecturally executed instruction counted by L1D\_LFB\_HIT\_LDST\_RETIRED that is a

Memory-writing instruction.

- 0x82D9 , L2D\_LFB\_HIT\_ST\_RETIRED, Store instruction architecturally executed, line-fill buffer hit in Level 2 data cache

The counter counts each architecturally executed instruction counted by L2D\_LFB\_HIT\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x82DA

## 0x82DB

- , L3D\_LFB\_HIT\_ST\_RETIRED, Store instruction architecturally executed, line-fill buffer hit in Level 3 data cache

The counter counts each architecturally executed instruction counted by L3D\_LFB\_HIT\_LDST\_RETIRED that is a Memory-writing instruction.

- , LL\_LFB\_HIT\_ST\_RETIRED, Store instruction architecturally executed, line-fill buffer hit in Last level cache The counter counts each architecturally executed instruction counted by LL\_LFB\_HIT\_LDST\_RETIRED that is a

Memory-writing instruction.

0x82DC , L1D\_LFB\_HIT\_LDST\_RETIRED, Load or store instruction architecturally executed, line-fill buffer hit in Level 1 data cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by L1D\_CACHE\_HIT\_LDST\_RETIRED that hit a recently fetched line in Level 1 data or unified cache.

## 0x82DD , L2D\_LFB\_HIT\_LDST\_RETIRED, Load or store instruction architecturally executed, line-fill buffer hit in Level 2 data cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by L2D\_CACHE\_HIT\_LDST\_RETIRED that hit a recently fetched line in Level 2 data or unified cache.

## 0x82DE , L3D\_LFB\_HIT\_LDST\_RETIRED, Load or store instruction architecturally executed, line-fill buffer hit in Level 3 data cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by L3D\_CACHE\_HIT\_LDST\_RETIRED that hit a recently fetched line in Level 3 data or unified cache.

## 0x82DF , LL\_LFB\_HIT\_LDST\_RETIRED, Load or store instruction architecturally executed, line-fill buffer hit in Last level cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by LL\_CACHE\_HIT\_LDST\_RETIRED that hit a recently fetched line in Last level cache.

## 0x82E0 , L1I\_CACHE\_HIT\_RETIRED, Instruction architecturally executed, hit in Level 1 instruction cache

The counter counts each instruction architecturally executed counted by INST\_RETIRED that hit in Level 1 instruction or unified cache when fetched.

## 0x82E1 , L2I\_CACHE\_HIT\_RETIRED, Instruction architecturally executed, hit in Level 2 instruction cache

The counter counts each instruction architecturally executed counted by INST\_RETIRED that hit in Level 2 instruction or unified cache when fetched.

## 0x82E4 , L1D\_CACHE\_HIT\_LD\_RETIRED, Load instruction architecturally executed, hit in Level 1 data cache

The counter counts each architecturally executed instruction counted by L1D\_CACHE\_HIT\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x82E5 , L2D\_CACHE\_HIT\_LD\_RETIRED, Load instruction architecturally executed, hit in Level 2 data cache

The counter counts each architecturally executed instruction counted by L2D\_CACHE\_HIT\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x82E6 , L3D\_CACHE\_HIT\_LD\_RETIRED, Load instruction architecturally executed, hit in Level 3 data cache

The counter counts each architecturally executed instruction counted by L3D\_CACHE\_HIT\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x82E7 , LL\_CACHE\_HIT\_LD\_RETIRED, Load instruction architecturally executed, hit in Last level cache

The counter counts each architecturally executed instruction counted by LL\_CACHE\_HIT\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x82E8 , L1D\_CACHE\_HIT\_ST\_RETIRED, Store instruction architecturally executed, hit in Level 1 data cache

The counter counts each architecturally executed instruction counted by L1D\_CACHE\_HIT\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x82E9 , L2D\_CACHE\_HIT\_ST\_RETIRED, Store instruction architecturally executed, hit in Level 2 data cache

The counter counts each architecturally executed instruction counted by L2D\_CACHE\_HIT\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x82EA , L3D\_CACHE\_HIT\_ST\_RETIRED, Store instruction architecturally executed, hit in Level 3 data cache

The counter counts each architecturally executed instruction counted by L3D\_CACHE\_HIT\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x82EB , LL\_CACHE\_HIT\_ST\_RETIRED, Store instruction architecturally executed, hit in Last level cache

The counter counts each architecturally executed instruction counted by LL\_CACHE\_HIT\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x82EC , L1D\_CACHE\_HIT\_LDST\_RETIRED, Load or store instruction architecturally executed, hit in Level 1 data cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by LDST\_ANY\_RETIRED that hit in Level 1 data or unified cache.

## 0x82ED , L2D\_CACHE\_HIT\_LDST\_RETIRED, Load or store instruction architecturally executed, hit in Level 2 data cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by LDST\_ANY\_RETIRED that hit in Level 2 data or unified cache.

## 0x82EE , L3D\_CACHE\_HIT\_LDST\_RETIRED, Load or store instruction architecturally executed, hit in Level 3 data cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by LDST\_ANY\_RETIRED that hit in Level 3 data or unified cache.

## 0x82EF , LL\_CACHE\_HIT\_LDST\_RETIRED, Load or store instruction architecturally executed, hit in Last level cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by LDST\_ANY\_RETIRED that hit in Last level cache.

## 0x82F0 , ITLB\_HIT\_RETIRED, Instruction architecturally executed, no translation table walk

The counter counts each instruction which was architecturally executed counted by INST\_RETIRED that did not cause a refill of an instruction TLB involving at least one translation table walk access.

The counter does not count the instruction which was architecturally executed if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the instruction which was architecturally executed if the access generates a Translation fault for any other reason.

## 0x82F1 , DTLB\_HIT\_LD\_RETIRED, Load instruction architecturally executed, no translation table walk

The counter counts each Memory-reading instruction architecturally executed counted by DTLB\_HIT\_LDST\_RETIRED that did not cause a refill of a data TLB involving at least one translation table walk access.

## 0x82F2 , DTLB\_HIT\_ST\_RETIRED, Store instruction architecturally executed, no translation table walk

The counter counts each Memory-writing instruction architecturally executed counted by DTLB\_HIT\_LDST\_RETIRED that did not cause a refill of a data TLB involving at least one translation table walk access.

## 0x82F3 , DTLB\_HIT\_LDST\_RETIRED, Load or store instruction architecturally executed, no translation table walk

The counter counts each Memory-reading instruction or Memory-writing instruction architecturally executed counted by LDST\_ANY\_RETIRED that did not cause a refill of a data TLB involving at least one translation table walk access.

## 0x82F4 , ITLB\_WALK\_RETIRED, Instruction architecturally executed, at least one translation table walk

The counter counts each instruction which was architecturally executed counted by INST\_RETIRED that caused a refill of an instruction TLB involving at least one translation table walk access.

The counter does not count the instruction which was architecturally executed if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the instruction which was architecturally executed if the access generates a Translation fault for any other reason.

## 0x82F5 , DTLB\_WALK\_LD\_RETIRED, Load instruction architecturally executed, at least one translation table walk

The counter counts each Memory-reading instruction architecturally executed counted by DTLB\_WALK\_LDST\_RETIRED that caused a refill of a data TLB involving at least one translation table walk access.

The counter does not count the Memory-reading instruction architecturally executed if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the Memory-reading instruction architecturally executed if the access generates a Translation fault for any other reason.

## 0x82F6 , DTLB\_WALK\_ST\_RETIRED, Store instruction architecturally executed, at least one translation table walk

The counter counts each Memory-writing instruction architecturally executed counted by DTLB\_WALK\_LDST\_RETIRED that caused a refill of a data TLB involving at least one translation table walk access.

The counter does not count the Memory-writing instruction architecturally executed if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the Memory-writing instruction architecturally executed if the access generates a Translation fault for any other reason.

## 0x82F7 , DTLB\_WALK\_LDST\_RETIRED, Load or store instruction architecturally executed, at least one translation table walk

The counter counts each Memory-reading instruction or Memory-writing instruction architecturally executed counted by LDST\_ANY\_RETIRED that caused a refill of a data TLB involving at least one translation table walk access.

The counter does not count the Memory-reading instruction or Memory-writing instruction architecturally executed if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the Memory-reading instruction or Memory-writing instruction architecturally executed if the access generates a Translation fault for any other reason.

## 0x82F8 , DTLB\_WALK\_PRF, Data TLB prefetch, with at least one translation table walk

The counter counts each software prefetch or hardware prefetch access counted by L1D\_TLB\_PRF that causes a refill or update of a data or unified TLB involving at least one translation table walk access.

The counter does not count the software prefetch or hardware prefetch access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the software prefetch or hardware prefetch access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x82F9 , ITLB\_WALK\_PRF, Instruction TLB prefetch, with at least one translation table walk

The counter counts each software prefetch or hardware prefetch access counted by L1I\_TLB\_PRF that causes a refill or update of an instruction TLB involving at least one translation table walk access.

The counter does not count the software prefetch or hardware prefetch access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the software prefetch or hardware prefetch access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x82FA , DTLB\_WALK\_HWPRF, Data TLB hardware prefetch, with at least one translation table walk

The counter counts each hardware prefetch access counted by L1D\_TLB\_HWPRF that causes a refill or update of a data or unified TLB involving at least one translation table walk access.

The counter does not count the hardware prefetch access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the hardware prefetch access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x82FB , ITLB\_WALK\_HWPRF, Instruction TLB hardware prefetch, with at least one translation table walk

The counter counts each hardware prefetch access counted by L1I\_TLB\_HWPRF that causes a refill or update of an instruction TLB involving at least one translation table walk access.

The counter does not count the hardware prefetch access if any of the following are true:

- The access is due to a TLB maintenance instruction.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the hardware prefetch access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x82FC , L1D\_TLB\_PRF, Level 1 data TLB access, prefetch

The counter counts each access counted by L1D\_TLB that is due to a prefetch instruction, or hardware prefetch.

The counter does not count the access if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x82FD , L1I\_TLB\_PRF, Level 1 instruction TLB access, prefetch

The counter counts each access counted by L1I\_TLB that is due to a prefetch instruction, or hardware prefetch.

The counter does not count the access if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x82FE , L1D\_TLB\_HWPRF, Level 1 data TLB access, hardware prefetch

The counter counts each access counted by L1D\_TLB\_PRF that is due to a hardware prefetch.

The counter does not count the access if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x82FF , L1I\_TLB\_HWPRF, Level 1 instruction TLB access, hardware prefetch

The counter counts each access counted by L1I\_TLB\_PRF that is due to a hardware prefetch.

The counter does not count the access if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8304 , DSNP\_HITM\_LD\_RETIRED, Load instruction architecturally executed, snoop hit

The counter counts each architecturally executed instruction counted by DSNP\_HITM\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x8305 , DSNP\_HITM\_NEAR\_LD\_RETIRED, Load instruction architecturally executed, snoop hit in near cache

The counter counts each architecturally executed instruction counted by DSNP\_HITM\_NEAR\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x8306 , DSNP\_HITM\_FAR\_LD\_RETIRED, Load instruction architecturally executed, snoop hit in far cache

The counter counts each architecturally executed instruction counted by DSNP\_HITM\_FAR\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x8307 , DSNP\_HITM\_REMOTE\_LD\_RETIRED, Load instruction architecturally executed, snoop hit in remote cache

The counter counts each architecturally executed instruction counted by DSNP\_HITM\_REMOTE\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x8308 , DSNP\_HITM\_ST\_RETIRED, Store instruction architecturally executed, snoop hit

The counter counts each architecturally executed instruction counted by DSNP\_HITM\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x8309 , DSNP\_HITM\_NEAR\_ST\_RETIRED, Store instruction architecturally executed, snoop hit in near cache

The counter counts each architecturally executed instruction counted by DSNP\_HITM\_NEAR\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x830A , DSNP\_HITM\_FAR\_ST\_RETIRED, Store instruction architecturally executed, snoop hit in far cache

The counter counts each architecturally executed instruction counted by DSNP\_HITM\_FAR\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x830B , DSNP\_HITM\_REMOTE\_ST\_RETIRED, Store instruction architecturally executed, snoop hit in remote cache

The counter counts each architecturally executed instruction counted by DSNP\_HITM\_REMOTE\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x830C , DSNP\_HITM\_LDST\_RETIRED, Load or store instruction architecturally executed, snoop hit

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by LDST\_ANY\_RETIRED that hit modified data in a data cache outside the cache hierarchy of this PE.

## 0x830D , DSNP\_HITM\_NEAR\_LDST\_RETIRED, Load or store instruction architecturally executed, snoop hit in near cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by DSNP\_HITM\_LDST\_RETIRED that hit modified data outside of the cache hierarchy of this PE in the local PE cluster.

## 0x830E , DSNP\_HITM\_FAR\_LDST\_RETIRED, Load or store instruction architecturally executed, snoop hit in far cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by DSNP\_HITM\_LDST\_RETIRED that hit modified data outside the local PE cluster on the same device.

## 0x830F , DSNP\_HITM\_REMOTE\_LDST\_RETIRED, Load or store instruction architecturally executed, snoop hit in remote cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by DSNP\_HITM\_LDST\_RETIRED that hit modified data on a remote device.

## 0x8310 , ISNP\_HIT\_RETIRED, Instruction architecturally executed, instruction fetch snoop hit

The counter counts each instruction architecturally executed counted by INST\_RETIRED that hit in an instruction cache outside the cache hierarchy of this PE when fetched.

## 0x8311 , ISNP\_HIT\_NEAR\_RETIRED, Instruction architecturally executed, instruction fetch snoop hit in near cache

The counter counts each instruction architecturally executed counted by ISNP\_HIT\_RETIRED that hit outside of the cache hierarchy of this PE in the local PE cluster when fetched.

## 0x8312 , ISNP\_HIT\_FAR\_RETIRED, Instruction architecturally executed, instruction fetch snoop hit in far cache

The counter counts each instruction architecturally executed counted by ISNP\_HIT\_RETIRED that hit outside the local PE cluster on the same device when fetched.

## 0x8313 , ISNP\_HIT\_REMOTE\_RETIRED, Instruction architecturally executed, instruction fetch snoop hit in remote cache

The counter counts each instruction architecturally executed counted by ISNP\_HIT\_RETIRED that hit on a remote device when fetched.

## 0x8314 , DSNP\_HIT\_LD\_RETIRED, Load instruction architecturally executed, snoop hit

The counter counts each architecturally executed instruction counted by DSNP\_HIT\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x8315 , DSNP\_HIT\_NEAR\_LD\_RETIRED, Load instruction architecturally executed, snoop hit in near cache

The counter counts each architecturally executed instruction counted by DSNP\_HIT\_NEAR\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x8316 , DSNP\_HIT\_FAR\_LD\_RETIRED, Load instruction architecturally executed, snoop hit in far cache

The counter counts each architecturally executed instruction counted by DSNP\_HIT\_FAR\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x8317 , DSNP\_HIT\_REMOTE\_LD\_RETIRED, Load instruction architecturally executed, snoop hit in remote cache

The counter counts each architecturally executed instruction counted by DSNP\_HIT\_REMOTE\_LDST\_RETIRED that is a Memory-reading instruction.

## 0x8318 , DSNP\_HIT\_ST\_RETIRED, Store instruction architecturally executed, snoop hit

The counter counts each architecturally executed instruction counted by DSNP\_HIT\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x8319 , DSNP\_HIT\_NEAR\_ST\_RETIRED, Store instruction architecturally executed, snoop hit in near cache

The counter counts each architecturally executed instruction counted by DSNP\_HIT\_NEAR\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x831A , DSNP\_HIT\_FAR\_ST\_RETIRED, Store instruction architecturally executed, snoop hit in far cache

The counter counts each architecturally executed instruction counted by DSNP\_HIT\_FAR\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x831B , DSNP\_HIT\_REMOTE\_ST\_RETIRED, Store instruction architecturally executed, snoop hit in remote cache

The counter counts each architecturally executed instruction counted by DSNP\_HIT\_REMOTE\_LDST\_RETIRED that is a Memory-writing instruction.

## 0x831C , DSNP\_HIT\_LDST\_RETIRED, Load or store instruction architecturally executed, snoop hit

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by LDST\_ANY\_RETIRED that hit in a data cache outside the cache hierarchy of this PE.

## 0x831D , DSNP\_HIT\_NEAR\_LDST\_RETIRED, Load or store instruction architecturally executed, snoop hit in near cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by DSNP\_HIT\_LDST\_RETIRED that hit outside of the cache hierarchy of this PE in the local PE cluster.

## 0x831E , DSNP\_HIT\_FAR\_LDST\_RETIRED, Load or store instruction architecturally executed, snoop hit in far cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by DSNP\_HIT\_LDST\_RETIRED that hit outside the local PE cluster on the same device.

## 0x831F , DSNP\_HIT\_REMOTE\_LDST\_RETIRED, Load or store instruction architecturally executed, snoop hit in remote cache

The counter counts each architecturally executed Memory-reading instruction or Memory-writing instruction counted by DSNP\_HIT\_LDST\_RETIRED that hit on a remote device.

## 0x8320 , L1D\_CACHE\_REFILL\_PERCYC, Level 1 data or unified cache refills in progress

The counter increments by the number of Level 1 data or unified cache refills counted by L1D\_CACHE\_REFILL in progress on each Processor cycle.

The ratio L1D\_CACHE\_REFILL\_PERCYC ÷ L1D\_CACHE\_REFILL is the mean duration of Level 1 data or unified cache refills in Processor cycles.

## 0x8321 , L2D\_CACHE\_REFILL\_PERCYC, Level 2 data or unified cache refills in progress

The counter increments by the number of Level 2 data or unified cache refills counted by L2D\_CACHE\_REFILL in progress on each Processor cycle.

The ratio L2D\_CACHE\_REFILL\_PERCYC ÷ L2D\_CACHE\_REFILL is the mean duration of Level 2 data or unified cache refills in Processor cycles.

## 0x8322 , L3D\_CACHE\_REFILL\_PERCYC, Level 3 data or unified cache refills in progress

The counter increments by the number of Level 3 data or unified cache refills counted by L3D\_CACHE\_REFILL in progress on each Processor cycle.

The ratio L3D\_CACHE\_REFILL\_PERCYC ÷ L3D\_CACHE\_REFILL is the mean duration of Level 3 data or unified cache refills in Processor cycles.

## 0x8324 , L1I\_CACHE\_REFILL\_PERCYC, Level 1 instruction or unified cache refills in progress

The counter increments by the number of Level 1 instruction or unified cache refills counted by L1I\_CACHE\_REFILL in progress on each Processor cycle.

The ratio L1I\_CACHE\_REFILL\_PERCYC ÷ L1I\_CACHE\_REFILL is the mean duration of Level 1 instruction or unified cache refills in Processor cycles.

## 0x8325 , L2I\_CACHE\_REFILL\_PERCYC, Level 2 instruction or unified cache refills in progress

The counter increments by the number of Level 2 instruction or unified cache refills counted by L2I\_CACHE\_REFILL in progress on each Processor cycle.

The ratio L2I\_CACHE\_REFILL\_PERCYC ÷ L2I\_CACHE\_REFILL is the mean duration of Level 2 instruction or unified cache refills in Processor cycles.

## 0x8328 , REMOTE\_CACHE\_HIT\_RD, Remote cache demand access hit, read

The counter counts each cache hit on a remote device due to a demand read.

## 0x8329 , REMOTE\_CACHE\_HITM\_RD, Remote cache demand access hit modified, read

The counter counts each cache hit on a remote device counted by REMOTE\_CACHE\_HIT\_RD that accesses a previously modified location.

## 0x832A , REMOTE\_LFB\_HIT\_RD, Remote cache demand access line-fill buffer hit, read

The counter counts each cache hit on a remote device counted by REMOTE\_CACHE\_HIT\_RD that hits a recently fetched line.

That is, the read hits a cache line that is in the process of being loaded into the cache attached to a remote device, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x832B , REMOTE\_CACHE\_HIT\_PRFM, Remote cache software prefetch hit

The counter counts each cache hit on a remote device due to a software prefetch.

## 0x832C , STALL\_BACKEND\_ATOMIC\_FP, Backend stall cycles, atomic in-memory floating-point load or store

The counter counts each cycle counted by STALL\_BACKEND\_ATOMIC when the backend is processing an Atomic in-memory floating-point operation.

## 0x832D , LSE\_FP\_LD\_SPEC, Atomic in-memory floating-point Operation speculatively executed, load

The counter counts each in-memory floating-point operation counted by LSE\_FP\_LDST\_SPEC that atomically loads a value from memory, operates on that value, stores the result of the operation to memory, and writes the initially loaded value to a destination register.

This includes operations with acquire, release, and neither release nor acquire semantics.

## 0x832E , LSE\_FP\_ST\_SPEC, Atomic in-memory floating-point Operation speculatively executed, store

The counter counts each in-memory floating-point operation counted by LSE\_FP\_LDST\_SPEC that atomically loads a value from memory, operates on that value, stores the result of the operation to memory, and does not write the initially loaded value to a destination register.

This includes operations with acquire, release, and neither release nor acquire semantics.

## 0x832F , LSE\_FP\_LDST\_SPEC, Atomic in-memory floating-point Operation speculatively executed, load or store

The counter counts each in-memory floating-point operation counted by LSE\_LDST\_SPEC that atomically loads a value from memory, operates on the value, and stores the result of the operation to memory.

This includes operations with acquire, release, and neither release nor acquire semantics.

## 0x8330 , L1GCS\_CACHE, Level 1 GCS cache access

The counter counts each GCS data read operation or GCS data write operation that causes a cache access to at least a Level 1 cache.

Each access to a cache line is counted including the multiple accesses caused by single instructions such as GCSPUSHX or GCSPOPX . Each access to other Level 1 memory structures, for example refill buffers, write buffers, and write-back buffers, is also counted.

Accesses to a Level 1 cache due to a GCS hardware prefetcher as well are counted.

When there are separate GCS caching structures implemented:

- It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.
- Accesses that only update the cache status information for a cache entry without accessing the content of the cache entry are not counted.

## 0x8331 , L1GCS\_CACHE\_RW, Level 1 GCS cache demand access

The counter counts each access counted by L1GCS\_CACHE that is due to a demand Memory-read operation or demand Memory-write operation.

This includes accesses made by Speculatively executed instructions.

Arm recommends that this event is implemented if event L1GCS\_CACHE\_HWPRF is implemented.

## 0x8332 , L1GCS\_CACHE\_HWPRF, Level 1 GCS cache hardware prefetch

The counter counts each access counted by L1GCS\_CACHE that is due to a GCS hardware prefetcher.

## 0x8334 , L1GCS\_CACHE\_MISS, Level 1 GCS cache demand access miss

The counter counts each access counted by L1GCS\_CACHE\_RW that misses in the Level 1 caches causing an access to outside of the Level 1 caches of this PE.

## 0x8335 , L1GCS\_CACHE\_MISS\_RD, Level 1 GCS cache demand access read miss

The counter counts each access counted by L1GCS\_CACHE\_MISS that is also a Memory-read operation.

It is IMPLEMENTATION DEFINED whether accesses that result from cache maintenance instructions are counted.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

Arm recommends that this event is implemented if event L1GCS\_CACHE is implemented.

## 0x8336 , L1GCS\_CACHE\_HIT\_RW, Level 1 GCS cache demand access hit

The counter counts each access counted by L1GCS\_CACHE\_RW that hits in a Level 1 cache.

## 0x8337 , L1GCS\_CACHE\_HIT\_RW\_FHWPRF, Level 1 GCS cache demand access first hit, fetched by GCS hardware prefetcher

The counter counts each demand access first hit counted by L1GCS\_CACHE\_HIT\_RW where the cache line was fetched by a GCS hardware prefetcher.

That is, the L1GCS\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

Only the first hit by a demand access is counted. After this event is generated for a cache line, the event is not generated again for the same cache line while it remains in the cache.

## 0x8338 , L1GCS\_CACHE\_REFILL, Level 1 GCS cache refill

The counter counts each access counted by L1GCS\_CACHE that causes a refill of a Level 1 cache from outside of the Level 1 cache.

Arefill includes any access that causes data to be fetched from outside of the Level 1 caches, even if the data is ultimately not allocated into the Level 1 cache. For example, data might be fetched into a buffer but then discarded, rather than being allocated into a cache. These buffers are treated as part of the cache.

For example, the counter counts accesses to the Level 1 cache that cause a refill that is satisfied by fetching data from memory, a Level 2 cache, or a Level 1 cache of another PE.

The counter does not count accesses that:

- Miss in the cache but are satisfied by the refill of a previous miss and do not cause a new refill, even if that previous refill is not complete at the time of the miss.
- Miss in the cache but do not generate a refill, such as a write through the cache.

If the cache is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the cache is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8339 , L1GCS\_CACHE\_REFILL\_HWPRF, Level 1 GCS cache refill, hardware prefetch

The counter counts each hardware prefetch counted by L1GCS\_CACHE\_HWPRF that causes a refill of a Level 1 cache from outside of the Level 1 cache.

## 0x833A , L1GCS\_CACHE\_REFILL\_PERCYC, Level 1 GCS cache refills in progress

The counter increments by the number of Level 1 GCS cache refills counted by L1GCS\_CACHE\_REFILL in progress on each Processor cycle.

The ratio L1GCS\_CACHE\_REFILL\_PERCYC ÷ L1GCS\_CACHE\_REFILL is the mean duration of Level 1 GCS cache refills in Processor cycles.

## 0x833C , L1GCS\_LFB\_HIT\_RW, Level 1 GCS cache demand access line-fill buffer hit

The counter counts each demand access counted by L1GCS\_CACHE\_HIT\_RW that hits a recently fetched line in a Level 1 cache.

That is, the access hits a cache line that is in the process of being loaded into the Level 1 cache, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x833D , L1GCS\_LFB\_HIT\_RW\_FHWPRF, Level 1 GCS cache demand access line-fill buffer first hit, recently fetched by GCS hardware prefetcher

The counter counts each demand access line-fill buffer first hit counted by L1GCS\_LFB\_HIT\_RW where the cache line was fetched by a GCS hardware prefetcher.

That is, the access hits a cache line that is in the process of being loaded into the Level 1 cache, and so does not generate a new refill, but has to wait for the previous refill to complete, and the L1GCS\_CACHE\_REFILL\_HWPRF event was generated when the cache line was fetched into the cache.

## 0x833E , L1GCS\_CACHE\_INVAL, Level 1 GCS cache invalidate

The counter counts each invalidation of a cache line in a Level 1 GCS cache.

For example:

- Invalidation of a cache line because of a GCSB effect.
- Transfer of ownership of a cache line to another cache because of a coherency or refill request.

The counter does not count events if a cache refill of the Level 1 cache invalidates a line in the Level 1 cache.

Note

Software that uses this event must know whether the Level 1 cache is shared with other PEs. This event does not follow the general rule of Level 1 cache events of only counting Attributable events.

## 0x8340 , L1GCS\_TLB, Level 1 GCS TLB access

The counter counts each GCS data read operation or GCS data write operation that causes a TLB access to at least a Level 1 TLB.

Each access to a TLB entry is counted including multiple accesses caused by single instructions such as GCSPUSHX or GCSPOPX .

The counter does not count the access if the access is due to a TLB maintenance instruction.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8341 , L1GCS\_TLB\_RW, Level 1 GCS demand TLB access

The counter counts each access counted by L1GCS\_TLB that is due to a demand Memory-read operation or demand Memory-write operation.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8342 , L1GCS\_TLB\_HWPRF, Level 1 GCS demand TLB access, GCS hardware prefetch

The counter counts each access counted by L1GCS\_TLB that is due to a GCS hardware prefetch.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8344 , GCSTLB\_WALK, GCS TLB access with at least one translation table walk

The counter counts each access counted by L1GCS\_TLB that causes a refill of a TLB involving at least one translation table walk access.

This includes each complete or partial translation table walk that causes an access to memory, including to data or translation table walk caches.

Accesses that cause an update of an existing TLB entry involving at least one translation table walk access are counted.

The counter does not count the access if any of the following are true:

- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- The access is due to a TLB maintenance instruction.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

The counter does not count the access if any of the following are true:

- The access generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- FEAT\_E0PD is implemented and the access is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.
- FEAT\_SVE is implemented and the access is a non-fault access that fails because the applicable TCR\_ELx.NFDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the access if the access generates a Translation fault for any other reason.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8345 , GCSTLB\_WALK\_RW, GCS TLB demand access with at least one translation table walk

The counter counts each demand access counted by both GCSTLB\_WALK and L1GCS\_TLB\_RW.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8346 , GCSTLB\_WALK\_PERCYC, Translation table walks in progress

The counter increments by the number of translation table walks counted by GCSTLB\_WALK in progress on each Processor cycle.

The ratio GCSTLB\_WALK\_PERCYC ÷ GCSTLB\_WALK is the mean duration of translation table walks in Processor cycles.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8347 , GCSTLB\_WALK\_STEP, GCS TLB translation table walk, step

The counter counts each translation table walk access due to a refill of a TLB.

The translation table walk must be due to either GCS data read operation or GCS data write operation.

The event is Attributable to the access that missed in the TLB and caused the walk, not to the owner of the translation tables being accessed. For example, this means that if an EL0 access causes a translation table walk consisting of accesses to both stage 1 and stage 2 translation tables, all accesses are counted if event counting is allowed at EL0, regardless of whether event counting is allowed at EL1 and/or EL2.

The counter does not count the event if any of the following are true:

- The access causing the refill generates a Translation fault because the applicable TCR\_ELx.EPDy bit is 1.
- The access causing the refill is an unprivileged access that generates a Translation fault because the applicable TCR\_ELx.E0PDy bit is 1.

It is IMPLEMENTATION DEFINED whether the counter counts the event if the access causing the refill generates a Translation fault for any other reason.

Implementation of this optional event requires that FEAT\_E0PD is implemented.

If the TLB is shared and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 0, then the counter counts only events Attributable to the PE counting the event. For a multithreaded processor implementation, if the TLB is shared by PEs other than the PEs in the multithreaded processor and the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT for the counter is 1, then the counter counts only events Attributable to PEs in the multithreaded processor. In all other cases, it is IMPLEMENTATION DEFINED whether only events Attributable to the PE counting the event or all events are counted, and might depend on the Effective value of PMEVTYPER&lt;n&gt;\_EL0.MT.

## 0x8348 , SAMPLE\_FEED\_FP, Statistical Profiling sample taken, floating-point

The counter counts each sample counted by SAMPLE\_FEED that is a floating-point data-processing, load, or store operation.

The values of PMSFCR\_EL1.{FP,FT} and, if FEAT\_SPE\_EFT is implemented, PMSFCR\_EL1.FPm, are ignored when generating this event.

Samples that are removed by filtering, or discarded, and not written to the Profiling Buffer are counted.

## 0x8349 , SAMPLE\_FEED\_SIMD, Statistical Profiling sample taken, SIMD

The counter counts each sample counted by SAMPLE\_FEED that is a SIMD data-processing, load, or store operation.

The values of PMSFCR\_EL1.{SIMD,FT} and, if FEAT\_SPE\_EFT is implemented, PMSFCR\_EL1.SIMDm, are ignored when generating this event.

Samples that are removed by filtering, or discarded, and not written to the Profiling Buffer are counted.

## 0x8350 , STALL\_BACKEND\_L1GCS, Backend stall cycles, Level 1 GCS cache

The counter counts each cycle counted by STALL\_BACKEND\_MEMBOUND when there is a demand data miss in a first level cache.

The demand data miss must be due to either GCS data read operation or GCS data write operation.

The counter does not count the cycle if any of the following are true:

- The STALL\_BACKEND\_L2D event is implemented and there is a demand data miss in the second level of data or unified cache, meaning the STALL\_BACKEND\_L2D event counts the cycle.
- There is a demand data miss in the last level of data or unified cache within the PE clock domain, meaning the STALL\_BACKEND\_MEM event counts the cycle.

Implementation of this optional event requires that the first level cache is implemented within the PE clock domain and is not the last level cache within the PE clock domain.

Implementation of this optional event requires implementing L1GCS\_CACHE event.

Note

It is possible that both the events STALL\_BACKEND\_L1GCS and STALL\_BACKEND\_L1D events may be counted on a same cycle.

## 0x8351 , STALL\_BACKEND\_GCSTLB, Backend stall cycles, GCS TLB

The counter counts each cycle counted by STALL\_BACKEND\_MEMBOUND when there is a demand data miss in a TLB.

The demand data miss must be due to translation of a GCS data read operation or GCS data write operation.

Implementation of this optional event requires implementing L1GCS\_TLB event.

## 0x8352 , SME\_FP\_SPEC, Operation speculatively executed, SME floating-point, data-processing

The counter counts each speculatively executed floating-point data-processing operation counted by SE\_FP\_SPEC due to an instruction which reads from or writes to any part of the ZA array.

## 0x8353 , SE\_FP\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD floating-point, dataprocessing

The counter counts each speculatively executed floating-point data-processing operation counted by FP\_SPEC due to an A64 Advanced SIMD, SVE, or SME operation.

That is, each operation counted by ASE\_FP\_SPEC, SVE\_FP\_SPEC, or SME\_FP\_SPEC.

It is IMPLEMENTATION DEFINED which floating-point data-processing operations are counted in AArch32 state.

## 0x8354 , SVE\_CMP\_IGRANULE\_SPEC, Operation speculatively executed, SVE in-granule compare

The counter counts each speculatively executed SVE in-granule comparison operation counted by SVE\_SPEC due to an instruction that detects or counts matching elements between segments in vectors.

This includes operations which are due to the following instructions:

- SVE: MATCH , NMATCH , or HISTSEG .

## 0x8355 , SVE\_CMP\_XGRANULE\_SPEC, Operation speculatively executed, SVE cross-granule compare

The counter counts each speculatively executed SVE cross-granule comparison operation counted by SVE\_SPEC due to due to an instruction that detects or counts matching elements between vectors.

This includes operations which are due to the following instructions:

- SVE: HISTCNT .

## 0x8356 , SVE\_BITPERM\_SPEC, Operation speculatively executed, SVE in-element permute

The counter counts each speculatively executed SVE permute operation counted by SVE\_SPEC due to an instruction that permutes bits within elements of a vector.

This includes operations which are due to the following instructions:

- SVE: BDEP , BEXT , or BGRP .

## 0x835C , SME\_SPEC, Operation speculatively executed, SME data processing

The counter counts each operation counted by SE\_SPEC that is an SME data-processing operation.

An SME data-processing operation is any operation due to an instruction that operates on the ZA or ZT registers that is not any of the following:

- Aload or store operation. These are counted by SME\_INST\_SPEC.
- Anon-SIMD SME operation.

Operations due to data-processing instructions defined by FEAT\_SME which involve the SVE registers but do not involve any ZA or ZT registers are counted as SVE data-processing operations.

## 0x835D , SE\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME data processing

The counter counts each operation counted by INST\_SPEC that is an Advanced SIMD, SVE, or SME data-processing operation.

See ASE\_SVE\_SPEC and SME\_SPEC for these classifications.

## 0x835E , SME\_INST\_SPEC, Operation speculatively executed, SME

The counter counts each speculatively executed operation counted by SE\_INST\_SPEC that is classified as an SME operation.

An SME operation is any operation due to an instruction that operates on the ZA or ZT registers that is not any of the following:

- Anon-SIMD SME operation.

Operations due to instructions defined by FEAT\_SME which involve the SVE registers but do not involve any ZA or ZT registers are counted as SVE operations.

## 0x835F , SE\_INST\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME

The counter counts each speculatively executed operation counted by INST\_SPEC that is classified as an Advanced SIMD, SVE, or SME operation.

See ASE\_SVE\_INST\_SPEC and SME\_INST\_SPEC for these classifications.

## 0x8360 , SME\_INT8\_SPEC, Operation speculatively executed, SME 8-bit integer, data-processing

The counter counts each speculatively executed 8-bit integer data-processing operation counted by SME\_INT\_SPEC due to an instruction which reads from or writes to any part of the ZA array.

This event counts based on the largest type read or written by an operation.

## 0x8361 , SE\_INT8\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD 8-bit integer, dataprocessing

The counter counts each speculatively executed 8-bit integer data-processing operation counted by SE\_INT\_SPEC due to an A64 Advanced SIMD, SVE, or SME operation.

That is, each operation counted by ASE\_INT8\_SPEC, SVE\_INT8\_SPEC, or SME\_INT8\_SPEC.

It is IMPLEMENTATION DEFINED which 8-bit integer data-processing operations are counted in AArch32 state.

## 0x8362 , SME\_FP\_BF16\_SPEC, Operation speculatively executed, SME BFloat16 floating-point, data-processing

The counter counts each speculatively executed BFloat16 floating-point data-processing operation counted by SME\_FP\_SPEC due to an instruction which reads from or writes to any part of the ZA array.

This event counts based on the largest type read or written by an operation.

## 0x8363 , SE\_FP\_BF16\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD BFloat16 floatingpoint, data-processing

The counter counts each speculatively executed BFloat16 floating-point data-processing operation counted by SE\_FP\_SPEC due to an A64 Advanced SIMD, SVE, or SME operation.

That is, each operation counted by SVE\_FP\_BF16\_SPEC, or SME\_FP\_BF16\_SPEC.

## 0x8364 , SME\_INT16\_SPEC, Operation speculatively executed, SME 16-bit integer, data-processing

The counter counts each speculatively executed 16-bit integer data-processing operation counted by SME\_INT\_SPEC due to an instruction which reads from or writes to any part of the ZA array.

This event counts based on the largest type read or written by an operation.

## 0x8365 , SE\_INT16\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD 16-bit integer, dataprocessing

The counter counts each speculatively executed 16-bit integer data-processing operation counted by SE\_INT\_SPEC due to an A64 Advanced SIMD, SVE, or SME operation.

That is, each operation counted by ASE\_INT16\_SPEC, SVE\_INT16\_SPEC, or SME\_INT16\_SPEC.

It is IMPLEMENTATION DEFINED which 16-bit integer data-processing operations are counted in AArch32 state.

## 0x8366 , SME\_FP\_HP\_SPEC, Operation speculatively executed, SME half-precision floating-point, data-processing

The counter counts each speculatively executed half-precision floating-point data-processing operation counted by SME\_FP\_SPEC due to an instruction which reads from or writes to any part of the ZA array.

This event counts based on the largest type read or written by an operation.

## 0x8367 , SE\_FP\_HP\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD half-precision floatingpoint, data-processing

The counter counts each speculatively executed half-precision floating-point data-processing operation counted by SE\_FP\_SPEC due to an A64 Advanced SIMD, SVE, or SME operation.

That is, each operation counted by ASE\_FP\_HP\_SPEC, SVE\_FP\_HP\_SPEC, or SME\_FP\_HP\_SPEC.

It is IMPLEMENTATION DEFINED which half-precision floating-point data-processing operations are counted in AArch32 state.

## 0x8368 , SME\_INT32\_SPEC, Operation speculatively executed, SME 32-bit integer, data-processing

The counter counts each speculatively executed 32-bit integer data-processing operation counted by SME\_INT\_SPEC due to an instruction which reads from or writes to any part of the ZA array.

This event counts based on the largest type read or written by an operation.

## 0x8369 , SE\_INT32\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD 32-bit integer, dataprocessing

The counter counts each speculatively executed 32-bit integer data-processing operation counted by SE\_INT\_SPEC due to an A64 Advanced SIMD, SVE, or SME operation.

That is, each operation counted by ASE\_INT32\_SPEC, SVE\_INT32\_SPEC, or SME\_INT32\_SPEC.

It is IMPLEMENTATION DEFINED which 32-bit integer data-processing operations are counted in AArch32 state.

## 0x836A , SME\_FP\_SP\_SPEC, Operation speculatively executed, SME single-precision floating-point, data-processing

The counter counts each speculatively executed single-precision floating-point data-processing operation counted by SME\_FP\_SPEC due to an instruction which reads from or writes to any part of the ZA array.

This event counts based on the largest type read or written by an operation.

## 0x836B , SE\_FP\_SP\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD single-precision floating-point, data-processing

The counter counts each speculatively executed single-precision floating-point data-processing operation counted by SE\_FP\_SPEC due to an A64 Advanced SIMD, SVE, or SME operation.

That is, each operation counted by ASE\_FP\_SP\_SPEC, SVE\_FP\_SP\_SPEC, or SME\_FP\_SP\_SPEC.

It is IMPLEMENTATION DEFINED which single-precision floating-point data-processing operations are counted in AArch32 state.

## 0x836C , SME\_INT64\_SPEC, Operation speculatively executed, SME 64-bit integer, data-processing

The counter counts each speculatively executed 64-bit integer data-processing operation counted by SME\_INT\_SPEC due to an instruction which reads from or writes to any part of the ZA array.

This event counts based on the largest type read or written by an operation.

## 0x836D , SE\_INT64\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD 64-bit integer, dataprocessing

The counter counts each speculatively executed 64-bit integer data-processing operation counted by SE\_INT\_SPEC due to an A64 Advanced SIMD, SVE, or SME operation.

That is, each operation counted by ASE\_INT64\_SPEC, SVE\_INT64\_SPEC, or SME\_INT64\_SPEC.

It is IMPLEMENTATION DEFINED which 64-bit integer data-processing operations are counted in AArch32 state.

## 0x836E , SME\_FP\_DP\_SPEC, Operation speculatively executed, SME double-precision floating-point, data-processing

The counter counts each speculatively executed double-precision floating-point data-processing operation counted by SME\_FP\_SPEC due to an instruction which reads from or writes to any part of the ZA array.

This event counts based on the largest type read or written by an operation.

## 0x836F , SE\_FP\_DP\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD double-precision floating-point, data-processing

The counter counts each speculatively executed double-precision floating-point data-processing operation counted by SE\_FP\_SPEC due to an A64 Advanced SIMD, SVE, or SME operation.

That is, each operation counted by ASE\_FP\_DP\_SPEC, SVE\_FP\_DP\_SPEC, or SME\_FP\_DP\_SPEC.

It is IMPLEMENTATION DEFINED which double-precision floating-point data-processing operations are counted in AArch32 state.

## 0x8370 , SME\_FP\_ADDSUB\_SPEC, Operation speculatively executed, SME floating-point addition or subtraction

The counter counts each speculatively executed floating-point addition or subtraction operation counted by SE\_FP\_ADDSUB\_SPEC due to any of the following instructions:

- SME2: BFADD, BFSUB, FADD, or FSUB.

## 0x8371 , SE\_FP\_ADDSUB\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD floating-point addition or subtraction

The counter counts each speculatively executed floating-point addition or subtraction operation counted by SE\_FP\_SPEC due to an A64 Advanced SIMD, SVE, or SME operation.

That is, each operation counted by ASE\_FP\_ADDSUB\_SPEC, SVE\_FP\_ADDSUB\_SPEC, or SME\_FP\_ADDSUB\_SPEC.

## 0x8372 , SME\_FP\_FMA\_SPEC, Operation speculatively executed, SME floating-point multiply-add or multiply-subtract

The counter counts each speculatively executed floating-point multiply-add, multiply-add long, multiply-subtract, or multiply-subtract long operation counted by SE\_FP\_FMA\_SPEC due to any of the following instructions:

- SME2: BFMLA, BFMLAL, BFMLS, BFMLSL, FMLA, FMLAL, FMLALL, FMLS, or FMLSL.

## 0x8373 , SE\_FP\_FMA\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD floating-point multiply-add or multiply-subtract

The counter counts each speculatively executed floating-point multiply-add, multiply-add long, multiply-subtract, or multiply-subtract long operation counted by SE\_FP\_SPEC due to an A64 Advanced SIMD, SVE, or SME operation.

That is, each operation counted by ASE\_FP\_FMA\_SPEC, SVE\_FP\_FMA\_SPEC, or SME\_FP\_FMA\_SPEC.

## 0x8374 , SME\_FP\_DOT\_SPEC, Operation speculatively executed, SME floating-point dot product

The counter counts each speculatively executed floating-point dot product operation counted by SE\_FP\_DOT\_SPEC due to any of the following instructions:

- SME2: BFDOT, BFVDOT, FDOT, FVDOT, FVDOTB, or FVDOTT.

## 0x8375 , SE\_FP\_DOT\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD floating-point dot product

The counter counts each speculatively executed floating-point dot product operation counted by SE\_FP\_SPEC due to any of the following A64 instructions:

- When FEAT\_BF16 is implemented, Advanced SIMD: BFDOT.
- When FEAT\_FP8DOT2 is implemented, Advanced SIMD: FDOT (8-bit floating-point to half-precision, by element) or FDOT (8-bit floating-point to half-precision, vector).
- When FEAT\_FP8DOT4 is implemented, Advanced SIMD: FDOT (8-bit floating-point to single-precision, by element) or FDOT (8-bit floating-point to single-precision, vector).
- SVE: BFDOT.
- SVE2: FDOT.
- SME2: BFDOT, BFVDOT, FDOT, FVDOT, FVDOTB, or FVDOTT.

That is, each operation counted by ASE\_FP\_DOT\_SPEC, SVE\_FP\_DOT\_SPEC, or SME\_FP\_DOT\_SPEC.

## 0x8376 , SME\_FP\_MOPA\_SPEC, Operation speculatively executed, SME floating-point outer product and accumulate, or outer product and subtract

The counter counts each speculatively executed floating-point outer product and accumulate, or outer product and subtract operation counted by SE\_FP\_SPEC due to any of the following instructions:

- SME2: BFMOPA, BFMOPS, FMOPA, or FMOPS.

## 0x8378 , SME\_INT\_SPEC, Operation speculatively executed, SME integer, data-processing

The counter counts each speculatively executed integer data-processing operation counted by SE\_INT\_SPEC due to an instruction which reads from or writes to any part of the ZA array.

## 0x8379 , SE\_INT\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD integer, data-processing

The counter counts each speculatively executed integer data-processing operation counted by INT\_SPEC due to an A64 Advanced SIMD, SVE, or SME operation.

That is, each operation counted by ASE\_INT\_SPEC, SVE\_INT\_SPEC, or SME\_INT\_SPEC.

It is IMPLEMENTATION DEFINED which integer data-processing operations are counted in AArch32 state.

## 0x837A , SME\_INT\_MUL\_SPEC, Operation speculatively executed, SME integer multiply or multiply-accumulate

The counter counts each speculatively executed integer multiply, multiply-add, or multiply-subtract operation counted by SE\_INT\_MUL\_SPEC due to any of the following instructions:

- SME2: SMLAL, SMLALL, SMLSL, SMLSLL, SUMLALL, UMLAL, UMLALL, UMLSL, UMLSLL, or USMLALL.

## 0x837B , SE\_INT\_MUL\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD integer multiply or multiply-accumulate

The counter counts each speculatively executed integer multiply, multiply-add, or multiply-subtract operation counted by SE\_INT\_SPEC due to an A64 Advanced SIMD, SVE, or SME operation.

That is, each operation counted by ASE\_INT\_MUL\_SPEC, SVE\_INT\_MUL\_SPEC, or SME\_INT\_MUL\_SPEC.

## 0x837C , SME\_INT\_DOT\_SPEC, Operation speculatively executed, SME integer dot product

The counter counts each speculatively executed integer dot product operation counted by SE\_INT\_DOT\_SPEC due to any of the following instructions:

- SME2: SDOT, SUDOT, SUVDOT, SVDOT, UDOT, USDOT, USVDOT, or UVDOT.

## 0x837D , SE\_INT\_DOT\_SPEC, Operation speculatively executed, Advanced SIMD, SVE, or SME SIMD integer dot product

The counter counts each speculatively executed integer dot product operation counted by SE\_INT\_SPEC due to any of the following A64 instructions:

- When FEAT\_DotProd is implemented, Advanced SIMD: SDOT or UDOT.
- When FEAT\_I8MM is implemented, Advanced SIMD: SUDOT or USDOT.
- SVE: SDOT, SUDOT, UDOT, or USDOT.
- SVE2: CDOT, SDOT, or UDOT.
- SME2: SDOT, SUDOT, SUVDOT, SVDOT, UDOT, USDOT, USVDOT, or UVDOT.

That is, each operation counted by ASE\_INT\_DOT\_SPEC, SVE\_INT\_DOT\_SPEC, or SME\_INT\_DOT\_SPEC.

## 0x837E , SME\_INT\_MOPA\_SPEC, Operation speculatively executed, SME integer outer product and accumulate, or outer product and subtract

The counter counts each speculatively executed integer outer product and accumulate, or outer product and subtract operation counted by SE\_INT\_SPEC due to any of the following instructions:

- SME2: BMOPA, BMOPS, SMOPA, SMOPS, SUMOPA (4-way), SUMOPS, UMOPA, UMOPS, USMOPA (4-way), or USMOPS.

## 0x8380 , ZA\_ACTIVE, CPU cycles, ZA enabled

The counter counts each cycle counted by CPU\_CYCLES when PSTATE.ZA is 1.

## 0x8381 , SME\_PRED2\_NOT\_FULL\_SPEC,Operationspeculatively executed, SME 2D predicated with at least one inactive element

The counter counts each speculatively executed predicated 2D SME operation which targets the ZA array counted by SME\_PRED2\_SPEC where at least one element is Inactive.

That is, at least one element in the Governing predicates is FALSE.

For outer product instructions which are widening, predication is considered with respect to the input element size.

## 0x8384 , SME\_PRED2\_SPEC, Operation speculatively executed, SME 2D predicated

The counter counts each speculatively executed 2D operation which targets the ZA array counted by SVE\_PRED\_SPEC due to an SME instruction with a Governing predicate operand that determines the Active elements.

## 0x8385 , SME\_PRED2\_EMPTY\_SPEC, Operation speculatively executed, SME 2D predicated with no active elements

The counter counts each speculatively executed predicated 2D SME operation which targets the ZA array counted by SME\_PRED2\_NOT\_FULL\_SPEC where all elements are Inactive.

That is, all elements in the Governing predicates are FALSE.

For outer product instructions which are widening, predication is considered with respect to the input element size.

## 0x8386 , SME\_PRED2\_FULL\_SPEC, Operation speculatively executed, SME 2D predicated with all active elements

The counter counts each speculatively executed predicated 2D SME operation which targets the ZA array counted by SME\_PRED2\_SPEC where all elements are Active.

That is, all elements in the Governing predicates are TRUE.

For outer product instructions which are widening, predication is considered with respect to the input element size.

## 0x8387 , SME\_PRED2\_PARTIAL\_SPEC,Operation speculatively executed, SME 2D predicated with partially active elements

The counter counts each speculatively executed predicated 2D SME operation which targets the ZA array counted by SME\_PRED2\_NOT\_FULL\_SPEC where neither all elements are Active nor all elements are Inactive.

That is, the elements in the Governing predicates are neither all TRUE nor all FALSE.

For outer product instructions which are widening, predication is considered with respect to the input element size.

## 0x8388 , SME\_LDST\_ZAREG\_SPEC, SME ZA unpredicated load/store

The counter counts each speculatively executed operation that reads from or writes to memory counted by SME\_LDST\_REG\_SPEC that was due to an unpredicated instruction targeting the ZA array.

That is, due to any of the following instructions:

- SME2: LDR (array vector) or STR (array vector).

## 0x8389 , SME\_LD\_ZAREG\_SPEC, SME ZA unpredicated load

The counter counts each speculatively executed operation that reads from memory counted by SME\_LDST\_ZAREG\_SPEC that was due to an unpredicated instruction targeting the ZA array.

That is, due to any of the following instructions:

- SME2: LDR (array vector).

## 0x838A , SME\_ST\_ZAREG\_SPEC, SME ZA unpredicated store

The counter counts each speculatively executed operation that writes to memory counted by SME\_LDST\_ZAREG\_SPEC that was due to an unpredicated instruction targeting the ZA array.

That is, due to any of the following instructions:

- SME2: STR (array vector).

## 0x838C , SME\_LDST\_ZTREG\_SPEC, SME ZT unpredicated load/store

The counter counts each speculatively executed operation that reads from or writes to memory counted by SME\_LDST\_REG\_SPEC that was due to an unpredicated instruction targeting the ZT register.

That is, due to any of the following instructions:

- SME2: LDR (table) or STR (table).

## 0x838D , SME\_LD\_ZTREG\_SPEC, SME ZT unpredicated load

The counter counts each speculatively executed operation that reads from memory counted by SME\_LDST\_ZTREG\_SPEC that was due to an unpredicated instruction targeting the ZT register.

That is, due to any of the following instructions:

- SME2: LDR (table).

## 0x838E , SME\_ST\_ZTREG\_SPEC, SME ZT unpredicated store

The counter counts each speculatively executed operation that writes to memory counted by SME\_LDST\_ZTREG\_SPEC that was due to an unpredicated instruction targeting the ZT register.

That is, due to any of the following instructions:

- SME2: STR (table).

## 0x8390 , SME\_LDST\_REG\_SPEC, SME unpredicated load/store

The counter counts each speculatively executed operation that reads from or writes to memory counted by SME\_INST\_SPEC that was due to an unpredicated instruction targeting the ZA array or ZT register.

That is, due to any of the following instructions:

- SME2: LDR or STR.

## 0x8391 , SME\_LD\_REG\_SPEC, SME unpredicated load

The counter counts each speculatively executed operation that reads from memory counted by SME\_LDST\_REG\_SPEC that was due to an unpredicated instruction targeting the ZA array or ZT register.

That is, due to any of the following instructions:

- SME2: LDR.

## 0x8392 , SME\_ST\_REG\_SPEC, SME unpredicated store

The counter counts each speculatively executed operation that writes to memory counted by SME\_LDST\_REG\_SPEC that was due to an unpredicated instruction targeting the ZA array or ZT register.

That is, due to any of the following instructions:

- SME2: STR.

## 0x8394 , SME\_LDST\_TILE\_SPEC, SME predicated tile load/store

The counter counts each speculatively executed operation that reads from or writes to memory counted by SME\_INST\_SPEC that was due to an instruction with at least one governing predicate which is targeting the ZA array.

That is, due to any of the following instructions:

- SME2: LD1B (scalar plus scalar, tile slice), LD1D (scalar plus scalar, tile slice), LD1H (scalar plus scalar, tile slice), LD1Q, LD1W (scalar plus scalar, tile slice), ST1B (scalar plus scalar, tile slice), ST1D (scalar plus scalar, tile slice), ST1H (scalar plus scalar, tile slice), ST1Q, or ST1W (scalar plus scalar, tile slice).

## 0x8395 , SME\_LD\_TILE\_SPEC, SME predicated tile load

The counter counts each speculatively executed operation that reads from memory counted by SME\_LDST\_TILE\_SPEC that was due to an instruction with at least one governing predicate which is targeting the ZA array.

That is, due to any of the following instructions:

- SME2: LD1B (scalar plus scalar, tile slice), LD1D (scalar plus scalar, tile slice), LD1H (scalar plus scalar, tile slice), LD1Q, or LD1W (scalar plus scalar, tile slice).

## 0x8396 , SME\_ST\_TILE\_SPEC, SME predicated tile store

The counter counts each speculatively executed operation that writes to memory counted by SME\_LDST\_TILE\_SPEC that was due to an instruction with at least one governing predicate which is targeting the ZA array.

That is, due to any of the following instructions:

- SME2: ST1B (scalar plus scalar, tile slice), ST1D (scalar plus scalar, tile slice), ST1H (scalar plus scalar, tile slice), ST1Q, or ST1W (scalar plus scalar, tile slice).

## 0x8398 , ASE\_LUT\_SPEC, Lookup table operation speculatively executed, Advanced SIMD data processing

The counter counts each speculatively executed LUT operation counted by SE\_LUT\_SPEC that returns a value from a lookup table made up of a V register which is indexed by values from a V register.

## 0x8399 , SVE\_LUT\_SPEC, Lookup table operation speculatively executed, SVE data processing

The counter counts each speculatively executed LUT operation counted by SE\_LUT\_SPEC that returns a value from a lookup table made up of a Z register which is indexed by values from a Z register.

That is, due to any of the following instructions:

- SVE2: LUTI2 (8-bit and 16-bit) or LUTI4 (8-bit and 16-bit).

## 0x839A , SME\_LUT\_SPEC, Lookup table operation speculatively executed, SME data processing

The counter counts each speculatively executed LUT operation counted by SE\_LUT\_SPEC that returns a value from a lookup table made up of a ZT register which is indexed by values from a Z register.

That is, due to any of the following instructions:

- SME2: LUTI2 or LUTI4.

## 0x839B , SE\_LUT\_SPEC, Lookup table operation speculatively executed, Advanced SIMD, SVE, or SME data processing

The counter counts each speculatively executed LUT operation counted by SE\_INST\_SPEC that returns a value from a lookup table made up of a ZT register, Z or V register which is indexed by values from a Z or V register.

## 0x83A0 , N1\_CACHE\_HIT\_RD, Cache at distance 1, demand access hit, read

The counter counts each cache hit at distance 1 due to a demand read.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83A1 , N2\_CACHE\_HIT\_RD, Cache at distance 2, demand access hit, read

The counter counts each cache hit at distance 2 due to a demand read.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

Cache distance 2 represents a further distance of travel than cache distance 1.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83A2 , N3\_CACHE\_HIT\_RD, Cache at distance 3, demand access hit, read

The counter counts each cache hit at distance 3 due to a demand read.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

Cache distance 3 represents a further distance of travel than cache distance 2.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83A3 , N4\_CACHE\_HIT\_RD, Cache at distance 4, demand access hit, read

The counter counts each cache hit at distance 4 due to a demand read.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

Cache distance 4 represents a further distance of travel than cache distance 3.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83A4 , N1\_CACHE\_HIT\_PRFM, Cache at distance 1, software prefetch hit

The counter counts each cache hit at distance 1 due to a software prefetch.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83A5 , N2\_CACHE\_HIT\_PRFM, Cache at distance 2, software prefetch hit

The counter counts each cache hit at distance 2 due to a software prefetch.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

Cache distance 2 represents a further distance of travel than cache distance 1.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83A6 , N3\_CACHE\_HIT\_PRFM, Cache at distance 3, software prefetch hit

The counter counts each cache hit at distance 3 due to a software prefetch.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

Cache distance 3 represents a further distance of travel than cache distance 2.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83A7 , N4\_CACHE\_HIT\_PRFM, Cache at distance 4, software prefetch hit

The counter counts each cache hit at distance 4 due to a software prefetch.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

Cache distance 4 represents a further distance of travel than cache distance 3.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83A8 , N1\_CACHE1\_HIT\_RD, Cache type 1 at distance 1 demand access hit, read

The counter counts each demand read counted by N1\_CACHE\_HIT\_RD due to a demand read accessing a first cache type at distance 1.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83A9 , N2\_CACHE1\_HIT\_RD, Cache type 1 at distance 2 demand access hit, read

The counter counts each demand read counted by N2\_CACHE\_HIT\_RD due to a demand read accessing a first cache type at distance 2.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83AA , N3\_CACHE1\_HIT\_RD, Cache type 1 at distance 3 demand access hit, read

The counter counts each demand read counted by N3\_CACHE\_HIT\_RD due to a demand read accessing a first cache type at distance 3.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83AB , N4\_CACHE1\_HIT\_RD, Cache type 1 at distance 4 demand access hit, read

The counter counts each demand read counted by N4\_CACHE\_HIT\_RD due to a demand read accessing a first cache type at distance 4.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83AC , N1\_CACHE1\_HIT\_PRFM, Cache type 1 at distance 1 software prefetch hit

The counter counts each software prefetch counted by N1\_CACHE\_HIT\_PRFM due to a software prefetch accessing a first cache type at distance 1.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83AD , N2\_CACHE1\_HIT\_PRFM, Cache type 1 at distance 2 software prefetch hit

The counter counts each software prefetch counted by N2\_CACHE\_HIT\_PRFM due to a software prefetch accessing a first cache type at distance 2.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83AE , N3\_CACHE1\_HIT\_PRFM, Cache type 1 at distance 3 software prefetch hit

The counter counts each software prefetch counted by N3\_CACHE\_HIT\_PRFM due to a software prefetch accessing a first cache type at distance 3.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83AF , N4\_CACHE1\_HIT\_PRFM, Cache type 1 at distance 4 software prefetch hit

The counter counts each software prefetch counted by N4\_CACHE\_HIT\_PRFM due to a software prefetch accessing a first cache type at distance 4.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83B0 , N1\_CACHE2\_HIT\_RD, Cache type 2 at distance 1 demand access hit, read

The counter counts each demand read counted by N1\_CACHE\_HIT\_RD due to a demand read accessing a second cache type at distance 1.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83B1 , N2\_CACHE2\_HIT\_RD, Cache type 2 at distance 2 demand access hit, read

The counter counts each demand read counted by N2\_CACHE\_HIT\_RD due to a demand read accessing a second cache type at distance 2.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83B2 , N3\_CACHE2\_HIT\_RD, Cache type 2 at distance 3 demand access hit, read

The counter counts each demand read counted by N3\_CACHE\_HIT\_RD due to a demand read accessing a second cache type at distance 3.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83B3 , N4\_CACHE2\_HIT\_RD, Cache type 2 at distance 4 demand access hit, read

The counter counts each demand read counted by N4\_CACHE\_HIT\_RD due to a demand read accessing a second cache type at distance 4.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83B4 , N1\_CACHE2\_HIT\_PRFM, Cache type 2 at distance 1 software prefetch hit

The counter counts each software prefetch counted by N1\_CACHE\_HIT\_PRFM due to a software prefetch accessing a second cache type at distance 1.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83B5 , N2\_CACHE2\_HIT\_PRFM, Cache type 2 at distance 2 software prefetch hit

The counter counts each software prefetch counted by N2\_CACHE\_HIT\_PRFM due to a software prefetch accessing a second cache type at distance 2.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83B6 , N3\_CACHE2\_HIT\_PRFM, Cache type 2 at distance 3 software prefetch hit

The counter counts each software prefetch counted by N3\_CACHE\_HIT\_PRFM due to a software prefetch accessing a second cache type at distance 3.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83B7 , N4\_CACHE2\_HIT\_PRFM, Cache type 2 at distance 4 software prefetch hit

The counter counts each software prefetch counted by N4\_CACHE\_HIT\_PRFM due to a software prefetch accessing a second cache type at distance 4.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83B8 , N1\_CACHE3\_HIT\_RD, Cache type 3 at distance 1 demand access hit, read

The counter counts each demand read counted by N1\_CACHE\_HIT\_RD due to a demand read accessing a third cache type at distance 1.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83B9 , N2\_CACHE3\_HIT\_RD, Cache type 3 at distance 2 demand access hit, read

The counter counts each demand read counted by N2\_CACHE\_HIT\_RD due to a demand read accessing a third cache type at distance 2.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83BA , N3\_CACHE3\_HIT\_RD, Cache type 3 at distance 3 demand access hit, read

The counter counts each demand read counted by N3\_CACHE\_HIT\_RD due to a demand read accessing a third cache type at distance 3.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83BB , N4\_CACHE3\_HIT\_RD, Cache type 3 at distance 4 demand access hit, read

The counter counts each demand read counted by N4\_CACHE\_HIT\_RD due to a demand read accessing a third cache type at distance 4.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83BC , N1\_CACHE3\_HIT\_PRFM, Cache type 3 at distance 1 software prefetch hit

The counter counts each software prefetch counted by N1\_CACHE\_HIT\_PRFM due to a software prefetch accessing a third cache type at distance 1.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83BD , N2\_CACHE3\_HIT\_PRFM, Cache type 3 at distance 2 software prefetch hit

The counter counts each software prefetch counted by N2\_CACHE\_HIT\_PRFM due to a software prefetch accessing a third cache type at distance 2.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83BE , N3\_CACHE3\_HIT\_PRFM, Cache type 3 at distance 3 software prefetch hit

The counter counts each software prefetch counted by N3\_CACHE\_HIT\_PRFM due to a software prefetch accessing a third cache type at distance 3.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83BF , N4\_CACHE3\_HIT\_PRFM, Cache type 3 at distance 4 software prefetch hit

The counter counts each software prefetch counted by N4\_CACHE\_HIT\_PRFM due to a software prefetch accessing a third cache type at distance 4.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83C0 , N1\_CACHE\_HITM\_RD, Cache at distance 1, demand access hit modified, read

The counter counts each demand read counted by N1\_CACHE\_HIT\_RD that accesses a previously modified location in a cache at distance 1.

## 0x83C1 , N2\_CACHE\_HITM\_RD, Cache at distance 2, demand access hit modified, read

The counter counts each demand read counted by N2\_CACHE\_HIT\_RD that accesses a previously modified location in a cache at distance 2.

## 0x83C2 , N3\_CACHE\_HITM\_RD, Cache at distance 3, demand access hit modified, read

The counter counts each demand read counted by N3\_CACHE\_HIT\_RD that accesses a previously modified location in a cache at distance 3.

## 0x83C3 , N4\_CACHE\_HITM\_RD, Cache at distance 4, demand access hit modified, read

The counter counts each demand read counted by N4\_CACHE\_HIT\_RD that accesses a previously modified location in a cache at distance 4.

## 0x83C4 , N1\_LFB\_HIT\_RD, Cache at distance 1 demand access line-fill buffer hit, read

The counter counts each demand read counted by N1\_CACHE\_HIT\_RD that hits a recently fetched line in a cache at distance 1.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 1, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x83C5 , N2\_LFB\_HIT\_RD, Cache at distance 2 demand access line-fill buffer hit, read

The counter counts each demand read counted by N2\_CACHE\_HIT\_RD that hits a recently fetched line in a cache at distance 2.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 2, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x83C6 , N3\_LFB\_HIT\_RD, Cache at distance 3 demand access line-fill buffer hit, read

The counter counts each demand read counted by N3\_CACHE\_HIT\_RD that hits a recently fetched line in a cache at distance 3.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 3, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x83C7 , N4\_LFB\_HIT\_RD, Cache at distance 4 demand access line-fill buffer hit, read

The counter counts each demand read counted by N4\_CACHE\_HIT\_RD that hits a recently fetched line in a cache at distance 4.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 4, and so does not generate a new refill, but has to wait for the previous refill to complete.

## 0x83C8 , N1\_CACHE1\_HITM\_RD, Cache type 1 at distance 1 demand access hit modified, read

The counter counts each demand read counted by N1\_CACHE\_HITM\_RD that accesses a previously modified location in a first cache type at distance 1.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83C9 , N2\_CACHE1\_HITM\_RD, Cache type 1 at distance 2 demand access hit modified, read

The counter counts each demand read counted by N2\_CACHE\_HITM\_RD that accesses a previously modified location in a first cache type at distance 2.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83CA , N3\_CACHE1\_HITM\_RD, Cache type 1 at distance 3 demand access hit modified, read

The counter counts each demand read counted by N3\_CACHE\_HITM\_RD that accesses a previously modified location in a first cache type at distance 3.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83CB , N4\_CACHE1\_HITM\_RD, Cache type 1 at distance 4 demand access hit modified, read

The counter counts each demand read counted by N4\_CACHE\_HITM\_RD that accesses a previously modified location in a first cache type at distance 4.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83CC , N1\_LFB1\_HIT\_RD, Cache type 1 at distance 1 demand access line-fill buffer hit, read

The counter counts each demand read counted by N1\_LFB\_HIT\_RD that hits a recently fetched line in a first cache type at distance 1.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 1, and so does not generate a new refill, but has to wait for the previous refill to complete.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83CD , N2\_LFB1\_HIT\_RD, Cache type 1 at distance 2 demand access line-fill buffer hit, read

The counter counts each demand read counted by N2\_LFB\_HIT\_RD that hits a recently fetched line in a first cache type at distance 2.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 2, and so does not generate a new refill, but has to wait for the previous refill to complete.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83CE , N3\_LFB1\_HIT\_RD, Cache type 1 at distance 3 demand access line-fill buffer hit, read

The counter counts each demand read counted by N3\_LFB\_HIT\_RD that hits a recently fetched line in a first cache type at distance 3.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 3, and so does not generate a new refill, but has to wait for the previous refill to complete.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83CF , N4\_LFB1\_HIT\_RD, Cache type 1 at distance 4 demand access line-fill buffer hit, read

The counter counts each demand read counted by N4\_LFB\_HIT\_RD that hits a recently fetched line in a first cache type at distance 4.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 4, and so does not generate a new refill, but has to wait for the previous refill to complete.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83D0 , N1\_CACHE2\_HITM\_RD, Cache type 2 at distance 1 demand access hit modified, read

The counter counts each demand read counted by N1\_CACHE\_HITM\_RD that accesses a previously modified location in a second cache type at distance 1.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83D1 , N2\_CACHE2\_HITM\_RD, Cache type 2 at distance 2 demand access hit modified, read

The counter counts each demand read counted by N2\_CACHE\_HITM\_RD that accesses a previously modified location in a second cache type at distance 2.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83D2 , N3\_CACHE2\_HITM\_RD, Cache type 2 at distance 3 demand access hit modified, read

The counter counts each demand read counted by N3\_CACHE\_HITM\_RD that accesses a previously modified location in a second cache type at distance 3.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83D3 , N4\_CACHE2\_HITM\_RD, Cache type 2 at distance 4 demand access hit modified, read

The counter counts each demand read counted by N4\_CACHE\_HITM\_RD that accesses a previously modified location in a second cache type at distance 4.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83D4 , N1\_LFB2\_HIT\_RD, Cache type 2 at distance 1 demand access line-fill buffer hit, read

The counter counts each demand read counted by N1\_LFB\_HIT\_RD that hits a recently fetched line in a second cache type at distance 1.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 1, and so does not generate a new refill, but has to wait for the previous refill to complete.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83D5 , N2\_LFB2\_HIT\_RD, Cache type 2 at distance 2 demand access line-fill buffer hit, read

The counter counts each demand read counted by N2\_LFB\_HIT\_RD that hits a recently fetched line in a second cache type at distance 2.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 2, and so does not generate a new refill, but has to wait for the previous refill to complete.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83D6 , N3\_LFB2\_HIT\_RD, Cache type 2 at distance 3 demand access line-fill buffer hit, read

The counter counts each demand read counted by N3\_LFB\_HIT\_RD that hits a recently fetched line in a second cache type at distance 3.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 3, and so does not generate a new refill, but has to wait for the previous refill to complete.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83D7 , N4\_LFB2\_HIT\_RD, Cache type 2 at distance 4 demand access line-fill buffer hit, read

The counter counts each demand read counted by N4\_LFB\_HIT\_RD that hits a recently fetched line in a second cache type at distance 4.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 4, and so does not generate a new refill, but has to wait for the previous refill to complete.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83D8 , N1\_CACHE3\_HITM\_RD, Cache type 3 at distance 1 demand access hit modified, read

The counter counts each demand read counted by N1\_CACHE\_HITM\_RD that accesses a previously modified location in a third cache type at distance 1.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83D9 , N2\_CACHE3\_HITM\_RD, Cache type 3 at distance 2 demand access hit modified, read

The counter counts each demand read counted by N2\_CACHE\_HITM\_RD that accesses a previously modified location in a third cache type at distance 2.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83DA , N3\_CACHE3\_HITM\_RD, Cache type 3 at distance 3 demand access hit modified, read

The counter counts each demand read counted by N3\_CACHE\_HITM\_RD that accesses a previously modified location in a third cache type at distance 3.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83DB , N4\_CACHE3\_HITM\_RD, Cache type 3 at distance 4 demand access hit modified, read

The counter counts each demand read counted by N4\_CACHE\_HITM\_RD that accesses a previously modified location in a third cache type at distance 4.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83DC , N1\_LFB3\_HIT\_RD, Cache type 3 at distance 1 demand access line-fill buffer hit, read

The counter counts each demand read counted by N1\_LFB\_HIT\_RD that hits a recently fetched line in a third cache type at distance 1.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 1, and so does not generate a new refill, but has to wait for the previous refill to complete.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83DD , N2\_LFB3\_HIT\_RD, Cache type 3 at distance 2 demand access line-fill buffer hit, read

The counter counts each demand read counted by N2\_LFB\_HIT\_RD that hits a recently fetched line in a third cache type at distance 2.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 2, and so does not generate a new refill, but has to wait for the previous refill to complete.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83DE , N3\_LFB3\_HIT\_RD, Cache type 3 at distance 3 demand access line-fill buffer hit, read

The counter counts each demand read counted by N3\_LFB\_HIT\_RD that hits a recently fetched line in a third cache type at distance 3.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 3, and so does not generate a new refill, but has to wait for the previous refill to complete.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83DF , N4\_LFB3\_HIT\_RD, Cache type 3 at distance 4 demand access line-fill buffer hit, read

The counter counts each demand read counted by N4\_LFB\_HIT\_RD that hits a recently fetched line in a third cache type at distance 4.

That is, the read hits a cache line that is in the process of being loaded into the cache at distance 4, and so does not generate a new refill, but has to wait for the previous refill to complete.

The definition of cache types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83E0 , N1\_MEM\_RD, Access to memory at distance 1, demand access, read

The counter counts each demand read to memory at distance 1.

The memory distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83E1 , N2\_MEM\_RD, Access to memory at distance 2, demand access, read

The counter counts each demand read to memory at distance 2.

The memory distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

Distance 2 represents a further distance of travel than distance 1.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83E2 , N3\_MEM\_RD, Access to memory at distance 3, demand access, read

The counter counts each demand read to memory at distance 3.

The memory distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

Distance 3 represents a further distance of travel than distance 2.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83E3 , N4\_MEM\_RD, Access to memory at distance 4, demand access, read

The counter counts each demand read to memory at distance 4.

The memory distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

Distance 4 represents a further distance of travel than distance 3.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83E4 , N1\_MEM\_PRFM, Access to memory at distance 1, software prefetch

The counter counts each software prefetch to memory at distance 1.

The memory distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83E5 , N2\_MEM\_PRFM, Access to memory at distance 2, software prefetch

The counter counts each software prefetch to memory at distance 2.

The memory distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

Distance 2 represents a further distance of travel than distance 1.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83E6 , N3\_MEM\_PRFM, Access to memory at distance 3, software prefetch

The counter counts each software prefetch to memory at distance 3.

The memory distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

Distance 3 represents a further distance of travel than distance 2.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83E7 , N4\_MEM\_PRFM, Access to memory at distance 4, software prefetch

The counter counts each software prefetch to memory at distance 4.

The memory distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

Distance 4 represents a further distance of travel than distance 3.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x83E8 , N1\_MEM1\_RD, Access to type 1 memory at distance 1, demand access, read

The counter counts each demand read counted by N1\_MEM\_RD to a first memory type at distance 1.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system. See also N1\_MEM1\_RD.

For example, the first memory type might be commodity DRAM connected to a device. However, this must be the same for all devices in the system, such that, for example, N1\_MEM1\_RD refers to commodity DRAM for a PE at distance 1 from the memory, regardless of which device the PE is located on, and N4\_MEM1\_RD refers to the same memory for any PE located at distance 4. This means that when a process counting the N1\_MEM1\_RD event migrates between PEs on different devices, its relative view of the first memory type remains unchanged, even if the distance changes.

## 0x83E9 , N2\_MEM1\_RD, Access to type 1 memory at distance 2, demand access, read

The counter counts each demand read counted by N2\_MEM\_RD to a first memory type at distance 2.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system. See also N1\_MEM1\_RD.

## 0x83EA , N3\_MEM1\_RD, Access to type 1 memory at distance 3, demand access, read

The counter counts each demand read counted by N3\_MEM\_RD to a first memory type at distance 3.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system. See also N1\_MEM1\_RD.

## 0x83EB , N4\_MEM1\_RD, Access to type 1 memory at distance 4, demand access, read

The counter counts each demand read counted by N4\_MEM\_RD to a first memory type at distance 4.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system. See also N1\_MEM1\_RD.

## 0x83EC , N1\_MEM1\_PRFM, Access to type 1 memory at distance 1, software prefetch

The counter counts each software prefetch counted by N1\_MEM\_PRFM to a first memory type at distance 1.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83ED , N2\_MEM1\_PRFM, Access to type 1 memory at distance 2, software prefetch

The counter counts each software prefetch counted by N2\_MEM\_PRFM to a first memory type at distance 2.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83EE , N3\_MEM1\_PRFM, Access to type 1 memory at distance 3, software prefetch

The counter counts each software prefetch counted by N3\_MEM\_PRFM to a first memory type at distance 3.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83EF , N4\_MEM1\_PRFM, Access to type 1 memory at distance 4, software prefetch

The counter counts each software prefetch counted by N4\_MEM\_PRFM to a first memory type at distance 4.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83F0 , N1\_MEM2\_RD, Access to type 2 memory at distance 1, demand access, read

The counter counts each demand read counted by N1\_MEM\_RD to a second memory type at distance 1.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system. See also N1\_MEM2\_RD.

For example, the second memory type might be bulk expansion memory connected to a device. However, this must be the same for all devices in the system, such that, for example, N1\_MEM2\_RD refers to bulk expansion memory for a PE at distance 1 from the memory, regardless of which device the PE is located on, and N4\_MEM2\_RD refers to the same memory for any PE located at distance 4. This means that when a process counting the N1\_MEM2\_RD event migrates between PEs on different devices, its relative view of the second memory type remains unchanged, even if the distance changes.

## 0x83F1 , N2\_MEM2\_RD, Access to type 2 memory at distance 2, demand access, read

The counter counts each demand read counted by N2\_MEM\_RD to a second memory type at distance 2.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system. See also N1\_MEM2\_RD.

## 0x83F2 , N3\_MEM2\_RD, Access to type 2 memory at distance 3, demand access, read

The counter counts each demand read counted by N3\_MEM\_RD to a second memory type at distance 3.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system. See also N1\_MEM2\_RD.

## 0x83F3 , N4\_MEM2\_RD, Access to type 2 memory at distance 4, demand access, read

The counter counts each demand read counted by N4\_MEM\_RD to a second memory type at distance 4.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system. See also N1\_MEM2\_RD.

## 0x83F4 , N1\_MEM2\_PRFM, Access to type 2 memory at distance 1, software prefetch

The counter counts each software prefetch counted by N1\_MEM\_PRFM to a second memory type at distance 1.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83F5 , N2\_MEM2\_PRFM, Access to type 2 memory at distance 2, software prefetch

The counter counts each software prefetch counted by N2\_MEM\_PRFM to a second memory type at distance 2.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83F6 , N3\_MEM2\_PRFM, Access to type 2 memory at distance 3, software prefetch

The counter counts each software prefetch counted by N3\_MEM\_PRFM to a second memory type at distance 3.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83F7 , N4\_MEM2\_PRFM, Access to type 2 memory at distance 4, software prefetch

The counter counts each software prefetch counted by N4\_MEM\_PRFM to a second memory type at distance 4.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83F8 , N1\_MEM3\_RD, Access to type 3 memory at distance 1, demand access, read

The counter counts each demand read counted by N1\_MEM\_RD to a third memory type at distance 1.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system. See also N1\_MEM3\_RD.

For example, the third memory type might be high-bandwidth memory connected to a device. However, this must be the same for all devices in the system, such that, for example, N1\_MEM3\_RD refers to high-bandwidth memory for a PE at distance 1 from the memory, regardless of which device the PE is located on, and N4\_MEM3\_RD refers to the same memory for any PE located at distance 4. This means that when a process counting the N1\_MEM3\_RD event migrates between PEs on different devices, its relative view of the third memory type remains unchanged, even if the distance changes.

## 0x83F9 , N2\_MEM3\_RD, Access to type 3 memory at distance 2, demand access, read

The counter counts each demand read counted by N2\_MEM\_RD to a third memory type at distance 2.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system. See also N1\_MEM3\_RD.

## 0x83FA , N3\_MEM3\_RD, Access to type 3 memory at distance 3, demand access, read

The counter counts each demand read counted by N3\_MEM\_RD to a third memory type at distance 3.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system. See also N1\_MEM3\_RD.

## 0x83FB , N4\_MEM3\_RD, Access to type 3 memory at distance 4, demand access, read

The counter counts each demand read counted by N4\_MEM\_RD to a third memory type at distance 4.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system. See also N1\_MEM3\_RD.

## 0x83FC , N1\_MEM3\_PRFM, Access to type 3 memory at distance 1, software prefetch

The counter counts each software prefetch counted by N1\_MEM\_PRFM to a third memory type at distance 1.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83FD , N2\_MEM3\_PRFM, Access to type 3 memory at distance 2, software prefetch

The counter counts each software prefetch counted by N2\_MEM\_PRFM to a third memory type at distance 2.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83FE , N3\_MEM3\_PRFM, Access to type 3 memory at distance 3, software prefetch

The counter counts each software prefetch counted by N3\_MEM\_PRFM to a third memory type at distance 3.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x83FF , N4\_MEM3\_PRFM, Access to type 3 memory at distance 4, software prefetch

The counter counts each software prefetch counted by N4\_MEM\_PRFM to a third memory type at distance 4.

The definition of memory types in the system is IMPLEMENTATION DEFINED, but must be similar for all devices in the system.

## 0x8400 , ISNP\_HIT\_N1\_RD, Snoop hit in cache at distance 1, demand instruction fetch

The counter counts each snoop generated by the PE in response to a demand Instruction memory access counted by ISNP\_HIT\_RD that hits in a cache at distance 1.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8401 , ISNP\_HIT\_N2\_RD, Snoop hit in cache at distance 2, demand instruction fetch

The counter counts each snoop generated by the PE in response to a demand Instruction memory access counted by ISNP\_HIT\_RD that hits in a cache at distance 2.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8402 , ISNP\_HIT\_N3\_RD, Snoop hit in cache at distance 3, demand instruction fetch

The counter counts each snoop generated by the PE in response to a demand Instruction memory access counted by ISNP\_HIT\_RD that hits in a cache at distance 3.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8403 , ISNP\_HIT\_N4\_RD, Snoop hit in cache at distance 4, demand instruction fetch

The counter counts each snoop generated by the PE in response to a demand Instruction memory access counted by ISNP\_HIT\_RD that hits in a cache at distance 4.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8404 , DSNP\_HIT\_N1\_RD, Snoop hit in cache at distance 1, demand data read

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_RD that hits in a cache at distance 1.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8405 , DSNP\_HIT\_N2\_RD, Snoop hit in cache at distance 2, demand data read

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_RD that hits in a cache at distance 2.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8406 , DSNP\_HIT\_N3\_RD, Snoop hit in cache at distance 3, demand data read

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_RD that hits in a cache at distance 3.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8407 , DSNP\_HIT\_N4\_RD, Snoop hit in cache at distance 4, demand data read

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_RD that hits in a cache at distance 4.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8408 , DSNP\_HIT\_N1\_WR, Snoop hit in cache at distance 1, demand data write

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_WR that hits in a cache at distance 1.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8409 , DSNP\_HIT\_N2\_WR, Snoop hit in cache at distance 2, demand data write

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_WR that hits in a cache at distance 2.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x840A , DSNP\_HIT\_N3\_WR, Snoop hit in cache at distance 3, demand data write

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_WR that hits in a cache at distance 3.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x840B , DSNP\_HIT\_N4\_WR, Snoop hit in cache at distance 4, demand data write

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_WR that hits in a cache at distance 4.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x840C , DSNP\_HIT\_N1\_RW, Snoop hit in cache at distance 1, demand data access

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_RW that hits in a cache at distance 1.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x840D , DSNP\_HIT\_N2\_RW, Snoop hit in cache at distance 2, demand data access

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_RW that hits in a cache at distance 2.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x840E , DSNP\_HIT\_N3\_RW, Snoop hit in cache at distance 3, demand data access

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_RW that hits in a cache at distance 3.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x840F , DSNP\_HIT\_N4\_RW, Snoop hit in cache at distance 4, demand data access

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_RW that hits in a cache at distance 4.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8410 , DSNP\_HIT\_N1\_PRFM, Snoop hit in cache at distance 1, software data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction counted by DSNP\_HIT\_PRFM that hits in a cache at distance 1.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8411 , DSNP\_HIT\_N2\_PRFM, Snoop hit in cache at distance 2, software data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction counted by DSNP\_HIT\_PRFM that hits in a cache at distance 2.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8412 , DSNP\_HIT\_N3\_PRFM, Snoop hit in cache at distance 3, software data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction counted by DSNP\_HIT\_PRFM that hits in a cache at distance 3.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8413 , DSNP\_HIT\_N4\_PRFM, Snoop hit in cache at distance 4, software data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction counted by DSNP\_HIT\_PRFM that hits in a cache at distance 4.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8414 , DSNP\_HIT\_N1\_HWPRF, Snoop hit in cache at distance 1, hardware data prefetch

The counter counts each snoop generated by a data hardware prefetch counted by DSNP\_HIT\_HWPRF that hits in a cache at distance 1.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8415 , DSNP\_HIT\_N2\_HWPRF, Snoop hit in cache at distance 2, hardware data prefetch

The counter counts each snoop generated by a data hardware prefetch counted by DSNP\_HIT\_HWPRF that hits in a cache at distance 2.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8416 , DSNP\_HIT\_N3\_HWPRF, Snoop hit in cache at distance 3, hardware data prefetch

The counter counts each snoop generated by a data hardware prefetch counted by DSNP\_HIT\_HWPRF that hits in a cache at distance 3.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8417 , DSNP\_HIT\_N4\_HWPRF, Snoop hit in cache at distance 4, hardware data prefetch

The counter counts each snoop generated by a data hardware prefetch counted by DSNP\_HIT\_HWPRF that hits in a cache at distance 4.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8418 , ISNP\_HIT\_N1\_PRFM, Snoop hit in cache at distance 1, software instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction counted by ISNP\_HIT\_PRFM that hits in a cache at distance 1.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8419 , ISNP\_HIT\_N2\_PRFM, Snoop hit in cache at distance 2, software instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction counted by ISNP\_HIT\_PRFM that hits in a cache at distance 2.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x841A , ISNP\_HIT\_N3\_PRFM, Snoop hit in cache at distance 3, software instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction counted by ISNP\_HIT\_PRFM that hits in a cache at distance 3.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x841B , ISNP\_HIT\_N4\_PRFM, Snoop hit in cache at distance 4, software instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction counted by ISNP\_HIT\_PRFM that hits in a cache at distance 4.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x841C , ISNP\_HIT\_N1\_HWPRF, Snoop hit in cache at distance 1, hardware instruction prefetch

The counter counts each snoop generated by an instruction hardware prefetch counted by ISNP\_HIT\_HWPRF that hits in a cache at distance 1.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x841D , ISNP\_HIT\_N2\_HWPRF, Snoop hit in cache at distance 2, hardware instruction prefetch

The counter counts each snoop generated by an instruction hardware prefetch counted by ISNP\_HIT\_HWPRF that hits in a cache at distance 2.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x841E , ISNP\_HIT\_N3\_HWPRF, Snoop hit in cache at distance 3, hardware instruction prefetch

The counter counts each snoop generated by an instruction hardware prefetch counted by ISNP\_HIT\_HWPRF that hits in a cache at distance 3.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x841F , ISNP\_HIT\_N4\_HWPRF, Snoop hit in cache at distance 4, hardware instruction prefetch

The counter counts each snoop generated by an instruction hardware prefetch counted by ISNP\_HIT\_HWPRF that hits in a cache at distance 4.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8420 , DSNP\_HIT\_N1\_PRF, Snoop hit in cache at distance 1, data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction, or by a data hardware prefetch counted by DSNP\_HIT\_PRF that hits in a cache at distance 1.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8421 , DSNP\_HIT\_N2\_PRF, Snoop hit in cache at distance 2, data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction, or by a data hardware prefetch counted by DSNP\_HIT\_PRF that hits in a cache at distance 2.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8422 , DSNP\_HIT\_N3\_PRF, Snoop hit in cache at distance 3, data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction, or by a data hardware prefetch counted by DSNP\_HIT\_PRF that hits in a cache at distance 3.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8423 , DSNP\_HIT\_N4\_PRF, Snoop hit in cache at distance 4, data prefetch

The counter counts each snoop generated by the PE in response to a data prefetch instruction, or by a data hardware prefetch counted by DSNP\_HIT\_PRF that hits in a cache at distance 4.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8424 , ISNP\_HIT\_N1\_PRF, Snoop hit in cache at distance 1, instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction, or by an instruction hardware prefetch counted by ISNP\_HIT\_PRF that hits in a cache at distance 1.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8425 , ISNP\_HIT\_N2\_PRF, Snoop hit in cache at distance 2, instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction, or by an instruction hardware prefetch counted by ISNP\_HIT\_PRF that hits in a cache at distance 2.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8426 , ISNP\_HIT\_N3\_PRF, Snoop hit in cache at distance 3, instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction, or by an instruction hardware prefetch counted by ISNP\_HIT\_PRF that hits in a cache at distance 3.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8427 , ISNP\_HIT\_N4\_PRF, Snoop hit in cache at distance 4, instruction prefetch

The counter counts each snoop generated by the PE in response to an instruction prefetch instruction, or by an instruction hardware prefetch counted by ISNP\_HIT\_PRF that hits in a cache at distance 4.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8428 , ISNP\_HIT\_N1, Snoop hit in cache at distance 1, instruction access

The counter counts each snoop counted by ISNP\_HIT that hits in a cache at distance 1.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8429 , ISNP\_HIT\_N2, Snoop hit in cache at distance 2, instruction access

The counter counts each snoop counted by ISNP\_HIT that hits in a cache at distance 2.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x842A , ISNP\_HIT\_N3, Snoop hit in cache at distance 3, instruction access

The counter counts each snoop counted by ISNP\_HIT that hits in a cache at distance 3.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x842B , ISNP\_HIT\_N4, Snoop hit in cache at distance 4, instruction access

The counter counts each snoop counted by ISNP\_HIT that hits in a cache at distance 4.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x842C , DSNP\_HIT\_N1, Snoop hit in cache at distance 1, data access

The counter counts each snoop counted by DSNP\_HIT that hits in a cache at distance 1.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x842D , DSNP\_HIT\_N2, Snoop hit in cache at distance 2, data access

The counter counts each snoop counted by DSNP\_HIT that hits in a cache at distance 2.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x842E , DSNP\_HIT\_N3, Snoop hit in cache at distance 3, data access

The counter counts each snoop counted by DSNP\_HIT that hits in a cache at distance 3.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x842F , DSNP\_HIT\_N4, Snoop hit in cache at distance 4, data access

The counter counts each snoop counted by DSNP\_HIT that hits in a cache at distance 4.

The event is counted by the PE generating the snoop, not the PE being snooped.

The cache distance indicates the relative distance that the return data has traveled. The distance is a relative distance that is defined at the system level, allowing flexibility of use for different systems that may have differing levels of hierarchy.

The interpretation of distance is IMPLEMENTATION DEFINED, and should be the same for all PEs in the base system, and the same for both cache and memory distances.

## 0x8431 , ASE\_FP\_VREDUCE\_SPEC,Floating-point operation speculatively executed, Advanced SIMD pairwise or reduction

The counter counts each speculatively executed floating-point treewise reduction or pairwise operation counted by ASE\_SVE\_FP\_VREDUCE\_SPEC due to any of the following A64 instructions:

- Advanced SIMD: FADDP, FMAXNMP, FMAXNMV, FMAXP, FMAXV, FMINNMP, FMINNMV, FMINP, or FMINV.

Note

Treewise reduction instructions might be executed and counted as multiple pairwise operations.

## 0x8432 , SVE\_FP\_PREDUCE\_SPEC, Floating-point operation speculatively executed, SVE pairwise add step or pairwise reduce step

The counter counts each speculatively executed floating-point pairwise add step or pairwise reduce step operation counted by SVE\_FP\_VREDUCE\_SPEC due to any of the following instructions:

- SVE2: FADDP, FMAXNMP, FMAXP, FMINNMP, or FMINP.

## 0x8434 , DSNP\_HITM\_N1\_RD, Snoop hit in cache at distance 1, demand data read, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_N1\_RD that accesses a previously modified cache location.

## 0x8435 , DSNP\_HITM\_N2\_RD, Snoop hit in cache at distance 2, demand data read, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_N2\_RD that accesses a previously modified cache location.

## 0x8436 , DSNP\_HITM\_N3\_RD, Snoop hit in cache at distance 3, demand data read, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_N3\_RD that accesses a previously modified cache location.

## 0x8437 , DSNP\_HITM\_N4\_RD, Snoop hit in cache at distance 4, demand data read, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation counted by DSNP\_HIT\_N4\_RD that accesses a previously modified cache location.

## 0x8438 , DSNP\_HITM\_N1\_WR, Snoop hit in cache at distance 1, demand data write, modified

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_N1\_WR that accesses a previously modified cache location.

## 0x8439 , DSNP\_HITM\_N2\_WR, Snoop hit in cache at distance 2, demand data write, modified

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_N2\_WR that accesses a previously modified cache location.

## 0x843A , DSNP\_HITM\_N3\_WR, Snoop hit in cache at distance 3, demand data write, modified

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_N3\_WR that accesses a previously modified cache location.

## 0x843B , DSNP\_HITM\_N4\_WR, Snoop hit in cache at distance 4, demand data write, modified

The counter counts each snoop generated by the PE in response to a demand Memory-write operation counted by DSNP\_HIT\_N4\_WR that accesses a previously modified cache location.

## 0x843C , DSNP\_HITM\_N1\_RW, Snoop hit in cache at distance 1, demand data access, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_N1\_RW that accesses a previously modified cache location.

## 0x843D , DSNP\_HITM\_N2\_RW, Snoop hit in cache at distance 2, demand data access, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_N2\_RW that accesses a previously modified cache location.

## 0x843E , DSNP\_HITM\_N3\_RW, Snoop hit in cache at distance 3, demand data access, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_N3\_RW that accesses a previously modified cache location.

## 0x843F , DSNP\_HITM\_N4\_RW, Snoop hit in cache at distance 4, demand data access, modified

The counter counts each snoop generated by the PE in response to a demand Memory-read operation or demand Memory-write operation counted by DSNP\_HIT\_N4\_RW that accesses a previously modified cache location.

## 0x8440 , ASE\_FP\_SP\_MIN\_SPEC, Advanced SIMD data processing operation speculatively executed, smallest type is single-precision floating-point

The counter counts each Advanced SIMD data-processing operation counted by ASE\_SVE\_FP\_SP\_MIN\_SPEC due to an instruction where the smallest type was single-precision floating-point.

## 0x8442 , ASE\_FP\_HP\_MIN\_SPEC, Advanced SIMD data processing operation speculatively executed, smallest type is half-precision floating-point

The counter counts each Advanced SIMD data-processing operation counted by ASE\_SVE\_FP\_HP\_MIN\_SPEC due to an instruction where the smallest type was half-precision floating-point.

## 0x8443 , ASE\_FP\_BF16\_MIN\_SPEC, Advanced SIMD data processing operation speculatively executed, smallest type is BFloat16 floating-point

The counter counts each Advanced SIMD data-processing operation counted by ASE\_SVE\_FP\_BF16\_MIN\_SPEC due to an instruction where the smallest type was BFloat16 floating-point.

## 0x8444 , ASE\_FP\_FP8\_MIN\_SPEC, Advanced SIMD data processing operation speculatively executed, smallest type is 8-bit floating-point

The counter counts each Advanced SIMD data-processing operation counted by ASE\_SVE\_FP\_FP8\_MIN\_SPEC due to an instruction where the smallest type was 8-bit floating-point.

## 0x8448 , ASE\_SVE\_FP\_SP\_MIN\_SPEC,AdvancedSIMDdataprocessingorSVEdataprocessingoperationspeculatively executed, smallest type is single-precision floating-point

The counter counts each Advanced SIMD or SVE data-processing operation counted by SE\_FP\_SP\_MIN\_SPEC due to an instruction where the smallest type was single-precision floating-point.

0x844A , ASE\_SVE\_FP\_HP\_MIN\_SPEC,AdvancedSIMDdataprocessingorSVEdataprocessingoperation speculatively executed, smallest type is half-precision floating-point

The counter counts each Advanced SIMD or SVE data-processing operation counted by SE\_FP\_HP\_MIN\_SPEC due to an instruction where the smallest type was half-precision floating-point.

0x844B , ASE\_SVE\_FP\_BF16\_MIN\_SPEC,AdvancedSIMDdataprocessingorSVEdataprocessingoperation speculatively executed, smallest type is BFloat16 floating-point

The counter counts each Advanced SIMD or SVE data-processing operation counted by SE\_FP\_BF16\_MIN\_SPEC due to an instruction where the smallest type was BFloat16 floating-point.

0x844C , ASE\_SVE\_FP\_FP8\_MIN\_SPEC,AdvancedSIMDdataprocessingorSVEdataprocessingoperation speculatively executed, smallest type is 8-bit floating-point

The counter counts each Advanced SIMD or SVE data-processing operation counted by SE\_FP\_FP8\_MIN\_SPEC due to an instruction where the smallest type was 8-bit floating-point.

0x8450 , SE\_FP\_SP\_MIN\_SPEC, Advanced SIMD, SVE, or SME data processing operation speculatively executed, smallest type is single-precision floating-point

The counter counts each Advanced SIMD, SVE, or SME data processing operation counted by FP\_SP\_MIN\_SPEC due to an instruction where the smallest type was single-precision floating-point.

0x8452 , SE\_FP\_HP\_MIN\_SPEC, Advanced SIMD, SVE, or SME data processing operation speculatively executed, smallest type is half-precision floating-point

The counter counts each Advanced SIMD, SVE, or SME data processing operation counted by FP\_HP\_MIN\_SPEC due to an instruction where the smallest type was half-precision floating-point.

0x8453 , SE\_FP\_BF16\_MIN\_SPEC, Advanced SIMD, SVE, or SME data processing operation speculatively executed, smallest type is BFloat16 floating-point

The counter counts each Advanced SIMD, SVE, or SME data processing operation counted by FP\_BF16\_MIN\_SPEC due to an instruction where the smallest type was BFloat16 floating-point.

0x8454 , SE\_FP\_FP8\_MIN\_SPEC, Advanced SIMD, SVE, or SME data processing operation speculatively executed, smallest type is 8-bit floating-point

The counter counts each Advanced SIMD, SVE, or SME data processing operation counted by FP\_FP8\_MIN\_SPEC due to an instruction where the smallest type was 8-bit floating-point.

0x8458 , SME\_FP\_SP\_MIN\_SPEC, SME data processing operation speculatively executed, smallest type is singleprecision floating-point

The counter counts each SME data-processing operation counted by SE\_FP\_SP\_MIN\_SPEC due to an instruction where the smallest type was single-precision floating-point.

## 0x845A , SME\_FP\_HP\_MIN\_SPEC,SMEdataprocessingoperation speculatively executed, smallest type is half-precision floating-point

The counter counts each SME data-processing operation counted by SE\_FP\_HP\_MIN\_SPEC due to an instruction where the smallest type was half-precision floating-point.

## 0x845B , SME\_FP\_BF16\_MIN\_SPEC, SME data processing operation speculatively executed, smallest type is BFloat16 floating-point

The counter counts each SME data-processing operation counted by SE\_FP\_BF16\_MIN\_SPEC due to an instruction where the smallest type was BFloat16 floating-point.

0x845C

point

The counter counts each SME data-processing operation counted by SE\_FP\_FP8\_MIN\_SPEC due to an instruction where the smallest type was 8-bit floating-point.

## 0x8460 , SVE\_FP\_SP\_MIN\_SPEC, SVE data processing operation speculatively executed, smallest type is single-precision floating-point

The counter counts each SVE data-processing operation counted by ASE\_SVE\_FP\_SP\_MIN\_SPEC due to an instruction where the smallest type was single-precision floating-point.

## 0x8462 , SVE\_FP\_HP\_MIN\_SPEC, SVE data processing operation speculatively executed, smallest type is half-precision floating-point

The counter counts each SVE data-processing operation counted by ASE\_SVE\_FP\_HP\_MIN\_SPEC due to an instruction where the smallest type was half-precision floating-point.

## 0x8463 , SVE\_FP\_BF16\_MIN\_SPEC, SVE data processing operation speculatively executed, smallest type is BFloat16 floating-point

The counter counts each SVE data-processing operation counted by ASE\_SVE\_FP\_BF16\_MIN\_SPEC due to an instruction where the smallest type was BFloat16 floating-point.

## 0x8464 , SVE\_FP\_FP8\_MIN\_SPEC, SVE data processing operation speculatively executed, smallest type is 8-bit floatingpoint

The counter counts each SVE data-processing operation counted by ASE\_SVE\_FP\_FP8\_MIN\_SPEC due to an instruction where the smallest type was 8-bit floating-point.

## 0x846B , FP\_BF16\_FIXED\_OPS\_SPEC, Non-scalable element arithmetic operations speculatively executed, largest type is BFloat16 floating-point

The counter increments by v for each speculatively executed non-scalable element arithmetic operation, due to an instruction where the largest type was BFloat16 floating-point.

Where v is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_SCALE\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

, SME\_FP\_FP8\_MIN\_SPEC, SME data processing operation speculatively executed, smallest type is 8-bit floating-

## 0x8470 , FP\_SP\_MIN\_SPEC, Floating-point operation speculatively executed, smallest type is single-precision floatingpoint

The counter counts each floating-point operation counted by FP\_SPEC due to an instruction where the smallest type was single-precision floating-point.

## 0x8472 , FP\_HP\_MIN\_SPEC, Floating-point operation speculatively executed, smallest type is half-precision floatingpoint

The counter counts each floating-point operation counted by FP\_SPEC due to an instruction where the smallest type was half-precision floating-point.

## 0x8473 , FP\_BF16\_MIN\_SPEC, Floating-point operation speculatively executed, smallest type is BFloat16 floating-point

The counter counts each floating-point operation counted by FP\_SPEC due to an instruction where the smallest type was BFloat16 floating-point.

## 0x8474 , FP\_FP8\_MIN\_SPEC, Floating-point operation speculatively executed, smallest type is 8-bit floating-point

The counter counts each floating-point operation counted by FP\_SPEC due to an instruction where the smallest type was 8-bit floating-point.

## 0x8480 , FP\_SP\_FIXED\_MIN\_OPS\_SPEC, Non-scalable element arithmetic operations speculatively executed, smallest type is single-precision floating-point

The counter increments by v for each speculatively executed non-scalable element arithmetic operation, due to an instruction where the smallest type was single-precision floating-point.

Where v is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_SCALE\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x8482 , FP\_HP\_FIXED\_MIN\_OPS\_SPEC, Non-scalable element arithmetic operations speculatively executed, smallest type is half-precision floating-point

The counter increments by v for each speculatively executed non-scalable element arithmetic operation, due to an instruction where the smallest type was half-precision floating-point.

Where v is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_SCALE\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x8483 , FP\_BF16\_FIXED\_MIN\_OPS\_SPEC, Non-scalable element arithmetic operations speculatively executed, smallest type is BFloat16 floating-point

The counter increments by v for each speculatively executed non-scalable element arithmetic operation, due to an instruction where the smallest type was BFloat16 floating-point.

Where v is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_SCALE\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x8484 , FP\_FP8\_FIXED\_MIN\_OPS\_SPEC, Non-scalable element arithmetic operations speculatively executed, smallest type is 8-bit floating-point

The counter increments by v for each speculatively executed non-scalable element arithmetic operation, due to an instruction where the smallest type was 8-bit floating-point.

Where v is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_SCALE\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x8488 , FP\_SP\_SCALE\_MIN\_OPS\_SPEC, Scalable element arithmetic operations speculatively executed, smallest type is single-precision floating-point

The counter increments by v for each speculatively executed scalable element arithmetic operation, due to an instruction where the smallest type was single-precision floating-point.

Where v is a value such that (v × (VL÷128)) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x848A , FP\_HP\_SCALE\_MIN\_OPS\_SPEC, Scalable element arithmetic operations speculatively executed, smallest type is half-precision floating-point

The counter increments by v for each speculatively executed scalable element arithmetic operation, due to an instruction where the smallest type was half-precision floating-point.

Where v is a value such that (v × (VL÷128)) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x848B , FP\_BF16\_SCALE\_MIN\_OPS\_SPEC, Scalable element arithmetic operations speculatively executed, smallest type is BFloat16 floating-point

The counter increments by v for each speculatively executed scalable element arithmetic operation, due to an instruction where the smallest type was BFloat16 floating-point.

Where v is a value such that (v × (VL÷128)) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x848C , FP\_FP8\_SCALE\_MIN\_OPS\_SPEC, Scalable element arithmetic operations speculatively executed, smallest type is 8-bit floating-point

The counter increments by v for each speculatively executed scalable element arithmetic operation, due to an instruction where the smallest type was 8-bit floating-point.

Where v is a value such that (v × (VL÷128)) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE2\_OPS\_SPEC.

## 0x8490 , FP\_SP\_SCALE2\_MIN\_OPS\_SPEC, Scalable tile arithmetic operations speculatively executed, smallest type is single-precision floating-point

The counter increments by v for each speculatively executed scalable tile arithmetic operation, due to an instruction where the smallest type was single-precision floating-point.

Where v is a value such that (v × (VL÷128)²) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE\_OPS\_SPEC.

## 0x8492 , FP\_HP\_SCALE2\_MIN\_OPS\_SPEC, Scalable tile arithmetic operations speculatively executed, smallest type is half-precision floating-point

The counter increments by v for each speculatively executed scalable tile arithmetic operation, due to an instruction where the smallest type was half-precision floating-point.

Where v is a value such that (v × (VL÷128)²) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE\_OPS\_SPEC.

## 0x8493 , FP\_BF16\_SCALE2\_MIN\_OPS\_SPEC, Scalable tile arithmetic operations speculatively executed, smallest type is BFloat16 floating-point

The counter increments by v for each speculatively executed scalable tile arithmetic operation, due to an instruction where the smallest type was BFloat16 floating-point.

Where v is a value such that (v × (VL÷128)²) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE\_OPS\_SPEC.

## 0x8494 , FP\_FP8\_SCALE2\_MIN\_OPS\_SPEC, Scalable tile arithmetic operations speculatively executed, smallest type is 8-bit floating-point

The counter increments by v for each speculatively executed scalable tile arithmetic operation, due to an instruction where the smallest type was 8-bit floating-point.

Where v is a value such that (v × (VL÷128)²) is the number of arithmetic operations carried out by the operation or instruction which causes the counter to increment.

The counter does not count operations that are counted by FP\_FIXED\_OPS\_SPEC or FP\_SCALE\_OPS\_SPEC.