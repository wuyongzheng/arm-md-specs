## G5.11 VMSAv8-32 memory aborts

In a VMSAv8-32 implementation, the following mechanisms cause a PE to take an exception on a failed memory access:

Debug exception An exception caused by the debug configuration, see AArch32 Self-hosted Debug.

- Alignment fault An Alignment fault is generated if the address used for a memory access does not have the required alignment for the operation. For more information, see Unaligned data access and Alignment faults.
- MMUfault An MMUfault is a fault generated by the fault checking sequence for the current translation regime. See Types of MMU faults.

External abort Any memory system fault other than a Debug exception, an Alignment fault, or an MMU fault.

Collectively, these mechanisms are called aborts . AArch32 Self-hosted Debug and Halting Debug Events describe Debug exceptions, and the remainder of this section describes Alignment faults, MMU faults, and External aborts.

An access that causes an abort is said to be aborted, and uses the Fault Address Registers (FARs) and Fault Status Registers (FSRs) or Exception Syndrome Registers (ESRs) to record context information.

The exception generated on a synchronous memory abort:

- On an instruction fetch is called the Prefetch Abort exception.
- On a data access is called the Data Abort exception.

Note

The Prefetch Abort exception applies to any synchronous memory abort on an instruction fetch. It is not restricted to speculative instruction fetches.

The Exception level and PE mode that a VMSAv8-32 memory abort is taken to depends on the translation regime and stage that generate the abort. The fault context is dependent on whether:

- The abort is reported as a Prefetch Abort or as a Data Abort.
- The exception is taken from the same or a lower Exception level.

Note

A memory access from AArch32 state may be subject to one or more VMSAv8-64 translation stages. For example, a Non-secure EL0 access when EL1 is using AArch64 is subject to both stages of the VMSAv8-64 Non-secure EL1&amp;0 translation regime. A memory abort generated on a VMSAv8-64 translation stage is handled as described in Memory aborts.

For more information, see Routing of aborts taken to AArch32 state.

External aborts can be reported synchronously or asynchronously. Asynchronous External aborts are reported using the SError exception. For more information, see External aborts.

In AArch32 state, asynchronous memory aborts are a type of External abort, and are treated as a type of Data Abort exception.

The following sections describe the abort mechanisms:

- Types of MMU faults.
- VMSAv8-32 MMU fault terminology.
- The MMU fault-checking sequence.
- Alignment faults.
- External abort on a translation table walk.
- AArch32 state prioritization of synchronous aborts from a single stage of address translation.

An access that causes an abort is said to be aborted. On an abort, System registers are used to record context information. For more information, see Exception reporting in a VMSAv8-32 implementation.

## G5.11.1 Types of MMU faults

This section describes the faults that might be detected during one of the fault-checking sequences described in The MMUfault-checking sequence. Unless indicated otherwise, information in this section applies to the fault checking sequences for both the Short-descriptor translation table format and the Long-descriptor translation table format.

MMUfaults are always synchronous.

When an MMU fault generates an abort for a region of memory, no memory access is made if that region is or could be marked as any type of Device memory.

The MMU faults that might be detected during a fault checking sequence are:

- Permission fault.
- Translation fault.
- Address size fault.
- Access flag fault.
- Domain fault, Short-descriptor translation tables only.
- TLB conflict abort.

See also External abort on a translation table walk.

Note

- Although the TLB conflict abort is classified as an MMU fault, it is described in the section Translation Lookaside Buffers.
- In VMSAv8-64 an External abort on a translation table walk is classified as an MMU fault. However, in VMSAv8-32, for consistency with earlier versions of the architecture these aborts are not classified as MMU faults.

## G5.11.1.1 Permission fault

APermission fault can be generated at any level of lookup, and the reported fault code identifies the lookup level. See About access permissions for information about conditions that cause a Permission fault.

Note

When using the Short-descriptor translation table format, the Translation Table descriptors are checked for Permission faults only for accesses to memory regions in Client domains.

ATLBmight hold a translation table entry that cause a Permission fault. Therefore, if the handling of a Permission fault results in an update to the associated translation tables, the software that updates the translation tables must invalidate the appropriate TLB entry, to prevent the stale information in the TLB being used on a subsequent memory access. For more information, see the translation table entry update examples in Ordering and completion of TLB maintenance instructions.

In an implementation that includes EL2, this maintenance requirement applies to Permission faults in both stage 1 and stage 2 translations.

Cache or branch predictor maintenance operations cannot cause a Permission fault, except that:

- Astage 1 translation table walk performed as part of a cache or branch predictor maintenance operation can generate a stage 2 Permission fault as described in Stage 2 fault on a stage 1 translation table walk.
- When FEAT\_CMOW is implemented and the Effective value of HCRX\_EL2.CMOW is 1, the DCCIMVAC and ICIMVAU cache maintenance instructions can generate a stage 2 Permission fault if they do not have read and write permission at EL1 or EL0. See Permission fault.

## G5.11.1.2 Translation fault

ATranslation fault can be generated at any level of lookup, and the reported fault code identifies the lookup level. A Translation fault is generated if bits[1:0] of a Translation Table descriptor identify the descriptor as either a Fault encoding or a reserved encoding. For more information, see:

- VMSAv8-32 Short-descriptor Translation Table format descriptors.

- VMSAv8-32 Long-descriptor Translation Table format descriptors.

In addition, a Translation fault is generated if the input address for a translation either does not map onto an address range of a TTBR, or the TTBR range that it maps onto is disabled. In these cases the fault is reported as a level 1 Translation fault on the translation stage at which the mapping to a region described by a TTBR failed.

The architecture guarantees that any translation table entry that causes a Translation fault is not cached, meaning the TLB never holds such an entry. Therefore, when a Translation fault occurs, the fault handler does not have to perform any TLB maintenance instructions to remove the faulting entry.

Adata or unified cache maintenance by VA instruction can generate a Translation fault. However:

- If the Point of Coherency is before any level of cache, it is IMPLEMENTATION DEFINED whether a data or unified cache maintenance by VA to the Point of Coherency instruction can generate a Translation fault.
- If the Point of Unification is before any level of data cache, it is IMPLEMENTATION DEFINED whether a data or unified cache clean by V A to the Point of Unification instruction can generate a Translation fault.

It is IMPLEMENTATION DEFINED whether an instruction cache invalidate by V A operation can generate a Translation fault.

It is IMPLEMENTATION DEFINED whether a branch predictor maintenance operation can generate a Translation fault.

## G5.11.1.3 Address size fault

An Address size fault can be generated at any level of lookup, and the reported fault code identifies the lookup level.

An Address size fault is generated if the translation table entries or the TTBR for the stage of translation have nonzero address bits above the most significant bit of the maximum output address size. Because VMSAv8-32 supports a maximum PA and IPA size of 40 bits, this means any case where a translation table entry or the TTBR holds an address for which A[47:40] is nonzero generates an Address size fault.

Adata or unified cache maintenance by VA instruction can generate an Address size fault. However:

- If the Point of Coherency is before any level of cache, it is IMPLEMENTATION DEFINED whether a data or unified cache maintenance by VA instruction can generate an Address size fault.
- If the Point of Unification is before any level of data cache, it is IMPLEMENTATION DEFINED whether a data or unified cache clean by V A to the Point of Unification instruction can generate an Address size fault.

It is IMPLEMENTATION DEFINED whether an instruction cache invalidate by V A operation can generate an Address size fault.

It is IMPLEMENTATION DEFINED whether a branch predictor maintenance operation can generate an Address size fault.

The architecture guarantees that any translation table entry that causes an Address size fault is not cached, meaning the TLB never holds such an entry. Therefore, when an Address size fault occurs, the fault handler does not have to perform any TLB maintenance instructions to remove the faulting entry.

## G5.11.1.4 Access flag fault

An Access flag fault can be generated at any level of lookup, and the reported fault code identifies the lookup level. An Access flag fault is generated only if all of the following apply:

- The translation tables support an Access flag bit:
- -The Short-descriptor format supports an Access flag only when SCTLR.AFE is set to 1.
- -The Long-descriptor format always supports an Access flag.
- ATranslation Table descriptor with the Access flag bit set to 0 is loaded.

For more information about the Access flag bit see:

- VMSAv8-32 Short-descriptor Translation Table format descriptors
- VMSAv8-32 Long-descriptor Translation Table format descriptors.

The architecture guarantees that any translation table entry that causes an Access flag fault is not cached, meaning the TLB never holds such an entry. Therefore, when an Access flag fault occurs, the fault handler does not have to perform any TLB maintenance instructions to remove the faulting entry.

Whether any cache maintenance instruction by VA can generate Access flag faults is IMPLEMENTATION DEFINED.

Whether branch predictor invalidate by V A operations can generate Access flag faults is IMPLEMENTATION DEFINED.

For more information, see The Access flag.

## G5.11.1.5 Domain fault, Short-descriptor format translation tables only

When using the Short-descriptor translation table format, a Domain fault can be generated at level 1or level 2 of lookup. The reported fault code identifies the lookup level. The conditions for generating a Domain fault are:

- Level 1 When a level 1 descriptor fetch returns a valid Section level 1 descriptor, the domain field of that descriptor is checked against the DACR. A level 1 Domain fault is generated if this check fails.
- Level 2 When a level 2 descriptor fetch returns a valid level 2 descriptor, the domain field of the level 1 descriptor that required the level 2 fetch is checked against the DACR, and a level 2 Domain fault is

generated if this check fails.

For more information, see Domains, Short-descriptor format only.

Domain faults cannot occur on cache or branch predictor maintenance operations.

ATLBmight hold a translation table entry that cause a Domain fault. Therefore, if the handling of a Domain fault results in an update to the associated translation tables, the software that updates the translation tables must invalidate the appropriate TLB entry, to prevent the stale information in the TLB being used on a subsequent memory access. For more information, see the translation table entry update examples in Ordering and completion of TLB maintenance instructions.

Any change to the DACR must be synchronized by a Context Synchronization event. For more information, see Synchronization of changes to AArch32 System registers.

## G5.11.2 VMSAv8-32 MMU fault terminology

The Armv7 Large Physical Address Extension introduced new terminology for faults on a stage of address translation, to provide consistent terminology across all implementations. Table G5-24 shows the terminology used in this manual for an MMU faults, compared with older Arm documentation. The current terms are the same for faults that occur with the Short-descriptor translation table format and with the Long-descriptor format, and also apply to faults in a level 3 lookup when using the Long-descriptor translation table format.

## Table G5-24 MMU fault terminology

| Current term              | Old term                  | Note                                                                                                                                                                  |
|---------------------------|---------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Level 1 Translation fault | Section Translation fault | -                                                                                                                                                                     |
| Level 2 Translation fault | Page Translation fault    | -                                                                                                                                                                     |
| Level 3 Translation fault | -                         | Long-descriptor translation table format only.                                                                                                                        |
| Level 1 Access flag fault | Section Access flag fault | -                                                                                                                                                                     |
| Level 2 Access flag fault | Page Access flag fault    | -                                                                                                                                                                     |
| Level 3 Access flag fault | -                         | Long-descriptor translation table format only.                                                                                                                        |
| Level 1 Domain fault      | Section Domain fault      | Short-descriptor translation table format only, except for reporting faults on address translation instructions in the 64-bit PAR, see Determining the PAR format. 3. |
| Level 2 Domain fault      | Page Domain fault         | Cannot occur at level                                                                                                                                                 |
| Level 1 Permission fault  | Section Permission fault  | -                                                                                                                                                                     |
| Level 2 Permission fault  | Page Permission fault     | -                                                                                                                                                                     |
| Level 3 Permission fault  | -                         | Long-descriptor translation table format only.                                                                                                                        |

In an implementation that includes EL2, MMU faults are also classified by the translation stage at which the fault is generated. This means that a memory access from a Non-secure PL1 or EL0 mode can generate:

- Astage 1 MMU fault, for example, a stage 1 Translation fault.
- Astage 2 MMU fault, for example, a stage 2 Translation fault.

## G5.11.3 The MMU fault-checking sequence

This section describes the MMU checks made for the memory accesses required for instruction fetches and for explicit memory effects:

- If an instruction fetch faults it generates a Prefetch Abort exception.
- If an data memory access faults it generates a Data Abort exception.

For more information about Prefetch Abort exceptions and Data Abort exceptions see Handling exceptions that are taken to an Exception level using AArch32.

In VMSAv8-32, all memory accesses require VA to PA translation. Therefore, when a corresponding stage of address translation is enabled, each access requires a lookup of the Translation Table descriptor for the accessed V A. For more information, see Translation tables and subsequent sections of this chapter. MMU fault checking is performed for each level of translation table lookup. If an implementation includes EL2 and is operating in Non-secure state, MMU fault checking is performed for each stage of address translation.

Note

In an implementation that includes EL2, if a PE is executing in Non-secure state, the operating system or similar Non-secure system software defines the stage 1 translation tables in the IPA address map, and typically is unaware of the stage 2 translation from IPA to PA. However, each Non-secure stage 1 translation table access is subject to stage 2 address translation, and might be faulted at that stage.

The MMU fault checking sequence is largely independent of the translation table format, as the figures in this section show. The differences are:

## When using the Short-descriptor format

- There are one or two levels of lookup.
- Lookup always starts at level 1.
- The final level of lookup checks the Domain field of the descriptor and:
- -Faults if there is no access to the Domain.
- -Checks the access permissions only for Client domains.

## When using the Long-descriptor format

- There are one, two, or three levels of lookup.
- Lookup starts at either level 1 or level 2.
- Domains are not supported. All accesses are treated as Client domain accesses.

The fault-checking sequence shows a translation from an Input address to an Output address. For more information about this terminology, see About address translation for VMSAv8-32.

Note

The descriptions in this section do not include the possibility that the attempted address translation generates a TLB conflict abort, as described in TLB conflict aborts.

Types of MMU faults describes the faults that an MMU fault-checking sequence can report.

Figure G5-15 shows the process of fetching a descriptor from the translation table. For the top-level fetch for any translation, the descriptor is fetched only if the input address passes any required alignment check. As the figure shows, in an implementation that includes EL2, if the translation is stage 1 of the Non-secure PL1&amp;0 translation regime, then the descriptor address is in the IPA address map, and is subject to a stage 2 translation to obtain the required PA. This stage 2 translation requires a recursive entry to the fault checking sequence.

Note

Figure G5-15 and Figure G5-16 give an overview of the fault checking performed by the MMU. See AArch32 state prioritization of synchronous aborts from a single stage of address translation for the complete set of possible faults and their prioritization.

Figure G5-15 Fetching the descriptor in a VMSAv8-32 translation table walk

<!-- image -->

Figure G5-16 shows the full VMSAv8-32 fault checking sequence, including the alignment check on the initial access.

Figure G5-16 VMSAv8-32 fault checking sequence

<!-- image -->

## G5.11.3.1 Stage 2 fault on a stage 1 translation table walk

When an implementation that includes EL2 is operating in a Non-secure PL1 or EL0 mode, any memory access goes through two stages of translation:

- Stage 1, from V A to IPA.
- Stage 2, from IPA to PA.

Note

In a virtualized system that is using AArch32, typically, a Guest OS operating in a Non-secure PL1 mode defines the translation tables and translation table register entries controlling the Non-secure PL1&amp;0 stage 1 translations. A Guest OS has no awareness of the stage 2 address translation, and therefore believes it is specifying translation table addresses in the PA map. However, it actually specifies these addresses in its IPA map. Therefore, to support virtualization, translation table addresses for the Non-secure PL1&amp;0 stage 1 translations are always defined in the IPA address map.

On performing a translation table walk for the stage 1 translations, the descriptor addresses must be translated from IPA to PA, using a stage 2 translation. This means that a memory access made as part of a stage 1 translation table lookup might generate, on a stage 2 translation:

- ATranslation fault, Access flag fault, or Permission fault.
- Asynchronous External abort on the memory access.

If SCR.EA is set to 1, a synchronous External abort is taken to EL3, and if EL3 is using AArch32 it is taken to Secure Monitor mode. Otherwise, these faults are reported as stage 2 memory aborts. When EL2 is using AArch32, HSR.ISS[7] is set to 1, to indicate a stage 2 fault during a stage 1 translation table walk, and the part of the ISS field that might contain details of the instruction is invalid. For more information, see Use of the HSR.

Alternatively, a memory access made as part of a stage 1 translation table lookup might target an area of memory with the Device memory attribute assigned on the stage 2 translation of the address accessed. When the value of the HCR.PTW bit is 1, such an access generates a stage 2 Permission fault.

Note

- On most systems, such a mapping to a Device memory type on the stage 2 translation is likely to indicate a Guest OS error, where the stage 1 translation table is corrupted. Therefore, it is appropriate to trap this access to the hypervisor.

ATLBmight hold entries that depend on the effect of HCR.PTW. Therefore, if HCR.PTW is changed without changing the current VMID, the TLBs must be invalidated before executing in a Non-secure PL1 or EL0 mode. For more information, see Changing HCR.PTW.

Acache maintenance instruction executed at Non-secure PL1 can cause a stage 1 translation table walk that might generate a stage 2 Permission fault, as described in this section. However:

- If the Point of Coherency is before any level of cache, it is IMPLEMENTATION DEFINED whether a cache maintenance by VA instruction can generate a Permission fault in this way.
- If the Point of Unification is before any level of data cache, it is IMPLEMENTATION DEFINED whether a data or unified cache clean by V A to the Point of Unification instruction can generate a Permission fault in this way.

Note

This is an exception to the general rule that a cache maintenance instruction cannot generate a Permission fault.

## G5.11.3.1.1 The level associated with MMU faults

When an MMU fault is from a stage of translation that is using Long-descriptor translation table format, Table G5-25 shows how the LL bits in the STATUS field of DFSR, IFSR, and HSR encode the lookup level associated with the fault.

## Table G5-25 Use of LL bits to encode the lookup level at which the fault occurred

|   LL bits | Meaning                                                                     |
|-----------|-----------------------------------------------------------------------------|
|        00 | Level 0 of translation or translation table base register.                  |
|        01 | Level 1.                                                                    |
|        10 | Level 2.                                                                    |
|        11 | Level 3. When xFSR.STATUS indicates a Domain fault, this value is reserved. |

The lookup level associated with a fault is:

- For a fault generated on a translation table walk, the lookup level of the walk being performed.
- For a Translation fault, the lookup level of the translation table that gave the fault. If a fault occurs because a stage of address translation is disabled, or because the input address is outside the range specified by the appropriate base address register or registers, the fault is reported as a level 1 fault.
- For an Access flag fault, the lookup level of the translation table that gave the fault.
- For a Permission fault, including a Permission fault caused by hierarchical permissions, the lookup level of the final level of translation table accessed for the translation. That is, the lookup level of the translation table that returned a Block or Page descriptor.

Also see Synchronous External abort errors from address translation caching structures.

## G5.11.4 Alignment faults

The Arm memory architecture requires support for strict alignment checking. This checking is controlled by:

- SCTLR.A, for accesses made from any PE mode other than Hyp mode.
- HSCTLR.A, for accesses made from Hyp mode.

In addition, some instructions do not support unaligned accesses, regardless of the value of SCTLR.A or HSCTLR.A.

Unaligned data access:

- Defines when Alignment faults are generated, for both values of SCTLR.A or HSCTLR.A.
- Describes the possible generation of Alignment faults on accesses to Device memory by AArch32 Load Multiple or Store Multiple instructions when FEAT\_LSMAOC is implemented.

An Alignment fault can occur on an access for which the stage of address translation is disabled.

Any unaligned access to memory region with any Device memory type attribute generates an Alignment fault.

Routing of aborts taken to AArch32 state defines the mode to which an Alignment fault is taken.

The prioritization of Alignment faults depends on whether the fault was generated because of an access to a Device memory type, or for another reason. For more information, see AArch32 state prioritization of synchronous aborts from a single stage of address translation.

## G5.11.5 External abort on a translation table walk

An External abort on a translation table walk can be either synchronous or asynchronous. For more information on External aborts, see External aborts.

An External abort on a translation table walk is reported:

- If the External abort is synchronous, using:
- -Asynchronous Prefetch Abort exception if the translation table walk is for an instruction fetch.
- -Asynchronous Data Abort exception if the translation table walk is for a data access.

- If the External abort is asynchronous, using an SError exception, which is taken as an asynchronous Data Abort exception.

If an implementation reports the error in the translation table walk asynchronously from executing the instruction whose instruction fetch or memory access caused the translation table walk, these aborts behave essentially as interrupts. The aborts are masked when PSTATE.A is set to 1, otherwise they are reported using the Data Abort exception.

## G5.11.5.1 Behavior of External aborts on a translation table walk caused by address translation instructions

The address translation instructions summarized in Address translation system instructions require translation table walks. An External abort can occur in the translation table walk. The abort generates a Data Abort exception, and can be synchronous or asynchronous. For more information, see Handling of faults and aborts during an address translation instruction.

## G5.11.6 AArch32 state prioritization of synchronous aborts from a single stage of address translation

Exception prioritization for exceptions taken to AArch32 state describes the prioritization of exceptions taken from an Exception level that is using AArch32. This section gives additional information about the prioritization of MMU faults from VMSAv8-32 translation regimes.

If a single instruction generates aborts on more than one memory access, the architecture does not define any prioritization between those aborts.

In general, the Arm architecture does not define when asynchronous events are taken, and therefore the prioritization of asynchronous events is IMPLEMENTATION DEFINED.

Note

The priority numbering in this list only shows the relative priorities of aborts from a single stage of address translation in a VMSAv8-32 translation regime. This numbering has no global significance and, for example, does not correlate with the equivalent AArch64 list in MMU fault prioritization from a single address translation stage.

For a single stage of translation in a VMSAv8-32 translation regime, the following numbered list shows the priority of the possible memory management faults on a memory access. In this list:

- For memory accesses that undergo two stages of translation, the italic entries show where the faults from the stage 2 translation can occur . Astage 2 fault within a stage 1 translation table walk follows the same prioritization of faults.
- For synchronous External aborts from translation table walks see also Synchronous External abort errors from address translation caching structures.

The priority order, from highest priority to lowest priority, is:

1. Alignment fault not caused by memory type. This is possible for a stage 1 translation only.
2. Translation fault due to the input address being out of the address range to be translated or requiring an AArch32 TTBR that is disabled. This includes VTCR.SL0 being inconsistent with VTCR.T0SZ or programmed to a reserved value.
3. Address size fault on an AArch32 TTBR caused by the PA being out of the range implemented.
4. Second stage abort on a level 1 lookup of a a stage 1 table walk. When stage 2 address translation is enabled this includes an Address size fault caused by the P A being out of the range implemented . This is second stage abort during a first stage translation table walk.
5. Synchronous parity or ECC error on a level 1 lookup of a translation table walk.
6. Synchronous External abort on a level 1 lookup level of a translation table walk.
7. Translation fault on a level 1 translation table entry.
8. Address size fault on a level 1 lookup translation table entry caused by the output address being out of the range implemented.
9. Second stage abort on a level 2 lookup of a a stage 1 table walk. When stage 2 address translation is enabled this includes an Address size fault caused by the P A being out of the range implemented . This is second stage abort during a first stage translation table walk.
10. Synchronous parity or ECC error on a level 2 lookup of a translation table walk.

11. Synchronous External abort on a level 2 lookup level of a translation table walk.
12. Translation fault on a level 2 translation table entry.
13. Address size fault on a level 2 lookup translation table entry caused by the output address being out of the range implemented.
14. Second stage abort on a level 3 lookup of a a stage 1 table walk. When stage 2 address translation is enabled this includes an Address size fault caused by the P A being out of the range implemented . This is second stage abort during a first stage translation table walk.
15. Synchronous parity or ECC error on a level 3 lookup of a translation table walk.
16. Synchronous External abort on a level 3 lookup level of a translation table walk.
17. Translation fault on a level 3 translation table entry.
18. Address size fault on a level 3 lookup translation table entry caused by the output address being out of the range implemented.
19. Access Flag fault.
20. Alignment fault caused by the memory type.
21. Domain fault.

Note

Domain faults are possible only when using the VMSAv8-32 Short-descriptor translation table format, see Domain fault, Short-descriptor format translation tables only.

22. Permission fault.
23. A fault from the stage 2 translation of the memory access. When stage 2 address translation is enabled this includes an Address size fault caused by the P A being out of the range implemented .
24. Synchronous parity or ECC error on the memory access.
25. Synchronous External abort on the memory access.

Note

- The prioritization of TLB Conflict aborts is IMPLEMENTATION DEFINED, as the exact cause of these aborts depends on the form of TLBs implemented. However, the TLB conflict abort must have higher priority than any abort that depends on a value held in the TLB.
- The prioritization of IMPLEMENTATION DEFINED MMU faults for a Load-Exclusive or Store-Exclusive to an unsupported memory type is IMPLEMENTATION DEFINED.

See also The MMU fault-checking sequence.

## G5.11.6.1 Synchronous External abort errors from address translation caching structures

Acaching structure used for caching translation table walks might support:

- An arbitrary number of levels of translation table lookup.
- One or more stages of translation, which might not correspond to the stages of an address translation lookup.

This might mean that, on a synchronous External abort arising from the caching structure, such as from a parity or ECC error, the PE cannot precisely determine one or both of the translation stage and level of lookup at which the error occurred. In this case:

- If the PE cannot determine precisely the translation stage at which the error occurred, it is reported and prioritized as a stage 1 error.
- If the PE cannot determine precisely the lookup level at which the error occurred, the level is reported and prioritized as either:
- -The lowest-numbered level that could have given rise to the error.
- -Level 1 if it the PE cannot determine any information about the level.