## D2.1 About self-hosted debug

Self-hosted debug supports debugging through the generation and handling of debug exceptions , which are taken using the Exception model described in The AArch64 System Level Programmers' Model. This section introduces some terms that are used in describing self-hosted debug, and then introduces the debug exceptions. See:

- Definition of a debugger in the context of self-hosted debug.
- Context ID and Process ID.
- About debug exceptions.

## D2.1.1 Definition of a debugger in the context of self-hosted debug

Within this chapter, debugger means that part of an operating system, or higher level of system software, that handles debug exceptions and programs the Debug system registers. An operating system with rich application environments might provide debug services that support a debugger user interface executing at EL0. From the architectural perspective, the debug services are the debugger.

## D2.1.2 Context ID and Process ID

ACONTEXTIDR\_ELx identifies the current Context ID , which is used by:

- The debug logic, for breakpoint and watchpoint matching.
- Implemented trace logic, to identify the current process.

In AArch64 state, the CONTEXTIDR\_ELx has a single field, PROCID, that is defined as the Process Identifier (Process ID). Therefore, in AArch64 state, the Context ID and Process ID are identical.

## D2.1.3 About debug exceptions

Debug exceptions occur during normal program flow if a debugger has programmed the PE to generate them. For example, a software developer might use a debugger contained in an operating system to debug an application. To do this, the debugger enables one or more debug exceptions. The debug exceptions that can be generated in stage 1 of an AArch64 translation regime are:

- Breakpoint Instruction exceptions.
- Breakpoint exceptions, generated by hardware breakpoints.
- Watchpoint exceptions, generated by hardware watchpoints.
- Software Step exceptions.

In addition, debug exceptions generated in an AArch32 translation regime might be routed to EL2 using AArch64. See Routing debug exceptions. AArch32 Self-hosted Debug describes the debug exceptions that can be generated in an AArch32 translation regime.

Vector Catch exceptions are exceptions that cannot be generated in an AArch64 translation regime but can be generated in stage 1 of an AArch32 translation regime and routed to EL2 using AArch64. Vector Catch exceptions describes the behavior for this case.

Other than Breakpoint Instruction exceptions, the PE can generate a particular debug exception only if all of the following are true:

- The OS Lock is unlocked.
- DoubleLockStatus() == FALSE.
- Debug exceptions are not disabled from the current Exception level and Security state. See Enabling debug exceptions from the current Exception level and Security state.
- Adebugger has not disabled that particular debug exception. All of the debug exceptions except for Breakpoint Instruction exceptions have an enable control contained in the MDSCR\_EL1. See The debug exception enable controls.

Breakpoint Instruction exceptions are always enabled.

Note

If halting is allowed and EDSCR.HDE is 1, hardware breakpoints and watchpoints cause entry to Debug state instead of causing debug exceptions. In Debug state, the PE is halted. For the definition of halting is allowed, see Halting allowed and halting prohibited.

The following list summarizes each of the debug exceptions:

## Breakpoint Instruction exceptions

Breakpoint instructions generate these. Breakpoint instructions are instructions that software developers can use to cause exceptions at particular points in the program flow.

The breakpoint instruction in the A64 instruction set is BRK #&lt;immediate&gt; . Whenever one of these is committed for execution, the PE takes a Breakpoint Instruction exception.

Breakpoint Instruction exceptions cannot be masked. The PE takes Breakpoint Instruction exceptions regardless of both of the following:

- The current Exception level.
- The current Security state.

For more information, see Breakpoint Instruction exceptions.

## Breakpoint exceptions

The architecture provides 2-64 hardware breakpoints. These can be programmed to generate Breakpoint exceptions based on one or more of particular instruction addresses, accesses to any address in an instruction address range, or particular PE contexts.

For example, a software developer might program a hardware breakpoint to generate a Breakpoint exception whenever the instruction with address 0x1000 is committed for execution.

The architecture supports the following types of hardware breakpoint for use in stage 1 of an AArch64 translation regime:

- Address.
- -Comparisons are made with the virtual address of each instruction in the program flow.
- Context:
- -Context ID Match. Matches with the Context ID held in the CONTEXTIDR\_EL1, and if FEAT\_VHE is implemented, CONTEXTIDR\_EL2.
- -VMIDMatch. Matches with the VMID value held in the VTTBR\_EL2.
- -Context ID and VMID Match. Matches with both the Context ID and the VMID value.

An Address breakpoint can link to a Context-matching breakpoint, so that the Address breakpoint generates a Breakpoint exception only if the PE is in a particular context when the address match occurs.

Abreakpoint generates a Breakpoint exception whenever an instruction that causes a match is committed for execution.

If halting is allowed and EDSCR.HDE is 1, hardware breakpoints cause entry to Debug state. That is, they halt the PE. See Debug State.

## Otherwise:

- If debug exceptions are enabled, hardware breakpoints cause Breakpoint exceptions.
- If debug exceptions are disabled, hardware breakpoints are ignored.

For more information, see Breakpoint exceptions.

## Watchpoint exceptions

The architecture provides 2-64 hardware watchpoints. These can be programmed to generate Watchpoint exceptions based on accesses to particular data addresses, or based on accesses to any address in a data address range.

For example, a software developer might program a hardware watchpoint to generate a Watchpoint exception on an access to any address in the data address range 0x1000 -0x101F .

Ahardware watchpoint can link to a hardware breakpoint if the hardware breakpoint is a Context matching breakpoint with linking enabled. In this case, the watchpoint generates a Watchpoint exception only if the PE is in a particular context when the data address match occurs.

Ahardware watchpoint can link to a hardware breakpoint if the hardware breakpoint is an address breakpoint with linking enabled. In this case, the watchpoint generates a Watchpoint exception only if the address of the instruction making the access matches the breakpoint.

The smallest data address size that a watchpoint can be programmed to match on is a byte. A single watchpoint can be programmed to match on one or more bytes.

Awatchpoint generates a Watchpoint exception whenever an instruction that initiates an access that causes a match is committed for execution.

If halting is allowed and EDSCR.HDE is 1, hardware watchpoints cause entry to Debug state. That is, they halt the PE. See Debug State.

## Otherwise:

- If debug exceptions are enabled, hardware watchpoints cause Watchpoint exceptions.
- If debug exceptions are disabled, hardware watchpoints are ignored.

For more information, see Watchpoint exceptions.

## Vector Catch exceptions

These are not generated in an AArch64 translation regime. They can be generated only in an AArch32 translation regime. See Vector Catch exceptions.

## Software Step exceptions

Software step is a resource that a debugger can use to make the PE single-step instructions.

For example, by using software step, debugger software executing at a higher Exception level can debug software executing at a lower Exception level, by making it single-step instructions.

After the software being debugged has single-stepped an instruction, the PE takes a Software Step exception.

Software step can be used only by a debugger executing in an Exception level that is using AArch64. However, the instruction stepped might be executed in either Execution state, and therefore Software Step exceptions can be taken from either Execution state.

If debug exceptions are enabled, Software Step exceptions can be generated.

If debug exceptions are disabled, software step is inactive.

For more information, see Software Step exceptions.

Table D2-1 summarizes PE behavior and shows the location of the pseudocode for each of the debug exceptions.

Table D2-1 PE behavior and pseudocode for each of the debug exceptions

|                                   | PE behavior if debug exceptions   | PE behavior if debug exceptions   | Pseudocode                                                                                       |
|-----------------------------------|-----------------------------------|-----------------------------------|--------------------------------------------------------------------------------------------------|
| Debug exception                   | are: Enabled                      | Disabled                          | Pseudocode                                                                                       |
| Breakpoint Instruction exceptions | Takes the exception               | Takes the exception               | Pseudocode description of Breakpoint Instruction exceptions                                      |
| Breakpoint exceptions             | Takes the exception a             | Ignored                           | Pseudocode description of Breakpoint exceptions taken from an AArch64 stage 1 translation regime |

|                          | PE behavior if debug exceptions   | PE behavior if debug exceptions   | Pseudocode                                                               |
|--------------------------|-----------------------------------|-----------------------------------|--------------------------------------------------------------------------|
| Debug exception          | are: Enabled                      | Disabled                          |                                                                          |
| Watchpoint exceptions    | Takes the exception a             | Ignored                           | Pseudocode description of Watchpoint exceptions taken from AArch64 state |
| Vector Catch exceptions  | Takes the exception               | Ignored                           | Pseudocode description of Vector Catch exceptions                        |
| Software Step exceptions | Takes the exception               | Not applicable b                  | Pseudocode description of Software Step exceptions                       |