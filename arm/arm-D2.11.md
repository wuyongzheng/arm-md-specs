## D2.11 Software Step exceptions

The following subsections describe Software Step exceptions:

- About Software Step exceptions.
- Rules for setting MDSCR\_EL1.SS to 1.
- The software step state machine.
- Entering the active-not-pending state.
- Behavior in the active-not-pending state.
- Entering the active-pending state.
- Behavior in the active-pending state.
- Stepping T32 IT instructions.
- Exception syndrome information and preferred return address.
- Additional considerations.
- Pseudocode description of Software Step exceptions.

## D2.11.1 About Software Step exceptions

Software step is a resource that a debugger can use to make the PE single-step instructions.

For example, by using software step, debugger software executing at a higher Exception level can single-step instructions at a lower Exception level.

Operation is as follows:

1. Adebugger:
- a. Enables software step by setting MDSCR\_EL1.SS to 1. See The debug exception enable controls.
- b. Executes an exception return instruction, to branch to the instruction to be single-stepped in the software being debugged.
- c. Optionally configures the MDSTEPOP\_EL1 register. See Behavior in the active-not-pending state.
2. The PE then:
- a. Executes the instruction to be single-stepped.
- b. Takes a Software Step exception on the next instruction, returning control to the debugger.

However, another exception might be generated while the instruction is being stepped. This exception is either:

- Asynchronous exception that is generated by the instruction being stepped.
- An asynchronous exception that is taken before or after the instruction being stepped.

The PE can take a Software Step exception only if debug exceptions are enabled from the current Exception level and Security state. See Enabling debug exceptions from the current Exception level and Security state.

Astate machine describes the behavior of software step, shown in The software step state machine.

Throughout this Software Step exceptions section, including in all subsections, ELD means the Exception level that Software Step exceptions are targeting. Routing debug exceptions defines ELD as the debug target Exception level .

## D2.11.2 Rules for setting MDSCR\_EL1.SS to 1

Debugger software must be executing in an Exception level and Security state that debug exceptions are disabled from when it sets MDSCR\_EL1.SS to 1.

The Exception level that hosts the debugger software must be using AArch64.

## D2.11.3 The software step state machine

## In Figure D2-3:

- The OS Lock is unlocked and DoubleLockStatus() == FALSE.
- The PE is not in Secure state with MDCR\_EL3.SDD set to 1.

<!-- image -->

For a description of when debug exceptions are enabled or disabled from an Exception level, see Enabling debug exceptions from the current Exception level and Security state.

For more information about how a step is completed, see Behavior in the active-not-pending state.

The software step states are:

## Inactive

Software step is inactive. It cannot generate any Software Step exceptions or affect PE execution. Software step is inactive whenever any of the following are true:

- MDSCR\_EL1.SS is 0.
- ELD is using AArch32.
- Debug exceptions are disabled from the current Exception level or Security state.

## Active-not-pending

None of the conditions mentioned in Inactive are true, therefore software step is active.

The instruction to be stepped is usually the instruction in memory at the address specified by the PC. However, when FEAT\_STEP2 is implemented, the instruction to be stepped might be specified in MDSTEPOP\_EL1.

None of the conditions mentioned in Inactive are true, therefore software step is active.

ASoftware Step exception is pending on the current instruction.

Whenever software step is active, whether the state machine is in the active-not pending state or the active-pending state depends on PSTATE.SS. Table D2-17 shows this.

Table D2-17 State machine states

| EL D using:   | Debug exception enable status in the current Exception level and Security state   | MDSCR_EL1.SS   | PSTATE.SS   | State machine state   |
|---------------|-----------------------------------------------------------------------------------|----------------|-------------|-----------------------|
| AArch32       | X                                                                                 | X              | X           | Inactive              |
| AArch64       | Disabled                                                                          | X              | X           | Inactive              |
| AArch64       | Enabled                                                                           | 0              | X           | Inactive              |
| AArch64       | Enabled                                                                           | 1              | 1           | Active-not-pending    |
| AArch64       | Enabled                                                                           | 1              | 0           | Active-pending        |

## D2.11.4 Entering the active-not-pending state

Software step can only enter the active-not-pending state from the inactive state.

Software step:

- Enters the active-not-pending state when an Exception return instruction writes 1 to PSTATE.SS, by copying from SPSR\_ELx.SS when it restores PSTATE.
- Might enter the active-not-pending state on exiting Debug state when DSPSR\_EL0.SS or DSPSR.SS is 1. See Exiting Debug state.

An Exception return instruction only copies 1 from SPSR\_ELx.SS to PSTATE.SS if all of the following are true:

- MDSCR\_EL1.SS is 1.
- ELD is using AArch64.

## Active-pending

- Debug exceptions are disabled from the current Exception level.
- Debug exceptions are enabled from the Exception level that the Exception return instruction targets.

Otherwise, Exception return instructions set PSTATE.SS to 0, regardless of the value of SPSR\_ELx.SS.

Table D2-18 shows this. In the table:

Lock

Means the value of (OSLSR\_EL1.OSLK == '1' || DoubleLockStatus() ).

NS

Means the Effective value of SCR\_EL3.NS.

SDD

Means the Effective value of MDCR\_EL3.SDD. See Disabling debug exceptions from Secure state.

EEL2

Means the Effective value of SCR\_EL3.EEL2. If FEAT\_SEL2 is not implemented, this is 0.

TGE

Means the value of HCR\_EL2.TGE. If EL2 is not implemented, the PE behaves as if this is 0.

TDE

Means the Effective value of MDCR\_EL2.TDE. See Routing debug exceptions.

EL1 is using

The Execution state when the ELD is EL1.

EL2 is using

The Execution state when the ELD is EL2.

## Table D2-18 Value an Exception return instruction writes to PSTATE.SS

| MDSCR_EL1.SS   | Lock   | NS   | SDD   | EEL2   | TGE   | TDE   | EL1 is using   | EL2 is using   | Value an Exception return instruction writes to PSTATE.SS   |
|----------------|--------|------|-------|--------|-------|-------|----------------|----------------|-------------------------------------------------------------|
| 0              | X      | X    | X     | X      | X     | X     | X              | X              | 0                                                           |
| 1              | TRUE   | X    | X     | X      | X     | X     | X              | X              | 0                                                           |
|                | FALSE  | 0    | 1     | X      | X     | X     | X              | X              | 0                                                           |
|                |        |      | 0     | 0      | X     | X     | AArch32        | n/a            | 0                                                           |
|                |        |      |       |        |       |       | AArch64        | n/a            | See Table D2-19                                             |
|                |        |      |       | 1      | 0     | 0     | AArch32        | n/a            | 0                                                           |
|                |        |      |       |        |       |       | AArch64        | AArch64        | See Table D2-19                                             |
|                |        |      |       |        |       | 1     | AArch32        | AArch32        | 0                                                           |
|                |        |      |       |        |       |       | X              | AArch64        | See Table D2-20                                             |
|                |        |      |       |        | 1     | X     | n/a            | AArch32        | 0                                                           |
|                |        |      |       |        |       |       | n/a            | AArch64        | See Table D2-20                                             |
|                |        | 1    | X     | X      | 0     | 0     | AArch32        | n/a            | 0                                                           |
|                |        |      |       |        |       |       | AArch64        | AArch64        | See Table D2-19                                             |
|                |        |      |       |        |       | 1     | AArch32        | AArch32        | 0                                                           |
|                |        |      |       |        |       |       | X              | AArch64        | See Table D2-20                                             |
|                |        |      |       |        | 1     | X     | n/a            | AArch32        | 0                                                           |
|                |        |      |       |        |       |       | n/a            | AArch64        | See Table D2-20                                             |

## For:

- If ELD is EL1 using AArch64, Table D2-19 shows the value an Exception return instruction writes to PSTATE.SS.

- If ELD is EL2 using AArch64, Table D2-20 shows the value an Exception return instruction writes to PSTATE.SS.

## In both tables:

From EL

Means the Exception level at which the PE executes the Exception return instruction.

Target EL

Is the target Exception level of the Exception return instruction.

Note

If the Exception return instruction is an illegal exception return, the target Exception level of the Exception return instruction is the current Exception level. See Illegal exception returns from AArch64 state.

KDE

Is MDSCR\_EL1.KDE. See Enabling debug exceptions from the current Exception level and Security state

Table D2-19 Value an Exception return instruction writes to PSTATE.SS if ELD is EL1 using AArch64

|         |           |     | Software   | Software   | Software   | Software   | Value an Exception return instruction writes to PSTATE.SS   |
|---------|-----------|-----|------------|------------|------------|------------|-------------------------------------------------------------|
| From EL | Target EL | KDE | PSTATE.D   | SPSR_ELx.D | From EL    | Target EL  | Value an Exception return instruction writes to PSTATE.SS   |
| EL3     | EL3       | X   | X          | X          | Disabled   | Disabled   | 0                                                           |
| EL3     | EL2       | X   | X          | X          | Disabled   | Disabled   | 0                                                           |
| EL3     | EL1       | 0   | X          | X          | Disabled   | Disabled   | 0                                                           |
| EL3     |           | 1   | X          | 1          | Disabled   | Disabled   | 0                                                           |
| EL3     |           |     |            | 0          | Disabled   | Enabled    | SPSR_EL3.SS                                                 |
| EL3     | EL0       | X   | X          | X          | Disabled   | Enabled    | SPSR_EL3.SS                                                 |
| EL2     | EL2       | X   | X          | X          | Disabled   | Disabled   | 0                                                           |
| EL2     | EL1       | 0   | X          | X          | Disabled   | Disabled   | 0                                                           |
| EL2     |           | 1   | X          | 1          | Disabled   | Disabled   | 0                                                           |
| EL2     |           |     |            | 0          | Disabled   | Enabled    | SPSR_EL2.SS                                                 |
| EL2     | EL0       | X   | X          | X          | Disabled   | Enabled    | SPSR_EL2.SS                                                 |
| EL1     | EL1       | 0   | X          | X          | Disabled   | Disabled   | 0                                                           |
| EL1     |           | 1   | 0          | X          | Enabled a  | - b        | 0                                                           |
| EL1     |           |     | 1          | 1          | Disabled   | Disabled   | 0                                                           |
| EL1     |           |     |            | 0          | Disabled   | Enabled    | SPSR_EL1.SS                                                 |
| EL1     | EL0       | 0   | X          | X          | Disabled   | Enabled    | SPSR_EL1.SS                                                 |
| EL1     |           | 1   | 0          | X          | Enabled a  | Enabled    | 0                                                           |
| EL1     |           |     | 1          | X          | Disabled   | Enabled    | SPSR_EL1.SS                                                 |

## Table D2-20 Value an Exception return instruction writes to PSTATE.SS if ELD is EL2 using AArch64

|         |           |     |          |            | Software step   | Software step   | Value an Exception return instruction writes to PSTATE.SS   |
|---------|-----------|-----|----------|------------|-----------------|-----------------|-------------------------------------------------------------|
| From EL | Target EL | KDE | PSTATE.D | SPSR_ELx.D | From EL         | Target EL       |                                                             |
| EL3     | EL3       | X   | X        | X          | Disabled        | Disabled        | 0                                                           |
|         | EL2       | 0   | X        | X          | Disabled        | Disabled        | 0                                                           |
|         |           | 1   | X        | 1          | Disabled        | Disabled        | 0                                                           |
|         |           |     |          | 0          | Disabled        | Enabled         | SPSR_EL3.SS                                                 |
|         | EL1       | X   | X        | X          | Disabled        | Enabled         | SPSR_EL3.SS                                                 |
|         | EL0       | X   | X        | X          | Disabled        | Enabled         | SPSR_EL3.SS                                                 |
| EL2     | EL2       | 0   | X        | X          | Disabled        | Disabled        | 0                                                           |
|         |           | 1   | 0        | X          | Enabled a       | - b             | 0                                                           |
|         |           |     | 1        | 1          | Disabled        | Disabled        | 0                                                           |
|         |           |     |          | 0          | Disabled        | Enabled         | SPSR_EL2.SS                                                 |
|         | EL1       | 0   | X        | X          | Disabled        | Enabled         | SPSR_EL2.SS                                                 |
|         |           | 1   | 0        | X          | Enabled a       | Enabled         | 0                                                           |
|         |           |     | 1        | X          | Disabled        | Enabled         | SPSR_EL2.SS                                                 |
|         | EL0       | 0   | X        | X          | Disabled        | Enabled         | SPSR_EL2.SS                                                 |
|         |           | 1   | 0        | X          | Enabled a       | Enabled         | 0                                                           |
|         |           |     | 1        | X          | Disabled        | Enabled         | SPSR_EL2.SS                                                 |
| EL1     | EL1       | X   | X        | X          | Enabled a       | Enabled         | 0                                                           |
|         | EL0       | X   | X        | X          | Enabled a       | Enabled         | 0                                                           |

Note

No AArch32 instruction can set PSTATE.SS to 1.

## D2.11.5 Behavior in the active-not-pending state

In this state, the PE does one of the following:

- Executes the instruction to be stepped and either:
- -Completes it without taking a synchronous exception.
- -Takes a synchronous exception if the instruction generates one.
- Takes an asynchronous exception without executing any instructions.
- Enters Debug state because of a Halting debug event .

The instruction to be stepped is usually the instruction in memory at the address specified by the PC.

However, when FEAT\_STEP2 is implemented, the instruction to be stepped might be specified in MDSTEPOP\_EL1. See Software Step behavior when FEAT\_STEP2 is implemented.

If the PE executes the instruction without taking any exceptions, then the PE sets PSTATE.SS to 0, meaning that after the instruction has been executed:

- If the instruction has disabled debug by setting PSTATE.D to 1 then software step advances to the inactive state.

- If the instruction disables software step by a direct write to a System register, for example a write to MDSCR\_EL1.KDE or MDSCR\_EL1.SS, then software step might advance to the inactive state. These writes require explicit synchronization to guarantee their effect. See Synchronization and the software step state machine.
- Otherwise, software step advances to the active-pending state. See Behavior in the active-pending state.

If the PE takes either a synchronous or an asynchronous exception, behavior is as described in one of the following:

- If the PE takes an exception to an Exception level that is using AArch64.
- If the PE takes an exception to an Exception level that is using AArch32.

If the PE enters Debug state because of a Halting debug event, behavior is as described in Entering Debug state and Software Step.

## D2.11.5.1 If the PE takes an exception to an Exception level that is using AArch64

As part of exception entry, the PE does all of the following:

- Sets SPSR\_ELx.SS to 0 or 1, depending on the exception. See Table D2-21.
- It is UNPREDICTABLE whether SPSR\_ELx.SS to 0 or 1 when an SError exception is taken to ELx without executing the instruction.
- Sets PSTATE.SS to 0. This causes software step to enter either the active-pending state or the inactive state, depending on whether debug exceptions are enabled or disabled from the Exception level that the exception is taken to:
- Sets PSTATE.D to 1.

Enabled

Software step enters the active-pending state.

Disabled

Software step enters the inactive state.

In either case, on taking the exception, a step is complete.

Table D2-21 Categorization of exceptions, for setting SPSR\_ELx.SS to 0 or 1

| Exception description                                                                                        | Exceptions                                                                                                         |   SPSR_ELx.SS |
|--------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|---------------|
| Exceptions whose preferred return address is for the instruction that follows the instruction to be stepped. | Supervisor Call ( SVC ) exceptions. Hypervisor Call ( HVC ) exceptions. Secure Monitor Call ( SMC ) exceptions.    |             0 |
| Exceptions whose preferred return address is the address of the instruction to be stepped.                   | All other synchronous exceptions, and asynchronous exceptions that are taken before the instruction to be stepped. |             1 |

Note

If an SMC instruction executed at Non-secure EL1 is trapped to EL2 because HCR\_EL2.TSC is 1, the exception is a Trap exception, not a Secure Monitor Call exception, and so SPSR\_ELx.SS is set to 1, not 0.

## D2.11.5.2 If the PE takes an exception to an Exception level that is using AArch32

This can happen only when all of the following is true:

- EL2 is implemented and is using AArch64, and the Effective value of MDCR\_EL2.TDE is 1. Because MDCR\_EL2.TDE is 1, ELD is EL2.
- The exception is taken to EL1 using AArch32.

As part of exception entry, the PE sets PSTATE.SS to 0. This causes software step to enter the active-pending state.

RVTLLV

IVXWNT

ILYLNF

Note

- Software step always enters the active-pending state because the exception is taken to an Exception level that debug exceptions are enabled from, EL1. Debug exceptions are enabled from EL1 because ELD is EL2, and debug exceptions are always enabled from Exception levels that are lower than ELD.
- AArch32 SPSRs have no SS bit.

## D2.11.5.3 Software Step behavior when FEAT\_STEP2 is implemented

When FEAT\_STEP2 is implemented, executing from MDSTEPOP\_EL1 is enabled when all of the following are true:

- The PE is in AArch64 state.
- Software Step is in the active-not-pending state.
- MDSCR\_EL1.EnSTEPOP is 1.
- Either EL3 is not implemented or MDCR\_EL3.EnSTEPOP is 1.
- Any of the following apply:
- -EL2 is not implemented.
- -EL2 is disabled in the current Security state.
- -MDCR\_EL2.EnSTEPOP is 1.

Otherwise, executing from MDSTEPOP\_EL1 is disabled.

IWTPKX The pseudocode function SoftwareStepOpEnabled() returns TRUE when executing from MDSTEPOP\_EL1 is enabled and FALSE otherwise.

ISFGGB When executing from MDSTEPOP\_EL1 is disabled, the value in MDSTEPOP\_EL1 is ignored.

RKPFLX When executing from MDSTEPOP\_EL1 is enabled, the instruction to be stepped is specified by the value of MDSTEPOP\_EL1. That is, the PE executes an instruction from MDSTEPOP\_EL1 instead of executing an instruction from memory.

RXTKVL When the PE executes an instruction from MDSTEPOP\_EL1, all of the following apply:

- The instruction address in the PC is checked by the PE as if the instruction is fetched from memory.
- For example, the instruction might generate any of the following exceptions based on the current value of PC:
- -PC alignment fault exception.
- -Instruction abort exception.
- -Breakpoint exception.
- Aread of PC by the instruction returns the current value of PC.
- Awrite to PC updates the PC as normal.

IRJMRP In RXTKVL, reads of the PC includes indirect reads in the event of an exception or debug event being taken, as follows:

- If the instruction execution causes a synchronous exception, or is preempted by an asynchronous exception, then the preferred return address for the exception is based on the current PC value.
- If the instruction execution causes a synchronous entry to Debug state, or is preempted by an asynchronous entry to Debug state, then the preferred restart address for the debug event is based on the current PC value.

When the PE executes an instruction from MDSTEPOP\_EL1, it is CONSTRAINED UNPREDICTABLE whether the PE fetches an instruction from the memory location addressed by the current PC. This means that, in the case where the instruction fetch would generate a synchronous External abort, it is CONSTRAINED UNPREDICTABLE whether this exception will be generated. In the case where the instruction fetch would generate a synchronous External abort on a translation table fetch or translation table update, then the exception is generated because RXTKVL requires that the translation table is checked.

If the PE does fetch an instruction from the memory location addressed by the current PC, then that instruction is ignored.

Instruction execution properties that are derived from the current PC value use the same method whether the PE executes an instruction from MDSTEPOP\_EL1 or from memory. For example, instruction execution properties that are derived from the PC being in a guarded page.

Note

Execution from MDSTEPOP\_EL1 is not considered concurrent modification and execution of instructions. Tracing properties and performance monitoring of instruction execution from MDSTEPOP\_EL1 are unchanged.

RDQFDD

The MOVPRFX instruction execution from MDSTEPOP\_EL1 does not pair with another instruction.

IRDLQR

If a BRK instruction that is prefixed by a MOVPRFX instruction generates a Breakpoint Instruction exception then the ELR\_ELx points to the PC of BRK instruction and the MOVPRFX instruction is required to have updated the architectural state. The debugger can use MDSTEPOP\_EL1 to execute the original instruction that was replaced by the BRK instruction.

IXLQPG

Executing an instruction from MDSTEPOP\_EL1 is an indirect read of MDSTEPOP\_EL1.

## D2.11.5.4 Summary of behavior in the active-not-pending state

Table D2-22 summarizes behavior in the active-not-pending state.

## Table D2-22 Summary of behavior in the active-not-pending state

| Event        | Value written to PSTATE.SS   | Target Exception level is using:   | Details a                                                                   | Value written to SPSR_ELx.SS   | Next state                   |
|--------------|------------------------------|------------------------------------|-----------------------------------------------------------------------------|--------------------------------|------------------------------|
| No exception | 0                            | n/a                                | Disables Software step                                                      | n/a                            | Inactive                     |
| Exception    | 0                            | AArch64                            | Supervisor Call ( SVC ) Hypervisor Call ( HVC ) Secure Monitor Call ( SMC ) | 0                              | Active-pending or inactive b |
|              |                              |                                    | Other                                                                       | 1                              |                              |
|              |                              | AArch32                            | All                                                                         | 0                              | Active-pending               |

## D2.11.6 Entering the active-pending state

Software step enters the active-pending state after any of the following operations, provided that both:

- MDSCR\_EL1.SS is 1.
- Debug exceptions are enabled from the Exception level and Security state that execution is in after the operation.

The operations are:

## While software step is in the active-not-pending state

The PE either:

- Executing the instruction to be stepped without taking any exceptions.
- Taking an exception.

## While software step is in the active-pending state

The PE takes an asynchronous exception.

## While software step is in the inactive state

The PE executes either:

Note

If entry to the active-pending state is because of the PE taking an exception, it means that the exception is one that is taken to EL1 when MDCR\_EL2.TDE is 1 and EL2 is implemented and enabled in the current Security state. Otherwise, debug exceptions are masked by PSTATE.D, therefore they would be disabled from the target Exception level of the exception.

In addition, software step might enter the active-pending state either:

- After a direct write to a System register, for example a write to MDSCR\_EL1.KDE or MDSCR\_EL1.SS. These writes require explicit synchronization to guarantee their effect. See Synchronization and the software step state machine.
- On exiting Debug state when DSPSR\_EL0.SS or DSPSR.SS is 0. See Exiting Debug state.

## D2.11.7 Behavior in the active-pending state

When the PE is in the active-pending state, a Software Step exception is taken before the PE executes an instruction.

The Software Step exception has higher priority than all other types of synchronous exception. However, the prioritization of this exception with respect to any unmasked pending asynchronous exception is not defined by the architecture.

For more information, see the following:

- Prioritization of Synchronous exceptions taken to AArch64 state.
- Prioritization of asynchronous exceptions.
- Architectural requirements for taking asynchronous exceptions.

## D2.11.8 Stepping T32 IT instructions

The A-profile architecture permits a combination of an IT instruction and another 16-bit T32 instruction to comprise one 32-bit instruction.

For the purpose of stepping an item, it is IMPLEMENTATION DEFINED whether:

- The PE considers this combination to be one instruction.
- The PE considers this combination to be two instructions.

In an implementation that supports the ITD control, which can disable some uses of the IT instruction, it is then IMPLEMENTATION DEFINED whether this behavior depends on the value of the applicable ITD field. For example:

- The PE might consider this combination to be one instruction, regardless of the state of the applicable ITD field.
- The PE might consider this combination to be two instructions, regardless of the state of the applicable ITD field.
- The PE might consider this combination to be one instruction when the applicable ITD field is 1, and two instructions when it is 0.

The applicable ITD field is one of:

- SCTLR\_EL1.ITD if execution is at EL0 using AArch32 when EL1 is using AArch64.
- SCTLR.ITD if execution is at EL0 or EL1 when EL1 is using AArch32.
- HSCTLR.ITD if execution is at Non-secure EL2 using AArch32.
- An Exception return instruction when SPSR\_ELx.SS is 0.
- An instruction that enables debug by setting PSTATE.D to 0.

## D2.11.9 Exception syndrome information and preferred return address

See the following:

- Exception syndrome information.
- Preferred return address.

## D2.11.9.1 Exception syndrome information

On taking a Software Step exception, the PE records information about the exception in the Exception Syndrome Register (ESR\_ELx) at the Exception level the exception is taken to. See ISS encoding for an exception from a Software Step exception for more information.

If no instruction was stepped because software step entered the active-pending state from the inactive state without passing through the active-not-pending state, then ESR\_ELx.{ISV , EX} are set to {0, 0}.

When an instruction has been stepped, if the stepped instruction was a conditional Load-Exclusive instruction that failed its Condition code test, then ESR\_ELx.ISV is set to 1 and ESR\_ELx.EX is set to a CONSTRAINED UNPREDICTABLE choice of 0 or 1.

When an instruction has been stepped, if the stepped instruction was an Exception return instruction or an ISB , then ESR\_ELx.ISV is set to a CONSTRAINED UNPREDICTABLE choice of 0 or 1, and ESR\_ELx.EX is set to 0.

If the PE is executing at EL1 or EL0, and the Effective value of MDCR\_EL2.TDE is 1, then a different exception might be taken to EL1 before the Software Step exception is taken to EL2. In this case, on taking the Software Step exception ESR\_EL2.ISV is set to a CONSTRAINED UNPREDICTABLE choice of 0 or 1, and:

- If ESR\_EL2.ISV is set to 1, then ESR\_EL2.EX is set to the correct value for the instruction.
- If ESR\_EL2.ISV is set to 0, then ESR\_EL2.EX is set to 0.

Other than for the cases described above, when an instruction has been stepped:

- ESR\_ELx.ISV is set to 1, to indicate that ESR\_ELx.EX is valid.
- If the instruction stepped was a Load-Exclusive instruction, then ESR\_ELx.EX is set to 1. Otherwise, ESR\_ELx.EX is set to 0.

Note

If the PE cannot determine the correct value of ESR\_ELx.EX for the stepped instruction, then it sets ESR\_ELx.{ISV , EX} to {0, 0}. For example, the exception is taken before the PE decodes the stepped instruction, or the exception means the PE has no valid stepped instruction to decode.

Note

ALoad-Exclusive instruction is any one of the following:

- In the A64 instruction set, any instruction that has a mnemonic starting with either LDX or LDAX .

- In the T32 and A32 instruction sets, any instruction that has a mnemonic starting with either LDREX or LDAEX .

Note

An implementation that always sets ISV to 0 and never sets EX is not compliant.

Table D2-23 summarizes the possible values that the PE can record in ESR\_ELx.{ISV, EX}.

| Description                                                                                                                                                                                                                                                          | ESR_ELx.ISV   | ESR_ELx.EX                                    |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------|-----------------------------------------------|
| Syndrome data is not available because no instruction was stepped.                                                                                                                                                                                                   | 0             | 0                                             |
| Syndrome data is available because an instruction was stepped. The instruction stepped was a conditional Load-Exclusive instruction that failed its Condition code test.                                                                                             | 1             | 0 or 1                                        |
| Syndrome data is available because an instruction was stepped. The instruction stepped was an Exception Return instruction or an ISB .                                                                                                                               | 0 or 1        | 0                                             |
| Adifferent exception is taken before the Software Step exception.                                                                                                                                                                                                    | 0             | 0                                             |
| Adifferent exception is taken before the Software Step exception.                                                                                                                                                                                                    | 1             | Set to the correct value for the instruction. |
| Syndrome data is available because an instruction was stepped. The instruction stepped was an instruction other than a Load-Exclusive instruction, an Exception Return instruction, or an ISB , and no other exception was taken before the Software Step exception. | 1             | 0                                             |
| Syndrome data is available because an instruction was stepped. The instruction stepped was a Load-Exclusive instruction that was either not conditional or did not fail its Condition code test.                                                                     | 1             | 1                                             |

## D2.11.9.2 Preferred return address

The preferred return of a Software Step exception is the address of the instruction that was not executed because the PE took the Software Step exception instead.

## D2.11.10 Additional considerations

This section contains the following:

- Behavior when an Exception return instruction is an illegal exception return.
- Behavior when the instruction stepped writes a misaligned PC value.
- Stepping code that uses Exclusives monitors.
- Synchronization and the software step state machine.

## D2.11.10.1 Behavior when an Exception return instruction is an illegal exception return

If the conditions for entering the active-not-pending state in Entering the active-not-pending state are met, but the PE executes an Exception return instruction that is an illegal exception return, the exception return must be taken to the same Exception level that it was taken from. In this scenario, even though the Exception level remains the same before and after the Exception return instruction, software step can advance from the inactive state to one of the active states. Consider the following case:

1. MDSCR\_EL1.SS is 1 and software step is inactive. The current Exception level is EL1 using AArch64, the OS Lock and OS Double Lock are unlocked, and MDCR\_EL2.TDE is 0, MDSCR\_EL1.KDE is 1, and PSTATE.D is 1.

PSTATE.D == 1 is the reason why software step is inactive, because PSTATE.D == 1 means that debug exceptions are disabled from the current Exception level.

2. The PE executes an Exception return instruction.
3. The intended target of the Exception return instruction is EL2. This means that the Exception return instruction is an illegal exception return because the intended target is higher than the Exception level the Exception return
3. instruction it is executed at. In this case, the Exception return instruction must target EL1 instead of EL2. If SPSR\_EL1.D is 0, then on the Exception return instruction PSTATE.D becomes 0 and debug exceptions become enabled from the current Exception level. Software step therefore advances from the inactive state to one of the active states.

Which active state software step advances to depends on whether SPSR\_ELx.SS is 1 or 0:

- If SPSR\_ELx.SS is 1, software step advances to the active-not-pending state. In this case, an Illegal Execution state exception is pending on the instruction to be stepped, and the PE takes the Illegal Execution state exception instead of executing the instruction to be stepped.
- If SPSR\_ELx.SS is 0, software step advances to the active-pending state. In this case, a Software Step exception and an Illegal Execution state exception are both pending. The Software Step exception has higher priority. On taking the Software Step exception, the PE sets SPSR\_ELx.IL to 1.

Note

Prioritization of Synchronous exceptions taken to AArch64 state shows the relative priorities of synchronous exceptions.

## D2.11.10.2 Behavior when the instruction stepped writes a misaligned PC value

An indirect branch that writes a misaligned PC value might generate a PC alignment fault exception at the target of the branch. However, if the indirect branch is stepped using software step, the PE takes a Software Step exception instead, because the Software Step exception has higher priority. Behavior on returning from the Software Step exception depends on which Execution state the Exception level being returned to is using:

| AArch64   | APCalignment fault exception is generated.                                                                                            |
|-----------|---------------------------------------------------------------------------------------------------------------------------------------|
| AArch32   | The return from the Software Step exception forces the PC to the correct alignment, and no PC alignment fault exception is generated. |

Debugger software must therefore take care when using software step to single-step an indirect branch instruction executed in AArch32 state, that it does not hide a PC alignment fault exception.

## D2.11.10.3 Stepping code that uses Exclusives monitors

The A-profile architecture provides no mechanism for preserving the state of the Exclusives monitors when a Load-Exclusive or a Store-Exclusive instruction is stepped.

However, for certain progressions through the software step state machine, on taking a Software Step exception, the PE provides an indication of whether the instruction stepped was a Load-Exclusive instruction.

Debugger software can use this to detect the state of the Exclusives monitors. For example, if the PE reports that the instruction stepped was a Load-Exclusive instruction, the debugger is aware that the next Store-Exclusive operation will fail, because all Exclusives monitors are cleared on returning from the Software Step exception. The debugger must then take action to ensure that the code being stepped makes forwards progress.

For more information on how the PE reports whether the instruction stepped was a Load-Exclusive instruction, see Exception syndrome information and preferred return address.

## D2.11.10.4 Synchronization and the software step state machine

Any of the following can cause transitions between software step states:

- Adirect write to a System register.
- Adirect write to a Special-purpose register.
- Awrite to an external debug register.

The software step state machine indirectly reads some of these registers and so is not guaranteed to observe any new values until after a Context Synchronization event has occurred.

Between a write to the register and the next Context Synchronization event, it is CONSTRAINED UNPREDICTABLE whether software step uses the state of the PE before the write, or the state of the PE after the write.

After a Context Synchronization event, the state machine must use the state of the PE after the write.

Example D2-11 Example of synchronization and software step state machine changing states

1. Software changes MDSCR\_EL1.SS from 0 to 1 when debug exceptions are enabled.
2. The PE executes some instructions.
3. AContext Synchronization event occurs.

During step 2, it is CONSTRAINED UNPREDICTABLE whether software step remains in the inactive state, as if MDSCR\_EL1.SS is 0, or enters the active-pending state because MDSCR\_EL1.SS is 1. If it is in the:

- Inactive state, then after the Context Synchronization event, it must enter the active-pending state.
- Active-pending state, the PE might take a Software Step exception before the Context Synchronization event.

Note

Adirect write to a Special-purpose register does not require explicit synchronization.

## D2.11.11 Pseudocode description of Software Step exceptions

SSAdvance() advances software step from the active-not-pending state to the active-pending state, by setting PSTATE.SS to 0. It is called on completing execution of each instruction.

CheckSoftwareStep() checks whether software step is in the active-pending state, and if it is, generates a Software Step exception. It is called before each instruction executed, regardless of Execution state, before checking for any other synchronous exceptions.

DebugExceptionReturnSS() returns the value to write to PSTATE.SS on an exception return or an exit from Debug state. See Entering the active-not-pending state.

These functions are defined in A-profile Architecture Pseudocode.