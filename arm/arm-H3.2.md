## H3.2 Halting Step debug events

Halting Step is a debug resource that a debugger can use to make the PE step through code one instruction at a time. This section describes the Halting Step debug events. It is divided into the following sections:

- Overview of a Halting Step debug event.
- The Halting Step state machine.
- Using Halting Step.
- Detailed Halting Step state machine behavior.
- Synchronization and the Halting Step state machine.
- Stepping T32 IT instructions.
- Disabling interrupts while stepping.
- Syndrome information on Halting Step.
- Pseudocode description of Halting Step debug events.

The architecture describes the behavior as a simple Halting Step state machine. See The Halting Step state machine.

## H3.2.1 Overview of a Halting Step debug event

The behavior of Halting Step is defined by a state machine, shown in Figure H3-1. A Halting Step debug event executes a single instruction and then returns control to the debugger. When the debugger software wants to execute a Halting Step:

1. With the PE in Debug state, the debugger activates Halting Step.
2. The debugger signals the PE to exit Debug state and return to the instruction that is to be stepped.
3. The PE executes that single instruction.
4. The PE enters Debug state before executing the next instruction.

However, an exception might be generated while the instruction is being stepped. That is either:

- Asynchronous exception generated by the instruction being stepped.
- An asynchronous exception taken before or after the instruction being stepped.

Halting Step has its own enable control bit, EDECR.SS and EDESR.SS.

Note

Because the Halting Step state machine states occur as a result of normal PE operation, the states can be described as both:

- PE states.
- Halting Step states.

## H3.2.2 The Halting Step state machine

The state machine states are:

## Inactive

Halting Step is inactive. No Halting Step debug events can be generated, therefore execution is not affected by Halting Step. The PE is in this state whenever either of the following is true:

- Halting Step is disabled. That is, EDECR.SS is set to 0 and EDESR.SS is set to 0.
- Halting is prohibited. See Halting the PE on debug events. In this state, if EDECR.SS is set to 1, then a Halting Step debug event is pending.

In Figure H3-1, this state is shown in red.

## Active-not-pending

Halting Step is enabled and active. This is the state in which the PE steps an instruction. EDECR.SS == 1 and EDESR.SS == 0. Software must not set EDECR.SS to 1 unless the PE is in Debug state, otherwise behavior is CONSTRAINED UNPREDICTABLE, as described in Changing the value of EDECR.SS when not in Debug state.

In Figure H3-1, this state is shown in green.

Halting Step is enabled and active. The step has completed and the PE enters Debug state. EDESR.SS == 1.

In Figure H3-1, this state is shown in green.

Whenever Halting Step is enabled and active, whether the state machine is in the active-not-pending state or in the active-pending state depends on EDESR.SS. Table H3-3 shows this.

In the simple sequential execution of the program, the PE executes the Halting Step state machine as follows:

1. Initially, Halting Step is inactive.
2. After exiting Debug state, Halting Step is active-not-pending.
3. The PE executes an instruction and Halting Step is active-pending.
4. The pending Debug state entry is taken on the next instruction and the step is complete.

Exceptions and other changes to the PE context can interrupt this sequence.

Figure H3-1 shows a Halting Step state machine.

## Active-pending

Figure H3-1 Halting Step state machine

<!-- image -->

Note

Figure H3-1 describes only state transitions to and from the inactive state by exit from Debug state, executing an exception return, or taking an exception. Other changes to the PE context, including writes to registers such as EDECR and OSDLR and changes to the authentication interface can also cause changes to the Halting Step state machine. These can lead to UNPREDICTABLE or CONSTRAINED UNPREDICTABLE behavior. See Synchronization and the Halting Step state machine.

The following bits control the state machine, as shown in Table H3-3:

- EDECR.SS. This is the Halting Step enable bit.
- EDESR.SS. This is the Halting Step debug event pending bit.

Table H3-3 shows the Halting Step state machine states. The letter X in a register column means that the relevant bit can be set to either zero or one.

## Table H3-3 Halting Step state machine states

| Halting    | EDECR.SS   | EDESR.SS   | Halting Step state                             |
|------------|------------|------------|------------------------------------------------|
| Prohibited | X          | X          | Inactive (Halting Step debug even not pending) |
| Prohibited | X          | 1          | Inactive (Halting Step debug event pending)    |
| Allowed    | 0          | 0          | Inactive                                       |
| Allowed    | 1          | 0          | Active-not-pending                             |
| Allowed    | X          | 1          | Active-pending                                 |

## H3.2.3 Using Halting Step

To step a single instruction the PE must be in Debug state:

1. The debugger sets EDECR.SS to 1 to enable Halting step.
2. The debugger signals the PE to exit Debug state with DLR set to the address of the instruction being stepped. The PE clears EDESR.SS to 0 and the Halting Step state machine enters the active-not-pending state.
3. The PE executes the instruction being stepped. If an exception is taken to a state where halting is prohibited, then EDESR.SS is always correct for the preferred

return address of the exception.

4. The PE enters Debug state before executing the next instruction and the step is complete.

## Note

- If FEAT\_DoPD is not implemented, EDECR.SS value is in the Debug power domain, meaning that the state machine is maintained over a powerdown of the Core power domain.
- If FEAT\_DoPD is implemented, the values of EDECR.SS and EDESR.SS are set to 0 on a Cold reset, and, if the PE was stepping an instruction, EDESR.SS is effectively UNKNOWN after a Warm reset. A debugger must use a Reset Catch debug event to step over a powerdown state.
- A debugger must only change the value of EDECR.SS when the PE is in Debug state, otherwise behavior is CONSTRAINED UNPREDICTABLE as described in Changing the value of EDECR.SS when not in Debug state.

## H3.2.4 Detailed Halting Step state machine behavior

The behavior of the Halting Step state machine is described in the following sections:

- Entering the active-not-pending state.
- PE behavior in the active-not-pending state.
- Entering the active-pending state.
- PE behavior in the active-pending state.
- PE behavior in the inactive state when in Non-debug state.
- PE behavior in Debug state.

## H3.2.4.1 Entering the active-not-pending state

The PE enters the active-not-pending state:

- By exiting Debug state to a state where halting is allowed with EDECR.SS == 1.
- By an exception return from a state where halting is prohibited to a state where halting is allowed with EDECR.SS == 1 and EDESR.SS == 0.
- As described in Synchronization and the Halting Step state machine.

## H3.2.4.2 PE behavior in the active-not-pending state

When the PE is in the active-not-pending state it does one of the following:

- It executes one instruction and does one of the following:
- -Completes it without taking a synchronous exception.
- -Takes a synchronous exception generated by the instruction.
- -Generates a debug event that causes entry to Debug state.
- It takes an asynchronous exception without executing any instruction.
- It takes an asynchronous debug event into Debug state.

## H3.2.4.2.1 If no exception or debug event is generated

If no exception or debug event is generated the PE sets EDESR.SS to 1. This means that the Halting Step state machine advances to the active-pending state.

## H3.2.4.2.2 If an exception or debug event is generated

The PE sets EDESR.SS according to all of the following:

- The type of exception.
- The target Exception level of the exception.
- If the exception is taken to EL3, whether halting is prohibited at EL3. This is determined by:
- -The result of ExternalRootInvasiveDebugEnabled() , if FEAT\_RME is implemented.
- -The result of ExternalSecureInvasiveDebugEnabled() , if FEAT\_RME is not implemented.

If an exception or debug event is generated, the PE sets EDESR.SS to 1 if the exception is an SMC exception or is taken to a state where halting is allowed.

Otherwise, EDESR.SS is unchanged.

It is UNPREDICTABLE whether EDESR.SS is set to 1 or unchanged when an SError exception is taken to EL3 without executing the instruction, and halting is prohibited at EL3.

If halting is prohibited after taking the exception or debug event, then the Halting Step state machine advances to the inactive state. Otherwise, the Halting Step state machine advances to the active-pending state.

Note

The underlying criteria for the value of EDESR.SS on an exception are:

- Whether halting is allowed at the target of the exception. If halting is allowed, the PE must step into the exception. If halting is prohibited, the PE must step over the exception.
- Whether the preferred return address of the exception is the instruction itself or the next instruction, if the PE steps over the exception.

Table H3-4 shows the behavior of the active-not-pending state. The letter X indicates that halting can be either allowed or prohibited at EL3.

## Table H3-4 Summary of active-not-pending state behavior

| Event                              | Target Exception level   | Halting is allowed at EL3   | Value written to EDESR.SS   |
|------------------------------------|--------------------------|-----------------------------|-----------------------------|
| No exception or debug event        | Not applicable           | X                           | 1                           |
| SMCexception                       | EL3                      | X                           | 1                           |
| Reset                              | Highest                  | X                           | 1                           |
| Exception, other than SMCexception | EL1                      | X                           | 1                           |
| Exception, other than SMCexception | EL2                      | X                           | 1                           |
| Exception, other than SMCexception | EL3                      | TRUE                        | 1                           |
| Exception, other than SMCexception |                          | FALSE                       | Unchanged                   |
| Debug event                        | Debug state              | X                           | Unchanged                   |

## H3.2.4.3 Entering the active-pending state

The PE enters the active-pending state by one of the following:

- From the active-not-pending state by:
- -Executing an instruction without taking an exception.
- -Taking an exception so that the PE remains in a state where halting is allowed.
- An exception return from a state where halting is prohibited when EDESR.SS == 1.

Note

For example, an exception return from EL3 with invasive debug prohibited, to a lower Exception level where invasive debug is allowed.

- Areset when the value of EDECR.SS == 1, regardless of the state the PE was in before the reset occurred.
- From the active-pending state by taking an asynchronous exception to a state where halting is allowed.
- Following the description in Synchronization and the Halting Step state machine.

## H3.2.4.4 PE behavior in the active-pending state

When the PE is in the active-pending state, it enters Debug state before executing an instruction.

The entry into Debug state has higher priority than all other types of synchronous debug event and synchronous exception. However, the architecture does not define the prioritization of this Debug state entry with respect to any unmasked pending asynchronous exception. If an asynchronous exception is prioritized over the entry to Debug state, then EDESR.SS is unchanged.

For more information on the prioritization of debug events, see Debug state entry and debug event prioritization.

## H3.2.4.5 PE behavior in the inactive state when in Non-debug state

EDESR.SS is not updated by the execution of an instruction or the taking of an exception when Halting Step is inactive. This means that EDESR.SS is not changed by an exception handled in a state where halting is prohibited.

On return to a state where halting is allowed, the Halting Step state machine is restored either to the active-pending state or the active-not-pending state, depending on the value of EDESR.SS. The return to a state where halting is allowed is normally by an exception return, which in some situations is a Context Synchronization event.

See also Synchronization and the Halting Step state machine.

## H3.2.4.6 PE behavior in Debug state

Halting Step is inactive in Debug state because halting is prohibited, see Halting allowed and halting prohibited.

Entry to Debug state does not change EDESR.SS.

EDESR.SS is cleared to 0 on exiting Debug state as the result of a restart request. If EDECR.SS == 1, Halting Step enters the active-not-pending state.

Note

This means that EDESR.SS is never cleared to 0 by the execution of an instruction in Debug state, or by taking an exception when in Debug state as described in PE behavior in the active-not-pending state, because the Halting Step state machine is not in the active-not-pending state. EDESR.SS can be cleared by a write to EDESR, see the register description.

However, if the PE exits Debug state as the result of a PE reset and EDECR.SS == 1, then Halting Step immediately enters the active-pending state, as EDESR.SS is set to the value of EDECR.SS.

## H3.2.5 Synchronization and the Halting Step state machine

The Halting Step state machine also changes state if:

- Halting becomes allowed or prohibited other than by exit from Debug state, an exception return, or taking an exception. This means that halting becomes allowed or prohibited because:
- -The Security state changes without an exception return. See State and mode changes without explicit Context Synchronization events.
- -The external authentication interface changes.
- -FEAT\_DoubleLock is implemented and the status, DoubleLockStatus() , changes.
- Awrite to EDECR when the PE is in Non-debug state changes the value of EDECR.SS.

Note

Behavior is CONSTRAINED UNPREDICTABLE if the value of EDECR.SS is changed when the PE is in Non-debug state, see Changing the value of EDECR.SS when not in Debug state.

- Awrite to EDESR when the PE is in Non-debug state clears EDESR.SS to 0.

These operations are guaranteed to take effect only after a Context Synchronization event. If the instruction being stepped generates a Context Synchronization event, then the PE might use the old or new state.

The PE must perform the required behavior of the new state before or immediately following the next Context Synchronization event, but it is not required to do so immediately. This means that the PE can perform the required behavior of the old state before the next Context Synchronization event. This is illustrated in Example H3-1 and Example H3-2.

Example H3-1 Synchronization requirements 1

EDECR.SS is set to 1 in Debug state, requesting the active-not-pending state on exit from Debug state. On exit from Debug state the PE immediately takes an exception to EL3, where halting is prohibited. The PE does not step any instructions but executes the software at EL3 as normal. EDESR.SS remains set to 0. If halting is subsequently allowed, the PE must perform the required behavior of the active-not-pending state before or immediately following the next Context Synchronization event, but it is not required to do so immediately.

## SCTLR.ITD

## Example H3-2 Synchronization requirements 2

EDECR.SS is set to 1 in Debug state. On exit from Debug the PE executes an MSR instruction that sets OSDLR\_EL1.DLK to 1 and DoubleLockStatus() becomes TRUE. This change requires a Context Synchronization event to guarantee its effect, meaning it is CONSTRAINED UNPREDICTABLE whether:

- Halting is allowed:
- -The PE enters Debug state on the next instruction.
- Halting is prohibited:
- -The PE does not enter Debug state.

The value in EDESR.SS depends on whether halting was allowed or prohibited when the write to OSDLR\_EL1.DLK completed, and so it might be 0 or 1. If a second MSR instruction clears OSDLR\_EL1.DLK to 0, the PE must perform the required behavior of the state indicated by EDESR.SS before or immediately following the next Context Synchronization event, but it is not required to do so immediately.

See also Synchronization and Halting debug events.

## H3.2.5.1 Changing the value of EDECR.SS when not in Debug state

If software changes the value of EDECR.SS when the PE is not in Debug state then behavior is CONSTRAINED UNPREDICTABLE, and one or more of the following behaviors occurs:

- The value of EDECR.SS becomes UNKNOWN.
- The state of the Halting Step state machine becomes UNKNOWN.
- On a reset of the PE, the value of EDECR.SS and the state of the Halting Step state machine are UNKNOWN.

## H3.2.6 Stepping T32 IT instructions

In an implementation that supports the ITD control, the architecture permits a combination of one T32 IT instruction and another 16-bit T32 instruction to be treated as a single 32-bit instruction when the value of the ITD field that applies to the current Exception level is 1.

For the purpose of stepping an item, it is IMPLEMENTATION DEFINED whether:

- The PE considers such a pair of instructions to be one instruction.
- The PE considers such a pair of instructions be two instructions.

It is IMPLEMENTATION DEFINED whether this behavior depends on the value of the applicable ITD bit. For example:

- The debug logic might consider such a pair of instructions as one instruction, regardless of the state of the applicable ITD field.
- The debug logic might consider such a pair of instructions as two instructions, regardless of the state of the applicable ITD field.
- The debug logic might consider such a pair of instructions as one instruction when the value of the applicable ITD field is 1, and as two instructions when the value of the ITD field is 0.

An implementation that does not support the ITD control behaves as if the value of the ITD field is 0.

The ITD control fields are:

## HSCTLR.ITD

Applies to execution at EL2 when EL2 is using AArch32.

Applies to execution at EL0 or EL1 when EL1 is using AArch32.

## SCTLR\_EL1.ITD

Applies to execution at EL0 using AArch32 when EL1 is using AArch64.

## H3.2.7 Disabling interrupts while stepping

When using Halting Step, the sequence of entering Debug state, interacting with the debugger, and then exiting Debug state for each instruction reduces the rate at which the PE executes instructions. However, the rate at which certain interrupts, such as timer interrupts, are generated might be fixed by the system. This means it might be necessary to disable interrupts while using Halting Step by setting EDSCR.INTdis, to allow the code being debugged to make forward progress.

## H3.2.8 Syndrome information on Halting Step

Three EDSCR.STATUS encodings record different scenarios for entering Debug state on a Halting Step debug event:

## Halting Step, normal

An instruction other than a Load-Exclusive instruction was stepped.

## Halting Step, exclusive

ALoad-Exclusive instruction was stepped.

## Halting Step, no syndrome

The syndrome data is not available.

If the PE enters Debug state due to a Halting Step debug event immediately after stepping an instruction in the active-not-pending state, EDSCR.STATUS is set to either:

- Halting Step, normal, if the stepped instruction was not a Load-Exclusive instruction.
- Halting Step, exclusive, if the stepped instruction was a Load-Exclusive instruction.

If the stepped instruction was a conditional Load-Exclusive instruction that failed its Condition code check, EDSCR.STATUS is set to a CONSTRAINED UNPREDICTABLE choice of Halting Step, normal, or Halting Step, exclusive.

Otherwise, the PE enters Debug state without stepping an instruction. This means that the Halting Step state machine enters the active-pending state directly from the inactive state, without going through active-not-pending state. In this case, EDSCR.STATUS is set to Halting Step, no syndrome.

This happens when:

- The PE enters directly into the active-pending state on an exception return to a state where halting is allowed from EL3 when halting is prohibited at EL3.
- The active-pending state is entered for other reasons. See Synchronization and the Halting Step state machine

In addition, EDSCR.STATUS is CONSTRAINED UNPREDICTABLE when:

- Adifferent exception is taken before the Halting Step debug event.

In this case EDSCR.STATUS is set to a CONSTRAINED UNPREDICTABLE choice of:

- -Halting Step, no syndrome, or Halting Step, normal, if the stepped instruction was not a Load-Exclusive instruction.
- -Halting Step, no syndrome, or Halting Step, exclusive, if the stepped instruction was a Load-Exclusive instruction.
- The instruction that was stepped was an Exception Return instruction or an ISB . As these instructions are not in the Load-Exclusive instructions, EDSCR.STATUS is set to a CONSTRAINED UNPREDICTABLE choice of Halting Step, no syndrome or Halting Step, normal.
- The PE enters directly into the active-pending state on a Warm reset because EDECR.SS is set to 1. EDSCR.STATUS is set to a CONSTRAINED UNPREDICTABLE choice of Halting Step, no syndrome or Halting Step, normal.

In all cases, if EDSCR.STATUS is not set to Halting Step, no syndrome, then it must indicate whether the stepped instruction was a Load-Exclusive instruction by setting EDSCR.STATUS to Halting Step, normal or Halting Step, exclusive.

Note

If the PE cannot determine whether the stepped instruction was a Load-Exclusive instruction or not, then it sets EDSCR.STATUS to Halting Step, no syndrome. For example, the exception is taken before the PE decodes the stepped instruction, or the exception means the PE has no valid stepped instruction to decode.

Note

The architecture does not permit an implementation to always set EDSCR.STATUS to Halting Step, no syndrome.

## H3.2.9 Pseudocode description of Halting Step debug events

There are two pseudocode functions for Halting Step debug events:

- HSAdvance() . This is called after an instruction has executed and any exception generated by the instruction is taken, except for the case of an SVC, HVC, or SMC exception, in which case it is called before the exception is taken. HSAdvance() affects the next instruction.
- CheckHaltingStep() . This is called before the next instruction is executed. If a step is pending, it generates the debug event.