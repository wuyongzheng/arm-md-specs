## G1.17 AArch32 state exception descriptions

Handling exceptions that are taken to an Exception level using AArch32 gives general information about exception handling. This section describes each of the exceptions, in the following subsections:

- Undefined Instruction exception.
- Monitor Trap exception.
- Hyp Trap exception.
- Supervisor Call (SVC) exception.
- Secure Monitor Call (SMC) exception.
- Hypervisor Call (HVC) exception.
- Prefetch Abort exception.
- Data Abort exception.
- Virtual SError interrupt exception.
- IRQ exception.
- Virtual IRQ exception.
- FIQ exception.
- Virtual FIQ exception.

Additional pseudocode functions for exception handling gives additional pseudocode that is used in the pseudocode descriptions of a number of the exceptions.

## G1.17.1 Undefined Instruction exception

An Undefined Instruction exception might be caused by:

- ASystem register access, floating-point, or Advanced SIMD instruction that is not accessible because of the settings in one or more of the CPACR, NSACR, HCPTR, and DBGDSCRext.
- ASystem register access, floating-point, or Advanced SIMD instruction that is not implemented.
- ASystem register access, floating-point, or Advanced SIMD instruction that causes an exception during execution. This includes:
- -Trapped floating-point exceptions that are taken to AArch32, if an implementation supports these traps. See Floating-point exceptions and exception traps.
- -Execution of certain floating-point instructions when one or both of the FPSCR.{Stride, Len} fields in nonzero, in an implementation in which those fields are RW. The description of FPEXC specifies the instructions to which this applies.
- If FEAT\_UINJ is implemented, an attempt at EL0 using AArch32 to execute any instruction when PSTATE.UINJ is 1. See Undefined Instruction exceptions injected by PSTATE.UINJ.
- An instruction that is UNDEFINED.

Note

The Undefined Instruction exception is taken using offset 0x04 in the Hyp, Secure, or Non-secure vector table. In the Monitor vector table this offset is used for the Monitor Trap exception. See Monitor Trap exception and The vector tables and exception offsets.

By default, an Undefined Instruction exception is taken to Undefined mode, but an Undefined Instruction exception can be taken to EL2, meaning it is taken to Hyp mode if EL2 is using AArch32, see The PE mode to which the Undefined Instruction exception is taken.

The Undefined Instruction exception can provide:

- Signaling of an illegal instruction execution.
- Lazy context switching of System registers.

The preferred return address for an Undefined Instruction exception is the address of the instruction that generated the exception. For an exception taken to AArch32 state, this return is performed as follows:

- If returning from Secure or Non-secure Undefined mode, the exception return uses the SPSR and LR\_und values generated by the exception entry, as follows:
- -If SPSR.T is 0, indicating that the exception occurred in A32 state, the return uses an exception return instruction with a subtraction of 4.
- -If SPSR.T is 1, indicating that the exception occurred in T32 state, the return uses an exception return instruction with a subtraction of 2.
- If returning from Hyp mode, the exception return is performed by an ERET instruction, using the SPSR and ELR\_hyp values generated by the exception entry.

For more information, see Exception return to an Exception level using AArch32.

<!-- image -->

Note

If handling the Undefined Instruction exception requires instruction emulation, followed by return to the next instruction after the instruction that caused the exception, the instruction emulator must use the instruction length to calculate the correct return address, and to calculate the updated values of the IT bits if necessary.

## G1.17.1.1 The PE mode to which the Undefined Instruction exception is taken

Figure G1-4 shows how the implementation, state, and configuration options determine the PE mode to which an Undefined Instruction exception is taken, when the exception is taken to an Exception level that is using AArch32.

<!-- image -->

Figure G1-4 The PE mode an Undefined Instruction exception is taken to in AArch32 state

See also UNPREDICTABLE cases when the value of HCR.TGE is 1.

## G1.17.1.2 Pseudocode description of taking the Undefined Instruction exception

The AArch32.Undefined() pseudocode procedure determines whether the Undefined Instruction exception is taken to AArch32 state. If it is taken to AArch32 state, the AArch32.TakeUndefInstrException() pseudocode procedure describes how the PE takes the exception.

An Undefined Instruction exception is taken to an Exception level using AArch64 if either:

- It is generated in User mode when EL1 is using AArch64.
- It is generated in User mode when EL2 is enabled in the current Security state and is using AArch64 and the value of HCR\_EL2.TGE is 1.

## G1.17.1.3 Conditional execution of undefined instructions

The conditional execution rules described in Conditional execution apply to all instructions. This includes undefined instructions and other instructions that would cause entry to the Undefined Instruction exception.

If such an instruction fails its condition check, the behavior depends on the potential cause of entry to the Undefined Instruction exception, as follows:

- If the potential cause is the execution of the instruction itself and depends on data values used by the instruction, the instruction executes as a NOP and does not cause an Undefined Instruction exception.
- In the following cases, it is IMPLEMENTATION DEFINED whether the instruction executes as a NOP or causes an Undefined Instruction exception:
- -The potential cause is the execution of an earlier System register access instruction, floating-point instruction, or Advanced SIMD instruction.
- -The potential cause is the execution of the instruction itself without dependence on the data values used by the instruction.

An implementation must handle all such cases in the same way.

## G1.17.1.4 Interaction of UNDEFINED instruction behavior with UNPREDICTABLE or CONSTRAINED UNPREDICTABLE instruction behavior

If this manual describes an instruction as both:

- UNPREDICTABLE and UNDEFINED then the instruction is UNPREDICTABLE.
- CONSTRAINED UNPREDICTABLE and UNDEFINED then the instruction is CONSTRAINED UNPREDICTABLE.

Note

An example of this is where both:

- An instruction, or instruction class, is made UNDEFINED by some general principle, or by a configuration field.
- Aparticular encoding of that instruction or instruction class is specified as CONSTRAINED UNPREDICTABLE.

## G1.17.2 Monitor Trap exception

The Monitor Trap exception is implemented only as part of EL3, and can be generated only if EL3 is using AArch32.

Note

The Monitor Trap exception is taken using offset 0x04 in the Monitor vector table. In the other vector tables, this offset is used for the Undefined Instruction exception. See Undefined Instruction exception and The vector tables and exception offsets.

AMonitor Trap exception is generated if the PE is running in a mode other than Monitor mode, and commits for execution a WFI or WFE instruction that would otherwise cause suspension of execution when:

- In the case of the WFI instruction, the value of the SCR.TWI bit is 1.
- In the case of the WFE instruction, the value of the SCR.TWE bit is 1.

Note

Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.

The preferred return address for a Monitor Trap exception is the address of the instruction that generated the exception. The exception return uses the SPSR and LR\_mon values generated by the exception entry, as follows:

- If SPSR.T is 0, indicating that the exception occurred in A32 state, the return uses an exception return instruction with a subtraction of 4.
- If SPSR.T is 1, indicating that the exception occurred in T32 state, the return uses an exception return instruction with a subtraction of 2.

For more information, see Exception return to an Exception level using AArch32.

## G1.17.2.1 The PE mode to which the Monitor Trap exception is taken

When EL3 is using AArch32, a Monitor Trap exception is taken to Monitor mode, using a vector offset of 0x04 from the Monitor exception base address.

## G1.17.2.2 Pseudocode description of taking the Monitor Trap exception

The AArch32.TakeMonitorTrapException() pseudocode procedure describes how the PE takes the exception.

## G1.17.3 Hyp Trap exception

The Hyp Trap exception provides the standard mechanism for trapping Guest OS functions to the hypervisor.

The Hyp Trap exception is implemented only as part of EL2 and can be generated only if EL2 is using AArch32.

AHypTrap exception is generated if the PE is running in a Non-secure mode other than Hyp mode, and commits for execution an instruction that is trapped to Hyp mode. Instruction traps are enabled by setting bits to 1 in the HCR, HCPTR, HDCR, or HSTR. For more information, see EL2 configurable controls.

Traps to Hyp mode never apply in Secure state, regardless of the value of the SCR.NS bit.

The preferred return address for a Hyp Trap exception is the address of the trapped instruction. The exception return is performed by an ERET instruction, using the SPSR and ELR\_hyp values generated by the exception entry.

Note The SPSR and ELR\_hyp values generated on exception entry can be used, without modification, for an exception return to re-execute the trapped instruction. If the exception handler emulates the trapped instruction, and must return to the following instruction, the emulation of the instruction must include modifying ELR\_hyp, and possibly updating SPSR\_hyp.

When the PE enters the handler for a Hyp Trap exception, the HSR holds syndrome information for the exception. For more information, see Use of the HSR.

## G1.17.3.1 The PE mode to which the Hyp Trap exception is taken

AHypTrap exception is taken to Hyp mode, using a vector offset of 0x14 from the Hyp exception base address.

## G1.17.3.2 Pseudocode description of taking the Hyp Trap exception

The AArch32.TakeHypTrapException() pseudocode procedure describes how the PE takes the exception.

## G1.17.4 Supervisor Call (SVC) exception

The Supervisor Call instruction, SVC , requests a supervisor function, typically to request an operating system function. When EL1 is using AArch32, executing an SVC instruction causes the PE to enter Supervisor mode. For more information, see SVC.

Note

In an implementation that includes EL2, when EL2 is using AArch32:

- When an SVC instruction is executed in Hyp mode, the Supervisor Call exception is taken to Hyp mode. For more information, see SVC.
- When the HCR.TGE bit is set to 1, the Supervisor Call exception generated by execution of an SVC instruction in Non-secure User mode is routed to Hyp mode. For more information, see Supervisor Call exception, when the value of HCR.TGE is 1.

By default, a Supervisor Call exception that is taken to AArch32 state is taken to Supervisor mode, but a Supervisor Call exception can be taken to EL2, meaning it is taken to Hyp mode if EL2 is using AArch32, see The PE mode to which the Supervisor Call exception is taken.

The preferred return address for a Supervisor Call exception is the address of the next instruction after the SVC instruction. For an exception taken to AArch32 state, this return is performed as follows:

- If returning from Secure or Non-secure Supervisor mode, the exception return uses the SPSR and LR\_svc values generated by the exception entry, in an exception return instruction without subtraction.
- If returning from Hyp mode, the exception return is performed by an ERET instruction, using the SPSR and ELR\_hyp values generated by the exception entry.

For more information, see Exception return to an Exception level using AArch32.

## G1.17.4.1 The PE mode to which the Supervisor Call exception is taken

Figure G1-5 shows how the implementation, state, and configuration options determine the PE mode to which a Supervisor Call exception is taken, when the exception is taken to an Exception level that is using AArch32.

Figure G1-5 The PE mode the Supervisor Call exception is taken to in AArch32 state

<!-- image -->

See also UNPREDICTABLE cases when the value of HCR.TGE is 1.

## G1.17.4.2 Pseudocode description of taking the Supervisor Call exception

The AArch32.CallSupervisor() pseudocode procedure determines whether the Supervisor Call exception is taken to AArch32 state. If it is taken to AArch32 state, the AArch32.TakeSVCException() pseudocode procedure describes how the PE takes the exception.

An Supervisor Call exception is taken to an Exception level using AArch64 if either:

- It is generated by executing an SVC instruction in User mode when EL1 is using AArch64.
- It is generated by executing an SVC instruction in Non-secure User mode when EL2 is using AArch64 and the value of HCR\_EL2.TGE is 1.

## G1.17.5 Secure Monitor Call (SMC) exception

The Secure Monitor Call exception is implemented only as part of EL3. When EL3 is using AArch32, the exception is taken to Monitor mode.

The Secure Monitor Call instruction, SMC , requests a Secure Monitor function. When EL3 is using AArch32, executing an SMC instruction causes the PE to enter Monitor mode. For more information, see SMC.

Note

- In an implementation that includes EL2, execution of an SMC instruction in a Non-secure EL1 mode can be trapped to EL2. When EL2 is using AArch32, this means that when HCR.TSC 1, execution of an SMC instruction in a Non-secure EL1 mode generates a Hyp Trap Exception that is taken to Hyp mode.
- The Operation pseudocode in the description of the AArch32 SMC instruction, in SMC, identifies cases where execution of the instruction generates an exception that is taken to EL3 using AArch64.

The preferred return address for a Secure Monitor Call exception is the address of the next instruction after the SMC instruction. For an exception taken to AArch32 state, this return is performed using the SPSR and LR\_mon values generated by the exception entry, using an exception return instruction without a subtraction.

For more information, see Exception return to an Exception level using AArch32.

Note

For an exception taken to AArch32 state, the exception handler can return to the SMC instruction itself by returning using a subtraction of 4, without any adjustment to the SPSR.IT[7:0] bits. If it does this, the return occurs, then asynchronous exceptions might occur and be handled, then the SMC instruction is re-executed and another Secure Monitor Call exception occurs.

This relies on:

- The SMC instruction being used correctly, either outside an IT block or as the last instruction in an IT block, so that the SPSR.IT[7:0] bits indicate unconditional execution.
- The Secure Monitor Call handler not changing the result of the original conditional execution test for the SMC instruction.

## G1.17.5.1 The PE mode to which the Secure Monitor Call exception is taken

The Secure Monitor Call exception is supported only as part of EL3. When EL3 is using AArch32, a Secure Monitor Call exception is taken to Monitor mode, using vector offset 0x08 from the Monitor exception base address.

Note

- An SMC instruction that is trapped to Hyp mode because HCR.TSC is set to 1 generates a Hyp Trap exception, see The PE mode to which the Hyp Trap exception is taken.
- If EL3 is using AArch64 then Security behavior in Exception levels using AArch32 when EL2 or EL3 are using AArch64 describes the effect of executing an SMC instruction at an Exception level that is using EL1.

## G1.17.5.2 Pseudocode description of taking the Secure Monitor Call exception

The AArch32.TakeSMCException() pseudocode procedure describes how the PE takes the exception when the exception is taken to an Exception level that is using AArch32.

## G1.17.6 Hypervisor Call (HVC) exception

The Hypervisor Call exception is implemented only as part of EL2.

The Hypervisor Call instruction, HVC , requests a hypervisor function. When EL2 is using AArch32, executing an HVC instruction generates a Hypervisor Call exception that is taken to Hyp mode. For more information, see HVC.

Note

- Execution of HVC instructions is disabled when the value of SCR.HCE is 0. Descriptions of HVC instruction execution elsewhere in this section assume the Effective value of SCR.HCE is 1.
- When EL2 is using AArch64 an HVC instruction executed in a Non-secure EL1 mode generates an exception that is taken to EL2 using AArch64.

The preferred return address for a Hypervisor Call exception is the address of the next instruction after the HVC instruction. The exception return is performed by an ERET instruction, using the SPSR and ELR\_hyp values generated by the exception entry.

For more information, see Exception return to an Exception level using AArch32.

When EL2 is using AArch32, executing an HVC instruction transfers the immediate argument of the instruction to the HSR. The exception handler retrieves the argument from the HSR, and therefore does not have to access the original HVCinstruction. For more information, see Use of the HSR.

## G1.17.6.1 The PE mode to which the Hypervisor Call exception is taken

The Hypervisor Call exception is supported only as part of EL2. When EL2 is using AArch32, a Hypervisor Call exception is taken to Hyp mode, using a vector offset that depends on the mode from which the exception is taken, as Figure G1-6 shows. This offset is from the Hyp exception base address.

Figure G1-6 The PE mode the Hypervisor Call exception is taken to in AArch32 state

<!-- image -->

## G1.17.6.2 Pseudocode description of taking the Hypervisor Call exception

The AArch32.CallHypervisor() pseudocode procedure determines whether the valid execution of an HVC instruction in AArch32 state generates an exception that is taken to EL2 using AArch64, or generates a Hypervisor Call exception taken to Hyp mode. The AArch32.TakeHVCException() pseudocode procedure describes how the PE takes a Hypervisor Call exception.

## G1.17.7 Prefetch Abort exception

APrefetch Abort exception can be generated by:

- Asynchronous memory abort on an instruction fetch.

Note

Asynchronous External aborts on instruction fetches are reported as SError exceptions using the Data Abort exception, see Data Abort exception.

APrefetch Abort exception entry is synchronous to the instruction whose fetch aborted. For more information about memory aborts see VMSAv8-32 memory aborts.

- ABreakpoint, Vector Catch or Breakpoint Instruction exception, see AArch32 Self-hosted Debug.

Note

If an implementation fetches instructions speculatively, it must handle a synchronous abort on such an instruction fetch by:

- Generating a Prefetch Abort exception only if the instruction would be executed in a simple sequential execution of the program.
- Ignoring the abort if the instruction would not be executed in a simple sequential execution of the program.

By default, when EL1 is using AArch32, a Prefetch Abort exception is taken to Abort mode, but a Prefetch Abort exception can be taken to:

- EL2, meaning it is taken to Hyp mode if EL2 is using AArch32.

- EL3, meaning it is taken to Monitor mode if EL3 is using AArch32.

## For more information:

- About cases where the Prefetch Abort exception is taken to an Exception level that is using AArch32, see The PE mode to which the Prefetch Abort exception is taken.
- About cases where the Prefetch Abort generates an exception that is taken to an Exception level that is using AArch64, see Pseudocode description of taking the Prefetch Abort exception.

The preferred return address for a Prefetch Abort exception is the address of the aborted instruction. For an exception taken to AArch32 state this return is performed as follows:

- If returning from a mode other than Hyp mode, using the SPSR and LR values generated by the exception entry, using an exception return instruction with a subtraction of 4. This means using:
- -SPSR\_abt and LR\_abt if returning from Abort mode.
- -SPSR\_mon and LR\_mon if returning from Monitor mode.
- If returning from Hyp mode, using the SPSR\_hyp and ELR\_hyp values generated by the exception entry, using an ERET instruction.

For more information about the handling of Prefetch Abort exceptions in AArch32 state, see Exception return to an Exception level using AArch32.

## G1.17.7.1 Prefetch Abort exception reporting a PC alignment fault exception

APCalignment fault exception that is taken to an Exception level that is using AArch32 is reported as a Prefetch Abort exception, and:

## If the exception is taken to EL1 using AArch32 or EL3 using AArch32

- The IFSR indicates the cause of the exception:
- -If the value of TTBCR.EAE is 0, IFSR.FS takes the value 0b00001 .
- -If the value of TTBCR.EAE is 1, IFSR.STATUS takes the value 0b100001 .
- IFAR holds the value of the address that faulted, including the misaligned low order bit or bits.
- R14\_abt holds the address that faulted, including the misaligned low order bit or bits, with the standard offset for a Prefetch Abort exception.

## If the exception is taken to EL2 using AArch32

- HSR.EC takes the value 0b100010 .
- HSR.IL is UNKNOWN.
- HSR.ISS is RES0.
- HIFAR and ELR\_hyp each hold the value of the address that faulted, including the misaligned low order bit or bits.

For a PC alignment fault exception taken to an Exception level that is using AArch32:

- If the exception occurred because of the CONSTRAINED UNPREDICTABLE behavior of a branch to an unaligned PC value, as described in Branching to an unaligned PC, then bit[0] of the faulting address is forced to zero, and therefore the misalignment is because the value of bit[1] of this address is 1.
- If the exception occurred on an exit from Debug state, as described in Exiting Debug state, then it is CONSTRAINED UNPREDICTABLE whether bit[0] of the faulting address is forced to zero.

## G1.17.7.2 The PE mode to which the Prefetch Abort exception is taken

Figure G1-7 shows how the implementation, state, and configuration options determine the PE mode to which a Prefetch Abort exception is taken, when the exception is taken to an Exception level that is using AArch32.

Note

In this figure, the Effective value of HCR2.TEA is 0 if FEAT\_RAS is not implemented.

Figure G1-7 The PE mode the Prefetch Abort exception is taken to in AArch32 state

<!-- image -->

See also UNPREDICTABLE cases when the value of HCR.TGE is 1.

## G1.17.7.3 Pseudocode description of taking the Prefetch Abort exception

The AArch32.Abort() pseudocode function determines whether the Prefetch Abort condition generates an exception that is taken to an Exception level that is using AArch64, or generates a Prefetch Abort exception that is taken in AArch32 state. When the exception is taken in AArch32 state, the AArch32.TakePrefetchAbortException() pseudocode procedure describes how the PE takes the exception.

The exception is taken to an Exception level using AArch64 if one of the following applies:

- The exception is generated in User mode when EL1 is using AArch64.
- The implementation includes EL2, EL2 is using AArch64, and one of the following applies:
- -The value of HCR\_EL2.TGE is 1 and the exception is generated in Non-secure User mode.
- -The value of MDCR\_EL2.TDE is 1 and the exception is generated by a Debug exception in a Non-secure EL1 or Non-secure EL0 mode.
- -The exception is generated by a stage 2 fault during a stage 1 translation table walk using the AArch32 Non-secure EL1&amp;0 translation regime.
- The implementation includes EL3, EL3 is using AArch64, the value of SCR\_EL3.EA is 1. and the exception is generated by an External abort in AArch32 state.

## G1.17.8 Data Abort exception

In AArch32 state, a Data Abort exception can be generated by:

- Asynchronous abort on a data read or write memory access. Exception entry is synchronous to the instruction that generated the memory access.
- An SError exception. The SError exception might be caused by an External abort on a memory access, which can be any of:
- -Adata read or write access.
- -An instruction fetch.
- -In a VMSA memory system, a translation table access.

Exception entry occurs asynchronously.

As described in Asynchronous exception masking controls, SError exceptions can be masked. When this happens, a generated SError exception is not taken until it is not masked.

- Awatchpoint, see Watchpoint exceptions.

By default, when EL1 is using AArch32 a Data Abort exception is taken to Abort mode, but a Data Abort exception can be taken to:

- EL2, meaning it is taken to Hyp mode if EL2 is using AArch32.
- EL3, meaning it is taken to Monitor mode if EL3 is using AArch32.

For more information:

- About cases where the Data Abort exception is taken to an Exception level that is using AArch32, see The PE mode to which the Data Abort exception is taken.
- About memory aborts in AArch32 state, see VMSAv8-32 memory aborts.
- About cases where the Data Abort generates an exception that is taken to an Exception level that is using AArch64, see Pseudocode description of taking the Data Abort exception.

The preferred return address for a Data Abort exception is the address of the instruction that generated the aborting memory access, or the address of the instruction following the instruction boundary at which an SError exception was taken. For an exception taken to AArch32 state, this return is performed as follows:

- If returning from a mode other than Hyp mode, using the SPSR and LR values generated by the exception entry, using an exception return instruction with a subtraction of 8. This means using:

- -SPSR\_abt and LR\_abt if returning from Abort mode.
- -SPSR\_mon and LR\_mon if returning from Monitor mode.
- If returning from Hyp mode, using the SPSR\_hyp and ELR\_hyp values generated by the exception entry, using an ERET instruction.

For more information about the handling of Data Abort exceptions in AArch32 state, see Exception return to an Exception level using AArch32.

## G1.17.8.1 The PE mode to which the Data Abort exception is taken

Figure G1-8 shows the determination of the mode to which a Data Abort exception is taken when the exception is taken to an Exception level that is using AArch32.

Note

In this figure, the Effective value of HCR2.TEA is 0 if FEAT\_RAS is not implemented.

<!-- image -->

See also UNPREDICTABLE cases when the value of HCR.TGE is 1.

## G1.17.8.2 Pseudocode description of taking the Data Abort exception

The AArch32.Abort() pseudocode function determines whether the Data Abort condition generates an exception that is taken to an Exception level that is using AArch64, or generates a Data Abort exception that is taken in AArch32 state. When the exception is taken in AArch32 state, the AArch32.TakeDataAbortException() pseudocode procedure describes how the PE takes the exception.

The exception is taken to an Exception level using AArch64 if one of the following applies:

- The exception is generated in User mode when EL1 is using AArch64.
- The implementation includes EL2, EL2 is using AArch64, and one of the following applies:
- -The value of HCR\_EL2.TGE is 1 and the exception is generated in Non-secure User mode.
- -The value of MDCR\_EL2.TDE is 1 and the exception is generated by a Debug exception in a Non-secure EL1 or Non-secure EL0 mode.
- -The exception is generated by a stage 2 fault during a stage 1 translation table walk using the AArch32
- Non-secure EL1&amp;0 translation regime.
- The implementation includes EL3, EL3 is using AArch64, the value of SCR\_EL3.EA is 1. and the exception is generated by an External abort in AArch32 state.

## G1.17.8.3 Effects of data-aborted instructions

An instruction that accesses data memory can modify memory by storing one or more values. If the execution of such an instruction generates a Data Abort exception, or causes Debug state entry because of a watchpoint set on the location, the value of each memory location that the instruction stores to is:

- Unchanged for any location for which one of the following applies:
- -An Alignment fault is generated.
- -An MMUfault is generated.
- -AWatchpoint is generated.
- -An External abort is generated, if that External abort is taken synchronously.
- UNKNOWN for any location for which no exception and no debug event is generated.

If the access to a memory location generates an External abort that is taken asynchronously, it is outside the scope of the architecture to define the effect of the store on that memory location, because this depends on the system-specific nature of the External abort. However, in general, Arm recommends that such locations are unchanged.

For External aborts and Watchpoints, where in principle faulting could be identified at byte or halfword granularity, the size of a location in this definition is the size for which a memory access is single-copy atomic.

In AArch32 state, instructions that access data memory can modify registers in the following ways:

- By loading values into one or more of the general-purpose registers. The registers loaded can include the PC.
- By loading values into one or more of the registers in the Advanced SIMD and floating-point register file.
- By specifying base register writeback , in which the base register used in the address calculation has a modified value written to it. All instructions that support base register writeback have CONSTRAINED UNPREDICTABLE results if base register writeback is specified with the PC as the base register. Only general-purpose registers can be modified reliably in this way.
- By a direct transfer to or from the Debug Communication Channel (DCC) register, using the LDC and STC instructions. For more information, see The Debug Communication Channel and Instruction Transfer Register. If the instruction that accesses the DCC registers is an LDC or STC instruction, UNKNOWN values are left in the Data Transfer Register and DCC flow-control flags.
- By modifying PSTATE.

If the execution of such an instruction generates a synchronous Data Abort exception, the following rules determine the values left in these registers:

- On entry to the Data Abort exception handler:

- -The PC value is the Data Abort vector address, see Exception vectors and the exception base address.
- -The LR\_abt value is determined from the address of the aborted instruction.

Neither value is affected by the results of any load specified by the instruction.

- The base register is restored to its original value if either:
- -The aborted instruction is a load and the list of registers to be loaded includes the base register.
- -The base register is being written back.
- If the instruction only loads one general-purpose register the value in that register is unchanged.
- If the instruction loads more than one general-purpose register, UNKNOWN values are left in destination registers other than the PC and the base register of the instruction.
- If the instruction affects any registers in the Advanced SIMD and floating-point register file, UNKNOWN values are left in the registers that are affected.
- PSTATE bits that are not defined as updated on exception entry retain their current value.
- If the instruction is a STREX , STREXB , STREXH , or STREXD , &lt;Rd&gt; is not updated.

After taking a Data Abort exception, the state of the Exclusives monitors is UNKNOWN. Therefore, Arm strongly recommends that the abort handler performs a CLREX instruction, or a dummy STREX instruction, to clear the Exclusives monitor state.

An External abort might signal a data corruption to the PE. For example, a memory location might have been corrupted. The error that caused the External abort might have been propagated. The RAS Extension provides mechanisms for software to determine the extent of the corruption and contain propagation of the error. For more information, see RAS PE Architecture.

## G1.17.8.4 The Arm abort model

The abort model used by an Arm PE is described as a Base Restored Abort Model . This means that if a synchronous Data Abort exception is generated by executing an instruction that specifies base register writeback, the value in the base register is unchanged.

The abort model applies uniformly across all instructions.

## G1.17.9 Virtual SError interrupt exception

The Virtual SError interrupt exception is implemented only as part of EL2 is enabled in the current Security state.

AVirtual SError interrupt exception is generated in AArch32 state if all of the following apply:

- The PE is in a mode other than Hyp mode.
- The value of PSTATE.A is 0.
- Either:
- -EL2 is using AArch32 and the values of the HCR.{TGE, AMO, VA} bits are {0, 1, 1}.
- -EL2 is using AArch64 and the values of the HCR\_EL2.{TGE, AMO, VA} bits are {0, 1, 1}.

The preferred return address for a Virtual SError interrupt exception is the address of the instruction immediately after the instruction boundary where the exception was taken. For an exception taken to AArch32 state, this return is performed using the SPSR and LR\_abt values generated by the exception entry, using an exception return instruction without subtraction.

## G1.17.9.1 The PE mode to which the Virtual SError interrupt exception is taken

The Virtual SError interrupt exception is taken using a vector offset of 0x10 from the Non-secure exception base address.

The conditions for generating a Virtual SError interrupt exception in AArch32 state mean the exception is:

- Taken from a EL1 or EL0 mode.
- Taken to Abort mode if EL1 is using AArch32.
- Taken to EL1, when EL0 is using AArch32 and EL1 is using AArch64.

For more information, see Virtual exceptions when an implementation includes EL2.

Note

Because a Virtual SError interrupt exception taken to AArch32 state is always taken to Abort mode, on exception entry the preferred return address is always saved to LR\_abt.

## G1.17.9.2 Pseudocode description of taking the Virtual SError interrupt exception

The AArch32.TakeVirtualSErrorException() pseudocode procedure describes how the PE takes the exception.

## G1.17.10 IRQ exception

The IRQ exception is generated by IMPLEMENTATION DEFINED means. Typically this is by asserting an IRQ interrupt request input to the PE.

When an IRQ exception is taken, exception entry is precise to an instruction boundary.

As described in Asynchronous exception masking controls, IRQ exceptions can be masked. When this happens, a generated IRQ exception is not taken until it is not masked.

By default, when EL1 is using AArch32, an IRQ exception is taken to IRQ mode, but an IRQ exception can be taken to:

- EL2, meaning it is taken to Hyp mode if EL2 is using AArch32.
- EL3, meaning it is taken to Monitor mode if EL3 is using AArch32.

For more information:

- About cases where the exception is taken to an Exception level using AArch32, see The PE mode to which the physical IRQ exception is taken.
- About cases where the exception is taken to an Exception level using AArch64, see Pseudocode description of taking the physical IRQ exception.

The preferred return address for an IRQ exception is the address of the instruction following the instruction boundary at which the exception was taken. For an exception taken to AArch32 state this return is performed as follows:

- If returning from a mode other than Hyp mode, using the SPSR and LR values generated by the exception entry, using an exception return instruction with a subtraction of 4. This means using:
- -SPSR\_irq and LR\_irq if returning from IRQ mode.
- -SPSR\_mon and LR\_mon if returning from Monitor mode.
- If returning from Hyp mode, using the SPSR\_hyp and ELR\_hyp values generated by the exception entry, using an ERET instruction.

For more information, see Exception return to an Exception level using AArch32.

## G1.17.10.1 The PE mode to which the physical IRQ exception is taken

Figure G1-9 shows how the implementation, state, and configuration options determine the mode to which an IRQ exception is taken when the exception is taken to an Exception level that is using AArch32.

Figure G1-9 The PE mode the IRQ exception is taken to in AArch32 state

<!-- image -->

## G1.17.10.2 Pseudocode description of taking the physical IRQ exception

The AArch32.TakePhysicalIRQException() pseudocode procedure describes how the PE takes the exception. This procedure includes the case where the exception is taken to an Exception level that is using AArch64. This happens if one of the following applies:

- The exception is taken from User mode and EL1 is using AArch64. The Exception is taken to EL1 using AArch64.
- The exception is taken from User mode, EL2 is implemented in the current Security state and using AArch64, and the value of HCR\_EL2.TGE is 1. The Exception is taken to EL2 using AArch64.
- The exception is taken from EL0 or EL1 mode, EL2 is implemented in the current Security state and using AArch64, and the value of HCR\_EL2.IMO is 1. The Exception is taken to EL2 using AArch64.
- The exception is taken from a PE mode other than Monitor mode, EL3 is implemented and using AArch64, and the value of SCR\_EL3.IRQ is 1. The Exception is taken to EL3 using AArch64.

## G1.17.11 Virtual IRQ exception

The Virtual IRQ exception is implemented only as part of EL2, if EL2 is enabled in the current Security state.

AVirtual IRQ exception is generated in AArch32 state if all of the following apply:

- The PE is in a mode other than Hyp mode.
- The value of PSTATE.I is 0.
- Either:
- -EL2 is using AArch32 and the value of HCR.{TGE, IMO} is {0, 1}.
- -EL2 is using AArch64 and the value of HCR\_EL2.{TGE, IMO} is {0, 1}.
- One of the following applies:
- -EL2 is using AArch32 and the value of HCR.VI is 1.
- -EL2 is using AArch64 and the value of HCR\_EL2.VI is 1.
- -AVirtual IRQ exception is generated by an IMPLEMENTATION DEFINED mechanism.

The preferred return address for a Virtual IRQ exception is the address of the instruction immediately after the instruction boundary where the exception was taken. For an exception taken to AArch32 state this return is performed using the SPSR and LR\_irq values generated by the exception entry, using an exception return instruction with a subtraction of 4.

## G1.17.11.1 The PE mode to which the Virtual IRQ exception is taken

The Virtual IRQ exception uses a vector offset of 0x18 .

The conditions for generating a Virtual IRQ exception in AArch32 state mean the exception is:

- Taken from an EL1 or EL0 mode.
- Taken to IRQ mode if EL1 is using AArch32.
- Taken to EL1 if EL0 is using AArch32 and EL1 is using AArch64.

For more information, see Virtual exceptions when an implementation includes EL2.

## G1.17.11.2 Pseudocode description of taking the Virtual IRQ exception

The AArch32.TakeVirtualIRQException() pseudocode procedure describes how the PE takes the exception.

## G1.17.12 FIQ exception

The FIQ exception is generated by IMPLEMENTATION DEFINED means. Typically this is by asserting an FIQ interrupt request input to the PE.

When an FIQ exception is taken, exception entry is precise to an instruction boundary.

As described in Asynchronous exception masking controls, FIQ exceptions can be masked. When this happens, a generated FIQ exception is not taken until it is not masked.

By default, an FIQ exception is taken to FIQ mode, but an FIQ exception can be taken to:

- EL2, meaning it is taken to Hyp mode if EL2 is using AArch32.
- EL3, meaning it is taken to Monitor mode if EL3 is using AArch32.

For more information:

- About cases where the exception is taken to an Exception level using AArch32, see The PE mode to which the physical FIQ exception is taken.
- About cases where the exception is taken to an Exception level using AArch64, see Pseudocode description of taking the FIQ exception.

The preferred return address for an FIQ exception is the address of the instruction following the instruction boundary at which the exception was taken. For an exception taken to AArch32 state this return is performed as follows:

- If returning from a mode other than Hyp mode, using the SPSR and LR values generated by the exception entry, using an exception return instruction with a subtraction of 4. This means using:
- -SPSR\_fiq and LR\_fiq if returning from FIQ mode.
- -SPSR\_mon and LR\_mon if returning from Monitor mode.
- If returning from Hyp mode, using the SPSR\_hyp and ELR\_hyp values generated by the exception entry, using an ERET instruction.

For more information, see Exception return to an Exception level using AArch32.

## G1.17.12.1 The PE mode to which the physical FIQ exception is taken

Figure G1-10 shows how the implementation, state, and configuration options determine the PE mode to which an FIQ exception is taken when the exception is taken to an Exception level that is using AArch32.

Figure G1-10 The PE mode the FIQ exception is taken to in AArch32 state

<!-- image -->

## G1.17.12.2 Pseudocode description of taking the FIQ exception

The AArch32.TakePhysicalFIQException() pseudocode procedure describes how the PE takes the exception. This procedure includes the case where the exception is taken to an Exception level that is using AArch64. This happens if one of the following applies:

- The exception is taken from User mode and EL1 is using AArch64. The Exception is taken to EL1 using AArch64.
- The exception is taken from User mode, EL2 is implemented in the current Security state and using AArch64, and the value of HCR\_EL2.TGE is 1. The Exception is taken to EL2 using AArch64.
- The exception is taken from an EL0 or EL1 mode, EL2 is implemented in the current Security state and using AArch64, and the value of HCR\_EL2.FMO is 1. The Exception is taken to EL2 using AArch64.
- The exception is taken from a PE mode other than Monitor mode, EL3 is implemented and using AArch64, and the value of SCR\_EL3.FIQ is 1. The Exception is taken to EL3 using AArch64.

## G1.17.13 Virtual FIQ exception

The Virtual FIQ exception is implemented only as part of EL2, if EL2 is enabled in the current Security state.

AVirtual FIQ exception is generated in AArch32 state if all of the following apply:

- The PE is in a mode other than Hyp mode.
- The value of PSTATE.F is 0.
- Either:
- -EL2 is using AArch32 and the value of HCR.{TGE, FMO} is {0, 1}.
- -EL2 is using AArch64 and the value of HCR\_EL2.{TGE, FMO} is {0, 1}.
- One of the following applies:
- -EL2 is using AArch32 and the value of HCR.VF is 1.
- -EL2 is using AArch64 and the value of HCR\_EL2.VF is 1.
- -AVirtual FIQ exception is generated by an IMPLEMENTATION DEFINED mechanism.

The preferred return address for a Virtual FIQ exception is the address of the instruction immediately after the instruction boundary where the exception was taken. For an exception taken to AArch32 state this return is performed using the SPSR and LR\_irq values generated by the exception entry, using an exception return instruction with a subtraction of 4.

## G1.17.13.1 The PE mode to which the Virtual FIQ exception is taken

The Virtual FIQ exception is taken using a vector offset of 0x1C .

The conditions for generating a Virtual FIQ exception in AArch32 state mean the exception is:

- Taken from EL1 or EL0.
- Taken to FIQ mode if EL1 is using AArch32.
- Taken to EL1 if EL0 is using AArch32 and EL1 is using AArch64.

For more information, see Virtual exceptions when an implementation includes EL2.

## G1.17.13.2 Pseudocode description of taking the Virtual FIQ exception

The AArch32.TakeVirtualFIQException() pseudocode procedure describes how the PE takes the exception.

## G1.17.14 Additional pseudocode functions for exception handling

The AArch32.EnterMonitorMode() pseudocode function changes the PE mode to Monitor mode, with the required state changes.

The AArch32.EnterHypMode() pseudocode function changes the PE mode to Hyp mode, with the required state changes.

The AArch32.EnterMode() pseudocode function changes the PE mode to a PL1 mode, with the required state changes. It is used for all exceptions that are not routed to Hyp mode or Monitor mode.

The AArch32.EnterMonitorMode() , AArch32.EnterHypMode() , and AArch32.EnterMode() functions are described in A-profile Architecture Pseudocode.