## D24.2.191 TCR2\_EL2, Extended Translation Control Register (EL2)

The TCR2\_EL2 characteristics are:

## Purpose

The control register for stage 1 of the EL2&amp;0 translation regime.

## Configuration

If EL2 is not implemented, this register is RES0 from EL3.

This register is present only when FEAT\_TCR2 is implemented and FEAT\_AA64 is implemented. Otherwise, direct accesses to TCR2\_EL2 are UNDEFINED.

## Attributes

TCR2\_EL2 is a 64-bit register.

## Field descriptions

When !ELIsInHost(EL2):

<!-- image -->

Unless stated otherwise, all the bits in TCR2\_EL2 are permitted to be cached in a TLB.

## Bits [63:13]

Reserved, RES0.

## AMEC0, bit [12]

## When FEAT\_MEC is implemented:

This field controls the enabling of the Alternate MECID translations for the EL2 translation regime.

TCR2\_EL2.AMEC0 is provided to enable the safe update of MECID\_A0\_EL2, by disabling access and speculation to AMEC==1 Block or Page descriptors during the update.

| AMEC0   | Meaning                                                                                                                       |
|---------|-------------------------------------------------------------------------------------------------------------------------------|
| 0b0     | Use of a Block or Page descriptor containing AMEC==1generates a Translation fault.                                            |
| 0b1     | Accesses translated by a Block or Page descriptor containing AMEC==1are associated with the MECID configured in MECID_A0_EL2. |

This bit is permitted to be cached in a TLB only if it is 1.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

When SCTLR2\_EL2.EMEC is 0, this field is ignored by the PE and the bit position of AMEC is RES0 in Block and Page descriptors.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

Accessing this field has the following behavior:

- When IsCurrentSecurityState(SS\_Secure), access to this field is RES0.
- When IsCurrentSecurityState(SS\_NonSecure), access to this field is RES0.

## Otherwise:

Reserved, RES0.

## HAFT, bit [11]

## When FEAT\_HAFT is implemented:

Hardware managed Access Flag for Table descriptors.

Enables the Hardware managed Access Flag for Table descriptors.

| HAFT   | Meaning                                                         |
|--------|-----------------------------------------------------------------|
| 0b0    | Hardware managed Access Flag for Table descriptors is disabled. |
| 0b1    | Hardware managed Access Flag for Table descriptors is enabled.  |

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## PTTWI, bit [10]

## When FEAT\_THE is implemented:

Permit Translation table walk Incoherence.

Permits RCWS instructions to generate writes that have the Reduced Coherence property.

| PTTWI   | Meaning                                                                                     |
|---------|---------------------------------------------------------------------------------------------|
| 0b0     | Write accesses generated by RCWSat EL2 or EL2&0 do not have the Reduced Coherence property. |
| 0b1     | Write accesses generated by RCWSat EL2 or EL2&0 have the Reduced Coherence property.        |

This bit is permitted to be implemented as a read-only bit with a fixed value of 0.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## Bits [9:5]

Reserved, RES0.

## AIE, bit [4]

## When FEAT\_AIE is implemented:

Enable Attribute Indexing Extension.

| AIE   | Meaning                                |
|-------|----------------------------------------|
| 0b0   | Attribute Indexing Extension Disabled. |
| 0b1   | Attribute Indexing Extension Enabled.  |

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

POE, bit [3]

## When FEAT\_S1POE is implemented:

Enables Permission Overlay for EL2 accesses.

| POE   | Meaning                                                                          |
|-------|----------------------------------------------------------------------------------|
| 0b0   | Permission overlay disabled for EL2 access in stage 1 of EL2 translation regime. |
| 0b1   | Permission overlay enabled for EL2 access in stage 1 of EL2 translation regime.  |

This bit is not permitted to be cached in a TLB.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## Bit [2]

Reserved, RES0.

## PIE, bit [1]

## When FEAT\_S1PIE is implemented:

Enables usage of Indirect Permission Scheme.

| PIE   | Meaning                    |
|-------|----------------------------|
| 0b0   | Direct permission model.   |
| 0b1   | Indirect permission model. |

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## PnCH, bit [0]

## When FEAT\_THE is implemented:

Protected attribute enable. Enables use of bit[52] of stage 1 translation table entries as the Protected bit, for translations using TTBR0\_EL2 when HCR\_EL2.E2H is 0.

| PnCH   | Meaning                                                                                                     |
|--------|-------------------------------------------------------------------------------------------------------------|
| 0b0    | For translations using TTBRn_EL2, bit[52] of each stage 1 translation table entry is not the Protected bit. |
| 0b1    | For translations using TTBR0_EL2, bit[52] of each stage 1 translation table entry is the Protected bit.     |

If bit[52] is used as the Protected bit, it is not used as the Contiguous bit.

This field is RES0 when TCR2\_EL2.D128 is 1.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## When ELIsInHost(EL2):

<!-- image -->

Unless stated otherwise, all the bits in TCR2\_EL2 are permitted to be cached in a TLB.

## Bits [63:19]

Reserved, RES0.

## FNG1, bit [18]

## When FEAT\_ASID2 is implemented:

Force non-global translations for TTBR1\_EL2.

| FNG1   | Meaning                                                                       |
|--------|-------------------------------------------------------------------------------|
| 0b0    | This bit has no effect on the interpretation of the nG bit.                   |
| 0b1    | Translations are treated as non-global regardless of the value of the nG bit. |

This bit is permitted to be cached in a TLB.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## FNG0, bit [17]

## When FEAT\_ASID2 is implemented:

Force non-global translations for TTBR0\_EL2.

| FNG0   | Meaning                                                                       |
|--------|-------------------------------------------------------------------------------|
| 0b0    | This bit has no effect on the interpretation of the nG bit.                   |
| 0b1    | Translations are treated as non-global regardless of the value of the nG bit. |

This bit is permitted to be cached in a TLB.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## A2, bit [16]

## When FEAT\_ASID2 is implemented:

Enable use of two ASIDs.

This bit is permitted to be cached in a TLB.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero. The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

DisCH1, bit [15]

## When FEAT\_D128 is implemented and TCR2\_EL2.D128 == '1':

Disable the Contiguous bit for the Start Table for TTBR1\_EL2.

| DisCH1   | Meaning                                                                                                         |
|----------|-----------------------------------------------------------------------------------------------------------------|
| 0b0      | The Contiguous bit of Block or Page descriptors of the Start Table for TTBR1_EL2 is not affected by this field. |
| 0b1      | The Contiguous bit of Block or Page descriptors of the Start Table for TTBR1_EL2 is treated as 0.               |

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

DisCH0, bit [14]

| A2   | Meaning                       |
|------|-------------------------------|
| 0b0  | Use of two ASIDs is disabled. |
| 0b1  | Use of two ASIDs is enabled.  |

## When FEAT\_D128 is implemented and TCR2\_EL2.D128 == '1':

Disable the Contiguous bit for the Start Table for TTBR0\_EL2.

| DisCH0   | Meaning                                                                                                         |
|----------|-----------------------------------------------------------------------------------------------------------------|
| 0b0      | The Contiguous bit of Block or Page descriptors of the Start Table for TTBR0_EL2 is not affected by this field. |
| 0b1      | The Contiguous bit of Block or Page descriptors of the Start Table for TTBR0_EL2 is treated as 0.               |

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## AMEC1, bit [13]

## When FEAT\_MEC is implemented:

This field controls the enabling of the Alternate MECID translations for accesses in the TTBR1\_EL2 half of the VA range, for the EL2&amp;0 translation regime.

TCR2\_EL2.AMEC1 is provided to enable the safe update of MECID\_A1\_EL2, by disabling access and speculation to AMEC == 1 Block or Page descriptors during the update.

| AMEC1   | Meaning                                                                                                                       |
|---------|-------------------------------------------------------------------------------------------------------------------------------|
| 0b0     | Use of a Block or Page descriptor containing AMEC==1generates a Translation fault.                                            |
| 0b1     | Accesses translated by a Block or Page descriptor containing AMEC==1are associated with the MECID configured in MECID_A1_EL2. |

This bit is permitted to be cached in a TLB only if it is 1.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

When SCTLR2\_EL2.EMEC is 0, this field is ignored by the PE and the bit position of AMEC is RES0 in Block and Page descriptors.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

Accessing this field has the following behavior:

- When IsCurrentSecurityState(SS\_Secure), access to this field is RES0.
- When IsCurrentSecurityState(SS\_NonSecure), access to this field is RES0.

## Otherwise:

Reserved, RES0.

## AMEC0, bit [12]

## When FEAT\_MEC is implemented:

This field controls the enabling of the Alternate MECID translations for accesses in the TTBR0\_EL2 half of the VA range, for the EL2&amp;0 translation regime.

TCR2\_EL2.AMEC0 is provided to enable the safe update of MECID\_A0\_EL2, by disabling access and speculation to AMEC==1 Block or Page descriptors during the update.

| AMEC0   | Meaning                                                                                                                       |
|---------|-------------------------------------------------------------------------------------------------------------------------------|
| 0b0     | Use of a Block or Page descriptor containing AMEC==1generates a Translation fault.                                            |
| 0b1     | Accesses translated by a Block or Page descriptor containing AMEC==1are associated with the MECID configured in MECID_A0_EL2. |

This bit is permitted to be cached in a TLB only if it is 1.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

When SCTLR2\_EL2.EMEC is 0, this field is ignored by the PE and the bit position of AMEC is RES0 in Block and Page descriptors.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

Accessing this field has the following behavior:

- When IsCurrentSecurityState(SS\_Secure), access to this field is RES0.
- When IsCurrentSecurityState(SS\_NonSecure), access to this field is RES0.

## Otherwise:

Reserved, RES0.

## HAFT, bit [11]

## When FEAT\_HAFT is implemented:

Hardware managed Access Flag for Table descriptors.

Enables the Hardware managed Access Flag for Table descriptors.

| HAFT   | Meaning                                                         |
|--------|-----------------------------------------------------------------|
| 0b0    | Hardware managed Access Flag for Table descriptors is disabled. |
| 0b1    | Hardware managed Access Flag for Table descriptors is enabled.  |

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## PTTWI, bit [10]

## When FEAT\_THE is implemented:

Permit Translation table walk Incoherence.

Permits RCWS instructions to generate writes that have the Reduced Coherence property.

| PTTWI   | Meaning                                                                    |
|---------|----------------------------------------------------------------------------|
| 0b0     | Write accesses generated by RCWSdonot have the Reduced Coherence property. |
| 0b1     | Write accesses generated by RCWShave the Reduced Coherence property.       |

This bit is permitted to be implemented as a read-only bit with a fixed value of 0.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## Bits [9:6]

Reserved, RES0.

## D128, bit [5]

## When FEAT\_D128 is implemented:

Enables VMSAv9-128 translation system.

| D128   | Meaning                                                    |
|--------|------------------------------------------------------------|
| 0b0    | Translation system follows VMSAv8-64 translation process.  |
| 0b1    | Translation system follows VMSAv9-128 translation process. |

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## AIE, bit [4]

## When FEAT\_AIE is implemented:

Enable Attribute Indexing Extension.

| AIE   | Meaning                                |
|-------|----------------------------------------|
| 0b0   | Attribute Indexing Extension Disabled. |
| 0b1   | Attribute Indexing Extension Enabled.  |

This field is RES1 when TCR2\_EL2.D128 is 1.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

POE, bit [3]

## When FEAT\_S1POE is implemented:

Enables Permission Overlay for privileged accesses from EL2&amp;0 translation regime.

| POE   | Meaning                                                                            |
|-------|------------------------------------------------------------------------------------|
| 0b0   | Permission overlay disabled for EL2 access in stage 1 of EL2&0 translation regime. |
| 0b1   | Permission overlay enabled for EL2 access in stage 1 of EL2&0 translation regime.  |

This bit is not permitted to be cached in a TLB.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

E0POE, bit [2]

## When FEAT\_S1POE is implemented:

Enables Permission Overlay for unprivileged accesses from EL2&amp;0 translation regime.

| E0POE   | Meaning                                                                            |
|---------|------------------------------------------------------------------------------------|
| 0b0     | Permission overlay disabled for EL0 access in stage 1 of EL2&0 translation regime. |
| 0b1     | Permission overlay enabled for EL0 access in stage 1 of EL2&0 translation regime.  |

This bit is not permitted to be cached in a TLB.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## PIE, bit [1]

## When FEAT\_S1PIE is implemented:

Enables usage of Indirect Permission Scheme.

This field is RES1 when TCR2\_EL2.D128 is 1.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## PnCH, bit [0]

## When FEAT\_THE is implemented:

Protected attribute enable. Enables use of bit[52] of stage 1 translation table entries as the Protected bit, for translations using TTBRn\_EL2 when HCR\_EL2.E2H is 1.

| PnCH   | Meaning                                                                                                     |
|--------|-------------------------------------------------------------------------------------------------------------|
| 0b0    | For translations using TTBRn_EL2, bit[52] of each stage 1 translation table entry is not the Protected bit. |
| 0b1    | For translations using TTBR0_EL2, bit[52] of each stage 1 translation table entry is the Protected bit.     |

If bit[52] is used as the Protected bit, it is not used as the Contiguous bit.

This field is RES0 when TCR2\_EL2.D128 is 1.

When EL3 is implemented and SCR\_EL3.TCR2En == 0, this field is ignored by the PE and treated as zero.

The reset behavior of this field is:

| PIE   | Meaning                    |
|-------|----------------------------|
| 0b0   | Direct permission model.   |
| 0b1   | Indirect permission model. |

- On a Warm reset:
- When the highest implemented Exception level is EL2, this field resets to '0' .
- Otherwise, this field resets to an architecturally UNKNOWN value.

## Otherwise:

Reserved, RES0.

## Accessing TCR2\_EL2

When the Effective value of HCR\_EL2.E2H is 1, without explicit synchronization, accesses from EL2 using the accessor name TCR2\_EL2 or TCR2\_EL1 are not guaranteed to be ordered with respect to accesses using the other accessor name.

If FEAT\_SRMASK is implemented, accesses to TCR2\_EL2 are masked by TCR2MASK\_EL2.

Accesses to this register use the following encodings in the System register encoding space:

<!-- formula-not-decoded -->

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b100 | 0b0010 | 0b0000 | 0b011 |

```
if !(IsFeatureImplemented(FEAT_TCR2) && IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EffectiveHCR_EL2_NVx() IN {'xx1'} then AArch64.SystemAccessTrap(EL2, 0x18); else UNDEFINED; elsif PSTATE.EL == EL2 then if HaveEL(EL3) && EL3SDDUndefPriority() && SCR_EL3.TCR2En == '0' then UNDEFINED; elsif HaveEL(EL3) && SCR_EL3.TCR2En == '0' then if EL3SDDUndef() then UNDEFINED; else AArch64.SystemAccessTrap(EL3, 0x18); else if IsFeatureImplemented(FEAT_SRMASK) then TCR2_EL2 = (X[t, 64] AND NOT EffectiveTCR2MASK_EL2()) OR (TCR2_EL2 AND ↪ → EffectiveTCR2MASK_EL2()); else TCR2_EL2 = X[t, 64]; elsif PSTATE.EL == EL3 then TCR2_EL2 = X[t, 64];
```

<!-- formula-not-decoded -->

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b000 | 0b0010 | 0b0000 | 0b011 |

```
if !(IsFeatureImplemented(FEAT_TCR2) && IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if HaveEL(EL3) && EL3SDDUndefPriority() && SCR_EL3.TCR2En == '0' then UNDEFINED; elsif EL2Enabled() && HCR_EL2.TRVM == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGRTR_EL2.TCR_EL1 == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && (!IsHCRXEL2Enabled() || HCRX_EL2.TCR2En == '0') then AArch64.SystemAccessTrap(EL2, 0x18); elsif HaveEL(EL3) && SCR_EL3.TCR2En == '0' then if EL3SDDUndef() then UNDEFINED; else AArch64.SystemAccessTrap(EL3, 0x18); elsif EffectiveHCR_EL2_NVx() IN {'111'} then X[t, 64] = NVMem[0x270]; else X[t, 64] = TCR2_EL1; elsif PSTATE.EL == EL2 then if HaveEL(EL3) && EL3SDDUndefPriority() && SCR_EL3.TCR2En == '0' then UNDEFINED; elsif HaveEL(EL3) && SCR_EL3.TCR2En == '0' then if EL3SDDUndef() then UNDEFINED; else AArch64.SystemAccessTrap(EL3, 0x18); elsif ELIsInHost(EL2) then X[t, 64] = TCR2_EL2; else X[t, 64] = TCR2_EL1; elsif PSTATE.EL == EL3 then X[t, 64] = TCR2_EL1;
```

MSR TCR2\_EL1, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b000 | 0b0010 | 0b0000 | 0b011 |

```
if !(IsFeatureImplemented(FEAT_TCR2) && IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if HaveEL(EL3) && EL3SDDUndefPriority() && SCR_EL3.TCR2En == '0' then UNDEFINED; elsif EL2Enabled() && HCR_EL2.TVM == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGWTR_EL2.TCR_EL1 == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && (!IsHCRXEL2Enabled() || HCRX_EL2.TCR2En == '0') then AArch64.SystemAccessTrap(EL2, 0x18); elsif HaveEL(EL3) && SCR_EL3.TCR2En == '0' then if EL3SDDUndef() then
```

```
UNDEFINED; else AArch64.SystemAccessTrap(EL3, 0x18); elsif EffectiveHCR_EL2_NVx() IN {'111'} then NVMem[0x270] = X[t, 64]; else if IsFeatureImplemented(FEAT_SRMASK) then TCR2_EL1 = (X[t, 64] AND NOT EffectiveTCR2MASK_EL1()) OR (TCR2_EL1 AND ↪ → EffectiveTCR2MASK_EL1()); else TCR2_EL1 = X[t, 64]; elsif PSTATE.EL == EL2 then if HaveEL(EL3) && EL3SDDUndefPriority() && SCR_EL3.TCR2En == '0' then UNDEFINED; elsif HaveEL(EL3) && SCR_EL3.TCR2En == '0' then if EL3SDDUndef() then UNDEFINED; else AArch64.SystemAccessTrap(EL3, 0x18); elsif ELIsInHost(EL2) then if IsFeatureImplemented(FEAT_SRMASK) then TCR2_EL2 = (X[t, 64] AND NOT EffectiveTCR2MASK_EL2()) OR (TCR2_EL2 AND ↪ → EffectiveTCR2MASK_EL2()); else TCR2_EL2 = X[t, 64]; else TCR2_EL1 = X[t, 64]; elsif PSTATE.EL == EL3 then TCR2_EL1 = X[t, 64];
```

When FEAT\_VHE is implemented MRS &lt;Xt&gt;, TCR2\_EL2

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b100 | 0b0010 | 0b0000 | 0b011 |

```
if !(IsFeatureImplemented(FEAT_TCR2) && IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EffectiveHCR_EL2_NVx() IN {'xx1'} then AArch64.SystemAccessTrap(EL2, 0x18); else UNDEFINED; elsif PSTATE.EL == EL2 then if HaveEL(EL3) && EL3SDDUndefPriority() && SCR_EL3.TCR2En == '0' then UNDEFINED; elsif HaveEL(EL3) && SCR_EL3.TCR2En == '0' then if EL3SDDUndef() then UNDEFINED; else AArch64.SystemAccessTrap(EL3, 0x18); else X[t, 64] = TCR2_EL2; elsif PSTATE.EL == EL3 then X[t, 64] = TCR2_EL2;
```