## C8.2.521 PRFD (scalar plus vector)

Gather prefetch doublewords (scalar plus vector)

This instruction performs a gather prefetch of doublewords from the active memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign-extended or zero-extended from 32 to 64 bits and then multiplied by 8. Inactive addresses are not prefetched from memory.

The &lt;prfop&gt; operand specifies the prefetch hint as follows:

- Access type:
- PLD for prefetch for load.
- PST for prefetch for store.
- Target cache level:
- L1 for Level 1 cache.
- L2 for Level 2 cache.
- L3 for Level 3 cache.
- Policy:
- KEEP for retained or temporal prefetch, allocated in the cache normally.
- STRMfor streaming or non-temporal prefetch, for data that is used only once.

This instruction is illegal when executed in Streaming SVE mode, unless FEAT\_SME\_FA64 is implemented and enabled.

It has encodings from 3 classes: 32-bit scaled offset, 32-bit unpacked scaled offset, and 64-bit scaled offset

```
32-bit scaled offset (FEAT_SVE)
```

<!-- image -->

## Encoding

```
PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) then EndOfDecode(Decode_UNDEF); constant integer esize = 32; constant integer g = UInt(Pg); constant integer n = UInt(Rn); constant integer m = UInt(Zm); constant integer level = UInt(prfop<2:1>); constant boolean stream = (prfop<0> == '1'); constant PrefetchHint pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE; constant integer offs_size = 32; constant boolean offs_unsigned = (xs == '0'); constant integer scale = 3;
```

## 32-bit unpacked scaled offset

(FEAT\_SVE)

<!-- image -->

## Encoding

```
PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) then EndOfDecode(Decode_UNDEF); constant integer esize = 64; constant integer g = UInt(Pg); constant integer n = UInt(Rn); constant integer m = UInt(Zm); constant integer level = UInt(prfop<2:1>); constant boolean stream = (prfop<0> == '1'); constant PrefetchHint pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE; constant integer offs_size = 32; constant boolean offs_unsigned = (xs == '0'); constant integer scale = 3;
```

## 64-bit scaled offset

(FEAT\_SVE)

<!-- image -->

## Encoding

```
PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) then EndOfDecode(Decode_UNDEF); constant integer esize = 64; constant integer g = UInt(Pg); constant integer n = UInt(Rn); constant integer m = UInt(Zm); constant integer level = UInt(prfop<2:1>); constant boolean stream = (prfop<0> == '1'); constant PrefetchHint pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE; constant integer offs_size = 64; constant boolean offs_unsigned = TRUE; constant integer scale = 3;
```

msz

## Assembler Symbols

## &lt;prfop&gt;

Is the prefetch operation specifier, encoded in 'prfop':

| prfop   | <prfop>   |
|---------|-----------|
| 0000    | PLDL1KEEP |
| 0001    | PLDL1STRM |
| 0010    | PLDL2KEEP |
| 0011    | PLDL2STRM |
| 0100    | PLDL3KEEP |
| 0101    | PLDL3STRM |
| x11x    | #uimm4    |
| 1000    | PSTL1KEEP |
| 1001    | PSTL1STRM |
| 1010    | PSTL2KEEP |
| 1011    | PSTL2STRM |
| 1100    | PSTL3KEEP |
| 1101    | PSTL3STRM |

Is the name of the governing scalable predicate register P0-P7, encoded in the 'Pg' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Zm&gt;

Is the name of the offset scalable vector register, encoded in the 'Zm' field.

## &lt;mod&gt;

Is the index extend and shift specifier, encoded in 'xs':

|   xs | <mod>   |
|------|---------|
|    0 | UXTW    |
|    1 | SXTW    |

## &lt;Pg&gt;

## Operation

```
CheckNonStreamingSVEEnabled(); constant integer VL = CurrentVL; constant integer PL = VL DIV 8; constant integer elements = VL DIV esize; constant bits(PL) mask = P[g, PL]; bits(64) base; bits(VL) offset;
```

```
if AnyActiveElement(mask, esize) then base = if n == 31 then SP[64] else X[n, 64]; offset = Z[m, VL]; for e = 0 to elements-1 if ActivePredicateElement(mask, e, esize) then constant bits(offs_size) offselt = Elem[offset, e, esize]<offs_size-1:0>; constant integer off = if offs_unsigned then UInt(offselt) else SInt(offselt); constant bits(64) addr = base + (off << scale); Hint_Prefetch(addr, pref_hint, level, stream);
```