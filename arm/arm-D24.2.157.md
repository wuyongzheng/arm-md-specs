## D24.2.157 RGSR\_EL1, Random Allocation Tag Seed Register.

The RGSR\_EL1 characteristics are:

## Purpose

Random Allocation Tag Seed Register.

## Configuration

When GCR\_EL1.RRND== 0b1 , updates to RGSR\_EL1 are implementation-specific.

Direct and indirect reads and writes to the register appear to occur in program order relative to other instructions, without the need for any explicit synchronization.

This register is present only when FEAT\_MTE2 is implemented. Otherwise, direct accesses to RGSR\_EL1 are UNDEFINED.

## Attributes

RGSR\_EL1 is a 64-bit register.

## Field descriptions

When GCR\_EL1.RRND == '0':

<!-- image -->

## Bits [63:24]

Reserved, RES0.

## SEED, bits [23:8]

Seed register used for generating values returned by RandomTag().

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Bits [7:4]

Reserved, RES0.

## TAG, bits [3:0]

Tag generated by the most recent IRG instruction.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Otherwise:

<!-- image -->

## Bits [63:56]

Reserved, RES0.

## IMPLEMENTATIONDEFINED, bits [55:8]

IMPLEMENTATION DEFINED.

<!-- image -->

Note

Software is recommended to avoid writing SEED[15:0] with a value of zero, unless this has been generated by the PE in response to an earlier value with SEED being nonzero.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Bits [7:4]

Reserved, RES0.

## TAG, bits [3:0]

IMPLEMENTATION DEFINED.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## Accessing RGSR\_EL1

Accesses to this register use the following encodings in the System register encoding space:

```
MRS <Xt>, RGSR_EL1
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b000 | 0b0001 | 0b0000 | 0b101 |

```
if !IsFeatureImplemented(FEAT_MTE2) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if HaveEL(EL3) && EL3SDDUndefPriority() && !(IsFeatureImplemented(FEAT_MTE2) && SCR_EL3.ATA == '1') ↪ → then UNDEFINED; elsif EL2Enabled() && !ELIsInHost(EL0) && !(IsFeatureImplemented(FEAT_MTE2) && HCR_EL2.ATA == '1') ↪ → then AArch64.SystemAccessTrap(EL2, 0x18); elsif HaveEL(EL3) && !(IsFeatureImplemented(FEAT_MTE2) && SCR_EL3.ATA == '1') then
```

```
if EL3SDDUndef() then UNDEFINED; else AArch64.SystemAccessTrap(EL3, 0x18); else X[t, 64] = RGSR_EL1; elsif PSTATE.EL == EL2 then if HaveEL(EL3) && EL3SDDUndefPriority() && !(IsFeatureImplemented(FEAT_MTE2) && SCR_EL3.ATA == '1') ↪ → then UNDEFINED; elsif HaveEL(EL3) && !(IsFeatureImplemented(FEAT_MTE2) && SCR_EL3.ATA == '1') then if EL3SDDUndef() then UNDEFINED; else AArch64.SystemAccessTrap(EL3, 0x18); else X[t, 64] = RGSR_EL1; elsif PSTATE.EL == EL3 then X[t, 64] = RGSR_EL1;
```

MSR RGSR\_EL1, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b11  | 0b000 | 0b0001 | 0b0000 | 0b101 |

```
if !IsFeatureImplemented(FEAT_MTE2) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if HaveEL(EL3) && EL3SDDUndefPriority() && !(IsFeatureImplemented(FEAT_MTE2) && SCR_EL3.ATA == '1') ↪ → then UNDEFINED; elsif EL2Enabled() && !ELIsInHost(EL0) && !(IsFeatureImplemented(FEAT_MTE2) && HCR_EL2.ATA == '1') ↪ → then AArch64.SystemAccessTrap(EL2, 0x18); elsif HaveEL(EL3) && !(IsFeatureImplemented(FEAT_MTE2) && SCR_EL3.ATA == '1') then if EL3SDDUndef() then UNDEFINED; else AArch64.SystemAccessTrap(EL3, 0x18); else RGSR_EL1 = X[t, 64]; elsif PSTATE.EL == EL2 then if HaveEL(EL3) && EL3SDDUndefPriority() && !(IsFeatureImplemented(FEAT_MTE2) && SCR_EL3.ATA == '1') ↪ → then UNDEFINED; elsif HaveEL(EL3) && !(IsFeatureImplemented(FEAT_MTE2) && SCR_EL3.ATA == '1') then if EL3SDDUndef() then UNDEFINED; else AArch64.SystemAccessTrap(EL3, 0x18); else RGSR_EL1 = X[t, 64]; elsif PSTATE.EL == EL3 then RGSR_EL1 = X[t, 64];
```