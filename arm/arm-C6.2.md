## C6.2 Alphabetical list of A64 base instructions

This section lists every instruction in the base category of the A64 instruction set. For details of the format used, see Understanding the A64 instruction descriptions.

## C6.2.1 ABS

Absolute value

This instruction computes the absolute value of the signed integer value in the source register, and writes the result to the destination register.

## Integer

(FEAT\_CSSC)

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
ABS <Wd>, <Wn>
```

## Encoding for the 64-bit variant

Applies when (sf == 1)

```
ABS <Xd>, <Xn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CSSC) then constant integer datasize = 32 << UInt(sf); constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand1 = constant integer result = Abs(SInt(operand1)); X[d, datasize] = result<datasize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

```
X[n, datasize];
```

## C6.2.2 ADC

## Add with carry

This instruction adds two register values and the Carry flag value, and writes the result to the destination register.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
ADC
```

```
0) <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

Applies when (sf == 1)

```
ADC
```

```
<Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = X[m, datasize]; bits(datasize) result; (result, -) = AddWithCarry(operand1, operand2, PSTATE.C); X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.3 ADCS

Add with carry, setting flags

This instruction adds two register values and the Carry flag value, and writes the result to the destination register. It updates the condition flags based on the result.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
ADCS <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

Applies when (sf == 1)

```
ADCS
```

```
<Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = X[m, datasize]; bits(datasize) result; bits(4) nzcv; (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C); X[d, datasize] = result; PSTATE.<N,Z,C,V> = nzcv;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.4 ADD (extended register)

Add extended and scaled register

This instruction adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0)
```

```
ADD <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend>
```

```
{#<amount>}}
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) ADD <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}
```

## Decode for all variants of this encoding

```
if imm3 IN {'101', '110', '111'} then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer shift = UInt(imm3); constant integer datasize = 32 << UInt(sf); constant ExtendType extend_type = DecodeRegExtend(option);
```

## Assembler Symbols

## &lt;Wd|WSP&gt;

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Wn|WSP&gt;

Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;extend&gt;

For the '32-bit' variant: is the extension to be applied to the second source operand, encoded in 'option':

|   option | <extend>   |
|----------|------------|
|      000 | UXTB       |
|      001 | UXTH       |

Is a width specifier, encoded in 'option':

|   option | <extend>      |
|----------|---------------|
|      010 | LSL&#124;UXTW |
|      011 | UXTX          |
|      100 | SXTB          |
|      101 | SXTH          |
|      110 | SXTW          |
|      111 | SXTX          |

If 'Rd' or 'Rn' is '11111' (WSP) and 'option' is '010' then LSL is preferred, but may be omitted when 'imm3' is '000'. In all other cases &lt;extend&gt; is required and must be UXTW when 'option' is '010'.

For the '64-bit' variant: is the extension to be applied to the second source operand, encoded in 'option':

|   option | <extend>      |
|----------|---------------|
|      000 | UXTB          |
|      001 | UXTH          |
|      010 | UXTW          |
|      011 | LSL&#124;UXTX |
|      100 | SXTB          |
|      101 | SXTH          |
|      110 | SXTW          |
|      111 | SXTX          |

If 'Rd' or 'Rn' is '11111' (SP) and 'option' is '011' then LSL is preferred, but may be omitted when 'imm3' is '000'. In all other cases &lt;extend&gt; is required and must be UXTX when 'option' is '011'.

## &lt;amount&gt;

Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the 'imm3' field. It must be absent when &lt;extend&gt; is absent, is required when &lt;extend&gt; is LSL, and is optional when &lt;extend&gt; is present but not LSL.

## &lt;Xd|SP&gt;

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

| option   | <R>   |
|----------|-------|
| 00x      | W     |

&lt;m&gt;

Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the 'Rm' field.

## Operation

```
constant bits(datasize) operand1 = if n == 31 then SP[datasize] else X[n, datasize]; constant bits(datasize) operand2 = ExtendReg(m, extend_type, shift, datasize); bits(datasize) result; (result, -) = AddWithCarry(operand1, operand2, '0'); if d == 31 then SP[64] = ZeroExtend(result, 64); else X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| option   | <R>   |
|----------|-------|
| 010      | W     |
| x11      | X     |
| 10x      | W     |
| 110      | W     |

## C6.2.5 ADD (immediate)

Add immediate value

This instruction adds a register value and an optionally-shifted immediate value, and writes the result to the destination register.

This instruction is used by the alias MOV (to/from SP).

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0)
```

```
ADD
```

```
<Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
ADD <Xd|SP>, <Xn|SP>, #<imm>{,
```

```
1) <shift>}
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant bits(24) imm = if sh == '0' then Zeros(12):imm12
```

## Assembler Symbols

## &lt;Wd|WSP&gt;

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Wn|WSP&gt;

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is an unsigned immediate, in the range 0 to 4095, encoded in the 'imm12' field.

## &lt;shift&gt;

Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in 'sh':

|   sh | <shift>   |
|------|-----------|
|    0 | LSL #0    |
|    1 | LSL #12   |

```
else imm12:Zeros(12);
```

## &lt;Xd|SP&gt;

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

```
Alias Is preferred when
```

```
MOV (to/from SP) sh == '0' && imm12 == '000000000000' && (Rd == '11111' || Rn == '11111')
```

## Operation

```
constant bits(datasize) operand1 = if n == 31 then SP[datasize] else X[n, datasize]; constant bits(datasize) operand2 = ZeroExtend(imm, datasize); bits(datasize) result; (result, -) = AddWithCarry(operand1, operand2, '0'); if d == 31 then SP[64] = ZeroExtend(result, 64); else X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.6 ADD (shifted register)

Add optionally-shifted register

This instruction adds a register value and an optionally-shifted register value, and writes the result to the destination register.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) ADD <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
ADD <Xd>, <Xn>, <Xm>{, <shift>
```

```
1) #<amount>}
```

## Decode for all variants of this encoding

```
if shift == '11' then EndOfDecode(Decode_UNDEF); if sf == '0' && imm6<5> == '1' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type = DecodeShift(shift); constant integer shift_amount = UInt(imm6);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded in 'shift':

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

&lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount, datasize); bits(datasize) result; (result, -) = AddWithCarry(operand1, operand2, '0'); X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   shift | <shift>   |
|---------|-----------|
|      01 | LSR       |
|      10 | ASR       |
|      11 | RESERVED  |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.7 ADDG

Add with tag

This instruction adds an immediate value scaled by the Tag Granule to the address in the source register, modifies the Logical Address Tag of the address using an immediate value, and writes the result to the destination register. Tags specified in GCR\_EL1.Exclude are excluded from the possible outputs when modifying the Logical Address Tag.

## Integer

(FEAT\_MTE)

<!-- image -->

## Encoding

```
ADDG <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant bits(4) tag_offset = imm4; constant bits(64) offset = LSL(ZeroExtend(imm6, 64),
```

## Assembler Symbols

## &lt;Xd|SP&gt;

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;uimm6&gt;

Is an unsigned immediate, a multiple of 16 in the range 0 to 1008, encoded in the 'imm6' field.

## &lt;uimm4&gt;

Is an unsigned immediate, in the range 0 to 15, encoded in the 'imm4' field.

## Operation

```
constant bits(64) operand1 = if n == 31 then SP[64] else X[n, 64]; constant bits(4) start_tag = AArch64.AllocationTagFromAddress(operand1); constant bits(16) exclude = GCR_EL1.Exclude; constant bits(4) rtag = AArch64.ChooseNonExcludedTagOrZero(start_tag, tag_offset, exclude); bits(64) result; (result, -) = AddWithCarry(operand1, offset, '0'); result = AArch64.AddressWithAllocationTag(result, rtag); if d == 31 then SP[64] = result; else X[d, 64] = result;
```

```
LOG2_TAG_GRANULE);
```

## C6.2.8 ADDPT

## Add checked pointer

This instruction adds a base address register value and an optionally-shifted register value, and writes the result to the destination register. The optionally-shifted register value is treated as the offset.

If the operation would have generated a result where the most significant 8 bits of the result register differ from the most significant 8 bits of the base register, then the result is modified such that it is likely to be non-canonical when used as an address.

## Integer

(FEAT\_CPA)

<!-- image -->

## Encoding

```
ADDPT <Xd|SP>, <Xn|SP>, <Xm>{, LSL #<amount>}
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_CPA) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer shift = UInt(imm3);
```

## Assembler Symbols

## &lt;Xd|SP&gt;

Is the 64-bit name of the general-purpose destination register or stack pointer, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the first general-purpose source register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;amount&gt;

Is the left shift amount, in the range 0 to 7, defaulting to 0, encoded in the 'imm3' field.

## Operation

```
bits(64) result; constant bits(64) base = if n == 31 then SP[64] else X[n, 64]; constant bits(64) offset = LSL(X[m, 64], shift); result = base + offset; result = PointerAddCheck(result, base); if d == 31 then SP[64] = result; else X[d, 64] = result;
```

## C6.2.9 ADDS (extended register)

Add extended and scaled register, setting flags

This instruction adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result.

This instruction is used by the alias CMN (extended register).

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
ADDS <Wd>, <Wn|WSP>, <Wm>{, <extend>
```

```
0) {#<amount>}}
```

## Encoding for the 64-bit variant

Applies when

```
(sf == 1) ADDS <Xd>, <Xn|SP>, <R><m>{, <extend>
```

## Decode for all variants of this encoding

```
if imm3 IN {'101', '110', '111'} then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer shift = UInt(imm3); constant integer datasize = 32 << UInt(sf); constant ExtendType extend_type = DecodeRegExtend(option);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn|WSP&gt;

Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;extend&gt;

For the '32-bit' variant: is the extension to be applied to the second source operand, encoded in 'option':

|   option | <extend>   |
|----------|------------|
|      000 | UXTB       |

```
{#<amount>}}
```

Is a width specifier, encoded in 'option':

|   option | <extend>      |
|----------|---------------|
|      001 | UXTH          |
|      010 | LSL&#124;UXTW |
|      011 | UXTX          |
|      100 | SXTB          |
|      101 | SXTH          |
|      110 | SXTW          |
|      111 | SXTX          |

If 'Rn' is '11111' (WSP) and 'option' is '010' then LSL is preferred, but may be omitted when 'imm3' is '000'. In all other cases &lt;extend&gt; is required and must be UXTW when 'option' is '010'.

For the '64-bit' variant: is the extension to be applied to the second source operand, encoded in 'option':

|   option | <extend>      |
|----------|---------------|
|      000 | UXTB          |
|      001 | UXTH          |
|      010 | UXTW          |
|      011 | LSL&#124;UXTX |
|      100 | SXTB          |
|      101 | SXTH          |
|      110 | SXTW          |
|      111 | SXTX          |

If 'Rn' is '11111' (SP) and 'option' is '011' then LSL is preferred, but may be omitted when 'imm3' is '000'. In all other cases &lt;extend&gt; is required and must be UXTX when 'option' is '011'.

## &lt;amount&gt;

Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the 'imm3' field. It must be absent when &lt;extend&gt; is absent, is required when &lt;extend&gt; is LSL, and is optional when &lt;extend&gt; is present but not LSL.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;R&gt;

&lt;m&gt;

Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the 'Rm' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = if n == 31 then SP[datasize] else X[n, datasize]; constant bits(datasize) operand2 = ExtendReg(m, extend_type, shift, datasize); bits(datasize) result; bits(4) nzcv; (result, nzcv) = AddWithCarry(operand1, operand2, '0'); X[d, datasize] = result; PSTATE.<N,Z,C,V> = nzcv;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| option   | <R>   |
|----------|-------|
| 00x      | W     |
| 010      | W     |
| x11      | X     |
| 10x      | W     |
| 110      | W     |

| Alias                   | Is preferred when   |
|-------------------------|---------------------|
| CMN (extended register) | Rd == '11111'       |

## C6.2.10 ADDS (immediate)

Add immediate value, setting flags

This instruction adds a register value and an optionally-shifted immediate value, and writes the result to the destination register. It updates the condition flags based on the result.

This instruction is used by the alias CMN (immediate).

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) ADDS
```

```
<Wd>, <Wn|WSP>, #<imm>{, <shift>}
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) ADDS <Xd>, <Xn|SP>, #<imm>{, <shift>}
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant bits(24) imm = if sh == '0' then Zeros(12):imm12
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn|WSP&gt;

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is an unsigned immediate, in the range 0 to 4095, encoded in the 'imm12' field.

## &lt;shift&gt;

Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in 'sh':

|   sh | <shift>   |
|------|-----------|
|    0 | LSL #0    |
|    1 | LSL #12   |

```
else imm12:Zeros(12);
```

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = if n == 31 then SP[datasize] else X[n, datasize]; constant bits(datasize) operand2 = ZeroExtend(imm, datasize); bits(datasize) result; bits(4) nzcv; (result, nzcv) = AddWithCarry(operand1, operand2, '0'); X[d, datasize] = result; PSTATE.<N,Z,C,V> = nzcv;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

CMN

(immediate)

## Is preferred when

Rd

==

'11111'

## C6.2.11 ADDS (shifted register)

Add optionally-shifted register, setting flags

This instruction adds a register value and an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.

This instruction is used by the alias CMN (shifted register).

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) ADDS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
ADDS <Xd>, <Xn>, <Xm>{, <shift>
```

```
1) #<amount>}
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if shift == '11' then EndOfDecode(Decode_UNDEF); if sf == '0' && imm6<5> == '1' then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type = DecodeShift(shift); constant integer shift_amount = UInt(imm6);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded in 'shift':

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount, datasize); bits(datasize) result; bits(4) nzcv; (result, nzcv) = AddWithCarry(operand1, operand2, '0'); X[d, datasize] = result; PSTATE.<N,Z,C,V> = nzcv;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |
|      10 | ASR       |
|      11 | RESERVED  |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Alias

## Is preferred when

CMN (shifted register) Rd == '11111'

## C6.2.12 ADR

Form PC-relative address

This instruction adds an immediate value to the PC value to form a PC-relative address, and writes the result to the destination register.

<!-- image -->

## Encoding

```
ADR <Xd>, <label>
```

## Decode for this encoding

```
constant integer d = UInt(Rd); constant bits(64) imm = SignExtend(immhi:immlo, 64);
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;label&gt;

Is the program label whose address is to be calculated. Its offset from the address of this instruction, in the range +/-1MB, is encoded in 'immhi:immlo'.

## Operation

```
X[d, 64] = PC64 + imm;
```

## C6.2.13 ADRP

Form PC-relative address to 4KB page

This instruction adds an immediate value that is shifted left by 12 bits, to the PC value to form a PC-relative address, with the bottom 12 bits masked out, and writes the result to the destination register.

<!-- image -->

## Encoding

```
ADRP <Xd>, <label>
```

## Decode for this encoding

```
constant integer d = UInt(Rd); constant bits(64) imm =
```

```
SignExtend(immhi:immlo:Zeros(12), 64);
```

## Assembler Symbols

&lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;label&gt;

Is the program label whose 4KB page address is to be calculated. Its offset from the page address of this instruction, in the range +/-4GB, is encoded as 'immhi:immlo' times 4096.

## Operation

```
constant bits(64) base X[d, 64] = base + imm;
```

```
= PC64<63:12>:Zeros(12);
```

## C6.2.14 AND (immediate)

Bitwise AND (immediate)

This instruction performs a bitwise AND of a register value and an immediate value, and writes the result to the destination register.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0)

```
AND <Wd|WSP>, <Wn>, #<imm>
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
1)
```

```
AND <Xd|SP>, <Xn>, #<imm>
```

## Decode for all variants of this encoding

```
if sf == '0' && N != '0' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); bits(datasize) imm; (imm, -) = DecodeBitMasks(N, imms, immr, TRUE, datasize);
```

## Assembler Symbols

## &lt;Wd|WSP&gt;

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;imm&gt;

For the '32-bit' variant: is the bitmask immediate, encoded in 'imms:immr'.

For the '64-bit' variant: is the bitmask immediate, encoded in 'N:imms:immr'.

## &lt;Xd|SP&gt;

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = imm; constant bits(datasize) result = operand1 AND if d == 31 then SP[64] = ZeroExtend(result, 64); else X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
operand2;
```

## C6.2.15 AND (shifted register)

Bitwise AND (shifted register)

This instruction performs a bitwise AND of a register value and an optionally-shifted register value, and writes the result to the destination register.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0) AND <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
AND <Xd>, <Xn>, <Xm>{, <shift>
```

```
1) #<amount>}
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if sf == '0' && imm6<5> == '1' then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type = DecodeShift(shift); constant integer shift_amount = UInt(imm6);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in 'shift':

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |
|      10 | ASR       |

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

&lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount, datasize); X[d, datasize] = operand1 AND operand2;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   shift | <shift>   |
|---------|-----------|
|      11 | ROR       |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.16 ANDS (immediate)

Bitwise AND (immediate), setting flags

This instruction performs a bitwise AND of a register value and an immediate value, and writes the result to the destination register. It updates the condition flags based on the result.

This instruction is used by the alias TST (immediate).

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0 && N ==
```

```
ANDS
```

```
0) <Wd>, <Wn>, #<imm>
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
1)
```

```
ANDS <Xd>, <Xn>, #<imm>
```

## Decode for all variants of this encoding

```
if sf == '0' && N != '0' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); bits(datasize) imm; (imm, -) = DecodeBitMasks(N, imms, immr, TRUE, datasize);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;imm&gt;

For the '32-bit' variant: is the bitmask immediate, encoded in 'imms:immr'.

For the '64-bit' variant: is the bitmask immediate, encoded in 'N:imms:immr'.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = imm; constant bits(datasize) result = operand1 AND operand2; X[d, datasize] = result; PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

TST (immediate)

## Is preferred when

Rd

==

'11111'

## C6.2.17 ANDS (shifted register)

Bitwise AND (shifted register), setting flags

This instruction performs a bitwise AND of a register value and an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.

This instruction is used by the alias TST (shifted register).

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) ANDS <Wd>, <Wn>, <Wm>{, <shift>
```

```
#<amount>}
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) ANDS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if sf == '0' && imm6<5> == '1' then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type = DecodeShift(shift); constant integer shift_amount = UInt(imm6);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in 'shift':

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount, datasize); constant bits(datasize) result = operand1 AND operand2; X[d, datasize] = result; PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   shift | <shift>   |
|---------|-----------|
|      10 | ASR       |
|      11 | ROR       |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

| Alias                  | Is preferred when   |
|------------------------|---------------------|
| TST (shifted register) | Rd == '11111'       |

## C6.2.18 APAS

Associate physical address space

This instruction associates a physical address space with a memory-mapped location that is protected by a memory-side physical address space filter.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_RME\_GPC3)

<!-- image -->

## Encoding

<!-- image -->

and is always the preferred disassembly.

## Assembler Symbols

&lt;Xt&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rt' field.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.19 ASR (register)

Arithmetic shift right (register)

This instruction shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The value of the second source register modulo the register size in bits gives the number of bits by which the first source register is right-shifted.

This is an alias of ASRV. This means:

- The encodings in this description are named to match the encodings of ASRV.
- The description of ASRV gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) ASR <Wd>, <Wn>, <Wm>
```

## is equivalent to

```
ASRV <Wd>, <Wn>, <Wm>
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (sf == 1) ASR <Xd>, <Xn>, <Xm>
```

## is equivalent to

```
ASRV <Xd>, <Xn>, <Xm>
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the 'Rm' field.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the 'Rm' field.

## Operation

The description of ASRV gives the operational pseudocode for this instruction.

## Operational Information

The description of ASRV gives the operational information for this instruction.

## C6.2.20 ASR (immediate)

Arithmetic shift right (immediate)

This instruction shifts a register value right by an immediate number of bits, shifting in copies of the sign bit in the upper bits and zeros in the lower bits, and writes the result to the destination register.

This is an alias of SBFM. This means:

- The encodings in this description are named to match the encodings of SBFM.
- The description of SBFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0 &amp;&amp; imms == 011111)

```
ASR <Wd>, <Wn>, #<shift>
```

## is equivalent to

```
SBFM <Wd>, <Wn>, #<shift>, #31
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (sf == 1 && N == 1 && imms == 111111) ASR <Xd>, <Xn>, #<shift>
```

## is equivalent to

```
SBFM <Xd>, <Xn>, #<shift>, #63
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, encoded in the 'immr' field.

For the '64-bit' variant: is the shift amount, in the range 0 to 63, encoded in the 'immr' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

## Operation

The description of SBFM gives the operational pseudocode for this instruction.

## Operational Information

The description of SBFM gives the operational information for this instruction.

## C6.2.21 ASRV

Arithmetic shift right variable

This instruction shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The value of the second source register modulo the register size in bits gives the number of bits by which the first source register is right-shifted.

This instruction is used by the alias ASR (register).

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
ASRV <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

Applies when 1)

```
(sf == ASRV <Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type =
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the 'Rm' field.

```
DecodeShift(op2);
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand2 = X[m, datasize]; X[d, datasize] = ShiftReg(n, shift_type, UInt(operand2) MOD datasize, datasize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias   | Is preferred when   |
|---------|---------------------|
| ASR     | Unconditionally     |

## C6.2.22 AT

## Address translate

For more information, see op0== 0b01 , cache maintenance, TLB maintenance, and address translation instructions.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

AT

&lt;at\_op&gt;,

&lt;Xt&gt;

## is equivalent to

```
SYS #<op1>, C7, <Cm>, #<op2>, <Xt>
```

and is the preferred disassembly when SysOp(op1, '0111', CRm, op2) == Sys\_AT .

## Assembler Symbols

## &lt;at\_op&gt;

Is an AT operation name, as listed for the AT system instruction group, encoded in 'op1:CRm:op2':

|   op1 |   CRm |   op2 | <at_op>   | Architectural Feature   |
|-------|-------|-------|-----------|-------------------------|
|   000 |  1000 |   000 | S1E1R     | -                       |
|   000 |  1000 |   001 | S1E1W     | -                       |
|   000 |  1000 |   010 | S1E0R     | -                       |
|   000 |  1000 |   011 | S1E0W     | -                       |
|   000 |  1001 |   000 | S1E1RP    | FEAT_PAN2               |
|   000 |  1001 |   001 | S1E1WP    | FEAT_PAN2               |
|   000 |  1001 |   010 | S1E1A     | FEAT_ATS1A              |
|   100 |  1000 |   000 | S1E2R     | -                       |
|   100 |  1000 |   001 | S1E2W     | -                       |
|   100 |  1000 |   100 | S12E1R    | -                       |
|   100 |  1000 |   101 | S12E1W    | -                       |
|   100 |  1000 |   110 | S12E0R    | -                       |
|   100 |  1000 |   111 | S12E0W    | -                       |
|   100 |  1001 |   010 | S1E2A     | FEAT_ATS1A              |
|   110 |  1000 |   000 | S1E3R     | -                       |

|   op1 |   CRm |   op2 | <at_op>   | Architectural Feature   |
|-------|-------|-------|-----------|-------------------------|
|   110 |  1000 |   001 | S1E3W     | -                       |
|   110 |  1001 |   010 | S1E3A     | FEAT_ATS1A              |

<!-- image -->

&lt;Xt&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rt' field.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.23 AUTDA, AUTDZA

Authenticate data address, using key A

This instruction authenticates a data address, using a modifier and key A.

The address is in the general-purpose register that is specified by &lt;Xd&gt; .

The modifier is:

- In the general-purpose register or stack pointer that is specified by &lt;Xn|SP&gt; , for AUTDA .
- The value zero, for AUTDZA .

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. For information on behavior if the authentication fails, see Faulting on pointer authentication.

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding for the AUTDA variant

```
Applies when (Z == 0) AUTDA <Xd>, <Xn|SP>
```

## Encoding for the AUTDZA variant

```
Applies when (Z == 1 && Rn == 11111)
```

```
AUTDZA <Xd>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then EndOfDecode(Decode_UNDEF); if Z == '1' && Rn != '11111' then EndOfDecode(Decode_UNDEF); constant boolean auth_combined = FALSE; constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant boolean source_is_sp = Z == '0' && n == 31;
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if source_is_sp then X[d, 64] = AuthDA(X[d, 64], SP[64], auth_combined); else X[d, 64] = AuthDA(X[d, 64], X[n, 64], auth_combined);
```

## C6.2.24 AUTDB, AUTDZB

Authenticate data address, using key B

This instruction authenticates a data address, using a modifier and key B.

The address is in the general-purpose register that is specified by &lt;Xd&gt; .

The modifier is:

- In the general-purpose register or stack pointer that is specified by &lt;Xn|SP&gt; for AUTDB .
- The value zero, for AUTDZB .

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. For information on behavior if the authentication fails, see Faulting on pointer authentication.

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding for the AUTDB variant

```
Applies when (Z == 0) AUTDB <Xd>, <Xn|SP>
```

## Encoding for the AUTDZB variant

```
Applies when (Z == 1 && Rn == 11111)
```

```
AUTDZB <Xd>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then EndOfDecode(Decode_UNDEF); if Z == '1' && Rn != '11111' then EndOfDecode(Decode_UNDEF); constant boolean auth_combined = FALSE; constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant boolean source_is_sp = Z == '0' && n == 31;
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if source_is_sp then X[d, 64] = AuthDB(X[d, 64], SP[64], auth_combined); else X[d, 64] = AuthDB(X[d, 64], X[n, 64], auth_combined);
```

## C6.2.25 AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIZA

Authenticate instruction address, using key A

This instruction authenticates an instruction address, using a modifier and key A.

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. For information on behavior if the authentication fails, see Faulting on pointer authentication.

## The address is:

- In the general-purpose register that is specified by &lt;Xd&gt; for AUTIA and AUTIZA .
- In X17, for AUTIA1716 .
- In X30, for AUTIASP and AUTIAZ .

## The modifier is:

- In the general-purpose register or stack pointer that is specified by &lt;Xn|SP&gt; for AUTIA .
- The value zero, for AUTIZA and AUTIAZ .
- In X16, for AUTIA1716 .
- In SP, for AUTIASP .

If FEAT\_PAuth\_LR is implemented and PSTATE.PACM is 1, then AUTIA1716 and AUTIASP include a second modifier that is:

- In X15, for AUTIA1716 .
- In X16, for AUTIASP .

It has encodings from 2 classes: Integer and System

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding for the AUTIA variant

Applies when (Z == 0)

```
AUTIA <Xd>, <Xn|SP>
```

## Encoding for the AUTIZA variant

```
Applies when (Z == 1 && Rn == 11111)
```

```
AUTIZA <Xd>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then EndOfDecode(Decode_UNDEF); if Z == '1' && Rn != '11111' then EndOfDecode(Decode_UNDEF); constant boolean autia1716 = FALSE; constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant boolean auth_combined = FALSE; constant boolean source_is_sp = Z == '0' && n == 31;
```

## System

(FEAT\_PAuth)

<!-- image -->

## Encoding for the AUTIA1716 variant

```
Applies when (CRm == 0001 && op2 == 100)
```

AUTIA1716

## Encoding for the AUTIASP variant

```
Applies when (CRm == 0011 && op2 == 101)
```

AUTIASP

## Encoding for the AUTIAZ variant

```
Applies when (CRm == 0011 && op2 == 100)
```

AUTIAZ

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then integer d; integer n; boolean source_is_sp = FALSE; boolean autia1716 = FALSE; constant boolean auth_combined = FALSE; case CRm:op2 of when '0011 100' // AUTIAZ d = 30; n = 31; when '0011 101' // AUTIASP d = 30; source_is_sp = TRUE; when '0001 100' // AUTIA1716 d = 17; n = 16; autia1716 = TRUE;
```

## Assembler Symbols

&lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the 'Rn' field.

```
EndOfDecode(Decode_NOP);
```

## Operation

```
if source_is_sp then if IsFeatureImplemented(FEAT_PAuth_LR) && PSTATE.PACM == '1' then X[d, 64] = AuthIA2(X[d, 64], SP[64], X[16, 64], auth_combined); else X[d, 64] = AuthIA(X[d, 64], SP[64], auth_combined); else if IsFeatureImplemented(FEAT_PAuth_LR) && PSTATE.PACM == '1' && autia1716 then X[d, 64] = AuthIA2(X[d, 64], X[n, 64], X[15, 64], auth_combined); else X[d, 64] = AuthIA(X[d, 64], X[n, 64], auth_combined);
```

## C6.2.26 AUTIA171615

Authenticate instruction address, using key A

This instruction authenticates an instruction address, using two modifiers and key A. The address is in X17. The 64-bit value of modifier1 is the value in X16. The 64-bit value of modifier2 is the value in X15.

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. For information on behavior if the authentication fails, see Faulting on pointer authentication.

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding

AUTIA171615

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_PAuth\_LR) then EndOfDecode(Decode\_UNDEF);

## Operation

```
constant boolean is_combined = FALSE; X[17, 64] = AuthIA2(X[17, 64], X[16, 64], X[15, 64], is_combined);
```

## C6.2.27 AUTIASPPC

Authenticate return address using key A, using an immediate offset

This instruction authenticates an instruction address, using two modifiers and key A.

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. For information on behavior if the authentication fails, see Faulting on pointer authentication.

The address is in X30.

The first modifier is in SP.

The second modifier is the address of a program label.

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding

```
AUTIASPPC <label>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_PAuth_LR) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = 30; constant bits(64) offset = ZeroExtend(imm16:'00', 64); constant boolean auth_combined = FALSE;
```

## Assembler Symbols

## &lt;label&gt;

Is the program label whose address is to be calculated. Its negative offset from the address of this instruction, a multiple of 4 in the range -262140 to 0, is encoded as an unsigned value in the 'imm16' field as &lt;label&gt;/4.

## Operation

```
constant bits(64) pac_addr = PC64 -offset; X[d, 64] = AuthIA2(X[d, 64], SP[64],
```

```
pac_addr, auth_combined);
```

## C6.2.28 AUTIASPPCR

Authenticate return address using key A, using a register

This instruction authenticates an instruction address, using two modifiers and key A.

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. For information on behavior if the authentication fails, see Faulting on pointer authentication.

The address is in X30.

The first modifier is in SP.

The second modifier is in the general-purpose register that is specified by &lt;Xn&gt; .

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding

AUTIASPPCR

&lt;Xn&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_PAuth_LR) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = 30; constant integer n = UInt(Rn); constant boolean auth_combined = FALSE;
```

## Assembler Symbols

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
X[d, 64] = AuthIA2(X[d, 64], SP[64], X[n, 64], auth_combined);
```

## C6.2.29 AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZB

Authenticate instruction address, using key B

This instruction authenticates an instruction address, using a modifier and key B.

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. For information on behavior if the authentication fails, see Faulting on pointer authentication.

## The address is:

- In the general-purpose register that is specified by &lt;Xd&gt; for AUTIB and AUTIZB .
- In X17, for AUTIB1716 .
- In X30, for AUTIBSP and AUTIBZ .

## The modifier is:

- In the general-purpose register or stack pointer that is specified by &lt;Xn|SP&gt; for AUTIB .
- The value zero, for AUTIZB and AUTIBZ .
- In X16, for AUTIB1716 .
- In SP, for AUTIBSP .

If FEAT\_PAuth\_LR is implemented and PSTATE.PACM is 1, then AUTIB1716 and AUTIBSP include a second modifier that is:

- In X15, for AUTIB1716 .
- In X16, for AUTIBSP .

It has encodings from 2 classes: Integer and System

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding for the AUTIB variant

Applies when (Z == 0)

```
AUTIB <Xd>, <Xn|SP>
```

## Encoding for the AUTIZB variant

```
Applies when (Z == 1 && Rn == 11111)
```

AUTIZB

&lt;Xd&gt;

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then EndOfDecode(Decode_UNDEF); if Z == '1' && Rn != '11111' then EndOfDecode(Decode_UNDEF); constant boolean autib1716 = FALSE; constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant boolean auth_combined = FALSE; constant boolean source_is_sp = Z == '0' && n == 31;
```

## System

(FEAT\_PAuth)

<!-- image -->

## Encoding for the AUTIB1716 variant

```
Applies when (CRm == 0001 && op2 == 110)
```

AUTIB1716

## Encoding for the AUTIBSP variant

```
Applies when (CRm == 0011 && op2 == 111)
```

AUTIBSP

## Encoding for the AUTIBZ variant

```
Applies when (CRm == 0011 && op2 == 110)
```

AUTIBZ

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then integer d; integer n; boolean source_is_sp = FALSE; boolean autib1716 = FALSE; constant boolean auth_combined = FALSE; case CRm:op2 of when '0011 110' // AUTIBZ d = 30; n = 31; when '0011 111' // AUTIBSP d = 30; source_is_sp = TRUE; when '0001 110' // AUTIB1716 d = 17; n = 16; autib1716 = TRUE;
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the 'Rn' field.

```
EndOfDecode(Decode_NOP);
```

## Operation

```
if source_is_sp then if IsFeatureImplemented(FEAT_PAuth_LR) && PSTATE.PACM == '1' then X[d, 64] = AuthIB2(X[d, 64], SP[64], X[16, 64], auth_combined); else X[d, 64] = AuthIB(X[d, 64], SP[64], auth_combined); else if IsFeatureImplemented(FEAT_PAuth_LR) && PSTATE.PACM == '1' && autib1716 then X[d, 64] = AuthIB2(X[d, 64], X[n, 64], X[15, 64], auth_combined); else X[d, 64] = AuthIB(X[d, 64], X[n, 64], auth_combined);
```

## C6.2.30 AUTIB171615

Authenticate instruction address, using key B

This instruction authenticates an instruction address, using two modifiers and key B. The address is in X17. The 64-bit value of modifier1 is the value in X16. The 64-bit value of modifier2 is the value in X15.

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. For information on behavior if the authentication fails, see Faulting on pointer authentication.

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding

AUTIB171615

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_PAuth\_LR) then EndOfDecode(Decode\_UNDEF);

## Operation

```
constant boolean is_combined = FALSE; X[17, 64] = AuthIB2(X[17, 64], X[16, 64], X[15, 64], is_combined);
```

## C6.2.31 AUTIBSPPC

Authenticate return address using key B, using an immediate offset

This instruction authenticates an instruction address, using two modifiers and key B.

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. For information on behavior if the authentication fails, see Faulting on pointer authentication.

The address is in X30.

The first modifier is in SP.

The second modifier is the address of a program label.

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding

```
AUTIBSPPC <label>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_PAuth_LR) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = 30; constant bits(64) offset = ZeroExtend(imm16:'00', 64); constant boolean auth_combined = FALSE;
```

## Assembler Symbols

## &lt;label&gt;

Is the program label whose address is to be calculated. Its negative offset from the address of this instruction, a multiple of 4 in the range -262140 to 0, is encoded as an unsigned value in the 'imm16' field as &lt;label&gt;/4.

## Operation

```
constant bits(64) pac_addr = PC64 -offset; X[d, 64] = AuthIB2(X[d, 64], SP[64],
```

```
pac_addr, auth_combined);
```

## C6.2.32 AUTIBSPPCR

Authenticate return address using key B, using a register

This instruction authenticates an instruction address, using two modifiers and key B.

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. For information on behavior if the authentication fails, see Faulting on pointer authentication.

The address is in X30.

The first modifier is in SP.

The second modifier is in the general-purpose register that is specified by &lt;Xn&gt; .

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding

AUTIBSPPCR

&lt;Xn&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_PAuth_LR) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = 30; constant integer n = UInt(Rn); constant boolean auth_combined = FALSE;
```

## Assembler Symbols

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
X[d, 64] = AuthIB2(X[d, 64], SP[64], X[n, 64], auth_combined);
```

## C6.2.33 AXFLAG

Convert floating-point condition flags from Arm to external format

This instruction converts the state of the PSTATE.{N,Z,C,V} flags from a form representing the result of an Arm floating-point scalar compare instruction to an alternative representation required by some software.

## System

(FEAT\_FlagM2)

<!-- image -->

## Encoding

AXFLAG

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_FlagM2) then EndOfDecode(Decode\_UNDEF);

## Operation

```
constant bit z = PSTATE.Z OR PSTATE.V; constant bit c = PSTATE.C AND NOT(PSTATE.V); PSTATE.<N,Z,C,V> = '0' : z : c : '0';
```

## C6.2.34 B.cond

## Branch conditionally

This instruction branches conditionally to a label at a PC-relative offset. This instruction provides a hint that this is not a subroutine call or return.

<!-- image -->

## Encoding

```
B.<cond> <label>
```

## Decode for this encoding

```
constant bits(64) offset = SignExtend(imm19:'00', 64); constant bits(4) condition = cond;
```

## Assembler Symbols

## &lt;cond&gt;

Is one of the standard conditions, encoded in the standard way, and encoded in 'cond':

|   cond | <cond>   |
|--------|----------|
|   0000 | EQ       |
|   0001 | NE       |
|   0010 | CS       |
|   0011 | CC       |
|   0100 | MI       |
|   0101 | PL       |
|   0110 | VS       |
|   0111 | VC       |
|   1000 | HI       |
|   1001 | LS       |
|   1010 | GE       |
|   1011 | LT       |
|   1100 | GT       |
|   1101 | LE       |
|   1110 | AL       |
|   1111 | NV       |

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as 'imm19' times 4.

## Operation

```
constant boolean branch_conditional = TRUE; if ConditionHolds(condition) then BranchTo(PC64 + offset, else BranchNotTaken(BranchType_DIR, branch_conditional);
```

```
BranchType_DIR, branch_conditional);
```

## C6.2.35 B

## Branch

This instruction branches unconditionally to a label at a PC-relative offset. This instruction provides a hint that this is not a subroutine call or return.

<!-- image -->

## Encoding

B

&lt;label&gt;

## Decode for this encoding

constant bits(64) offset = SignExtend(imm26:'00', 64);

## Assembler Symbols

## &lt;label&gt;

Is the program label to be unconditionally branched to. Its offset from the address of this instruction, in the range +/-128MB, is encoded as 'imm26' times 4.

## Operation

constant boolean branch\_conditional

BranchTo(PC64 + offset,

```
= FALSE; BranchType_DIR, branch_conditional);
```

## C6.2.36 BC.cond

Branch consistent conditionally

This instruction branches conditionally to a label at a PC-relative offset, with a hint that this branch is very unlikely to change direction. This instruction provides a hint that this is not a subroutine call or return.

19-bit signed PC-relative branch offset (FEAT\_HBC)

<!-- image -->

## Encoding

```
BC.<cond> <label>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_HBC) then EndOfDecode(Decode_UNDEF);
```

```
constant bits(64) offset = SignExtend(imm19:'00', 64); constant bits(4) condition = cond;
```

## Assembler Symbols

## &lt;cond&gt;

Is one of the standard conditions, encoded in the standard way, and encoded in 'cond':

|   cond | <cond>   |
|--------|----------|
|   0000 | EQ       |
|   0001 | NE       |
|   0010 | CS       |
|   0011 | CC       |
|   0100 | MI       |
|   0101 | PL       |
|   0110 | VS       |
|   0111 | VC       |
|   1000 | HI       |
|   1001 | LS       |
|   1010 | GE       |
|   1011 | LT       |
|   1100 | GT       |
|   1101 | LE       |
|   1110 | AL       |
|   1111 | NV       |

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as 'imm19' times 4.

## Operation

```
constant boolean branch_conditional = TRUE; if ConditionHolds(condition) then BranchTo(PC64 + offset, else BranchNotTaken(BranchType_DIR, branch_conditional);
```

```
BranchType_DIR, branch_conditional);
```

## C6.2.37 BFC

## Bitfield clear

This instruction sets a bitfield of &lt;width&gt; bits at bit position &lt;lsb&gt; of the destination register to zero, leaving the other destination bits unchanged.

This is an alias of BFM. This means:

- The encodings in this description are named to match the encodings of BFM.
- The description of BFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Leaving other bits unchanged

(FEAT\_ASMv8p2)

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0)

```
BFC <Wd>, #<lsb>, #<width>
```

## is equivalent to

```
BFM <Wd>, WZR, #(-<lsb> MOD 32), #(<width>-1)
```

and is the preferred disassembly when UInt(imms) &lt; UInt(immr) .

## Encoding for the 64-bit variant

Applies when (sf == 1 &amp;&amp; N == 1)

```
BFC <Xd>, #<lsb>, #<width>
```

## is equivalent to

```
BFM <Xd>, XZR, #(-<lsb> MOD 64), #(<width>-1)
```

and is the preferred disassembly when UInt(imms) &lt; UInt(immr) .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;lsb&gt;

For the '32-bit' variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.

For the '64-bit' variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.

## &lt;width&gt;

For the '32-bit' variant: is the width of the bitfield, in the range 1 to 32-&lt;lsb&gt;.

For the '64-bit' variant: is the width of the bitfield, in the range 1 to 64-&lt;lsb&gt;.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

The description of BFM gives the operational pseudocode for this instruction.

## Operational Information

The description of BFM gives the operational information for this instruction.

## C6.2.38 BFI

## Bitfield insert

This instruction copies a bitfield of &lt;width&gt; bits from the least significant bits of the source register to bit position &lt;lsb&gt; of the destination register, leaving the other destination bits unchanged.

This is an alias of BFM. This means:

- The encodings in this description are named to match the encodings of BFM.
- The description of BFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0)

```
BFI
```

```
<Wd>, <Wn>, #<lsb>, #<width>
```

## is equivalent to

```
BFM <Wd>, <Wn>, #(-<lsb> MOD 32), #(<width>-1)
```

and is the preferred disassembly when UInt(imms) &lt; UInt(immr) .

## Encoding for the 64-bit variant

```
Applies when (sf == 1 && N == BFI <Xd>, <Xn>, #<lsb>, #<width>
```

1)

## is equivalent to

```
BFM <Xd>, <Xn>, #(-<lsb> MOD 64), #(<width>-1)
```

and is the preferred disassembly when UInt(imms) &lt; UInt(immr) .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;lsb&gt;

For the '32-bit' variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.

For the '64-bit' variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.

## &lt;width&gt;

For the '32-bit' variant: is the width of the bitfield, in the range 1 to 32-&lt;lsb&gt;.

For the '64-bit' variant: is the width of the bitfield, in the range 1 to 64-&lt;lsb&gt;.

<!-- image -->

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

The description of BFM gives the operational pseudocode for this instruction.

## Operational Information

The description of BFM gives the operational information for this instruction.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.39 BFM

## Bitfield move

This instruction is usually accessed via one of its aliases, which are always preferred for disassembly.

If &lt;imms&gt; is greater than or equal to &lt;immr&gt; , this copies a bitfield of ( &lt;imms&gt; -&lt;immr&gt; +1) bits starting from bit position &lt;immr&gt; in the source register to the least significant bits of the destination register.

If &lt;imms&gt; is less than &lt;immr&gt; , this copies a bitfield of ( &lt;imms&gt; +1) bits from the least significant bits of the source register to bit position (regsize&lt;immr&gt; ) of the destination register, where regsize is the destination register size of 32 or 64 bits.

In both cases, the other bits of the destination register remain unchanged.

This instruction is used by the aliases BFC, BFI, and BFXIL.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0)

```
BFM
```

```
<Wd>, <Wn>, #<immr>, #<imms>
```

## Encoding for the 64-bit variant

Applies when (sf == 1 &amp;&amp; N == 1)

```
BFM
```

```
<Xd>, <Xn>, #<immr>, #<imms>
```

## Decode for all variants of this encoding

```
if sf == '1' && N != '1' then EndOfDecode(Decode_UNDEF); if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant integer s = UInt(imms); constant integer r = UInt(immr); bits(datasize) wmask; bits(datasize) tmask; (wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE, datasize);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;immr&gt;

For the '32-bit' variant: is the right rotate amount, in the range 0 to 31, encoded in the 'immr' field.

For the '64-bit' variant: is the right rotate amount, in the range 0 to 63, encoded in the 'immr' field.

## &lt;imms&gt;

For the '32-bit' variant: is the leftmost bit number to be moved from the source, in the range 0 to 31, encoded in the 'imms' field.

For the '64-bit' variant: is the leftmost bit number to be moved from the source, in the range 0 to 63, encoded in the 'imms' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
constant bits(datasize) dst = X[d, datasize]; constant bits(datasize) src = X[n, datasize]; // Perform bitfield move on low bits constant bits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, r) AND wmask); // Combine extension bits and result bits X[d, datasize] = (dst AND NOT(tmask)) OR (bot AND tmask);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias   | Is preferred when                        |
|---------|------------------------------------------|
| BFC     | Rn == '11111' && UInt(imms) < UInt(immr) |
| BFI     | Rn != '11111' && UInt(imms) < UInt(immr) |
| BFXIL   | UInt(imms) >= UInt(immr)                 |

## C6.2.40 BFXIL

Bitfield extract and insert at low end

This instruction copies a bitfield of &lt;width&gt; bits starting from bit position &lt;lsb&gt; in the source register to the least significant bits of the destination register, leaving the other destination bits unchanged.

This is an alias of BFM. This means:

- The encodings in this description are named to match the encodings of BFM.
- The description of BFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N ==

```
0) BFXIL <Wd>, <Wn>, #<lsb>, #<width>
```

## is equivalent to

```
BFM <Wd>, <Wn>, #<lsb>, #(<lsb>+<width>-1)
```

and is the preferred disassembly when UInt(imms) &gt;= UInt(immr) .

## Encoding for the 64-bit variant

```
Applies when (sf == 1 && N == 1) BFXIL <Xd>, <Xn>, #<lsb>, #<width>
```

## is equivalent to

```
BFM <Xd>, <Xn>, #<lsb>, #(<lsb>+<width>-1)
```

and is the preferred disassembly when UInt(imms) &gt;= UInt(immr) .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;lsb&gt;

For the '32-bit' variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.

For the '64-bit' variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.

## &lt;width&gt;

For the '32-bit' variant: is the width of the bitfield, in the range 1 to 32-&lt;lsb&gt;.

For the '64-bit' variant: is the width of the bitfield, in the range 1 to 64-&lt;lsb&gt;.

<!-- image -->

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

The description of BFM gives the operational pseudocode for this instruction.

## Operational Information

The description of BFM gives the operational information for this instruction.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.41 BIC (shifted register)

Bitwise bit clear (shifted register)

This instruction performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) BIC <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
BIC <Xd>, <Xn>, <Xm>{, <shift>
```

```
1) #<amount>}
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if sf == '0' && imm6<5> == '1' then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type = DecodeShift(shift); constant integer shift_amount = UInt(imm6);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in 'shift':

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |
|      10 | ASR       |

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount, datasize); X[d, datasize] = operand1 AND NOT(operand2);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   shift | <shift>   |
|---------|-----------|
|      11 | ROR       |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.42 BICS (shifted register)

Bitwise bit clear (shifted register), setting flags

This instruction performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) BICS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
BICS <Xd>, <Xn>, <Xm>{, <shift>
```

```
1) #<amount>}
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if sf == '0' && imm6<5> == '1' then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type = DecodeShift(shift); constant integer shift_amount = UInt(imm6);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in 'shift':

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |
|      10 | ASR       |

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount, datasize); constant bits(datasize) result = operand1 AND NOT(operand2); X[d, datasize] = result; PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   shift | <shift>   |
|---------|-----------|
|      11 | ROR       |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.43 BL

## Branch with link

This instruction branches to a PC-relative offset, setting register X30 to PC+4. This instruction provides a hint that this is a subroutine call.

<!-- image -->

## Encoding

```
BL <label>
```

## Decode for this encoding

```
constant bits(64) offset = SignExtend(imm26:'00', 64); constant integer d = 30;
```

## Assembler Symbols

## &lt;label&gt;

Is the program label to be unconditionally branched to. Its offset from the address of this instruction, in the range +/-128MB, is encoded as 'imm26' times 4.

## Operation

```
if IsFeatureImplemented(FEAT_GCS) && GCSPCREnabled(PSTATE.EL) AddGCSRecord(PC64 + 4); X[d, 64] = PC64 + 4; constant boolean branch_conditional = FALSE; BranchTo(PC64 + offset, BranchType_DIRCALL, branch_conditional);
```

```
then
```

## C6.2.44 BLR

Branch with link to register

This instruction calls a subroutine at an address in a register, setting register X30 to PC+4. This instruction provides a hint that this is a subroutine call.

<!-- image -->

## Encoding

BLR

&lt;Xn&gt;

## Decode for this encoding

```
constant integer n = UInt(Rn);
```

## Assembler Symbols

<!-- image -->

Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the 'Rn' field.

## Operation

```
constant bits(64) target = X[n, 64]; if IsFeatureImplemented(FEAT_GCS) && GCSPCREnabled(PSTATE.EL) AddGCSRecord(PC64 + 4); // Value in BTypeNext will be used to set PSTATE.BTYPE BTypeNext = '10'; X[30, 64] = PC64 + 4; constant boolean branch_conditional = FALSE; BranchTo(target, BranchType_INDCALL, branch_conditional);
```

```
then
```

## C6.2.45 BLRAA, BLRAAZ, BLRAB, BLRABZ

Branch with link to register, with pointer authentication

This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt; , using a modifier and the specified key, and calls a subroutine at the authenticated address, setting register X30 to PC+4.

The modifier is:

- In the general-purpose register or stack pointer that is specified by &lt;Xm|SP&gt; , for BLRAA and BLRAB .
- The value zero, for BLRAAZ and BLRABZ .

Key A is used for BLRAA and BLRAAZ . Key B is used for BLRAB and BLRABZ .

If the authentication passes, the PE continues execution at the target of the branch. For information on behavior if the authentication fails, see Faulting on pointer authentication.

The authenticated address is not written back to the general-purpose register.

This instruction provides a hint that this is a subroutine call.

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding for the Key A, register modifier variant

Applies when

BLRAA

&lt;Xn&gt;,

(Z == 1

&lt;Xm|SP&gt;

## Encoding for the Key A, zero modifier variant

```
Applies when (Z == 0 && M == 0 && Rm == 11111)
```

BLRAAZ

&lt;Xn&gt;

## Encoding for the Key B, register modifier variant

```
Applies when (Z == 1 && M == 1)
```

BLRAB

&lt;Xn&gt;,

&lt;Xm|SP&gt;

## Encoding for the Key B, zero modifier variant

```
Applies when (Z == 0 && M == 1 && Rm == 11111)
```

```
BLRABZ <Xn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_PAuth) then if Z == '0' && Rm != '11111' then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean use_key_a = (M == '0'); constant boolean source_is_sp = ((Z == '1') && (m == 31)); constant boolean auth_then_branch = TRUE;
```

&amp;&amp;

M

==

0)

## Assembler Symbols

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the 'Rn' field.

## &lt;Xm|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer holding the modifier, encoded in the 'Rm' field.

## Operation

```
bits(64) target = X[n, 64]; constant bits(64) modifier = if source_is_sp then SP[64] else if use_key_a then target = AuthIA(target, modifier, auth_then_branch); else target = AuthIB(target, modifier, auth_then_branch); if IsFeatureImplemented(FEAT_GCS) && GCSPCREnabled(PSTATE.EL) then AddGCSRecord(PC64 + 4); // Value in BTypeNext will be used to set PSTATE.BTYPE BTypeNext = '10'; X[30, 64] = PC64 + 4; constant boolean branch_conditional = FALSE; BranchTo(target, BranchType_INDCALL, branch_conditional);
```

```
X[m, 64];
```

## C6.2.46 BR

## Branch to register

This instruction branches unconditionally to an address in a register. This instruction provides a hint that this is not a subroutine call or return.

<!-- image -->

## Encoding

BR

&lt;Xn&gt;

## Decode for this encoding

```
constant integer n = UInt(Rn);
```

## Assembler Symbols

<!-- image -->

Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the 'Rn' field.

## Operation

```
constant bits(64) target = X[n, 64]; // Value in BTypeNext will be used to set PSTATE.BTYPE if InGuardedPage then if n == 16 || n == 17 then BTypeNext = '01'; else BTypeNext = '11'; else BTypeNext = '01'; constant boolean branch_conditional = FALSE; BranchTo(target, BranchType_INDIR, branch_conditional);
```

## C6.2.47 BRAA, BRAAZ, BRAB, BRABZ

Branch to register, with pointer authentication

This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt; , using a modifier and the specified key, and branches to the authenticated address.

The modifier is:

- In the general-purpose register or stack pointer that is specified by &lt;Xm|SP&gt; , for BRAA and BRAB .
- The value zero, for BRAAZ and BRABZ .

Key A is used for BRAA and BRAAZ . Key B is used for BRAB and BRABZ .

If the authentication passes, the PE continues execution at the target of the branch. For information on behavior if the authentication fails, see Faulting on pointer authentication.

The authenticated address is not written back to the general-purpose register.

This instruction provides a hint that this is not a subroutine call or return.

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding for the Key A, register modifier variant

Applies when

BRAA

(Z == 1

&lt;Xn&gt;, &lt;Xm|SP&gt;

## Encoding for the Key A, zero modifier variant

```
Applies when (Z == 0 && M == 0 && Rm == 11111)
```

BRAAZ

&lt;Xn&gt;

## Encoding for the Key B, register modifier variant

```
Applies when (Z == 1 && M == 1)
```

BRAB

&lt;Xn&gt;, &lt;Xm|SP&gt;

## Encoding for the Key B, zero modifier variant

```
Applies when (Z == 0 && M == 1 && Rm == 11111)
```

BRABZ

&lt;Xn&gt;

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_PAuth) then if Z == '0' && Rm != '11111' then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean use_key_a = (M == '0'); constant boolean source_is_sp = ((Z == '1') && (m == 31)); constant boolean auth_then_branch = TRUE;
```

&amp;&amp;

M

==

0)

## Assembler Symbols

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the 'Rn' field.

## &lt;Xm|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer holding the modifier, encoded in the 'Rm' field.

## Operation

```
bits(64) target = X[n, 64]; constant bits(64) modifier = if source_is_sp then SP[64] else if use_key_a then target = AuthIA(target, modifier, auth_then_branch); else target = AuthIB(target, modifier, auth_then_branch); // Value in BTypeNext will be used to set PSTATE.BTYPE if InGuardedPage then if n == 16 || n == 17 then BTypeNext = '01'; else BTypeNext = '11'; else BTypeNext = '01'; constant boolean branch_conditional = FALSE; BranchTo(target, BranchType_INDIR, branch_conditional);
```

```
X[m, 64];
```

## C6.2.48 BRB

Branch record buffer

For more information, see op0== 0b01 , cache maintenance, TLB maintenance, and address translation instructions.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

## (FEAT\_BRBE)

<!-- image -->

## Encoding

BRB

&lt;brb\_op&gt;

## is equivalent to

```
SYS #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}
```

and is the preferred disassembly when SysOp('001', '0111', '0010', op2) == Sys\_BRB .

## Assembler Symbols

## &lt;brb\_op&gt;

Is a BRB operation name, as listed for the BRB system instruction group, encoded in 'op2':

|   op2 | <brb_op>   | Architectural Feature   |
|-------|------------|-------------------------|
|   100 | IALL       | FEAT_BRBE               |
|   101 | INJ        | FEAT_BRBE               |

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.49 BRK

## Breakpoint instruction

This instruction generates a Breakpoint Instruction exception. The PE records the exception in ESR\_ELx, using the EC value 0x3 c, and captures the value of the immediate argument in ESR\_ELx.ISS.

Within a guarded memory region, while PSTATE.BTYPE != 0b00 , a BRK instruction will not generate a Branch Target exception and will generate a Breakpoint Instruction exception as normal. For more information, see PSTATE.BTYPE.

<!-- image -->

## Encoding

BRK

#&lt;imm&gt;

## Decode for this encoding

```
constant bits(16) comment = imm16; if IsFeatureImplemented(FEAT_BTI) SetBTypeCompatible(TRUE);
```

## Assembler Symbols

## &lt;imm&gt;

Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the 'imm16' field.

## Operation

AArch64.SoftwareBreakpoint(comment);

then

## C6.2.50 BTI

## Branch target identification

This instruction is used to guard against the execution of instructions that are not the intended target of a branch.

Outside of a guarded memory region, a BTI instruction executes as a NOP . Within a guarded memory region, while PSTATE.BTYPE != 0b00 , a BTI instruction compatible with the current value of PSTATE.BTYPE will not generate a Branch Target Exception and will allow execution of subsequent instructions within the memory region. For more information, see PSTATE.BTYPE.

The operand &lt;targets&gt; passed to a BTI instruction determines the values of PSTATE.BTYPE that the BTI instruction is compatible with.

## System

(FEAT\_BTI)

<!-- image -->

## Encoding

BTI {&lt;targets&gt;}

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_BTI) then EndOfDecode(Decode_NOP); // Check branch target compatibility between BTI instruction SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
```

## Assembler Symbols

## &lt;targets&gt;

Is the type of indirection, encoded in 'op2&lt;2:1&gt;':

## Operation

SetBTypeNext('00');

and PSTATE.BTYPE

|   op2<2:1> | <targets>   |
|------------|-------------|
|         00 | [absent]    |
|         01 | c           |
|         10 | j           |
|         11 | jc          |

## C6.2.51 CAS, CASA, CASAL, CASL

Compare and swap word or doubleword in memory

This instruction reads a 32-bit word or 64-bit doubleword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the comparison is not equal, the architecture permits writing the value read from the location to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write.

- If the destination register is not one of WZR or XZR , CASA and CASAL load from memory with acquire semantics.
- CASL and CASAL store to memory with release semantics.
- CAS has neither acquire nor release semantics.

The architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is &lt;Ws&gt; , or &lt;Xs&gt; , is restored to the value held in the register before the instruction was executed.

For a CAS or CASA instruction, when &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , this signals to the memory system that an additional subsequent CAS , CASA , CASAL , or CASL access to the specified location is likely to occur in the near future. The memory system can respond by taking actions that are expected to enable the subsequent CAS , CASA , CASAL , or CASL access to succeed when it does occur.

Acode sequence starting with a CAS or CASA instruction for which &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , and ending with a subsequent CAS , CASA , CASAL , or CASL to the same location, exhibits the following properties for best performance when the location may be accessed concurrently, on one or more other PEs:

- The sequence does not contain any direct system register writes, address translation instructions, cache or TLB maintenance operations, exception producing instructions, exception returns, or ISB barriers.
- The execution of the sequence includes 32 or fewer instructions.
- The value provided in &lt;Ws&gt; or &lt;Xs&gt; of the first CAS or CASA is a value likely to result in the comparison failing. A failing comparison result may lead to better performance due to the hardware not performing a write to memory.

Note

For a CAS or CASA instruction, when &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , the value in memory is not modified, because the CAS or CASA either fails its compare or writes the same value back to memory.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit CAS variant

Applies when (size == 10 &amp;&amp; L == 0 &amp;&amp; o0 == 0)

CAS

&lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #0}]

## Encoding for the 32-bit CASA variant

Applies when (size == 10 &amp;&amp; L == 1 &amp;&amp; o0 == 0)

CASA

&lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #0}]

## Encoding for the 32-bit CASAL variant

Applies when (size == 10 &amp;&amp; L == 1 &amp;&amp; o0 ==

```
CASAL <Ws>,
```

```
1) <Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 32-bit CASL variant

Applies when (size == 10 &amp;&amp; L == 0 &amp;&amp; o0 ==

```
CASL
```

```
1) <Ws>, <Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit CAS variant

```
Applies when (size == 11 && L == 0 && o0 ==
```

```
CAS
```

```
0) <Xs>, <Xt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit CASA variant

```
Applies when (size == 11 && L == 1 && o0 == 0) CASA <Xs>, <Xt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit CASAL variant

Applies when (size == 11 &amp;&amp; L == 1 &amp;&amp; o0 ==

```
CASAL <Xs>,
```

```
1) <Xt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit CASL variant

```
Applies when (size == 11 && L == 0 && o0 ==
```

```
CASL
```

```
1) <Xs>, <Xt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = L == '1' && t != 31; constant boolean release = o0 == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register to be compared and loaded, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be conditionally stored, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

&lt;Xs&gt;

Is the 64-bit name of the general-purpose register to be compared and loaded, encoded in the 'Rs' field.

<!-- image -->

Is the 64-bit name of the general-purpose register to be conditionally stored, encoded in the 'Rt' field.

## Operation

```
bits(64) address; bits(datasize) comparevalue; bits(datasize) newvalue; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_CAS, acquire, release, tagchecked, privileged, t, s); comparevalue = X[s, datasize]; newvalue = X[t, datasize]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) data = MemAtomic(address, comparevalue, newvalue, accdesc); X[s, regsize] = ZeroExtend(data, regsize);
```

## C6.2.52 CASB, CASAB, CASALB, CASLB

Compare and swap byte in memory

This instruction reads an 8-bit byte from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the comparison is not equal, the architecture permits writing the value read from the location to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write.

- If the destination register is not one of WZR or XZR , CASAB and CASALB load from memory with acquire semantics.
- CASLB and CASALB store to memory with release semantics.
- CASB has neither acquire nor release semantics.

The architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is &lt;Ws&gt; , is restored to the values held in the register before the instruction was executed.

For a CASB or CASAB instruction, when &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , this signals to the memory system that an additional subsequent CASB , CASAB , CASALB , or CASLB access to the specified location is likely to occur in the near future. The memory system can respond by taking actions that are expected to enable the subsequent CASB , CASAB , CASALB , or CASLB access to succeed when it does occur.

Acode sequence starting with a CASB or CASAB instruction for which &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , and ending with a subsequent CASB , CASAB , CASALB , or CASLB to the same location, exhibits the following properties for best performance when the location may be accessed concurrently, on one or more other PEs:

- The sequence does not contain any direct system register writes, address translation instructions, cache or TLB maintenance operations, exception producing instructions, exception returns, or ISB barriers.
- The execution of the sequence includes 32 or fewer instructions.
- The value provided in &lt;Ws&gt; or &lt;Xs&gt; of the first CASB or CASAB is a value likely to result in the comparison failing. Afailing comparison result may lead to better performance due to the hardware not performing a write to memory.

Note

For a CASB or CASAB instruction, when &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , the value in memory is not modified, because the CASB or CASAB either fails its compare or writes the same value back to memory.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LSE)

<!-- image -->

## Encoding for the CASB variant

<!-- image -->

## Encoding for the CASALB variant

```
Applies when (L == 1 && o0 == 1) CASALB <Ws>, <Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the CASLB variant

```
Applies when (L == 0 && o0 == 1) CASLB <Ws>, <Wt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = L == '1' && t != 31; constant boolean release = o0 == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register to be compared and loaded, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be conditionally stored, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; bits(8) comparevalue; bits(8) newvalue; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_CAS, acquire, release, tagchecked, privileged, t, s); comparevalue = X[s, 8]; newvalue = X[t, 8]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(8) data = MemAtomic(address, comparevalue, newvalue, accdesc); X[s, 32] = ZeroExtend(data, 32);
```

## C6.2.53 CASH, CASAH, CASALH, CASLH

Compare and swap halfword in memory

This instruction reads a 16-bit halfword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the comparison is not equal, the architecture permits writing the value read from the location to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write.

- If the destination register is not one of WZR or XZR , CASAH and CASALH load from memory with acquire semantics.
- CASLH and CASALH store to memory with release semantics.
- CASH has neither acquire nor release semantics.

The architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is &lt;Ws&gt; , is restored to the values held in the register before the instruction was executed.

For a CASH or CASAH instruction, when &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , this signals to the memory system that an additional subsequent CASH , CASAH , CASALH , or CASLH access to the specified location is likely to occur in the near future. The memory system can respond by taking actions that are expected to enable the subsequent CASH , CASAH , CASALH , or CASLH access to succeed when it does occur.

Acode sequence starting with a CASH or CASAH instruction for which &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , and ending with a subsequent CASH , CASAH , CASALH , or CASLH to the same location, exhibits the following properties for best performance when the location may be accessed concurrently, on one or more other PEs:

- The sequence does not contain any direct system register writes, address translation instructions, cache or TLB maintenance operations, exception producing instructions, exception returns, or ISB barriers.
- The execution of the sequence includes 32 or fewer instructions.
- The value provided in &lt;Ws&gt; or &lt;Xs&gt; of the first CASH or CASAH is a value likely to result in the comparison failing. Afailing comparison result may lead to better performance due to the hardware not performing a write to memory.

Note

For a CASH or CASAH instruction, when &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , the value in memory is not modified, because the CASH or CASAH either fails its compare or writes the same value back to memory.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LSE)

<!-- image -->

## Encoding for the CASH variant

<!-- image -->

## Encoding for the CASALH variant

```
Applies when (L == 1 && o0 == 1) CASALH <Ws>, <Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the CASLH variant

```
Applies when (L == 0 && o0 == 1) CASLH <Ws>, <Wt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = L == '1' && t != 31; constant boolean release = o0 == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register to be compared and loaded, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be conditionally stored, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; bits(16) comparevalue; bits(16) newvalue; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_CAS, acquire, release, tagchecked, privileged, t, s); comparevalue = X[s, 16]; newvalue = X[t, 16]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(16) data = MemAtomic(address, comparevalue, newvalue, accdesc); X[s, 32] = ZeroExtend(data, 32);
```

## C6.2.54 CASP, CASPA, CASPAL, CASPL

Compare and swap pair of words or doublewords in memory

This instruction reads a pair of 32-bit words or 64-bit doublewords from memory, and compares them against the values held in the first pair of registers. If the comparison is equal, the values in the second pair of registers are written to memory. If the comparison is not equal, the architecture permits writing the value read from the location to memory. If the writes are performed, the reads and writes occur atomically such that no other modification of the memory location can take place between the reads and writes.

- CASPA and CASPAL load from memory with acquire semantics.
- CASPL and CASPAL store to memory with release semantics.
- CASP has neither acquire nor release semantics.

The architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the registers which are compared and loaded, that is &lt;Ws&gt; and &lt;W(s+1)&gt; , or &lt;Xs&gt; and &lt;X(s+1)&gt; , are restored to the values held in the registers before the instruction was executed.

For a CASP or CASPA instruction, when &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , this signals to the memory system that an additional subsequent CASP , CASPA , CASPAL , or CASPL access to the specified location is likely to occur in the near future. The memory system can respond by taking actions that are expected to enable the subsequent CASP , CASPA , CASPAL , or CASPL access to succeed when it does occur.

Acode sequence starting with a CASP or CASPA instruction for which &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , and ending with a subsequent CASP , CASPA , CASPAL , or CASPL to the same location, exhibits the following properties for best performance when the location may be accessed concurrently, on one or more other PEs:

- The sequence does not contain any direct system register writes, address translation instructions, cache or TLB maintenance operations, exception producing instructions, exception returns, or ISB barriers.
- The execution of the sequence includes 32 or fewer instructions.
- The value provided in &lt;Ws&gt; or &lt;Xs&gt; of the first CASP or CASPA is a value likely to result in the comparison failing. Afailing comparison result may lead to better performance due to the hardware not performing a write to memory.

Note

For a CASP or CASPA instruction, when &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , the value in memory is not modified, because the CASP or CASPA either fails its compare or writes the same value back to memory.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit CASP variant

Applies when (sz == 0 &amp;&amp; L == 0 &amp;&amp; o0 == 0) CASP &lt;Ws&gt;, &lt;W(s+1)&gt;, &lt;Wt&gt;, &lt;W(t+1)&gt;, [&lt;Xn|SP&gt;{, #0}]

## Encoding for the 32-bit CASPA variant

```
Applies when (sz == 0 && L == 1 && o0 == 0) CASPA <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{, #0}]
```

## Encoding for the 32-bit CASPAL variant

```
Applies when (sz == 0 && L == 1 && o0 == 1)
```

```
CASPAL <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{, #0}]
```

## Encoding for the 32-bit CASPL variant

```
Applies when (sz == 0 && L == 0 && o0 == 1)
```

```
CASPL <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit CASP variant

```
Applies when (sz == 1 && L == 0 && o0 == 0) CASP <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit CASPA variant

```
Applies when (sz == 1 && L == 1 && o0 == 0) CASPA <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit CASPAL variant

```
Applies when (sz == 1 && L == 1 && o0 == 1) CASPAL <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit CASPL variant

```
Applies when (sz == 1 && L == 0 && o0 == 1) CASPL <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
if Rs<0> == '1' || Rt<0> == '1' then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sz); constant boolean acquire = L == '1'; constant boolean release = o0 == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the first general-purpose register to be compared and loaded, encoded in the 'Rs' field. &lt;Ws&gt; must be an even-numbered register.

## &lt;W(s+1)&gt;

Is the 32-bit name of the second general-purpose register to be compared and loaded.

## &lt;Wt&gt;

Is the 32-bit name of the first general-purpose register to be conditionally stored, encoded in the 'Rt' field. &lt;Wt&gt; must be an even-numbered register.

## &lt;W(t+1)&gt;

Is the 32-bit name of the second general-purpose register to be conditionally stored.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

Is the 64-bit name of the first general-purpose register to be compared and loaded, encoded in the 'Rs' field. &lt;Xs&gt; must be an even-numbered register.

## &lt;X(s+1)&gt;

Is the 64-bit name of the second general-purpose register to be compared and loaded.

## &lt;Xt&gt;

Is the 64-bit name of the first general-purpose register to be conditionally stored, encoded in the 'Rt' field. &lt;Xt&gt; must be an even-numbered register.

## &lt;X(t+1)&gt;

Is the 64-bit name of the second general-purpose register to be conditionally stored.

## Operation

```
bits(64) address; bits(2*datasize) comparevalue; bits(2*datasize) newvalue; bits(2*datasize) data; constant bits(datasize) s1 = X[s, datasize]; constant bits(datasize) s2 = X[s+1, datasize]; constant bits(datasize) t1 = X[t, datasize]; constant bits(datasize) t2 = X[t+1, datasize]; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_CAS, acquire, release, tagchecked, privileged, t, t+1, s, s+1); comparevalue = if BigEndian(accdesc.acctype) then s1:s2 else s2:s1; newvalue = if BigEndian(accdesc.acctype) then t1:t2 else t2:t1; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; data = MemAtomic(address, comparevalue, newvalue, accdesc);
```

```
if BigEndian(accdesc.acctype) then X[s, datasize] = data<2*datasize-1:datasize>; X[s+1, datasize] = data<datasize-1:0>; else X[s, datasize] = data<datasize-1:0>; X[s+1, datasize] = data<2*datasize-1:datasize>;
```

## C6.2.55 CASPT, CASPAT, CASPALT, CASPLT

Compare and swap pair unprivileged

This instruction reads a pair of 64-bit doublewords from memory, and compares them against the values held in the first pair of registers. If the comparison is equal, the values in the second pair of registers are written to memory. If the comparison is not equal, the architecture permits writing the value read from the location to memory. If the writes are performed, the reads and writes occur atomically such that no other modification of the memory location can take place between the reads and writes.

- CASPAT and CASPALT load from memory with acquire semantics.
- CASPLT and CASPALT store to memory with release semantics.
- CASPT has neither acquire nor release semantics.

The architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the registers which are compared and loaded, that is &lt;Xs&gt; and &lt;X(s+1)&gt; , are restored to the values held in the registers before the instruction was executed.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

For a CASPT or CASPAT instruction, when &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , this signals to the memory system that an additional subsequent CASPT , CASPAT , CASPALT , or CASPLT access to the specified location is likely to occur in the near future. The memory system can respond by taking actions that are expected to enable the subsequent CASPT , CASPAT , CASPALT , or CASPLT access to succeed when it does occur.

Acode sequence starting with a CASPT or CASPAT instruction for which &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , and ending with a subsequent CASPT , CASPAT , CASPALT , or CASPLT to the same location, exhibits the following properties for best performance when the location may be accessed concurrently, on one or more other PEs:

- The sequence does not contain any direct system register writes, address translation instructions, cache or TLB maintenance operations, exception producing instructions, exception returns, or ISB barriers.
- The execution of the sequence includes 32 or fewer instructions.
- The value provided in &lt;Ws&gt; or &lt;Xs&gt; of the first CASPT or CASPAT is a value likely to result in the comparison failing. A failing comparison result may lead to better performance due to the hardware not performing a write to memory.

Note

For a CASPT or CASPAT instruction, when &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , the value in memory is not modified, because the CASPT or CASPAT either fails its compare or writes the same value back to memory.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

No offset

(FEAT\_LSUI)

<!-- image -->

## Encoding for the CASPT variant

Applies when

```
(L == 0 && o0 == 0) CASPT <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{, #0}]
```

## Encoding for the CASPAT variant

```
Applies when (L == 1 && o0 == 0) CASPAT <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{, #0}]
```

## Encoding for the CASPALT variant

```
Applies when (L == 1 && o0 == 1) CASPALT <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{, #0}]
```

## Encoding for the CASPLT variant

```
Applies when (L == 0 && o0 == 1) CASPLT <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); if Rs<0> == '1' || Rt<0> == '1' then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 64; constant boolean acquire = L == '1'; constant boolean release = o0 == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Xs&gt;

Is the 64-bit name of the first general-purpose register to be compared and loaded, encoded in the 'Rs' field. &lt;Xs&gt; must be an even-numbered register.

## &lt;X(s+1)&gt;

Is the 64-bit name of the second general-purpose register to be compared and loaded.

## &lt;Xt&gt;

Is the 64-bit name of the first general-purpose register to be conditionally stored, encoded in the 'Rt' field. &lt;Xt&gt; must be an even-numbered register.

## &lt;X(t+1)&gt;

Is the 64-bit name of the second general-purpose register to be conditionally stored.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; bits(2*datasize) comparevalue; bits(2*datasize) newvalue; bits(2*datasize) data; constant bits(datasize) s1 = X[s, datasize]; constant bits(datasize) s2 = X[s+1, datasize]; constant bits(datasize) t1 = X[t, datasize]; constant bits(datasize) t2 = X[t+1, datasize]; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_CAS, acquire, release, tagchecked, privileged, t, t+1, s, s+1); comparevalue = if BigEndian(accdesc.acctype) then s1:s2 else s2:s1; newvalue = if BigEndian(accdesc.acctype) then t1:t2 else t2:t1; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; data = MemAtomic(address, comparevalue, newvalue, accdesc); if BigEndian(accdesc.acctype) then X[s, datasize] = data<2*datasize-1:datasize>; X[s+1, datasize] = data<datasize-1:0>; else X[s, datasize] = data<datasize-1:0>; X[s+1, datasize] = data<2*datasize-1:datasize>;
```

## C6.2.56 CAST, CASAT, CASALT, CASLT

Compare and swap unprivileged

This instruction reads a 64-bit doubleword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the comparison is not equal, the architecture permits writing the value read from the location to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write.

- If the destination register is not one of WZR or XZR , CASAT and CASALT load from memory with acquire semantics.
- CASLT and CASALT store to memory with release semantics.
- CAST has neither acquire nor release semantics.

The architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is &lt;Xs&gt; , is restored to the value held in the register before the instruction was executed.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

For a CAST or CASAT instruction, when &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , this signals to the memory system that an additional subsequent CAST , CASAT , CASALT , or CASLT access to the specified location is likely to occur in the near future. The memory system can respond by taking actions that are expected to enable the subsequent CAST , CASAT , CASALT , or CASLT access to succeed when it does occur.

Acode sequence starting with a CAST or CASAT instruction for which &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , and ending with a subsequent CAST , CASAT , CASALT , or CASLT to the same location, exhibits the following properties for best performance when the location may be accessed concurrently, on one or more other PEs:

- The sequence does not contain any direct system register writes, address translation instructions, cache or TLB maintenance operations, exception producing instructions, exception returns, or ISB barriers.
- The execution of the sequence includes 32 or fewer instructions.
- The value provided in &lt;Ws&gt; or &lt;Xs&gt; of the first CAST or CASAT is a value likely to result in the comparison failing. Afailing comparison result may lead to better performance due to the hardware not performing a write to memory.

Note

For a CAST or CASAT instruction, when &lt;Ws&gt; or &lt;Xs&gt; specifies the same register as &lt;Wt&gt; or &lt;Xt&gt; , the value in memory is not modified, because the CAST or CASAT either fails its compare or writes the same value back to memory.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LSUI)

<!-- image -->

## Encoding for the CAST variant

```
Applies when (L == 0 && o0 == 0) CAST <Xs>, <Xt>, [<Xn|SP>{, #0}]
```

## Encoding for the CASAT variant

```
Applies when (L == 1 && o0 == 0) CASAT <Xs>, <Xt>, [<Xn|SP>{, #0}]
```

## Encoding for the CASALT variant

```
Applies when (L == 1 && o0 == 1) CASALT <Xs>, <Xt>, [<Xn|SP>{, #0}]
```

## Encoding for the CASLT variant

```
Applies when (L == 0 && o0 == 1) CASLT <Xs>, <Xt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LSUI) then constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = L == '1' && t != 31; constant boolean release = o0 == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register to be compared and loaded, encoded in the 'Rs' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be conditionally stored, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; bits(64) comparevalue; bits(64) newvalue; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_CAS, acquire, release, tagchecked, privileged, t, s); comparevalue = X[s, 64]; newvalue = X[t, 64]; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; X[s, 64] = MemAtomic(address, comparevalue, newvalue, accdesc);
```

## C6.2.57 CBB&lt;cc&gt;

Compare bytes and branch

This instruction compares the byte values in two registers, and conditionally branches to a label at a PC-relative offset if the condition is true. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This instruction is used by the pseudo-instructions CBBLE, CBBLO, CBBLS, and CBBLT.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding for the Greater than variant

```
Applies when (cc == 000) CBBGT <Wt>, <Wm>, <label>
```

## Encoding for the Greater than or equal variant

```
Applies when (cc == 001) CBBGE <Wt>, <Wm>, <label>
```

## Encoding for the Higher variant

```
Applies when (cc == 010) CBBHI <Wt>, <Wm>, <label>
```

## Encoding for the Higher or same variant

```
Applies when (cc == 011) CBBHS <Wt>, <Wm>, <label>
```

## Encoding for the Equal variant

```
Applies when (cc == 110) CBBEQ <Wt>, <Wm>, <label>
```

## Encoding for the Not equal variant

```
Applies when (cc == 111) CBBNE <Wt>, <Wm>, <label>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CMPBR) then constant integer datasize = 8 << UInt(H); constant integer t = UInt(Rt); constant integer m = UInt(Rm); constant bits(64) offset = SignExtend(imm9:'00', 64); CmpOp op; boolean unsigned; case cc of when '000' op = Cmp_GT; unsigned = FALSE; when '001' op = Cmp_GE; unsigned = FALSE; when '010' op = Cmp_GT; unsigned = TRUE; when '011' op = Cmp_GE; unsigned = TRUE; when '110' op = Cmp_EQ; unsigned = TRUE; when '111' op = Cmp_NE; unsigned = TRUE; otherwise EndOfDecode(Decode_UNDEF);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## Operation

```
constant bits(datasize) operand1 = X[t, datasize]; constant bits(datasize) operand2 = X[m, datasize]; constant boolean branch_conditional = TRUE; constant integer value1 = if unsigned then UInt(operand1) else SInt(operand1); constant integer value2 = if unsigned then UInt(operand2) else SInt(operand2); boolean cond; case op of when Cmp_EQ cond = value1 == value2; when Cmp_NE cond = value1 != value2; when Cmp_GE cond = value1 >= value2; when Cmp_GT cond = value1 > value2; if cond then BranchTo(PC64 + offset, BranchType_DIR, branch_conditional); else BranchNotTaken(BranchType_DIR, branch_conditional);
```

## C6.2.58 CBBLE

Compare signed less than or equal to bytes and branch

This instruction compares the signed byte values in two registers, and conditionally branches to a label at a PC-relative offset if the second value is less than or equal to the first. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CBB&lt;cc&gt;. This means:

- The encodings in this description are named to match the encodings of CBB&lt;cc&gt;.
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CBB&lt;cc&gt; gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding

<!-- image -->

## Assembler Symbols

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## Operation

The description of CBB&lt;cc&gt; gives the operational pseudocode for this instruction.

## C6.2.59 CBBLO

Compare unsigned lower than bytes and branch

This instruction compares the unsigned byte values in two registers, and conditionally branches to a label at a PC-relative offset if the second value is lower than the first. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CBB&lt;cc&gt;. This means:

- The encodings in this description are named to match the encodings of CBB&lt;cc&gt;.
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CBB&lt;cc&gt; gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding

<!-- image -->

## Assembler Symbols

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## Operation

The description of CBB&lt;cc&gt; gives the operational pseudocode for this instruction.

## C6.2.60 CBBLS

Compare unsigned lower than or same as bytes and branch

This instruction compares the unsigned byte values in two registers, and conditionally branches to a label at a PC-relative offset if the second value is lower than or the same as the first. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CBB&lt;cc&gt;. This means:

- The encodings in this description are named to match the encodings of CBB&lt;cc&gt;.
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CBB&lt;cc&gt; gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding

<!-- image -->

## Assembler Symbols

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## Operation

The description of CBB&lt;cc&gt; gives the operational pseudocode for this instruction.

## C6.2.61 CBBLT

Compare signed less than bytes and branch

This instruction compares the signed byte values in two registers, and conditionally branches to a label at a PC-relative offset if the second value is less than the first. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CBB&lt;cc&gt;. This means:

- The encodings in this description are named to match the encodings of CBB&lt;cc&gt;.
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CBB&lt;cc&gt; gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding

<!-- image -->

## Assembler Symbols

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## Operation

The description of CBB&lt;cc&gt; gives the operational pseudocode for this instruction.

## C6.2.62 CB&lt;cc&gt; (immediate)

Compare register with immediate and branch

This instruction compares the value in a register with an immediate, and conditionally branches to a label at a PC-relative offset if the comparison is true. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This instruction is used by the pseudo-instructions CBGE (immediate), CBHS (immediate), CBLE (immediate), and CBLS (immediate).

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding for the 32-bit greater than variant

Applies when

0

CBGT

(sf

==

&amp;&amp;

cc

== 000)

&lt;Wt&gt;, #&lt;imm&gt;,

&lt;label&gt;

## Encoding for the 32-bit less than variant

Applies when

==

0

CBLT

(sf

&amp;&amp;

cc

== 001)

&lt;Wt&gt;, #&lt;imm&gt;,

&lt;label&gt;

## Encoding for the 32-bit higher variant

```
Applies when (sf == 0 && cc == 010) CBHI <Wt>, #<imm>, <label>
```

## Encoding for the 32-bit lower variant

```
Applies when (sf == 0 && cc == 011) CBLO <Wt>, #<imm>, <label>
```

## Encoding for the 32-bit equal variant

```
Applies when (sf == 0 && cc == 110) CBEQ <Wt>, #<imm>, <label>
```

## Encoding for the 32-bit not equal variant

```
Applies when (sf == 0 && cc == 111) CBNE <Wt>, #<imm>, <label>
```

## Encoding for the 64-bit greater than variant

```
Applies when (sf == 1 && cc == 000) CBGT <Xt>, #<imm>, <label>
```

## Encoding for the 64-bit less than variant

Applies when (sf == 1 &amp;&amp; cc

```
== 001) CBLT <Xt>, #<imm>, <label>
```

## Encoding for the 64-bit higher variant

Applies when (sf == 1 &amp;&amp; cc

```
CBHI <Xt>, #<imm>,
```

```
== 010) <label>
```

## Encoding for the 64-bit lower variant

Applies when (sf == 1 &amp;&amp; cc

```
== 011) CBLO <Xt>, #<imm>, <label>
```

## Encoding for the 64-bit equal variant

```
Applies when (sf == 1 && cc
```

```
CBEQ <Xt>, #<imm>,
```

```
== 110) <label>
```

## Encoding for the 64-bit not equal variant

Applies when (sf == 1 &amp;&amp; cc

```
CBNE <Xt>, #<imm>,
```

```
== 111) <label>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_CMPBR) then EndOfDecode(Decode_UNDEF); constant integer datasize = 32 << UInt(sf); constant integer t = UInt(Rt); constant bits(64) offset = SignExtend(imm9:'00', 64); CmpOp op; boolean unsigned; case cc of when '000' op = Cmp_GT; unsigned = FALSE; when '001' op = Cmp_LT; unsigned = FALSE; when '010' op = Cmp_GT; unsigned = TRUE; when '011' op = Cmp_LT; unsigned = TRUE; when '110' op = Cmp_EQ; unsigned = TRUE; when '111' op = Cmp_NE; unsigned = TRUE; otherwise EndOfDecode(Decode_UNDEF); constant integer value2 = UInt(imm6);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;imm&gt;

Is an unsigned immediate, in the range 0 to 63, encoded in the 'imm6' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

&lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## Operation

```
constant bits(datasize) operand1 = X[t, datasize]; constant boolean branch_conditional = TRUE; constant integer value1 = if unsigned then UInt(operand1) boolean cond; case op of when Cmp_EQ cond = value1 == value2; when Cmp_NE cond = value1 != value2; when Cmp_LT cond = value1 < value2; when Cmp_GT cond = value1 > value2; if cond then BranchTo(PC64 + offset, BranchType_DIR, branch_conditional); else BranchNotTaken(BranchType_DIR, branch_conditional);
```

```
else SInt(operand1);
```

## C6.2.63 CB&lt;cc&gt; (register)

Compare registers and branch

This instruction compares the values in two registers, and conditionally branches to a label at a PC-relative offset if the condition is true. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This instruction is used by the pseudo-instructions CBLE (register), CBLO (register), CBLS (register), and CBLT (register).

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding for the 32-bit greater than variant

Applies when

0

CBGT

(sf

==

&amp;&amp;

&lt;Wt&gt;, &lt;Wm&gt;, &lt;label&gt;

## Encoding for the 32-bit greater than or equal variant

Applies when

CBGE

(sf

==

0

&amp;&amp;

cc

== 001)

&lt;Wt&gt;, &lt;Wm&gt;, &lt;label&gt;

## Encoding for the 32-bit higher variant

Applies when

(sf

==

0

CBHI

&amp;&amp;

cc

== 010)

&lt;Wt&gt;, &lt;Wm&gt;, &lt;label&gt;

## Encoding for the 32-bit higher or same variant

Applies when

CBHS

(sf

==

0

&amp;&amp;

cc

== 011)

&lt;Wt&gt;, &lt;Wm&gt;, &lt;label&gt;

## Encoding for the 32-bit equal variant

Applies when

(sf

==

0

CBEQ

&amp;&amp;

cc

== 110)

&lt;Wt&gt;, &lt;Wm&gt;, &lt;label&gt;

## Encoding for the 32-bit not equal variant

```
Applies when (sf == 0 && cc == 111) CBNE <Wt>, <Wm>, <label>
```

## Encoding for the 64-bit greater than variant

```
Applies when (sf == 1 && cc == 000) CBGT <Xt>, <Xm>, <label>
```

cc

== 000)

## Encoding for the 64-bit greater than or equal variant

Applies when (sf == 1 &amp;&amp; cc == 001)

```
CBGE <Xt>, <Xm>, <label>
```

## Encoding for the 64-bit higher variant

```
Applies when (sf == 1 && cc
```

```
CBHI
```

```
== 010) <Xt>, <Xm>, <label>
```

## Encoding for the 64-bit higher or same variant

```
Applies when (sf == 1 && cc == 011)
```

```
CBHS
```

```
<Xt>, <Xm>, <label>
```

## Encoding for the 64-bit equal variant

```
Applies when (sf == 1 && cc == 110)
```

```
CBEQ <Xt>, <Xm>, <label>
```

## Encoding for the 64-bit not equal variant

```
Applies when (sf == 1 && cc == 111)
```

```
CBNE <Xt>, <Xm>, <label>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CMPBR) then constant integer datasize = 32 << UInt(sf); constant integer t = UInt(Rt); constant integer m = UInt(Rm); constant bits(64) offset = SignExtend(imm9:'00', 64); CmpOp op; boolean unsigned; case cc of when '000' op = Cmp_GT; unsigned = FALSE; when '001' op = Cmp_GE; unsigned = FALSE; when '010' op = Cmp_GT; unsigned = TRUE; when '011' op = Cmp_GE; unsigned = TRUE; when '110' op = Cmp_EQ; unsigned = TRUE; when '111' op = Cmp_NE; unsigned = TRUE; otherwise EndOfDecode(Decode_UNDEF);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

<!-- image -->

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

```
constant bits(datasize) operand1 = X[t, datasize]; constant bits(datasize) operand2 = X[m, datasize]; constant boolean branch_conditional = TRUE; constant integer value1 = if unsigned then UInt(operand1) else SInt(operand1); constant integer value2 = if unsigned then UInt(operand2) else SInt(operand2); boolean cond; case op of when Cmp_EQ cond = value1 == value2; when Cmp_NE cond = value1 != value2; when Cmp_GE cond = value1 >= value2; when Cmp_GT cond = value1 > value2; if cond then BranchTo(PC64 + offset, BranchType_DIR, branch_conditional); else BranchNotTaken(BranchType_DIR, branch_conditional);
```

## C6.2.64 CBGE (immediate)

Compare signed greater than or equal to immediate and branch

This instruction compares the signed value in a register with an immediate, and conditionally branches to a label at a PC-relative offset if the register value is greater than or equal to the immediate. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CB&lt;cc&gt; (immediate). This means:

- The encodings in this description are named to match the encodings of CB&lt;cc&gt; (immediate).
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CB&lt;cc&gt; (immediate) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding for the 32-bit greater than variant

Applies when (sf ==

```
<Wt>, #<immp1>, <label> is equivalent to CBGT <Wt>, #<imm>, <label>
```

```
0) CBGE
```

## Encoding for the 64-bit greater than variant

Applies when (sf ==

```
<Xt>, #<immp1>, <label> is equivalent to CBGT <Xt>, #<imm>, <label>
```

```
1) CBGE
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;immp1&gt;

Is an unsigned immediate, in the range 1 to 64, encoded as 'imm6' plus 1.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## Operation

The description of CB&lt;cc&gt; (immediate) gives the operational pseudocode for this instruction.

## C6.2.65 CBH&lt;cc&gt;

## Compare halfwords and branch

This instruction compares the halfword values in two registers, and conditionally branches to a label at a PC-relative offset if the condition is true. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This instruction is used by the pseudo-instructions CBHLE, CBHLO, CBHLS, and CBHLT.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding for the Greater than variant

```
Applies when (cc == 000) CBHGT <Wt>, <Wm>, <label>
```

## Encoding for the Greater than or equal variant

```
Applies when (cc == 001) CBHGE <Wt>, <Wm>, <label>
```

## Encoding for the Higher variant

```
Applies when (cc == 010) CBHHI <Wt>, <Wm>, <label>
```

## Encoding for the Higher or same variant

```
Applies when (cc == 011) CBHHS <Wt>, <Wm>, <label>
```

## Encoding for the Equal variant

```
Applies when (cc == 110) CBHEQ <Wt>, <Wm>, <label>
```

## Encoding for the Not equal variant

```
Applies when (cc == 111) CBHNE <Wt>, <Wm>, <label>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CMPBR) then constant integer datasize = 8 << UInt(H); constant integer t = UInt(Rt); constant integer m = UInt(Rm); constant bits(64) offset = SignExtend(imm9:'00', 64); CmpOp op; boolean unsigned; case cc of when '000' op = Cmp_GT; unsigned = FALSE; when '001' op = Cmp_GE; unsigned = FALSE; when '010' op = Cmp_GT; unsigned = TRUE; when '011' op = Cmp_GE; unsigned = TRUE; when '110' op = Cmp_EQ; unsigned = TRUE; when '111' op = Cmp_NE; unsigned = TRUE; otherwise EndOfDecode(Decode_UNDEF);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## Operation

```
constant bits(datasize) operand1 = X[t, datasize]; constant bits(datasize) operand2 = X[m, datasize]; constant boolean branch_conditional = TRUE; constant integer value1 = if unsigned then UInt(operand1) else SInt(operand1); constant integer value2 = if unsigned then UInt(operand2) else SInt(operand2); boolean cond; case op of when Cmp_EQ cond = value1 == value2; when Cmp_NE cond = value1 != value2; when Cmp_GE cond = value1 >= value2; when Cmp_GT cond = value1 > value2; if cond then BranchTo(PC64 + offset, BranchType_DIR, branch_conditional); else BranchNotTaken(BranchType_DIR, branch_conditional);
```

## C6.2.66 CBHLE

Compare signed less than or equal to halfwords and branch

This instruction compares the signed halfword values in two registers, and conditionally branches to a label at a PC-relative offset if the second value is less than or equal to the first. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CBH&lt;cc&gt;. This means:

- The encodings in this description are named to match the encodings of CBH&lt;cc&gt;.
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CBH&lt;cc&gt; gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding

<!-- image -->

## Assembler Symbols

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## Operation

The description of CBH&lt;cc&gt; gives the operational pseudocode for this instruction.

## C6.2.67 CBHLO

Compare unsigned lower than halfwords and branch

This instruction compares the unsigned halfword values in two registers, and conditionally branches to a label at a PC-relative offset if the second value is lower than the first. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CBH&lt;cc&gt;. This means:

- The encodings in this description are named to match the encodings of CBH&lt;cc&gt;.
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CBH&lt;cc&gt; gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding

<!-- image -->

## Assembler Symbols

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## Operation

The description of CBH&lt;cc&gt; gives the operational pseudocode for this instruction.

## C6.2.68 CBHLS

Compare unsigned lower than or same as halfwords and branch

This instruction compares the unsigned halfword values in two registers, and conditionally branches to a label at a PC-relative offset if the second value is lower than or the same as the first. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CBH&lt;cc&gt;. This means:

- The encodings in this description are named to match the encodings of CBH&lt;cc&gt;.
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CBH&lt;cc&gt; gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding

<!-- image -->

## Assembler Symbols

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## Operation

The description of CBH&lt;cc&gt; gives the operational pseudocode for this instruction.

## C6.2.69 CBHLT

Compare signed less than halfwords and branch

This instruction compares the signed halfword values in two registers, and conditionally branches to a label at a PC-relative offset if the second value is less than the first. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CBH&lt;cc&gt;. This means:

- The encodings in this description are named to match the encodings of CBH&lt;cc&gt;.
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CBH&lt;cc&gt; gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding

<!-- image -->

## Assembler Symbols

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## Operation

The description of CBH&lt;cc&gt; gives the operational pseudocode for this instruction.

## C6.2.70 CBHS (immediate)

Compare unsigned higher than or same as immediate and branch

This instruction compares the unsigned value in a register with an immediate, and conditionally branches to a label at a PC-relative offset if the register value is higher than or the same as the immediate. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CB&lt;cc&gt; (immediate). This means:

- The encodings in this description are named to match the encodings of CB&lt;cc&gt; (immediate).
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CB&lt;cc&gt; (immediate) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding for the 32-bit higher variant

Applies when (sf ==

```
<Wt>, #<immp1>, <label> is equivalent to CBHI <Wt>, #<imm>, <label>
```

```
0) CBHS
```

## Encoding for the 64-bit higher variant

Applies when (sf ==

```
<Xt>, #<immp1>, <label> is equivalent to CBHI <Xt>, #<imm>, <label>
```

```
1) CBHS
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;immp1&gt;

Is an unsigned immediate, in the range 1 to 64, encoded as 'imm6' plus 1.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## Operation

The description of CB&lt;cc&gt; (immediate) gives the operational pseudocode for this instruction.

## C6.2.71 CBLE (immediate)

Compare signed less than or equal to immediate and branch

This instruction compares the signed value in a register with an immediate, and conditionally branches to a label at a PC-relative offset if the register value is less than or equal to the immediate. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CB&lt;cc&gt; (immediate). This means:

- The encodings in this description are named to match the encodings of CB&lt;cc&gt; (immediate).
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CB&lt;cc&gt; (immediate) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding for the 32-bit less than variant

Applies when (sf ==

```
0) CBLE <Wt>, #<imms1>, <label>
```

## is equivalent to

```
CBLT <Wt>, #<imm>, <label>
```

## Encoding for the 64-bit less than variant

Applies when (sf ==

```
1) CBLE <Xt>, #<imms1>, <label>
```

## is equivalent to

```
CBLT <Xt>, #<imm>, <label>
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;imms1&gt;

Is a signed immediate, in the range -1 to 62, encoded as 'imm6' minus 1.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## Operation

The description of CB&lt;cc&gt; (immediate) gives the operational pseudocode for this instruction.

## C6.2.72 CBLE (register)

Compare signed less than or equal to register and branch

This instruction compares the signed values in two registers, and conditionally branches to a label at a PC-relative offset if the second value is less than or equal to the first. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CB&lt;cc&gt; (register). This means:

- The encodings in this description are named to match the encodings of CB&lt;cc&gt; (register).
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CB&lt;cc&gt; (register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding for the 32-bit greater than or equal variant

Applies when (sf ==

```
0) CBLE <Wm>, <Wt>, <label>
```

## is equivalent to

```
CBGE <Wt>, <Wm>, <label>
```

## Encoding for the 64-bit greater than or equal variant

Applies when (sf ==

```
1) CBLE <Xm>, <Xt>, <label>
```

## is equivalent to

```
CBGE <Xt>, <Xm>, <label>
```

## Assembler Symbols

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

<!-- image -->

Is the 64-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## Operation

The description of CB&lt;cc&gt; (register) gives the operational pseudocode for this instruction.

## C6.2.73 CBLO (register)

Compare unsigned lower than register and branch

This instruction compares the unsigned values in two registers, and conditionally branches to a label at a PC-relative offset if the second value is lower than the first. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CB&lt;cc&gt; (register). This means:

- The encodings in this description are named to match the encodings of CB&lt;cc&gt; (register).
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CB&lt;cc&gt; (register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding for the 32-bit higher variant

Applies when (sf ==

```
0) CBLO <Wm>, <Wt>, <label>
```

## is equivalent to

```
CBHI <Wt>, <Wm>, <label>
```

## Encoding for the 64-bit higher variant

Applies when (sf ==

```
1) CBLO <Xm>, <Xt>, <label>
```

## is equivalent to

```
CBHI <Xt>, <Xm>, <label>
```

## Assembler Symbols

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

<!-- image -->

Is the 64-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## Operation

The description of CB&lt;cc&gt; (register) gives the operational pseudocode for this instruction.

## C6.2.74 CBLS (immediate)

Compare unsigned lower than or same as immediate and branch

This instruction compares the unsigned value in a register with an immediate, and conditionally branches to a label at a PC-relative offset if the register value is lower than or the same as the immediate. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CB&lt;cc&gt; (immediate). This means:

- The encodings in this description are named to match the encodings of CB&lt;cc&gt; (immediate).
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CB&lt;cc&gt; (immediate) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding for the 32-bit lower variant

Applies when (sf ==

```
0) CBLS <Wt>, #<imms1>, <label>
```

## is equivalent to

```
CBLO <Wt>, #<imm>, <label>
```

## Encoding for the 64-bit lower variant

Applies when (sf ==

```
1) CBLS <Xt>, #<imms1>, <label>
```

## is equivalent to

```
CBLO <Xt>, #<imm>, <label>
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;imms1&gt;

Is a signed immediate, in the range -1 to 62, encoded as 'imm6' minus 1.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## Operation

The description of CB&lt;cc&gt; (immediate) gives the operational pseudocode for this instruction.

## C6.2.75 CBLS (register)

Compare unsigned lower than or same as register and branch

This instruction compares the unsigned values in two registers, and conditionally branches to a label at a PC-relative offset if the second value is lower than or the same as the first. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CB&lt;cc&gt; (register). This means:

- The encodings in this description are named to match the encodings of CB&lt;cc&gt; (register).
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CB&lt;cc&gt; (register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding for the 32-bit higher or same variant

Applies when (sf ==

```
0) CBLS <Wm>, <Wt>, <label>
```

## is equivalent to

```
CBHS <Wt>, <Wm>, <label>
```

## Encoding for the 64-bit higher or same variant

Applies when (sf ==

```
1) CBLS <Xm>, <Xt>, <label>
```

## is equivalent to

```
CBHS <Xt>, <Xm>, <label>
```

## Assembler Symbols

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

<!-- image -->

Is the 64-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## Operation

The description of CB&lt;cc&gt; (register) gives the operational pseudocode for this instruction.

## C6.2.76 CBLT (register)

Compare signed less than register and branch

This instruction compares the signed values in two registers, and conditionally branches to a label at a PC-relative offset if the second value is less than the first. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

This is a pseudo-instruction of CB&lt;cc&gt; (register). This means:

- The encodings in this description are named to match the encodings of CB&lt;cc&gt; (register).
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of CB&lt;cc&gt; (register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Branch

(FEAT\_CMPBR)

<!-- image -->

## Encoding for the 32-bit greater than variant

Applies when (sf ==

```
0) CBLT <Wm>, <Wt>, <label>
```

## is equivalent to

```
CBGT <Wt>, <Wm>, <label>
```

## Encoding for the 64-bit greater than variant

Applies when (sf ==

```
1) CBLT <Xm>, <Xt>, <label>
```

## is equivalent to

```
CBGT <Xt>, <Xm>, <label>
```

## Assembler Symbols

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range -1024 to 1020, is encoded as 'imm9' times 4.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

<!-- image -->

Is the 64-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## Operation

The description of CB&lt;cc&gt; (register) gives the operational pseudocode for this instruction.

## C6.2.77 CBNZ

## Compare and branch on nonzero

This instruction compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) CBNZ <Wt>, <label>
```

## Encoding for the 64-bit variant

```
Applies when (sf == CBNZ <Xt>, <label>
```

```
1)
```

## Decode for all variants of this encoding

```
constant integer t = UInt(Rt); constant integer datasize = 32 << UInt(sf); constant bits(64) offset
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as 'imm19' times 4.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## Operation

```
constant boolean branch_conditional = TRUE; constant bits(datasize) operand1 = X[t, datasize]; if !IsZero(operand1) then BranchTo(PC64 + offset, BranchType_DIR, branch_conditional); else BranchNotTaken(BranchType_DIR, branch_conditional);
```

```
= SignExtend(imm19:'00', 64);
```

## C6.2.78 CBZ

## Compare and branch on zero

This instruction compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) CBZ <Wt>, <label>
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) CBZ <Xt>, <label>
```

## Decode for all variants of this encoding

```
constant integer t = UInt(Rt); constant integer datasize = 32 << UInt(sf); constant bits(64) offset
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as 'imm19' times 4.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be tested, encoded in the 'Rt' field.

## Operation

```
constant boolean branch_conditional = TRUE; constant bits(datasize) operand1 = X[t, datasize]; if IsZero(operand1) then BranchTo(PC64 + offset, BranchType_DIR, branch_conditional); else BranchNotTaken(BranchType_DIR, branch_conditional);
```

```
= SignExtend(imm19:'00', 64);
```

## C6.2.79 CCMN (immediate)

Conditional compare negative (immediate)

This instruction sets the value of the condition flags to the result of the comparison of a register value and a negated immediate value if the condition is TRUE, and an immediate value otherwise.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) CCMN <Wn>, #<imm>, #<nzcv>,
```

```
<cond>
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
1)
```

```
CCMN <Xn>, #<imm>, #<nzcv>, <cond>
```

## Decode for all variants of this encoding

```
constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant bits(4) condition = cond; bits(4) flags = nzcv; constant bits(datasize) imm = ZeroExtend(imm5,
```

## Assembler Symbols

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;imm&gt;

Is a five bit unsigned (positive) immediate encoded in the 'imm5' field.

## &lt;nzcv&gt;

Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the 'nzcv' field.

## &lt;cond&gt;

Is one of the standard conditions, encoded in the standard way, and encoded in 'cond':

|   cond | <cond>   |
|--------|----------|
|   0000 | EQ       |
|   0001 | NE       |
|   0010 | CS       |

```
datasize);
```

<!-- image -->

## &lt;Xn&gt;

|   cond | <cond>   |
|--------|----------|
|   0011 | CC       |
|   0100 | MI       |
|   0101 | PL       |
|   0110 | VS       |
|   0111 | VC       |
|   1000 | HI       |
|   1001 | LS       |
|   1010 | GE       |
|   1011 | LT       |
|   1100 | GT       |
|   1101 | LE       |
|   1110 | AL       |
|   1111 | NV       |

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
if ConditionHolds(condition) then constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = imm; (-, flags) = AddWithCarry(operand1, operand2, '0'); PSTATE.<N,Z,C,V> = flags;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.80 CCMN (register)

Conditional compare negative (register)

This instruction sets the value of the condition flags to the result of the comparison of a register value and the inverse of another register value if the condition is TRUE, and an immediate value otherwise.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) CCMN <Wn>, <Wm>, #<nzcv>, <cond>
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
1) CCMN <Xn>, <Xm>, #<nzcv>, <cond>
```

## Decode for all variants of this encoding

```
constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << constant bits(4) condition = cond; bits(4) flags = nzcv;
```

## Assembler Symbols

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;nzcv&gt;

Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the 'nzcv' field.

## &lt;cond&gt;

Is one of the standard conditions, encoded in the standard way, and encoded in 'cond':

|   cond | <cond>   |
|--------|----------|
|   0000 | EQ       |
|   0001 | NE       |
|   0010 | CS       |

```
UInt(sf);
```

## &lt;Xn&gt;

|   cond | <cond>   |
|--------|----------|
|   0011 | CC       |
|   0100 | MI       |
|   0101 | PL       |
|   0110 | VS       |
|   0111 | VC       |
|   1000 | HI       |
|   1001 | LS       |
|   1010 | GE       |
|   1011 | LT       |
|   1100 | GT       |
|   1101 | LE       |
|   1110 | AL       |
|   1111 | NV       |

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

```
if ConditionHolds(condition) then constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = X[m, datasize]; (-, flags) = AddWithCarry(operand1, operand2, '0'); PSTATE.<N,Z,C,V> = flags;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.81 CCMP (immediate)

Conditional compare (immediate)

This instruction sets the value of the condition flags to the result of the comparison of a register value and an immediate value if the condition is TRUE, and an immediate value otherwise.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) CCMP <Wn>, #<imm>, #<nzcv>,
```

```
<cond>
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
1)
```

```
CCMP <Xn>, #<imm>, #<nzcv>, <cond>
```

## Decode for all variants of this encoding

```
constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant bits(4) condition = cond; bits(4) flags = nzcv; constant bits(datasize) imm = ZeroExtend(imm5,
```

## Assembler Symbols

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;imm&gt;

Is a five bit unsigned (positive) immediate encoded in the 'imm5' field.

## &lt;nzcv&gt;

Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the 'nzcv' field.

## &lt;cond&gt;

Is one of the standard conditions, encoded in the standard way, and encoded in 'cond':

|   cond | <cond>   |
|--------|----------|
|   0000 | EQ       |
|   0001 | NE       |
|   0010 | CS       |

```
datasize);
```

<!-- image -->

## &lt;Xn&gt;

|   cond | <cond>   |
|--------|----------|
|   0011 | CC       |
|   0100 | MI       |
|   0101 | PL       |
|   0110 | VS       |
|   0111 | VC       |
|   1000 | HI       |
|   1001 | LS       |
|   1010 | GE       |
|   1011 | LT       |
|   1100 | GT       |
|   1101 | LE       |
|   1110 | AL       |
|   1111 | NV       |

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
if ConditionHolds(condition) then constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = imm; (-, flags) = AddWithCarry(operand1, NOT(operand2), '1'); PSTATE.<N,Z,C,V> = flags;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.82 CCMP (register)

## Conditional compare (register)

This instruction sets the value of the condition flags to the result of the comparison of two registers if the condition is TRUE, and an immediate value otherwise.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
<cond>
```

```
0) CCMP <Wn>, <Wm>, #<nzcv>,
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
1)
```

```
CCMP <Xn>, <Xm>, #<nzcv>, <cond>
```

## Decode for all variants of this encoding

```
constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << constant bits(4) condition = cond; bits(4) flags = nzcv;
```

## Assembler Symbols

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;nzcv&gt;

Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the 'nzcv' field.

## &lt;cond&gt;

Is one of the standard conditions, encoded in the standard way, and encoded in 'cond':

|   cond | <cond>   |
|--------|----------|
|   0000 | EQ       |
|   0001 | NE       |
|   0010 | CS       |

```
UInt(sf);
```

## &lt;Xn&gt;

|   cond | <cond>   |
|--------|----------|
|   0011 | CC       |
|   0100 | MI       |
|   0101 | PL       |
|   0110 | VS       |
|   0111 | VC       |
|   1000 | HI       |
|   1001 | LS       |
|   1010 | GE       |
|   1011 | LT       |
|   1100 | GT       |
|   1101 | LE       |
|   1110 | AL       |
|   1111 | NV       |

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

```
if ConditionHolds(condition) then constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = X[m, datasize]; (-, flags) = AddWithCarry(operand1, NOT(operand2), PSTATE.<N,Z,C,V> = flags;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
'1');
```

## C6.2.83 CFINV

Invert carry flag

This instruction inverts the value of the PSTATE.C flag.

## System

(FEAT\_FlagM)

<!-- image -->

## Encoding

CFINV

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_FlagM) then EndOfDecode(Decode\_UNDEF);

## Operation

PSTATE.C = NOT(PSTATE.C);

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.84 CFP

Control flow prediction restriction by context

This instruction prevents control flow predictions that predict execution addresses based on information gathered from earlier execution within a particular execution context. Control flow predictions determined by the actions of code in the target execution context or contexts appearing in program order before the instruction cannot be used to exploitatively control speculative execution occurring after the instruction is complete and synchronized.

For more information, see CFP RCTX, Control Flow Prediction Restriction by Context.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_SPECRES)

<!-- image -->

## Encoding

<!-- image -->

and is always the preferred disassembly.

## Assembler Symbols

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rt' field.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.85 CHKFEAT

Check feature status

This instruction indicates the status of features. For more information, see Check Feature.

If FEAT\_CHK is not implemented, this instruction executes as a NOP .

## System

(FEAT\_CHK)

<!-- image -->

## Encoding

CHKFEAT X16

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_CHK) then EndOfDecode(Decode\_NOP);

## Operation

X[16, 64] = AArch64.ChkFeat(X[16, 64]);

## C6.2.86 CINC

## Conditional increment

This instruction returns, in the destination register, the value of the source register incremented by 1 if the condition is TRUE, and otherwise returns the value of the source register.

This is an alias of CSINC. This means:

- The encodings in this description are named to match the encodings of CSINC.
- The description of CSINC gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0) CINC <Wd>, <Wn>, <invcond>
```

## is equivalent to

```
CSINC <Wd>, <Wn>, <Wm>, <cond>
```

and is the preferred disassembly when Rn == Rm .

## Encoding for the 64-bit variant

```
Applies when (sf == 1) CINC <Xd>, <Xn>, <invcond>
```

## is equivalent to

```
CSINC <Xd>, <Xn>, <Xm>, <cond>
```

and is the preferred disassembly when Rn == Rm .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' and 'Rm' fields.

## &lt;invcond&gt;

Is one of the standard conditions, excluding AL and NV , encoded with its least significant bit inverted, and encoded in 'cond':

## &lt;Xd&gt;

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' and 'Rm' fields.

## Operation

The description of CSINC gives the operational pseudocode for this instruction.

## Operational Information

The description of CSINC gives the operational information for this instruction.

|   cond | <invcond>   | Description        |
|--------|-------------|--------------------|
|   0000 | NE          | Maps to <cond> EQ. |
|   0001 | EQ          | Maps to <cond> NE. |
|   0010 | CC          | Maps to <cond> CS. |
|   0011 | CS          | Maps to <cond> CC. |
|   0100 | PL          | Maps to <cond> MI. |
|   0101 | MI          | Maps to <cond> PL. |
|   0110 | VC          | Maps to <cond> VS. |
|   0111 | VS          | Maps to <cond> VC. |
|   1000 | LS          | Maps to <cond> HI. |
|   1001 | HI          | Maps to <cond> LS. |
|   1010 | LT          | Maps to <cond> GE. |
|   1011 | GE          | Maps to <cond> LT. |
|   1100 | LE          | Maps to <cond> GT. |
|   1101 | GT          | Maps to <cond> LE. |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.87 CINV

## Conditional invert

This instruction returns, in the destination register, the bitwise inversion of the value of the source register if the condition is TRUE, and otherwise returns the value of the source register.

This is an alias of CSINV. This means:

- The encodings in this description are named to match the encodings of CSINV.
- The description of CSINV gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0) CINV <Wd>, <Wn>, <invcond>
```

## is equivalent to

```
CSINV <Wd>, <Wn>, <Wm>, <cond>
```

and is the preferred disassembly when Rn == Rm .

## Encoding for the 64-bit variant

```
Applies when (sf == 1) CINV <Xd>, <Xn>, <invcond>
```

## is equivalent to

```
CSINV <Xd>, <Xn>, <Xm>, <cond>
```

and is the preferred disassembly when Rn == Rm .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' and 'Rm' fields.

## &lt;invcond&gt;

Is one of the standard conditions, excluding AL and NV , encoded with its least significant bit inverted, and encoded in 'cond':

## &lt;Xd&gt;

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' and 'Rm' fields.

## Operation

The description of CSINV gives the operational pseudocode for this instruction.

## Operational Information

The description of CSINV gives the operational information for this instruction.

|   cond | <invcond>   | Description        |
|--------|-------------|--------------------|
|   0000 | NE          | Maps to <cond> EQ. |
|   0001 | EQ          | Maps to <cond> NE. |
|   0010 | CC          | Maps to <cond> CS. |
|   0011 | CS          | Maps to <cond> CC. |
|   0100 | PL          | Maps to <cond> MI. |
|   0101 | MI          | Maps to <cond> PL. |
|   0110 | VC          | Maps to <cond> VS. |
|   0111 | VS          | Maps to <cond> VC. |
|   1000 | LS          | Maps to <cond> HI. |
|   1001 | HI          | Maps to <cond> LS. |
|   1010 | LT          | Maps to <cond> GE. |
|   1011 | GE          | Maps to <cond> LT. |
|   1100 | LE          | Maps to <cond> GT. |
|   1101 | GT          | Maps to <cond> LE. |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.88 CLRBHB

Clear branch history

This instruction can be used to clear the branch history.

For more information, see Branch history.

## System

(FEAT\_CLRBHB)

<!-- image -->

## Encoding

CLRBHB

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_CLRBHB) then EndOfDecode(Decode\_NOP);

## Operation

Hint\_CLRBHB();

## C6.2.89 CLREX

## Clear exclusive

This instruction clears the local monitor of the executing PE.

<!-- image -->

## Encoding

<!-- image -->

## Decode for this encoding

// CRm field

is ignored

## Assembler Symbols

&lt;imm&gt;

Is an optional 4-bit unsigned immediate, in the range 0 to 15, defaulting to 15 and encoded in the 'CRm' field.

## Operation

ClearExclusiveLocal(ProcessorID());

## C6.2.90 CLS

Count leading sign bits

This instruction counts the number of leading bits of the source register that have the same value as the most significant bit of the register, and writes the result to the destination register. This count does not include the most significant bit of the source register.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) CLS <Wd>, <Wn>
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) CLS <Xd>, <Xn>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 <<
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant integer result = X[d, datasize] = result<datasize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
UInt(sf);
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

```
CountLeadingSignBits(operand1);
```

## C6.2.91 CLZ

## Count leading zeros

This instruction counts the number of consecutive binary zero bits, starting from the most significant bit in the source register, and places the count in the destination register.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0) CLZ <Wd>, <Wn>
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) CLZ <Xd>, <Xn>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 <<
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant integer result = X[d, datasize] = result<datasize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
UInt(sf);
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

```
CountLeadingZeroBits(operand1);
```

## C6.2.92 CMN (extended register)

Compare negative (extended register)

This instruction adds a register value and a sign or zero-extended register value, followed by an optional left shift amount. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result, and discards the result.

This is an alias of ADDS (extended register). This means:

- The encodings in this description are named to match the encodings of ADDS (extended register).
- The description of ADDS (extended register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) CMN <Wn|WSP>, <Wm>{, <extend> {#<amount>}} is equivalent to ADDS WZR, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (sf == 1) CMN <Xn|SP>, <R><m>{, <extend>
```

```
{#<amount>}} is equivalent to ADDS XZR, <Xn|SP>, <R><m>{, <extend> {#<amount>}}
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wn|WSP&gt;

Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;extend&gt;

For the '32-bit' variant: is the extension to be applied to the second source operand, encoded in 'option':

Is a width specifier, encoded in 'option':

|   option | <extend>      |
|----------|---------------|
|      000 | UXTB          |
|      001 | UXTH          |
|      010 | LSL&#124;UXTW |
|      011 | UXTX          |
|      100 | SXTB          |
|      101 | SXTH          |
|      110 | SXTW          |
|      111 | SXTX          |

If 'Rn' is '11111' (WSP) and 'option' is '010' then LSL is preferred, but may be omitted when 'imm3' is '000'. In all other cases &lt;extend&gt; is required and must be UXTW when 'option' is '010'.

For the '64-bit' variant: is the extension to be applied to the second source operand, encoded in 'option':

|   option | <extend>      |
|----------|---------------|
|      000 | UXTB          |
|      001 | UXTH          |
|      010 | UXTW          |
|      011 | LSL&#124;UXTX |
|      100 | SXTB          |
|      101 | SXTH          |
|      110 | SXTW          |
|      111 | SXTX          |

If 'Rn' is '11111' (SP) and 'option' is '011' then LSL is preferred, but may be omitted when 'imm3' is '000'. In all other cases &lt;extend&gt; is required and must be UXTX when 'option' is '011'.

## &lt;amount&gt;

Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the 'imm3' field. It must be absent when &lt;extend&gt; is absent, is required when &lt;extend&gt; is LSL, and is optional when &lt;extend&gt; is present but not LSL.

## &lt;Xn|SP&gt;

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;R&gt;

| option   | <R>   |
|----------|-------|
| 00x      | W     |
| 010      | W     |

## &lt;m&gt;

Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the 'Rm' field.

## Operation

The description of ADDS (extended register) gives the operational pseudocode for this instruction.

## Operational Information

The description of ADDS (extended register) gives the operational information for this instruction.

| option   | <R>   |
|----------|-------|
| x11      | X     |
| 10x      | W     |
| 110      | W     |

## C6.2.93 CMN (immediate)

Compare negative (immediate)

This instruction adds a register value and an optionally-shifted immediate value. It updates the condition flags based on the result, and discards the result.

This is an alias of ADDS (immediate). This means:

- The encodings in this description are named to match the encodings of ADDS (immediate).
- The description of ADDS (immediate) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0)
```

```
CMN <Wn|WSP>, #<imm>{, <shift>} is equivalent to ADDS WZR, <Wn|WSP>, #<imm>{, <shift>}
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (sf == 1) CMN <Xn|SP>, #<imm>{, <shift>} is equivalent to ADDS XZR, <Xn|SP>, #<imm>{, <shift>}
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wn|WSP&gt;

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is an unsigned immediate, in the range 0 to 4095, encoded in the 'imm12' field.

## &lt;shift&gt;

Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in 'sh':

## &lt;Xn|SP&gt;

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of ADDS (immediate) gives the operational pseudocode for this instruction.

## Operational Information

The description of ADDS (immediate) gives the operational information for this instruction.

|   sh | <shift>   |
|------|-----------|
|    0 | LSL #0    |
|    1 | LSL #12   |

## C6.2.94 CMN (shifted register)

Compare negative (shifted register)

This instruction adds a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result.

This is an alias of ADDS (shifted register). This means:

- The encodings in this description are named to match the encodings of ADDS (shifted register).
- The description of ADDS (shifted register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0)
```

```
CMN <Wn>, <Wm>{, <shift> #<amount>}
```

## is equivalent to

```
ADDS WZR, <Wn>, <Wm>{, <shift> #<amount>}
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

Applies when (sf ==

```
1) CMN <Xn>, <Xm>{, <shift> #<amount>} is equivalent to ADDS XZR, <Xn>, <Xm>{, <shift> #<amount>}
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded in 'shift':

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xn&gt;

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |
|      10 | ASR       |
|      11 | RESERVED  |

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

The description of ADDS (shifted register) gives the operational pseudocode for this instruction.

## Operational Information

The description of ADDS (shifted register) gives the operational information for this instruction.

## C6.2.95 CMP (extended register)

Compare (extended register)

This instruction subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result, and discards the result.

This is an alias of SUBS (extended register). This means:

- The encodings in this description are named to match the encodings of SUBS (extended register).
- The description of SUBS (extended register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) CMP <Wn|WSP>, <Wm>{, <extend> {#<amount>}} is equivalent to SUBS WZR, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (sf == 1) CMP <Xn|SP>, <R><m>{, <extend>
```

```
{#<amount>}} is equivalent to SUBS XZR, <Xn|SP>, <R><m>{, <extend> {#<amount>}}
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wn|WSP&gt;

Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;extend&gt;

For the '32-bit' variant: is the extension to be applied to the second source operand, encoded in 'option':

Is a width specifier, encoded in 'option':

|   option | <extend>      |
|----------|---------------|
|      000 | UXTB          |
|      001 | UXTH          |
|      010 | LSL&#124;UXTW |
|      011 | UXTX          |
|      100 | SXTB          |
|      101 | SXTH          |
|      110 | SXTW          |
|      111 | SXTX          |

If 'Rn' is '11111' (WSP) and 'option' is '010' then LSL is preferred, but may be omitted when 'imm3' is '000'. In all other cases &lt;extend&gt; is required and must be UXTW when 'option' is '010'.

For the '64-bit' variant: is the extension to be applied to the second source operand, encoded in 'option':

|   option | <extend>      |
|----------|---------------|
|      000 | UXTB          |
|      001 | UXTH          |
|      010 | UXTW          |
|      011 | LSL&#124;UXTX |
|      100 | SXTB          |
|      101 | SXTH          |
|      110 | SXTW          |
|      111 | SXTX          |

If 'Rn' is '11111' (SP) and 'option' is '011' then LSL is preferred, but may be omitted when 'imm3' is '000'. In all other cases &lt;extend&gt; is required and must be UXTX when 'option' is '011'.

## &lt;amount&gt;

Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the 'imm3' field. It must be absent when &lt;extend&gt; is absent, is required when &lt;extend&gt; is LSL, and is optional when &lt;extend&gt; is present but not LSL.

## &lt;Xn|SP&gt;

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;R&gt;

| option   | <R>   |
|----------|-------|
| 00x      | W     |
| 010      | W     |

## &lt;m&gt;

Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the 'Rm' field.

## Operation

The description of SUBS (extended register) gives the operational pseudocode for this instruction.

## Operational Information

The description of SUBS (extended register) gives the operational information for this instruction.

| option   | <R>   |
|----------|-------|
| x11      | X     |
| 10x      | W     |
| 110      | W     |

## C6.2.96 CMP (immediate)

Compare (immediate)

This instruction subtracts an optionally-shifted immediate value from a register value. It updates the condition flags based on the result, and discards the result.

This is an alias of SUBS (immediate). This means:

- The encodings in this description are named to match the encodings of SUBS (immediate).
- The description of SUBS (immediate) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0) CMP <Wn|WSP>, #<imm>{, <shift>} is equivalent to SUBS WZR, <Wn|WSP>, #<imm>{, <shift>}
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (sf == 1) CMP <Xn|SP>, #<imm>{, <shift>} is equivalent to SUBS XZR, <Xn|SP>, #<imm>{, <shift>}
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wn|WSP&gt;

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is an unsigned immediate, in the range 0 to 4095, encoded in the 'imm12' field.

## &lt;shift&gt;

Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in 'sh':

## &lt;Xn|SP&gt;

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of SUBS (immediate) gives the operational pseudocode for this instruction.

## Operational Information

The description of SUBS (immediate) gives the operational information for this instruction.

|   sh | <shift>   |
|------|-----------|
|    0 | LSL #0    |
|    1 | LSL #12   |

## C6.2.97 CMP (shifted register)

Compare (shifted register)

This instruction subtracts an optionally-shifted register value from a register value. It updates the condition flags based on the result, and discards the result.

This is an alias of SUBS (shifted register). This means:

- The encodings in this description are named to match the encodings of SUBS (shifted register).
- The description of SUBS (shifted register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0)
```

```
CMP <Wn>, <Wm>{, <shift> #<amount>} is equivalent to SUBS WZR, <Wn>, <Wm>{, <shift> #<amount>}
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

Applies when (sf ==

```
1) CMP <Xn>, <Xm>{, <shift> #<amount>} is equivalent to SUBS XZR, <Xn>, <Xm>{, <shift> #<amount>}
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded in 'shift':

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xn&gt;

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |
|      10 | ASR       |
|      11 | RESERVED  |

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

The description of SUBS (shifted register) gives the operational pseudocode for this instruction.

## Operational Information

The description of SUBS (shifted register) gives the operational information for this instruction.

## C6.2.98 CMPP

Compare with tag

This instruction subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, updates the condition flags based on the result of the subtraction, and discards the result.

This is an alias of SUBPS. This means:

- The encodings in this description are named to match the encodings of SUBPS.
- The description of SUBPS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_MTE)

<!-- image -->

## Encoding

```
CMPP <Xn|SP>, <Xm|SP>
```

## is equivalent to

```
SUBPS <Xd>, <Xn|SP>, <Xm|SP>
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Xn|SP&gt;

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm|SP&gt;

Is the 64-bit name of the second general-purpose source register or stack pointer, encoded in the 'Rm' field.

## Operation

The description of SUBPS gives the operational pseudocode for this instruction.

## C6.2.99 CNEG

Conditional negate

This instruction returns, in the destination register, the negated value of the source register if the condition is TRUE, and otherwise returns the value of the source register.

This is an alias of CSNEG. This means:

- The encodings in this description are named to match the encodings of CSNEG.
- The description of CSNEG gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0)
```

```
CNEG <Wd>, <Wn>, <invcond>
```

## is equivalent to

```
CSNEG <Wd>, <Wn>, <Wm>, <cond>
```

and is the preferred disassembly when Rn == Rm .

## Encoding for the 64-bit variant

Applies when (sf ==

```
1) CNEG <Xd>, <Xn>, <invcond>
```

## is equivalent to

```
CSNEG <Xd>, <Xn>, <Xm>, <cond>
```

and is the preferred disassembly when Rn == Rm .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' and 'Rm' fields.

## &lt;invcond&gt;

Is one of the standard conditions, excluding AL and NV , encoded with its least significant bit inverted, and encoded in 'cond':

## &lt;Xd&gt;

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' and 'Rm' fields.

## Operation

The description of CSNEG gives the operational pseudocode for this instruction.

## Operational Information

The description of CSNEG gives the operational information for this instruction.

|   cond | <invcond>   | Description        |
|--------|-------------|--------------------|
|   0000 | NE          | Maps to <cond> EQ. |
|   0001 | EQ          | Maps to <cond> NE. |
|   0010 | CC          | Maps to <cond> CS. |
|   0011 | CS          | Maps to <cond> CC. |
|   0100 | PL          | Maps to <cond> MI. |
|   0101 | MI          | Maps to <cond> PL. |
|   0110 | VC          | Maps to <cond> VS. |
|   0111 | VS          | Maps to <cond> VC. |
|   1000 | LS          | Maps to <cond> HI. |
|   1001 | HI          | Maps to <cond> LS. |
|   1010 | LT          | Maps to <cond> GE. |
|   1011 | GE          | Maps to <cond> LT. |
|   1100 | LE          | Maps to <cond> GT. |
|   1101 | GT          | Maps to <cond> LE. |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.100 CNT

## Count bits

This instruction counts the number of binary one bits in the value of the source register, and writes the result to the destination register.

## Integer

(FEAT\_CSSC)

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

CNT

&lt;Wd&gt;, &lt;Wn&gt;

## Encoding for the 64-bit variant

Applies when (sf == 1)

```
CNT <Xd>, <Xn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CSSC) then constant integer datasize = 32 << UInt(sf); constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand1 = constant integer result = BitCount(operand1); X[d, datasize] = result<datasize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

```
X[n, datasize];
```

## C6.2.101 COSP

Clear other speculative prediction restriction by context

This instruction prevents predictions, other than Cache prefetch, Control flow, and Data Value predictions, that predict execution addresses based on information gathered from earlier execution within a particular execution context. Predictions, other than Cache prefetch, Control flow, and Data Value predictions, determined by the actions of code in the target execution context or contexts appearing in program order before the instruction cannot exploitatively control any speculative access occurring after the instruction is complete and synchronized.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_SPECRES2)

<!-- image -->

## Encoding

<!-- image -->

and is always the preferred disassembly.

## Assembler Symbols

&lt;Xt&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rt' field.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.102 CPP

Cache prefetch prediction restriction by context

This instruction prevents cache allocation predictions that predict execution addresses based on information gathered from earlier execution within a particular execution context. The actions of code in the target execution context or contexts appearing in program order before the instruction cannot exploitatively control cache prefetch predictions occurring after the instruction is complete and synchronized.

For more information, see CPP RCTX, Cache Prefetch Prediction Restriction by Context.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_SPECRES)

<!-- image -->

## Encoding

<!-- image -->

and is always the preferred disassembly.

## Assembler Symbols

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rt' field.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.103 CPYFP, CPYFM, CPYFE

Memory copy forward-only

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFP, then CPYFM, and then CPYFE.

CPYFP performs some preconditioning of the arguments suitable for using the CPYFM instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFM copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFE copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For CPYFP:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFP, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFP, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFM, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFM, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFE, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYFE, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYFP [<Xd>]!, [<Xs>]!,
```

```
<Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFM [<Xd>]!, [<Xs>]!,
```

```
<Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFE [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of
```

```
when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.104 CPYFPN, CPYFMN, CPYFEN

Memory copy forward-only, reads and writes non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPN, then CPYFMN, and then CPYFEN.

CPYFPN performs some preconditioning of the arguments suitable for using the CPYFMN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFEN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For CPYFPN:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPN, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPN, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFEN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYFEN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYFPN [<Xd>]!, [<Xs>]!,
```

```
<Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFMN [<Xd>]!, [<Xs>]!,
```

```
<Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFEN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of
```

```
when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.105 CPYFPRN, CPYFMRN, CPYFERN

Memory copy forward-only, reads non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRN, then CPYFMRN, and then CPYFERN.

CPYFPRN performs some preconditioning of the arguments suitable for using the CPYFMRN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMRN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFERN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For CPYFPRN:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPRN, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPRN, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

## For CPYFERN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYFERN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYFPRN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFMRN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFERN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of
```

```
when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.106 CPYFPRT, CPYFMRT, CPYFERT

Memory copy forward-only, reads unprivileged

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRT, then CPYFMRT, and then CPYFERT.

CPYFPRT performs some preconditioning of the arguments suitable for using the CPYFMRT instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMRT copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFERT copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For CPYFPRT:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPRT, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPRT, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMRT, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMRT, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFERT, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

For CPYFERT, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

Explicit Memory Read effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Read effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

<!-- image -->

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFMRT [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFERT [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0);
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then
```

```
if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.107 CPYFPRTN, CPYFMRTN, CPYFERTN

Memory copy forward-only, reads unprivileged, reads and writes non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTN, then CPYFMRTN, and then CPYFERTN.

CPYFPRTN performs some preconditioning of the arguments suitable for using the CPYFMRTN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMRTN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFERTN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For CPYFPRTN:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPRTN, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPRTN, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMRTN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMRTN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFERTN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

For CPYFERTN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

Explicit Memory Read effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Read effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYFPRTN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFMRTN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFERTN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0);
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then
```

```
if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.108 CPYFPRTRN, CPYFMRTRN, CPYFERTRN

Memory copy forward-only, reads unprivileged and non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTRN, then CPYFMRTRN, and then CPYFERTRN.

CPYFPRTRN performs some preconditioning of the arguments suitable for using the CPYFMRTRN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMRTRN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFERTRN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For CPYFPRTRN:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPRTRN, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPRTRN, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMRTRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMRTRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFERTRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

For CPYFERTRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

Explicit Memory Read effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Read effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYFPRTRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFMRTRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFERTRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0);
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then
```

```
if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.109 CPYFPRTWN, CPYFMRTWN, CPYFERTWN

Memory copy forward-only, reads unprivileged, writes non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTWN, then CPYFMRTWN, and then CPYFERTWN.

CPYFPRTWN performs some preconditioning of the arguments suitable for using the CPYFMRTWN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMRTWN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFERTWN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For CPYFPRTWN:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPRTWN, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPRTWN, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMRTWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMRTWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFERTWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

For CPYFERTWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

Explicit Memory Read effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Read effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

<!-- image -->

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFMRTWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFERTWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0);
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then
```

```
if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.110 CPYFPT, CPYFMT, CPYFET

Memory copy forward-only, reads and writes unprivileged

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPT, then CPYFMT, and then CPYFET.

CPYFPT performs some preconditioning of the arguments suitable for using the CPYFMT instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMT copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFET copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For CPYFPT:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPT, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPT, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMT, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMT, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFET, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

For CPYFET, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

<!-- image -->

## Encoding for the Main variant

<!-- image -->

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFET [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0);
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then
```

```
if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.111 CPYFPTN, CPYFMTN, CPYFETN

Memory copy forward-only, reads and writes unprivileged and non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTN, then CPYFMTN, and then CPYFETN.

CPYFPTN performs some preconditioning of the arguments suitable for using the CPYFMTN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMTN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFETN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For CPYFPTN:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPTN, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPTN, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMTN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMTN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFETN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

For CPYFETN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

<!-- image -->

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFMTN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFETN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0);
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then
```

```
if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.112 CPYFPTRN, CPYFMTRN, CPYFETRN

Memory copy forward-only, reads and writes unprivileged, reads non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTRN, then CPYFMTRN, and then CPYFETRN.

CPYFPTRN performs some preconditioning of the arguments suitable for using the CPYFMTRN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMTRN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFETRN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYFPTRN:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPTRN, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPTRN, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMTRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMTRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFETRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

For CPYFETRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYFPTRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFMTRN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFETRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0);
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then
```

```
if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.113 CPYFPTWN, CPYFMTWN, CPYFETWN

Memory copy forward-only, reads and writes unprivileged, writes non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTWN, then CPYFMTWN, and then CPYFETWN.

CPYFPTWNperforms some preconditioning of the arguments suitable for using the CPYFMTWN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMTWN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFETWN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For CPYFPTWN:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPTWN, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPTWN, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMTWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMTWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFETWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

For CPYFETWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYFPTWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFMTWN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFETWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0);
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then
```

```
if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.114 CPYFPWN, CPYFMWN, CPYFEWN

Memory copy forward-only, writes non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWN, then CPYFMWN, and then CPYFEWN.

CPYFPWNperforms some preconditioning of the arguments suitable for using the CPYFMWN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMWN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFEWN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For CPYFPWN:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPWN, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPWN, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFEWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYFEWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYFPWN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFMWN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFEWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of
```

```
when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

<!-- image -->

## &lt;Xn&gt;

```
else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.115 CPYFPWT, CPYFMWT, CPYFEWT

Memory copy forward-only, writes unprivileged

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWT, then CPYFMWT, and then CPYFEWT.

CPYFPWT performs some preconditioning of the arguments suitable for using the CPYFMWT instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMWT copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFEWT copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For CPYFPWT:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPWT, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPWT, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMWT, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMWT, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFEWT, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

For CPYFEWT, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

Explicit Memory Write effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Write effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

<!-- image -->

## Encoding for the Main variant

<!-- image -->

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFEWT [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0);
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then
```

```
if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.116 CPYFPWTN, CPYFMWTN, CPYFEWTN

Memory copy forward-only, writes unprivileged, reads and writes non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTN, then CPYFMWTN, and then CPYFEWTN.

CPYFPWTNperforms some preconditioning of the arguments suitable for using the CPYFMWTN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMWTN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFEWTN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For CPYFPWTN:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPWTN, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPWTN, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMWTN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMWTN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFEWTN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

For CPYFEWTN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

Explicit Memory Write effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Write effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYFPWTN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFMWTN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFEWTN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0);
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then
```

```
if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.117 CPYFPWTRN, CPYFMWTRN, CPYFEWTRN

Memory copy forward-only, writes unprivileged, reads non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTRN, then CPYFMWTRN, and then CPYFEWTRN.

CPYFPWTRNperforms some preconditioning of the arguments suitable for using the CPYFMWTRN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMWTRN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFEWTRN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYFPWTRN:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPWTRN, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPWTRN, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMWTRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMWTRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFEWTRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

For CPYFEWTRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

Explicit Memory Write effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Write effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYFPWTRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFMWTRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFEWTRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0);
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then
```

```
if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.118 CPYFPWTWN, CPYFMWTWN, CPYFEWTWN

Memory copy forward-only, writes unprivileged and non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address in a forward direction. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTWN, then CPYFMWTWN, and then CPYFEWTWN.

CPYFPWTWNperforms some preconditioning of the arguments suitable for using the CPYFMWTWN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYFMWTWN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYFEWTWN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The memory copy performed by these instructions is in the forward direction only, so the instructions are suitable for a memory copy only where there is no overlap between the source and destination locations, or where the source address is greater than or equal to the destination address.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYFPWTWN:

- If Xn&lt;63&gt; == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of CPYFPWTWN, option A:

- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of CPYFPWTWN, option B:

- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For CPYFMWTWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.

For CPYFMWTWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be copied.

- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

For CPYFEWTWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.

For CPYFEWTWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xn holds 0.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.

Explicit Memory Write effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Write effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYFPWTWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYFMWTWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYFEWTWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYFOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0);
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize<63> == '1' then memcpy.cpysize = ArchMaxMOPSBlockSize; if memcpy.implements_option_a then memcpy.nzcv = '0000'; // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; memcpy.forward = TRUE; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then
```

```
if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); if IsFault(memstatus) then constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.119 CPYP, CPYM, CPYE

## Memory copy

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYP, then CPYM, and then CPYE.

CPYP performs some preconditioning of the arguments suitable for using the CPYM instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYM copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYE copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYP:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward. Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYP, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYP, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYM, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYM, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.
- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.
- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYE, option A, when PSTATE.C = 0:

## For CPYE, option B, when PSTATE.C = 1:

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYP [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYM [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYE [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

&lt;Xs&gt;

## &lt;Xn&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite;
```

```
AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B;
```

```
memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.120 CPYPN, CPYMN, CPYEN

Memory copy, reads and writes non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPN, then CPYMN, and then CPYEN.

CPYPN performs some preconditioning of the arguments suitable for using the CPYMN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYEN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPN:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward. Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPN, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPN, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYEN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYEN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMN [<Xd>]!, [<Xs>]!,
```

```
<Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYEN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

&lt;Xs&gt;

## &lt;Xn&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite;
```

```
AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B;
```

```
memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.121 CPYPRN, CPYMRN, CPYERN

Memory copy, reads non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRN, then CPYMRN, and then CPYERN.

CPYPRN performs some preconditioning of the arguments suitable for using the CPYMRN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMRN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYERN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPRN:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward.

If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward.

Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPRN, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPRN, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYERN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYERN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYERN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

&lt;Xs&gt;

## &lt;Xn&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite;
```

```
AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B;
```

```
memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.122 CPYPRT, CPYMRT, CPYERT

Memory copy, reads unprivileged

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRT, then CPYMRT, and then CPYERT.

CPYPRT performs some preconditioning of the arguments suitable for using the CPYMRT instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMRT copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYERT copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPRT:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward.

Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPRT, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPRT, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMRT, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMRT, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYERT, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYERT, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

Explicit Memory Read effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Read effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPRT [<Xd>]!, [<Xs>]!,
```

```
<Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMRT [<Xd>]!, [<Xs>]!,
```

```
<Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYERT [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress,
```

```
memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B; memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.123 CPYPRTN, CPYMRTN, CPYERTN

Memory copy, reads unprivileged, reads and writes non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTN, then CPYMRTN, and then CPYERTN.

CPYPRTN performs some preconditioning of the arguments suitable for using the CPYMRTN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMRTN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYERTN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPRTN:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward. Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPRTN, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPRTN, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMRTN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMRTN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYERTN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYERTN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

Explicit Memory Read effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Read effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPRTN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMRTN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYERTN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress,
```

```
memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B; memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.124 CPYPRTRN, CPYMRTRN, CPYERTRN

Memory copy, reads unprivileged and non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTRN, then CPYMRTRN, and then CPYERTRN.

CPYPRTRN performs some preconditioning of the arguments suitable for using the CPYMRTRN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMRTRN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYERTRN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPRTRN:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward.

If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward.

Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPRTRN, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPRTRN, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMRTRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMRTRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYERTRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYERTRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

Explicit Memory Read effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Read effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPRTRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMRTRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYERTRN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress,
```

```
memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B; memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.125 CPYPRTWN, CPYMRTWN, CPYERTWN

Memory copy, reads unprivileged, writes non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTWN, then CPYMRTWN, and then CPYERTWN.

CPYPRTWNperforms some preconditioning of the arguments suitable for using the CPYMRTWN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMRTWN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYERTWN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPRTWN:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward. Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPRTWN, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPRTWN, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMRTWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMRTWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYERTWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYERTWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

Explicit Memory Read effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Read effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPRTWN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMRTWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYERTWN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress,
```

```
memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B; memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.126 CPYPT, CPYMT, CPYET

Memory copy, reads and writes unprivileged

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPT, then CPYMT, and then CPYET.

CPYPT performs some preconditioning of the arguments suitable for using the CPYMT instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMT copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYET copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPT:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward. Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPT, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPT, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMT, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMT, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYET, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYET, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPT [<Xd>]!, [<Xs>]!,
```

```
<Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMT [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYET [<Xd>]!, [<Xs>]!,
```

```
<Xn>!
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress,
```

```
memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B; memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.127 CPYPTN, CPYMTN, CPYETN

Memory copy, reads and writes unprivileged and non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTN, then CPYMTN, and then CPYETN.

CPYPTN performs some preconditioning of the arguments suitable for using the CPYMTN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMTN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYETN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPTN:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward.

Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPTN, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPTN, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMTN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMTN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYETN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYETN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPTN [<Xd>]!, [<Xs>]!,
```

```
<Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMTN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYETN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress,
```

```
memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B; memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.128 CPYPTRN, CPYMTRN, CPYETRN

Memory copy, reads and writes unprivileged, reads non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTRN, then CPYMTRN, and then CPYETRN.

CPYPTRN performs some preconditioning of the arguments suitable for using the CPYMTRN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMTRN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYETRN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPTRN:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward. Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPTRN, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPTRN, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMTRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMTRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYETRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYETRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPTRN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMTRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYETRN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress,
```

```
memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B; memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.129 CPYPTWN, CPYMTWN, CPYETWN

Memory copy, reads and writes unprivileged, writes non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTWN, then CPYMTWN, and then CPYETWN.

CPYPTWNperforms some preconditioning of the arguments suitable for using the CPYMTWN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMTWN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYETWN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPTWN:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward. Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPTWN, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPTWN, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMTWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMTWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYETWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYETWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPTWN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMTWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYETWN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress,
```

```
memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B; memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.130 CPYPWN, CPYMWN, CPYEWN

Memory copy, writes non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWN, then CPYMWN, and then CPYEWN.

CPYPWNperforms some preconditioning of the arguments suitable for using the CPYMWN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMWN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYEWN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPWN:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward. Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPWN, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPWN, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYEWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYEWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYEWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

&lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

&lt;Xs&gt;

## &lt;Xn&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize; else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite;
```

```
AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B;
```

```
memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.131 CPYPWT, CPYMWT, CPYEWT

Memory copy, writes unprivileged

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWT, then CPYMWT, and then CPYEWT.

CPYPWTperforms some preconditioning of the arguments suitable for using the CPYMWT instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMWT copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYEWT copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPWT:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward. Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPWT, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPWT, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMWT, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMWT, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYEWT, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYEWT, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

Explicit Memory Write effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Write effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPWT [<Xd>]!, [<Xs>]!,
```

```
<Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMWT [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYEWT [<Xd>]!, [<Xs>]!,
```

```
<Xn>!
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress,
```

```
memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B; memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.132 CPYPWTN, CPYMWTN, CPYEWTN

Memory copy, writes unprivileged, reads and writes non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTN, then CPYMWTN, and then CPYEWTN.

CPYPWTNperforms some preconditioning of the arguments suitable for using the CPYMWTN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMWTN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYEWTN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPWTN:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward. Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPWTN, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPWTN, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMWTN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMWTN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYEWTN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYEWTN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

Explicit Memory Write effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Write effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPWTN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMWTN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYEWTN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(Decode_UNDEF); CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress,
```

```
memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B; memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.133 CPYPWTRN, CPYMWTRN, CPYEWTRN

Memory copy, writes unprivileged, reads non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTRN, then CPYMWTRN, and then CPYEWTRN.

CPYPWTRNperforms some preconditioning of the arguments suitable for using the CPYMWTRN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMWTRN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYEWTRN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPWTRN:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward.

Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPWTRN, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPWTRN, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMWTRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMWTRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYEWTRN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYEWTRN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

Explicit Memory Write effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Write effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPWTRN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMWTRN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYEWTRN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress,
```

```
memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B; memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.134 CPYPWTWN, CPYMWTWN, CPYEWTWN

Memory copy, writes unprivileged and non-temporal

These instructions copy a requested number of bytes in memory from a source address to a destination address. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTWN,then CPYMWTWN, and then CPYEWTWN.

CPYPWTWNperforms some preconditioning of the arguments suitable for using the CPYMWTWN instruction, and copies an IMPLEMENTATION DEFINED portion of the requested number of bytes. CPYMWTWN copies a further IMPLEMENTATION DEFINED portion of the remaining bytes. CPYEWTWN copies any final remaining bytes.

Note

The ability to copy an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being copied are divided between the different instructions.

For more information on exceptions specific to memory copy instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory copy: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

## For CPYPWTWN:

- If Xn&lt;63:55&gt; != 000000000, the copy size Xn is saturated to 0x007FFFFFFFFFFFFF .
- After saturation is performed, the direction of the memory copy is based on the following: If (Xs&lt;55:0&gt; &gt; Xd&lt;55:0&gt;) and (Xd&lt;55:0&gt; + saturated copy size) &gt; Xs&lt;55:0&gt;, then the direction is forward. If (Xs&lt;55:0&gt; &lt; Xd&lt;55:0&gt;) and (Xs&lt;55:0&gt; + saturated copy size) &gt; Xd&lt;55:0&gt;, then the direction is backward. Otherwise, the direction is an IMPLEMENTATION DEFINED choice between forward and backward.

On completion of CPYPWTWN, option A:

- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
- If the copy is in the forward direction, then:
- Xn holds -1 times the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the original Xs + saturated copy size.
- Xd holds the original Xd + saturated copy size.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs and Xd are unchanged.

On completion of CPYPWTWN, option B:

- If the copy is in the forward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the lowest address that has not been copied from.
- Xd holds the lowest address that has not been copied to.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
- If the copy is in the backward direction, then:
- Xn holds the number of bytes in the saturated copy size remaining to be copied.
- Xs holds the highest address that has not been copied from + 1.
- Xd holds the highest address that has not been copied to + 1.
- PSTATE.{N,Z,C,V} are set to {1,0,1,0}.

For CPYMWTWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.

- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be copied.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds the number of bytes remaining to be copied.

## For CPYMWTWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds the number of bytes remaining to be copied.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

## For CPYEWTWN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- If the copy is in the forward direction (Xn holds a negative number), then:
- Xn holds -1 times the number of bytes remaining to be copied.
- Xs holds the lowest address to be copied from - Xn.
- Xd holds the lowest address to be copied to - Xn.
- On completion of the instruction, Xn holds 0.
- If the copy is in the backward direction (Xn holds a positive number), then:
- Xn holds the number of bytes remaining to be copied.
- Xs holds the highest address to be copied from + 1 - Xn.
- Xd holds the highest address to be copied to + 1 - Xn.
- On completion of the instruction, Xn holds 0.

## For CPYEWTWN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be copied.
- If the copy is in the forward direction (PSTATE.N == 0), then:
- Xs holds the lowest address to be copied from.
- Xd holds the lowest address to be copied to.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the lowest address that has not been copied from.
- Xdholds the lowest address that has not been copied to.
- If the copy is in the backward direction (PSTATE.N == 1), then:
- Xs holds the highest address to be copied from + 1.
- Xd holds the highest address to be copied to + 1.
- On completion of the instruction:
- Xnholds 0.
- Xsholds the highest address that has not been copied from + 1.
- Xdholds the highest address that has not been copied to + 1.

Explicit Memory Write effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Write effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op1 == 00) CPYPWTWN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Main variant

```
Applies when (op1 == 01) CPYMWTWN [<Xd>]!, [<Xs>]!, <Xn>!
```

## Encoding for the Epilogue variant

```
Applies when (op1 == 10) CPYEWTWN
```

```
[<Xd>]!, [<Xs>]!, <Xn>!
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != CPYParams memcpy; memcpy.d = UInt(Rd); memcpy.s = UInt(Rs); memcpy.n = UInt(Rn); constant bits(4) options = op2; constant boolean rnontemporal = options<3> == '1'; constant boolean wnontemporal = options<2> == '1'; case op1 of when '00' memcpy.stage = MOPSStage_Prologue; when '01' memcpy.stage = MOPSStage_Main; when '10' memcpy.stage = MOPSStage_Epilogue;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set CPY* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the source address and is updated by the instruction, encoded in the 'Rs' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the source address, encoded in the 'Rs' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be transferred and is updated by the instruction to encode the remaining size and destination, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be transferred and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## Operation

```
CheckMOPSEnabled(); CheckCPYConstrainedUnpredictable(memcpy.n, memcpy.d, memcpy.s); memcpy.nzcv = PSTATE.<N,Z,C,V>; memcpy.toaddress = X[memcpy.d, 64]; memcpy.fromaddress = X[memcpy.s, 64]; if memcpy.stage == MOPSStage_Prologue then memcpy.cpysize = UInt(X[memcpy.n, 64]); else memcpy.cpysize = SInt(X[memcpy.n, 64]); memcpy.implements_option_a = CPYOptionA(); constant boolean rprivileged = (if options<1> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant boolean wprivileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal); constant AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal); if memcpy.stage == MOPSStage_Prologue then if memcpy.cpysize > ArchMaxMOPSCPYSize then memcpy.cpysize = ArchMaxMOPSCPYSize; memcpy.forward = IsMemCpyForward(memcpy); if memcpy.implements_option_a then memcpy.nzcv = '0000'; if memcpy.forward then // Copy in the forward direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.cpysize = 0 -memcpy.cpysize;
```

## &lt;Xs&gt;

## &lt;Xn&gt;

```
else if !memcpy.forward then // Copy in the reverse direction offsets the arguments. memcpy.toaddress = memcpy.toaddress + memcpy.cpysize; memcpy.fromaddress = memcpy.fromaddress + memcpy.cpysize; memcpy.nzcv = '1010'; else memcpy.nzcv = '0010'; memcpy.stagecpysize = MemCpyStageSize(memcpy); if memcpy.stage != MOPSStage_Prologue then memcpy.forward = memcpy.cpysize < 0 || (!memcpy.implements_option_a && memcpy.nzcv<3> == '0'); CheckMemCpyParams(memcpy, options); integer copied; boolean iswrite; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; boolean fault = FALSE; MOPSBlockSize B = 0; if memcpy.implements_option_a then while memcpy.stagecpysize != 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); if memcpy.forward then assert B <= -1 * memcpy.stagecpysize; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else assert B <= memcpy.stagecpysize; memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes( memcpy.toaddress + memcpy.cpysize, memcpy.fromaddress + memcpy.cpysize, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; memcpy.cpysize = memcpy.cpysize + B; memcpy.stagecpysize = memcpy.stagecpysize + B; else while memcpy.stagecpysize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = CPYSizeChoice(memcpy); assert B <= memcpy.stagecpysize; if memcpy.forward then (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress, memcpy.fromaddress,
```

```
memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress + B; memcpy.toaddress = memcpy.toaddress + B; else (copied, iswrite, memaddrdesc, memstatus) = MemCpyBytes(memcpy.toaddress -B, memcpy.fromaddress -B, memcpy.forward, B, raccdesc, waccdesc); if copied != B then fault = TRUE; else memcpy.fromaddress = memcpy.fromaddress -B; memcpy.toaddress = memcpy.toaddress -B; if !fault then memcpy.cpysize = memcpy.cpysize -B; memcpy.stagecpysize = memcpy.stagecpysize -B; UpdateCpyRegisters(memcpy, fault, copied); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant AccessDescriptor accdesc = if iswrite then waccdesc else raccdesc; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memcpy.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memcpy.nzcv;
```

## C6.2.135 CRC32B, CRC32H, CRC32W, CRC32X

## CRC32 checksum

This instruction performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x04C11DB7 is used for the CRC calculation.

In an Armv8.0 implementation, this is an OPTIONAL instruction. From Armv8.1, it is mandatory for all implementations to implement this instruction.

## Note

ID\_AA64ISAR0\_EL1.CRC32 indicates whether this instruction is supported.

## CRC

(FEAT\_CRC32)

<!-- image -->

## Encoding for the CRC32B variant

```
Applies when (sf == 0 && sz == 00)
```

```
CRC32B <Wd>, <Wn>, <Wm>
```

## Encoding for the CRC32H variant

Applies when (sf

```
CRC32H <Wd>,
```

```
== 0 && sz == 01) <Wn>, <Wm>
```

## Encoding for the CRC32W variant

```
Applies when (sf
```

```
== 0 && sz == 10) CRC32W <Wd>, <Wn>, <Wm>
```

## Encoding for the CRC32X variant

Applies when (sf == 1 &amp;&amp; sz == 11)

```
CRC32X <Wd>, <Wn>, <Xm>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CRC32) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); if sf == '1' && sz != '11' then EndOfDecode(Decode_UNDEF); if sf == '0' && sz == '11' then EndOfDecode(Decode_UNDEF); constant integer size = 8 << UInt(sz);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose accumulator output register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose accumulator input register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the general-purpose data source register, encoded in the 'Rm' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose data source register, encoded in the 'Rm' field.

## Operation

```
constant bits(32) acc = X[n, 32]; // accumulator constant bits(size) val = X[m, size]; // input value constant bits(32) poly = \texttt{0x04C11DB7}<31:0>; constant bits(32+size) tempacc = BitReverse(acc):Zeros(size); constant bits(size+32) tempval = BitReverse(val):Zeros(32); // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation X[d, 32] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.136 CRC32CB, CRC32CH, CRC32CW, CRC32CX

## CRC32C checksum

This instruction performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for the CRC calculation.

In an Armv8.0 implementation, this is an OPTIONAL instruction. From Armv8.1, it is mandatory for all implementations to implement this instruction.

## Note

ID\_AA64ISAR0\_EL1.CRC32 indicates whether this instruction is supported.

## CRC

(FEAT\_CRC32)

<!-- image -->

## Encoding for the CRC32CB variant

```
Applies when (sf == 0 && sz == 00)
```

```
CRC32CB <Wd>, <Wn>, <Wm>
```

## Encoding for the CRC32CH variant

Applies when (sf

```
CRC32CH <Wd>,
```

```
== 0 && sz == 01) <Wn>, <Wm>
```

## Encoding for the CRC32CW variant

```
Applies when (sf == 0 && sz == 10)
```

```
CRC32CW <Wd>, <Wn>, <Wm>
```

## Encoding for the CRC32CX variant

Applies when (sf == 1 &amp;&amp; sz == 11)

```
CRC32CX <Wd>, <Wn>, <Xm>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CRC32) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); if sf == '1' && sz != '11' then EndOfDecode(Decode_UNDEF); if sf == '0' && sz == '11' then EndOfDecode(Decode_UNDEF); constant integer size = 8 << UInt(sz);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose accumulator output register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose accumulator input register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the general-purpose data source register, encoded in the 'Rm' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose data source register, encoded in the 'Rm' field.

## Operation

```
constant bits(32) acc = X[n, 32]; // accumulator constant bits(size) val = X[m, size]; // input value constant bits(32) poly = \texttt{0x1EDC6F41}<31:0>; constant bits(32+size) tempacc = BitReverse(acc):Zeros(size); constant bits(size+32) tempval = BitReverse(val):Zeros(32); // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation X[d, 32] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.137 CSDB

## Consumption of speculative data barrier

This instruction is a memory barrier that controls speculative execution arising from data value prediction. For more information and details of the semantics, see Consumption of Speculative Data Barrier (CSDB).

<!-- image -->

## Encoding

CSDB

## Decode for this encoding

<!-- image -->

## Operation

ConsumptionOfSpeculativeDataBarrier();

## C6.2.138 CSEL

## Conditional select

This instruction writes the value of the first source register to the destination register if the condition is TRUE. If the condition is FALSE, it writes the value of the second source register to the destination register.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
<cond>
```

```
0) CSEL <Wd>, <Wn>, <Wm>,
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
1)
```

```
CSEL <Xd>, <Xn>, <Xm>, <cond>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant bits(4) condition = cond;
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;cond&gt;

Is one of the standard conditions, encoded in the standard way, and encoded in 'cond':

|   cond | <cond>   |
|--------|----------|
|   0000 | EQ       |
|   0001 | NE       |
|   0010 | CS       |
|   0011 | CC       |

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

```
bits(datasize) result; if ConditionHolds(condition) then result = X[n, datasize]; else result = X[m, datasize]; X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   cond | <cond>   |
|--------|----------|
|   0100 | MI       |
|   0101 | PL       |
|   0110 | VS       |
|   0111 | VC       |
|   1000 | HI       |
|   1001 | LS       |
|   1010 | GE       |
|   1011 | LT       |
|   1100 | GT       |
|   1101 | LE       |
|   1110 | AL       |
|   1111 | NV       |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.139 CSET

## Conditional set

This instruction sets the destination register to 1 if the condition is TRUE, and otherwise sets it to 0.

This is an alias of CSINC. This means:

- The encodings in this description are named to match the encodings of CSINC.
- The description of CSINC gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
CSET
```

```
<Wd>, <invcond>
```

## is equivalent to

```
CSINC <Wd>, WZR, WZR, <cond>
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

Applies when 1)

```
(sf == CSET <Xd>, <invcond>
```

## is equivalent to

```
CSINC <Xd>, XZR, XZR, <cond>
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;invcond&gt;

Is one of the standard conditions, excluding AL and NV , encoded with its least significant bit inverted, and encoded in 'cond':

|   cond | <invcond>   | Description        |
|--------|-------------|--------------------|
|   0000 | NE          | Maps to <cond> EQ. |
|   0001 | EQ          | Maps to <cond> NE. |

<!-- image -->

|   cond | <invcond>   | Description        |
|--------|-------------|--------------------|
|   0010 | CC          | Maps to <cond> CS. |
|   0011 | CS          | Maps to <cond> CC. |
|   0100 | PL          | Maps to <cond> MI. |
|   0101 | MI          | Maps to <cond> PL. |
|   0110 | VC          | Maps to <cond> VS. |
|   0111 | VS          | Maps to <cond> VC. |
|   1000 | LS          | Maps to <cond> HI. |
|   1001 | HI          | Maps to <cond> LS. |
|   1010 | LT          | Maps to <cond> GE. |
|   1011 | GE          | Maps to <cond> LT. |
|   1100 | LE          | Maps to <cond> GT. |
|   1101 | GT          | Maps to <cond> LE. |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

The description of CSINC gives the operational pseudocode for this instruction.

## Operational Information

The description of CSINC gives the operational information for this instruction.

## C6.2.140 CSETM

Conditional set mask

This instruction sets all bits of the destination register to 1 if the condition is TRUE, and otherwise sets all bits to 0.

This is an alias of CSINV. This means:

- The encodings in this description are named to match the encodings of CSINV.
- The description of CSINV gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
CSETM <Wd>, <invcond>
```

## is equivalent to

```
CSINV <Wd>, WZR, WZR, <cond>
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

Applies when 1)

```
(sf == CSETM <Xd>, <invcond>
```

## is equivalent to

```
CSINV <Xd>, XZR, XZR, <cond>
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;invcond&gt;

Is one of the standard conditions, excluding AL and NV , encoded with its least significant bit inverted, and encoded in 'cond':

|   cond | <invcond>   | Description        |
|--------|-------------|--------------------|
|   0000 | NE          | Maps to <cond> EQ. |
|   0001 | EQ          | Maps to <cond> NE. |

<!-- image -->

|   cond | <invcond>   | Description        |
|--------|-------------|--------------------|
|   0010 | CC          | Maps to <cond> CS. |
|   0011 | CS          | Maps to <cond> CC. |
|   0100 | PL          | Maps to <cond> MI. |
|   0101 | MI          | Maps to <cond> PL. |
|   0110 | VC          | Maps to <cond> VS. |
|   0111 | VS          | Maps to <cond> VC. |
|   1000 | LS          | Maps to <cond> HI. |
|   1001 | HI          | Maps to <cond> LS. |
|   1010 | LT          | Maps to <cond> GE. |
|   1011 | GE          | Maps to <cond> LT. |
|   1100 | LE          | Maps to <cond> GT. |
|   1101 | GT          | Maps to <cond> LE. |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

The description of CSINV gives the operational pseudocode for this instruction.

## Operational Information

The description of CSINV gives the operational information for this instruction.

## C6.2.141 CSINC

## Conditional select increment

This instruction returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the value of the second source register incremented by 1.

This instruction is used by the aliases CINC and CSET.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) CSINC <Wd>, <Wn>, <Wm>,
```

```
<cond>
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
1)
```

```
CSINC <Xd>, <Xn>, <Xm>, <cond>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << constant bits(4) condition = cond;
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;cond&gt;

Is one of the standard conditions, encoded in the standard way, and encoded in 'cond':

|   cond | <cond>   |
|--------|----------|
|   0000 | EQ       |
|   0001 | NE       |
|   0010 | CS       |

```
UInt(sf);
```

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Alias Conditions

| Alias   | Is preferred when                                                 |
|---------|-------------------------------------------------------------------|
| CINC    | Rm != '11111' && Rn != '11111' && !(cond IN {'111x'}) && Rn == Rm |
| CSET    | Rm == '11111' && Rn == '11111' && !(cond IN {'111x'})             |

## Operation

```
bits(datasize) result; if ConditionHolds(condition) then result = X[n, datasize]; else result = X[m, datasize] + 1; X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   cond | <cond>   |
|--------|----------|
|   0011 | CC       |
|   0100 | MI       |
|   0101 | PL       |
|   0110 | VS       |
|   0111 | VC       |
|   1000 | HI       |
|   1001 | LS       |
|   1010 | GE       |
|   1011 | LT       |
|   1100 | GT       |
|   1101 | LE       |
|   1110 | AL       |
|   1111 | NV       |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.142 CSINV

## Conditional select invert

This instruction returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the bitwise inversion value of the second source register.

This instruction is used by the aliases CINV and CSETM.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) CSINV <Wd>, <Wn>, <Wm>,
```

```
<cond>
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
1)
```

```
CSINV <Xd>, <Xn>, <Xm>, <cond>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant bits(4) condition = cond;
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;cond&gt;

Is one of the standard conditions, encoded in the standard way, and encoded in 'cond':

|   cond | <cond>   |
|--------|----------|
|   0000 | EQ       |
|   0001 | NE       |
|   0010 | CS       |

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Alias Conditions

| Alias   | Is preferred when                                                 |
|---------|-------------------------------------------------------------------|
| CINV    | Rm != '11111' && Rn != '11111' && !(cond IN {'111x'}) && Rn == Rm |
| CSETM   | Rm == '11111' && Rn == '11111' && !(cond IN {'111x'})             |

## Operation

```
bits(datasize) result; if ConditionHolds(condition) then result = X[n, datasize]; else result = NOT(X[m, datasize]); X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   cond | <cond>   |
|--------|----------|
|   0011 | CC       |
|   0100 | MI       |
|   0101 | PL       |
|   0110 | VS       |
|   0111 | VC       |
|   1000 | HI       |
|   1001 | LS       |
|   1010 | GE       |
|   1011 | LT       |
|   1100 | GT       |
|   1101 | LE       |
|   1110 | AL       |
|   1111 | NV       |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.143 CSNEG

## Conditional select negation

This instruction returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the negated value of the second source register.

This instruction is used by the alias CNEG.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) CSNEG <Wd>, <Wn>, <Wm>,
```

```
<cond>
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
1)
```

```
CSNEG <Xd>, <Xn>, <Xm>, <cond>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant bits(4) condition = cond;
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;cond&gt;

Is one of the standard conditions, encoded in the standard way, and encoded in 'cond':

|   cond | <cond>   |
|--------|----------|
|   0000 | EQ       |
|   0001 | NE       |
|   0010 | CS       |

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Alias Conditions

## Operation

```
bits(datasize) result; if ConditionHolds(condition) then result = X[n, datasize]; else result = NOT(X[m, datasize]) + 1; X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   cond | <cond>   |
|--------|----------|
|   0011 | CC       |
|   0100 | MI       |
|   0101 | PL       |
|   0110 | VS       |
|   0111 | VC       |
|   1000 | HI       |
|   1001 | LS       |
|   1010 | GE       |
|   1011 | LT       |
|   1100 | GT       |
|   1101 | LE       |
|   1110 | AL       |
|   1111 | NV       |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

| Alias   | Is preferred when               |
|---------|---------------------------------|
| CNEG    | !(cond IN {'111x'}) && Rn == Rm |

## C6.2.144 CTZ

Count trailing zeros

This instruction counts the number of consecutive binary zero bits, starting from the least significant bit in the source register, and places the count in the destination register.

## Integer

(FEAT\_CSSC)

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

CTZ

&lt;Wd&gt;, &lt;Wn&gt;

## Encoding for the 64-bit variant

Applies when (sf ==

```
CTZ
```

```
1) <Xd>, <Xn>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CSSC) then constant integer datasize = 32 << UInt(sf); constant integer d = UInt(Rd); constant integer n = UInt(Rn);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

&lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant integer result = CountLeadingZeroBits(BitReverse(operand1)); X[d, datasize] = result<datasize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.145 DC

Data cache operation

For more information, see op0== 0b01 , cache maintenance, TLB maintenance, and address translation instructions.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

<!-- image -->

## is equivalent to

```
SYS #<op1>, C7, <Cm>, #<op2>, <Xt>
```

and is the preferred disassembly when SysOp(op1, '0111', CRm, op2) == Sys\_DC .

## Assembler Symbols

## &lt;dc\_op&gt;

Is a DC operation name, as listed for the DC system instruction group, encoded in 'op1:CRm:op2':

|   op1 |   CRm |   op2 | <dc_op>   | Architectural Feature   |
|-------|-------|-------|-----------|-------------------------|
|   000 |  0110 |   001 | IVAC      | -                       |
|   000 |  0110 |   010 | ISW       | -                       |
|   000 |  0110 |   011 | IGVAC     | FEAT_MTE2               |
|   000 |  0110 |   100 | IGSW      | FEAT_MTE2               |
|   000 |  0110 |   101 | IGDVAC    | FEAT_MTE2               |
|   000 |  0110 |   110 | IGDSW     | FEAT_MTE2               |
|   000 |  1010 |   010 | CSW       | -                       |
|   000 |  1010 |   100 | CGSW      | FEAT_MTE2               |
|   000 |  1010 |   110 | CGDSW     | FEAT_MTE2               |
|   000 |  1110 |   010 | CISW      | -                       |
|   000 |  1110 |   100 | CIGSW     | FEAT_MTE2               |
|   000 |  1110 |   110 | CIGDSW    | FEAT_MTE2               |
|   000 |  1111 |   001 | CIVAPS    | FEAT_PoPS               |
|   000 |  1111 |   101 | CIGDVAPS  | FEAT_PoPS && FEAT_MTE2  |
|   011 |  0100 |   001 | ZVA       | -                       |

|   op1 |   CRm |   op2 | <dc_op>   | Architectural Feature   |
|-------|-------|-------|-----------|-------------------------|
|   011 |  0100 |   011 | GVA       | FEAT_MTE                |
|   011 |  0100 |   100 | GZVA      | FEAT_MTE                |
|   011 |  1010 |   001 | CVAC      | -                       |
|   011 |  1010 |   011 | CGVAC     | FEAT_MTE                |
|   011 |  1010 |   101 | CGDVAC    | FEAT_MTE                |
|   011 |  1011 |   000 | CVAOC     | FEAT_OCCMO              |
|   011 |  1011 |   001 | CVAU      | -                       |
|   011 |  1011 |   111 | CGDVAOC   | FEAT_OCCMO && FEAT_MTE  |
|   011 |  1100 |   001 | CVAP      | FEAT_DPB                |
|   011 |  1100 |   011 | CGVAP     | FEAT_MTE                |
|   011 |  1100 |   101 | CGDVAP    | FEAT_MTE                |
|   011 |  1101 |   001 | CVADP     | FEAT_DPB2               |
|   011 |  1101 |   011 | CGVADP    | FEAT_MTE                |
|   011 |  1101 |   101 | CGDVADP   | FEAT_MTE                |
|   011 |  1110 |   001 | CIVAC     | -                       |
|   011 |  1110 |   011 | CIGVAC    | FEAT_MTE                |
|   011 |  1110 |   101 | CIGDVAC   | FEAT_MTE                |
|   011 |  1111 |   000 | CIVAOC    | FEAT_OCCMO              |
|   011 |  1111 |   111 | CIGDVAOC  | FEAT_OCCMO && FEAT_MTE  |
|   100 |  1110 |   000 | CIPAE     | FEAT_MEC                |
|   100 |  1110 |   111 | CIGDPAE   | FEAT_MEC && FEAT_MTE2   |
|   110 |  1110 |   001 | CIPAPA    | FEAT_RME                |
|   110 |  1110 |   101 | CIGDPAPA  | FEAT_RME && FEAT_MTE2   |

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rt' field.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.146 DCPS1

Debug change PE state to EL1

This instruction, when executed in Debug state:

- If executed at EL0, changes the current Exception level and SP to EL1 using SP\_EL1.
- Otherwise, if executed at ELx, selects SP\_ELx.

The target Exception level of a DCPS1 instruction is:

- EL1 if the instruction is executed at EL0.
- Otherwise, the Exception level at which the instruction is executed.

When the target Exception level of a DCPS1 instruction is ELx, on executing this instruction:

- ELR\_ELx becomes UNKNOWN.
- SPSR\_ELx becomes UNKNOWN.
- ESR\_ELx becomes UNKNOWN.
- DLR\_EL0 and DSPSR\_EL0 become UNKNOWN.
- The endianness is set according to SCTLR\_ELx.EE.

This instruction is always UNDEFINED in Non-debug state.

This instruction is UNDEFINED at EL0 if EL2 is implemented and enabled in the current Security state and HCR\_EL2.TGE == 1.

For more information on the operation of the DCPS&lt;n&gt; instructions, see DCPS.

<!-- image -->

## Encoding

```
DCPS1 {#<imm>}
```

## Decode for this encoding

// Empty.

## Assembler Symbols

## &lt;imm&gt;

Is an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in the 'imm16' field.

## Operation

```
if !Halted() then UNDEFINED;
```

```
DCPSInstruction(EL1);
```

## C6.2.147 DCPS2

Debug change PE state to EL2

This instruction, when executed in Debug state:

- If executed at EL0 or EL1, changes the current Exception level and SP to EL2 using SP\_EL2.
- Otherwise, if executed at ELx, selects SP\_ELx.

The target Exception level of a DCPS2 instruction is:

- EL2 if the instruction is executed at an Exception level that is not EL3.
- EL3 if the instruction is executed at EL3.

When the target Exception level of a DCPS2 instruction is ELx, on executing this instruction:

- ELR\_ELx becomes UNKNOWN.
- SPSR\_ELx becomes UNKNOWN.
- ESR\_ELx becomes UNKNOWN.
- DLR\_EL0 and DSPSR\_EL0 become UNKNOWN.
- The endianness is set according to SCTLR\_ELx.EE.

This instruction is always UNDEFINED in Non-debug state.

This instruction is UNDEFINED at the following Exception levels:

- All Exception levels if EL2 is not implemented.
- At EL0 and EL1 if EL2 is disabled in the current Security state.

For more information on the operation of the DCPS&lt;n&gt; instructions, see DCPS.

<!-- image -->

## Encoding

```
DCPS2 {#<imm>}
```

## Decode for this encoding

// Empty.

## Assembler Symbols

## &lt;imm&gt;

Is an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in the 'imm16' field.

## Operation

```
if !Halted() then UNDEFINED;
```

```
DCPSInstruction(EL2);
```

## C6.2.148 DCPS3

Debug change PE state to EL3

This instruction, when executed in Debug state:

- If executed at EL3, selects SP\_EL3.
- Otherwise, changes the current Exception level and SP to EL3 using SP\_EL3.

The target Exception level of a DCPS3 instruction is EL3.

On executing a DCPS3 instruction:

- ELR\_EL3 becomes UNKNOWN.
- SPSR\_EL3 becomes UNKNOWN.
- ESR\_EL3 becomes UNKNOWN.
- DLR\_EL0 and DSPSR\_EL0 become UNKNOWN.
- The endianness is set according to SCTLR\_EL3.EE.

This instruction is always UNDEFINED in Non-debug state.

This instruction is UNDEFINED at all Exception levels if either:

- EDSCR.SDD == 1.
- EL3 is not implemented.

For more information on the operation of the DCPS&lt;n&gt; instructions, see DCPS.

<!-- image -->

## Encoding

```
DCPS3 {#<imm>}
```

## Decode for this encoding

// Empty.

## Assembler Symbols

## &lt;imm&gt;

Is an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in the 'imm16' field.

## Operation

```
if !Halted() then UNDEFINED;
```

```
DCPSInstruction(EL3);
```

## C6.2.149 DGH

## Data gathering hint

This instruction is a hint instruction that indicates that it is not expected to be performance optimal to merge memory accesses with Normal Non-cacheable or Device-GRE attributes appearing in program order before the hint instruction with any memory accesses appearing after the hint instruction into a single memory transaction on an interconnect.

## System

(FEAT\_DGH)

<!-- image -->

## Encoding

DGH

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_DGH) then EndOfDecode(Decode\_NOP);

## Operation

Hint\_DGH();

## C6.2.150 DMB

## Data memory barrier

This instruction is a memory barrier that ensures the ordering of observations of memory accesses, see Data Memory Barrier.

<!-- image -->

## Encoding

```
DMB (<option>|#<imm>)
```

## Decode for this encoding

```
MBReqDomain domain; MBReqTypes types; case CRm<3:2> of when '00' domain = MBReqDomain_OuterShareable; when '01' domain = MBReqDomain_Nonshareable; when '10' domain = MBReqDomain_InnerShareable; when '11' domain = MBReqDomain_FullSystem; case CRm<1:0> of when '00' types = MBReqTypes_All; domain when '01' types = MBReqTypes_Reads; when '10' types = MBReqTypes_Writes; when '11' types = MBReqTypes_All;
```

## Assembler Symbols

## &lt;option&gt;

Specifies the limitation on the barrier operation. Values are:

- SY Full system is the required shareability domain, reads and writes are the required access types, both before and after the barrier instruction. This option is referred to as the full system barrier. Encoded as CRm = 0b1111 .
- ST Full system is the required shareability domain, writes are the required access type, both before and after the barrier instruction. Encoded as CRm = 0b1110 .
- LD Full system is the required shareability domain, reads are the required access type before the barrier instruction, and reads and writes are the required access types after the barrier instruction. Encoded as CRm = 0b1101 .
- ISH Inner Shareable is the required shareability domain, reads and writes are the required access types, both before and after the barrier instruction. Encoded as CRm = 0b1011 .
- ISHST Inner Shareable is the required shareability domain, writes are the required access type, both before and after the barrier instruction. Encoded as CRm = 0b1010 .
- ISHLD Inner Shareable is the required shareability domain, reads are the required access type before the barrier instruction, and reads and writes are the required access types after the barrier instruction. Encoded as CRm = 0b1001 .
- NSH Non-shareable is the required shareability domain, reads and writes are the required access, both before and after the barrier instruction. Encoded as CRm = 0b0111 .
- NSHST Non-shareable is the required shareability domain, writes are the required access type, both before and after the barrier instruction. Encoded as CRm = 0b0110 .
- NSHLD Non-shareable is the required shareability domain, reads are the required access type before the barrier instruction, and reads and writes are the required access types after the barrier instruction. Encoded as CRm = 0b0101 .
- OSH Outer Shareable is the required shareability domain, reads and writes are the required access types, both before and after the barrier instruction. Encoded as CRm = 0b0011 .
- OSHST Outer Shareable is the required shareability domain, writes are the required access type, both before and after the barrier instruction. Encoded as CRm = 0b0010 .

```
= MBReqDomain_FullSystem;
```

OSHLD Outer Shareable is the required shareability domain, reads are the required access type before the barrier instruction, and reads and writes are the required access types after the barrier instruction. Encoded as CRm = 0b0001 .

All other encodings of 'CRm' that are not listed are reserved and can be encoded using the #&lt;imm&gt; syntax. All unsupported and reserved options must execute as a full system barrier operation, but software must not rely on this behavior. For more information on whether an access is before or after a barrier instruction, see Data Memory Barrier (DMB) or see Data Synchronization Barrier (DSB).

| CRm   | <option>   |
|-------|------------|
| 0001  | OSHLD      |
| 0010  | OSHST      |
| 0011  | OSH        |
| 0101  | NSHLD      |
| 0110  | NSHST      |
| 0111  | NSH        |
| xx00  | RESERVED   |
| 1001  | ISHLD      |
| 1010  | ISHST      |
| 1011  | ISH        |
| 1101  | LD         |
| 1110  | ST         |
| 1111  | SY         |

## &lt;imm&gt;

Is a 4-bit unsigned immediate, in the range 0 to 15, encoded in the 'CRm' field.

## Operation

DataMemoryBarrier(domain, types);

## C6.2.151 DRPS

Debug restore PE state

This instruction restores PSTATE from the SPSR.

The SPSR is checked for the current Exception level for an illegal return event. See Illegal exception returns from AArch64 state.

This instruction is UNDEFINED in Non-debug state.

This instruction is UNDEFINED at EL0.

For more information on the operation of DRPS , see DRPS.

<!-- image -->

## Encoding

DRPS

## Decode for this encoding

// Empty.

## Operation

```
if !Halted() || PSTATE.EL == EL0 then UNDEFINED; DRPSInstruction();
```

## C6.2.152 DSB

Data synchronization barrier

This instruction is a memory barrier that ensures the completion of memory accesses, see Data Synchronization Barrier.

This instruction is used by the aliases PSSBB and SSBB.

It has encodings from 2 classes: Memory barrier and Memory nXS barrier

## Memory barrier

<!-- image -->

## Encoding

```
DSB (<option>|#<imm>)
```

## Decode for this encoding

```
boolean nXS = FALSE; DSBAlias alias; case CRm of when '0000' alias = DSBAlias_SSBB; when '0100' alias = DSBAlias_PSSBB; otherwise alias = DSBAlias_DSB; MBReqDomain domain; case CRm<3:2> of when '00' domain = MBReqDomain_OuterShareable; when '01' domain = MBReqDomain_Nonshareable; when '10' domain = MBReqDomain_InnerShareable; when '11' domain = MBReqDomain_FullSystem; MBReqTypes types; case CRm<1:0> of when '00' types = MBReqTypes_All; domain = MBReqDomain_FullSystem; when '01' types = MBReqTypes_Reads; when '10' types = MBReqTypes_Writes; when '11' types = MBReqTypes_All;
```

## Memory nXS barrier

(FEAT\_XS)

<!-- image -->

## Encoding

DSB &lt;option&gt;nXS

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_XS) then EndOfDecode(Decode_UNDEF);
```

```
constant MBReqTypes types = MBReqTypes_All; boolean nXS = TRUE; constant DSBAlias alias = DSBAlias_DSB; MBReqDomain domain; case imm2 of when '00' domain = MBReqDomain_OuterShareable; when '01' domain = MBReqDomain_Nonshareable; when '10' domain = MBReqDomain_InnerShareable; when '11' domain = MBReqDomain_FullSystem;
```

## Assembler Symbols

## &lt;option&gt;

For the 'Memory barrier' variant: specifies the limitation on the barrier operation. Values are:

- SY Full system is the required shareability domain, reads and writes are the required access types, both before and after the barrier instruction. This option is referred to as the full system barrier. Encoded as CRm = 0b1111 .
- ST Full system is the required shareability domain, writes are the required access type, both before and after the barrier instruction. Encoded as CRm = 0b1110 .
- LD Full system is the required shareability domain, reads are the required access type before the barrier instruction, and reads and writes are the required access types after the barrier instruction. Encoded as CRm = 0b1101 .
- ISH Inner Shareable is the required shareability domain, reads and writes are the required access types, both before and after the barrier instruction. Encoded as CRm = 0b1011 .
- ISHST Inner Shareable is the required shareability domain, writes are the required access type, both before and after the barrier instruction. Encoded as CRm = 0b1010 .
- ISHLD Inner Shareable is the required shareability domain, reads are the required access type before the barrier instruction, and reads and writes are the required access types after the barrier instruction. Encoded as CRm = 0b1001 .
- NSH Non-shareable is the required shareability domain, reads and writes are the required access, both before and after the barrier instruction. Encoded as CRm = 0b0111 .
- NSHST Non-shareable is the required shareability domain, writes are the required access type, both before and after the barrier instruction. Encoded as CRm = 0b0110 .
- NSHLD Non-shareable is the required shareability domain, reads are the required access type before the barrier instruction, and reads and writes are the required access types after the barrier instruction. Encoded as CRm = 0b0101 .
- OSH Outer Shareable is the required shareability domain, reads and writes are the required access types, both before and after the barrier instruction. Encoded as CRm = 0b0011 .
- OSHST Outer Shareable is the required shareability domain, writes are the required access type, both before and after the barrier instruction. Encoded as CRm = 0b0010 .
- OSHLD Outer Shareable is the required shareability domain, reads are the required access type before the barrier instruction, and reads and writes are the required access types after the barrier instruction. Encoded as CRm = 0b0001 .

All other encodings of 'CRm' that are not listed, other than the values 0b0000 and 0b0100 , are reserved and can be encoded using the #&lt;imm&gt; syntax. All unsupported and reserved options must execute as a full system barrier operation, but software must not rely on this behavior. For more information on whether an access is before or after a barrier instruction, see Data Memory Barrier (DMB) or see Data Synchronization Barrier (DSB).

Note

The value 0b0000 is used to encode SSBB and the value 0b0100 is used to encode PSSBB .

|   CRm | <option>   |
|-------|------------|
|  0001 | OSHLD      |

## &lt;imm&gt;

Is a 4-bit unsigned immediate, in the range 0 to 15, encoded in the 'CRm' field.

## Alias Conditions

## Operation

| CRm   | <option>   |
|-------|------------|
| 0010  | OSHST      |
| 0011  | OSH        |
| 0101  | NSHLD      |
| 0110  | NSHST      |
| 0111  | NSH        |
| 1001  | ISHLD      |
| 1010  | ISHST      |
| 1011  | ISH        |
| 1x00  | RESERVED   |
| 1101  | LD         |
| 1110  | ST         |
| 1111  | SY         |

For the 'Memory nXS barrier' variant: specifies the limitation on the barrier operation. Values are:

- SY Full system is the required shareability domain, reads and writes are the required access types, both before and after the barrier instruction. This option is referred to as the full system barrier. Encoded as imm2 = 0b11 .
- ISH Inner Shareable is the required shareability domain, reads and writes are the required access types, both before and after the barrier instruction. Encoded as imm2 = 0b10 .
- NSH Non-shareable is the required shareability domain, reads and writes are the required access, both before and after the barrier instruction. Encoded as imm2 = 0b01 .
- OSH Outer Shareable is the required shareability domain, reads and writes are the required access types, both before and after the barrier instruction. Encoded as imm2 = 0b00 .

|   imm2 | <option>   |
|--------|------------|
|     00 | OSH        |
|     01 | NSH        |
|     10 | ISH        |
|     11 | SY         |

| Alias   | Is preferred when   |
|---------|---------------------|
| PSSBB   | CRm == '0100'       |
| SSBB    | CRm == '0000'       |

```
case alias of when DSBAlias_SSBB SpeculativeStoreBypassBarrierToVA(); when DSBAlias_PSSBB SpeculativeStoreBypassBarrierToPA(); when DSBAlias_DSB if !nXS && IsFeatureImplemented(FEAT_XS) then nXS = PSTATE.EL IN {EL0, EL1} && IsHCRXEL2Enabled() && HCRX_EL2.FnXS == '1'; DataSynchronizationBarrier(domain, types, nXS); otherwise Unreachable();
```

## C6.2.153 DVP

Data value prediction restriction by context

This instruction prevents data value predictions that predict execution addresses based on information gathered from earlier execution within a particular execution context. Data value predictions determined by the actions of code in the target execution context or contexts appearing in program order before the instruction cannot be used to exploitatively control speculative execution occurring after the instruction is complete and synchronized.

For more information, see DVP RCTX, Data Value Prediction Restriction by Context.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_SPECRES)

<!-- image -->

## Encoding

<!-- image -->

and is always the preferred disassembly.

## Assembler Symbols

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rt' field.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.154 EON (shifted register)

Bitwise exclusive-OR NOT (shifted register)

This instruction performs a bitwise exclusive-OR NOT of a register value and an optionally-shifted register value, and writes the result to the destination register.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0) EON <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
EON <Xd>, <Xn>, <Xm>{, <shift>
```

```
1) #<amount>}
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if sf == '0' && imm6<5> == '1' then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type = DecodeShift(shift); constant integer shift_amount = UInt(imm6);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in 'shift':

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |
|      10 | ASR       |

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount, datasize); X[d, datasize] = operand1 EOR NOT(operand2);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   shift | <shift>   |
|---------|-----------|
|      11 | ROR       |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.155 EOR (immediate)

Bitwise exclusive-OR (immediate)

This instruction performs a bitwise exclusive-OR of a register value and an immediate value, and writes the result to the destination register.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0)

```
EOR <Wd|WSP>, <Wn>, #<imm>
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
1)
```

```
EOR <Xd|SP>, <Xn>, #<imm>
```

## Decode for all variants of this encoding

```
if sf == '0' && N != '0' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); bits(datasize) imm; (imm, -) = DecodeBitMasks(N, imms, immr, TRUE, datasize);
```

## Assembler Symbols

## &lt;Wd|WSP&gt;

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;imm&gt;

For the '32-bit' variant: is the bitmask immediate, encoded in 'imms:immr'.

For the '64-bit' variant: is the bitmask immediate, encoded in 'N:imms:immr'.

## &lt;Xd|SP&gt;

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = imm; constant bits(datasize) result = operand1 EOR if d == 31 then SP[64] = ZeroExtend(result, 64); else X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
operand2;
```

## C6.2.156 EOR (shifted register)

Bitwise exclusive-OR (shifted register)

This instruction performs a bitwise exclusive-OR of a register value and an optionally-shifted register value, and writes the result to the destination register.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0) EOR <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
EOR <Xd>, <Xn>, <Xm>{, <shift>
```

```
1) #<amount>}
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if sf == '0' && imm6<5> == '1' then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type = DecodeShift(shift); constant integer shift_amount = UInt(imm6);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in 'shift':

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |
|      10 | ASR       |

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount, datasize); X[d, datasize] = operand1 EOR operand2;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   shift | <shift>   |
|---------|-----------|
|      11 | ROR       |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.157 ERET

Exception return

This instruction restores PSTATE from the SPSR, and branches to the address held in the ELR.

The SPSR is checked for the current Exception level for an illegal return event. See Illegal exception returns from AArch64 state.

ERET is UNDEFINED at EL0.

<!-- image -->

## Encoding

ERET

## Decode for this encoding

```
constant boolean pac = FALSE; constant boolean use_key_a =
```

```
TRUE;
```

## Operation

```
if PSTATE.EL == EL0 then UNDEFINED; AArch64.CheckForERetTrap(pac, use_key_a); constant bits(64) target = ELR_ELx[];
```

AArch64.ExceptionReturn(target, SPSR\_ELx[]);

## C6.2.158 ERETAA, ERETAB

Exception return, with pointer authentication

This instruction authenticates the address in ELR, using SP as the modifier and the specified key, restores PSTATE from the SPSR for the current Exception level, and branches to the authenticated address.

Key A is used for ERETAA . Key B is used for ERETAB .

If the authentication passes, the PE continues execution at the target of the branch. For information on behavior if the authentication fails, see Faulting on pointer authentication.

The authenticated address is not written back to ELR.

The SPSR is checked for the current Exception level for an illegal return event. See Illegal exception returns from AArch64 state.

ERETAA and ERETAB are UNDEFINED at EL0.

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding for the ERETAA variant

```
Applies when (M == 0)
```

ERETAA

## Encoding for the ERETAB variant

```
Applies when (M == 1)
```

ERETAB

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then constant boolean pac = TRUE; constant boolean use_key_a = (M == '0'); constant boolean auth_then_branch = TRUE;
```

## Operation

```
if PSTATE.EL == EL0 then UNDEFINED; AArch64.CheckForERetTrap(pac, use_key_a); bits(64) target = ELR_ELx[]; constant bits(64) modifier = SP[64]; if use_key_a then target = AuthIA(target, modifier, else target = AuthIB(target, modifier, AArch64.ExceptionReturn(target, SPSR_ELx[]);
```

```
EndOfDecode(Decode_UNDEF);
```

```
auth_then_branch); auth_then_branch);
```

## C6.2.159 ESB

Error synchronization barrier

This instruction is an error synchronization event that might also update DISR\_EL1 and VDISR\_EL2.

This instruction can be used at all Exception levels and in Debug state.

In Debug state, this instruction behaves as if SError interrupts are masked at all Exception levels. For more information, see RAS PE architecture and Arm ® Reliability, Availability, and Serviceability (RAS) System Architecture, for A-profile architecture (ARM IHI 0100).

If FEAT\_RAS is not implemented, this instruction executes as a NOP .

## System

(FEAT\_RAS)

<!-- image -->

## Encoding

ESB

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_RAS) then EndOfDecode(Decode_NOP);
```

## Operation

```
SynchronizeErrors(); AArch64.ESBOperation(); if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation(); elsif IsFeatureImplemented(FEAT_E3DSE) && PSTATE.EL != EL3 then AArch64.dESBOperation(); TakeUnmaskedSErrorInterrupts();
```

## C6.2.160 EXTR

## Extract register

This instruction extracts a register from a pair of registers.

This instruction is used by the alias ROR (immediate).

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0 &amp;&amp; imms == 0xxxxx)

```
EXTR <Wd>, <Wn>, <Wm>, #<lsb>
```

## Encoding for the 64-bit variant

Applies when (sf == 1 &amp;&amp; N == 1)

```
EXTR <Xd>, <Xn>, <Xm>, #<lsb>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if N != sf then EndOfDecode(Decode_UNDEF); if sf == '0' && imms<5> == '1' then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant integer lsb = UInt(imms);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;lsb&gt;

## &lt;Xd&gt;

For the '32-bit' variant: is the least significant bit position from which to extract, in the range 0 to 31, encoded in the 'imms' field.

For the '64-bit' variant: is the least significant bit position from which to extract, in the range 0 to 63, encoded in the 'imms' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Alias Conditions

## Operation

```
bits(datasize) result; constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = X[m, datasize]; constant bits(2*datasize) concat = operand1:operand2; result = concat<(lsb+datasize)-1:lsb>; X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

ROR (immediate)

## Is preferred when

Rn == Rm

## C6.2.161 GCSB

Guarded Control Stack barrier

This instruction generates a GCSB effect.

If FEAT\_GCS is not implemented, this instruction executes as a NOP .

## System

(FEAT\_GCS)

<!-- image -->

## Encoding

GCSB

DSYNC

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_GCS) then EndOfDecode(Decode\_NOP);

## Operation

GCSSynchronizationBarrier();

## C6.2.162 GCSPOPCX

Guarded Control Stack pop and compare exception return record

This instruction loads an exception return record from the location indicated by the current Guarded control stack pointer register, compares the loaded values with the current ELR\_ELx, SPSR\_ELx, and LR, and increments the pointer by the size of a Guarded Control Stack exception return record.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_GCS)

<!-- image -->

## Encoding

GCSPOPCX

## is equivalent to

SYS

#&lt;op1&gt;, &lt;Cn&gt;, &lt;Cm&gt;, #&lt;op2&gt;{, &lt;Xt&gt;}

and is always the preferred disassembly.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.163 GCSPOPM

## Guarded Control Stack pop

This instruction loads the 64-bit doubleword that is pointed to by the current Guarded Control Stack pointer, writes it to the destination register, and increments the current Guarded Control Stack pointer register by the size of a Guarded Control Stack procedure return record.

This is an alias of SYSL. This means:

- The encodings in this description are named to match the encodings of SYSL.
- The description of SYSL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_GCS)

<!-- image -->

## Encoding

GCSPOPM

{&lt;Xt&gt;}

## is equivalent to

SYSL

&lt;Xt&gt;, #&lt;op1&gt;, &lt;Cn&gt;, &lt;Cm&gt;, #&lt;op2&gt;

and is always the preferred disassembly.

## Assembler Symbols

<!-- image -->

&lt;Xt&gt;

Is the 64-bit name of the optional general-purpose destination register, encoded in the 'Rt' field. Defaults to XZR if absent.

## Operation

The description of SYSL gives the operational pseudocode for this instruction.

## C6.2.164 GCSPOPX

Guarded Control Stack pop exception return record

This instruction loads an exception return record from the location indicated by the current Guarded Control Stack pointer register, checks that the record is an exception return record, and increments the pointer by the size of a Guarded Control Stack exception return record.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_GCS)

<!-- image -->

| Encoding                               |
|----------------------------------------|
| GCSPOPX                                |
| is equivalent to                       |
| SYS #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>} |

and is always the preferred disassembly.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.165 GCSPUSHM

Guarded Control Stack push

This instruction decrements the current Guarded Control Stack pointer register by the size of a Guarded control procedure return record and stores an entry to the Guarded Control Stack.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_GCS)

<!-- image -->

## Encoding

<!-- image -->

and is always the preferred disassembly.

## Assembler Symbols

&lt;Xt&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rt' field.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.166 GCSPUSHX

Guarded Control Stack push exception return record

This instruction decrements the current Guarded Control Stack pointer register by the size of a Guarded Control Stack exception return record and stores an exception return record to the Guarded Control Stack.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_GCS)

<!-- image -->

## Encoding

| GCSPUSHX         | GCSPUSHX                           |
|------------------|------------------------------------|
| is equivalent to | is equivalent to                   |
| SYS              | #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>} |

and is always the preferred disassembly.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.167 GCSSS1

Guarded Control Stack switch stack 1

This instruction validates that the stack being switched to contains a Valid cap entry, stores an In-progress cap entry to the stack that is being switched to, and sets the current Guarded control stack pointer to the stack that is being switched to.

If the instruction generates a synchronous Data Abort exception, Watchpoint exception, GPC exception, or GCS Data Check exception, the value of GCSPR\_ELx for the current Exception level is restored to the value held in the register before the instruction was executed.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_GCS)

<!-- image -->

## Encoding

GCSSS1

&lt;Xt&gt;

## is equivalent to

SYS

#3, C7,

C7, #2, &lt;Xt&gt;

and is always the preferred disassembly.

## Assembler Symbols

&lt;Xt&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rt' field.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.168 GCSSS2

Guarded Control Stack switch stack 2

This instruction validates that the most recent entry of the Guarded Control Stack being switched to contains an In-progress cap entry, stores a Valid cap entry to the Guarded Control Stack that is being switched from, and sets Xt to the Guarded Control Stack pointer that is being switched from.

This is an alias of SYSL. This means:

- The encodings in this description are named to match the encodings of SYSL.
- The description of SYSL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_GCS)

<!-- image -->

## Encoding

GCSSS2

&lt;Xt&gt;

## is equivalent to

```
SYSL <Xt>, #<op1>, <Cn>, <Cm>, #<op2>
```

and is always the preferred disassembly.

## Assembler Symbols

<!-- image -->

&lt;Xt&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rt' field.

## Operation

The description of SYSL gives the operational pseudocode for this instruction.

## C6.2.169 GCSSTR

Guarded Control Stack store register

This instruction stores a doubleword from a register to memory. The address that is used for the store is calculated from a base register.

## Integer

(FEAT\_GCS)

<!-- image -->

## Encoding

```
GCSSTR <Xt>, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_GCS) then EndOfDecode(Decode_UNDEF);
```

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn);
```

## Assembler Symbols

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; constant bits(2) effective_el = PSTATE.EL; if effective_el == PSTATE.EL then CheckGCSSTREnabled(); constant boolean privileged = effective_el != EL0; constant AccessDescriptor accdesc = CreateAccDescGCS(MemOp_STORE, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; Mem[address, 8, accdesc] = X[t, 64];
```

## C6.2.170 GCSSTTR

Guarded Control Stack store register (unprivileged)

This instruction stores a doubleword from a register to memory. The address that is used for the store is calculated from a base register.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1 and the Effective value of HCR\_EL2.{NV1, NV} is not {1, 1}.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_GCS)

<!-- image -->

## Encoding

```
GCSSTTR
```

```
<Xt>, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_GCS) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn);
```

## Assembler Symbols

&lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; constant bits(2) effective_el = if AArch64.IsUnprivAccessPriv() then PSTATE.EL else EL0; if effective_el == PSTATE.EL then CheckGCSSTREnabled(); constant boolean privileged = effective_el != EL0; constant AccessDescriptor accdesc = CreateAccDescGCS(MemOp_STORE, privileged); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64];
```

Mem[address, 8, accdesc] = X[t, 64];

## C6.2.171 GMI

Tag mask insert

This instruction inserts the tag in the first source register into the excluded set specified in the second source register, writing the new excluded set to the destination register.

## Integer

(FEAT\_MTE)

<!-- image -->

## Encoding

```
GMI <Xd>, <Xn|SP>, <Xm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

```
constant bits(64) address = if n == 31 then SP[64] else X[n, 64]; bits(64) mask = X[m, 64]; constant bits(4) tag = AArch64.AllocationTagFromAddress(address); mask<UInt(tag)> = '1'; X[d, 64] = mask;
```

## C6.2.172 HINT

Hint instruction

This instruction is for the instruction set space that is reserved for architectural hint instructions.

Some encodings described here are not allocated in this revision of the architecture, and behave as NOPs. These encodings might be allocated to other hint functionality in future revisions of the architecture and therefore must not be used by software.

<!-- image -->

## Encoding

```
HINT #<imm>
```

## Decode for this encoding

```
SystemHintOp op; boolean stream; case CRm:op2 of when '0000 000' op = SystemHintOp_NOP; when '0000 001' op = SystemHintOp_YIELD; when '0000 010' op = SystemHintOp_WFE; when '0000 011' op = SystemHintOp_WFI; when '0000 100' op = SystemHintOp_SEV; when '0000 101' op = SystemHintOp_SEVL; when '0000 110' if !IsFeatureImplemented(FEAT_DGH) then EndOfDecode(Decode_NOP); op = SystemHintOp_DGH; when '0000 111' SEE "XPACLRI"; when '0001 xxx' case op2 of when '000' SEE "PACIA1716"; when '010' SEE "PACIB1716"; when '100' SEE "AUTIA1716"; when '110' SEE "AUTIB1716"; otherwise EndOfDecode(Decode_NOP); when '0010 000' if !IsFeatureImplemented(FEAT_RAS) then EndOfDecode(Decode_NOP); op = SystemHintOp_ESB; when '0010 001' if !IsFeatureImplemented(FEAT_SPE) then EndOfDecode(Decode_NOP); op = SystemHintOp_PSB; when '0010 010' if !IsFeatureImplemented(FEAT_TRF) then EndOfDecode(Decode_NOP); op = SystemHintOp_TSB; when '0010 011' if !IsFeatureImplemented(FEAT_GCS) then EndOfDecode(Decode_NOP); op = SystemHintOp_GCSB; when '0010 100' op = SystemHintOp_CSDB; when '0010 110' if !IsFeatureImplemented(FEAT_CLRBHB) then EndOfDecode(Decode_NOP); op = SystemHintOp_CLRBHB; when '0011 xxx' case op2 of when '000' SEE "PACIAZ"; when '001' SEE "PACIASP"; when '010' SEE "PACIBZ";
```

```
when '011' SEE "PACIBSP"; when '100' SEE "AUTIAZ"; when '101' SEE "AUTIASP"; when '110' SEE "AUTIBZ"; when '111' SEE "AUTIBSP"; when '0100 xx0' if !IsFeatureImplemented(FEAT_BTI) then EndOfDecode(Decode_NOP); // Check branch target compatibility between BTI instruction and PSTATE.BTYPE SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>)); op = SystemHintOp_BTI; when '0100 111' SEE "PACM"; when '0101 000' if !IsFeatureImplemented(FEAT_CHK) then EndOfDecode(Decode_NOP); op = SystemHintOp_CHKFEAT; when '0110 00x' if !IsFeatureImplemented(FEAT_PCDPHINT) then EndOfDecode(Decode_NOP); stream = op2<0> == '1'; op = SystemHintOp_STSHH; otherwise EndOfDecode(Decode_NOP);
```

## Assembler Symbols

## &lt;imm&gt;

Is a 7-bit unsigned immediate, in the range 0 to 127, encoded in the 'CRm:op2' field.

The encodings that are allocated to architectural hint functionality are described in the 'Hints' table in the 'Index by Encoding'.

Note

For allocated encodings of 'CRm:op2':

- Adisassembler will disassemble the allocated instruction, rather than the HINT instruction.
- Anassembler may support assembly of allocated encodings using HINT with the corresponding &lt;imm&gt; value, but it is not required to do so.

## Operation

```
case op of when SystemHintOp_YIELD Hint_Yield(); when SystemHintOp_DGH Hint_DGH(); when SystemHintOp_WFE Hint_WFE(); when SystemHintOp_WFI Hint_WFI(); when SystemHintOp_SEV SendEvent(); when SystemHintOp_SEVL SendEventLocal(); when SystemHintOp_ESB SynchronizeErrors(); AArch64.ESBOperation(); if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation(); elsif IsFeatureImplemented(FEAT_E3DSE) && PSTATE.EL != EL3 then AArch64.dESBOperation();
```

```
TakeUnmaskedSErrorInterrupts(); when SystemHintOp_PSB if IsFeatureImplemented(FEAT_FGT) && IsFeatureImplemented(FEAT_SPEv1p5) then constant boolean trap_to_el2 = (PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && HFGITR_EL2.PSBCSYNC == '1'); if trap_to_el2 then ExceptionRecord except = ExceptionSyndrome(Exception_LDST64BTrap); // to be renamed except.syndrome.iss = \texttt{0x3}<24:0>; constant bits(64) preferred_exception_return = ThisInstrAddr(64); constant integer vect_offset = \texttt{0x0}; AArch64.TakeException(EL2, except, preferred_exception_return, vect_offset); ProfilingSynchronizationBarrier(); when SystemHintOp_TSB if IsFeatureImplemented(FEAT_FGT2) && IsFeatureImplemented(FEAT_TRBEv1p1) then constant boolean trap_to_el2 = (PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() && (!HaveEL(EL3) || SCR_EL3.FGTEn2 == '1') && HFGITR2_EL2.TSBCSYNC == '1'); if trap_to_el2 then ExceptionRecord except = ExceptionSyndrome(Exception_LDST64BTrap); // to be renamed except.syndrome.iss = \texttt{0x4}<24:0>; constant bits(64) preferred_exception_return = ThisInstrAddr(64); constant integer vect_offset = \texttt{0x0}; AArch64.TakeException(EL2, except, preferred_exception_return, vect_offset); TraceSynchronizationBarrier(); when SystemHintOp_GCSB GCSSynchronizationBarrier(); when SystemHintOp_CHKFEAT X[16, 64] = AArch64.ChkFeat(X[16, 64]); when SystemHintOp_CSDB ConsumptionOfSpeculativeDataBarrier(); when SystemHintOp_CLRBHB Hint_CLRBHB(); when SystemHintOp_BTI SetBTypeNext('00'); when SystemHintOp_STSHH Hint_StoreShared(stream); when SystemHintOp_NOP return; // Do nothing otherwise Unreachable();
```

## C6.2.173 HLT

Halt instruction

This instruction can generate a Halt Instruction debug event, which causes entry into Debug state.

Within a guarded memory region, while PSTATE.BTYPE != 0b00 , an HLT instruction that would cause entry into Debug state will not generate a Branch Target exception and will cause entry into Debug state as normal. For more information, see PSTATE.BTYPE.

<!-- image -->

## Encoding

```
HLT #<imm>
```

## Decode for this encoding

```
if EDSCR.HDE == '0' || !HaltingAllowed() then EndOfDecode(Decode_UNDEF); elsif IsFeatureImplemented(FEAT_BTI) then SetBTypeCompatible(TRUE);
```

## Assembler Symbols

## &lt;imm&gt;

Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the 'imm16' field.

## Operation

```
constant boolean is_async = FALSE; constant FaultRecord fault = NoFault();
```

```
Halt(DebugHalt_HaltInstruction, is_async, fault);
```

## C6.2.174 HVC

Hypervisor call

This instruction causes an exception to EL2. Software executing at EL1 can use this instruction to call the hypervisor to request a service.

The HVC instruction is UNDEFINED:

- When EL3 is implemented and SCR\_EL3.HCE is set to 0.
- When EL3 is not implemented and HCR\_EL2.HCD is set to 1.
- When EL2 is not implemented.
- At EL1 if EL2 is not enabled in the current Security state.
- At EL0.

On executing an HVC instruction, the PE records the exception as a Hypervisor Call exception in ESR\_ELx, using the EC syndrome value 0x16 , and the value of the immediate argument.

<!-- image -->

## Encoding

```
HVC #<imm>
```

## Decode for this encoding

```
if !HaveEL(EL2) then EndOfDecode(Decode_UNDEF);
```

```
constant bits(16) imm = imm16;
```

## Assembler Symbols

## &lt;imm&gt;

Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the 'imm16' field.

## Operation

```
if PSTATE.EL == EL0 then UNDEFINED; if PSTATE.EL == EL1 && !EL2Enabled() then UNDEFINED; if !HaveEL(EL3) && HCR_EL2.HCD == '1' then UNDEFINED; if HaveEL(EL3) && SCR_EL3.HCE == '0' then UNDEFINED; AArch64.CallHypervisor(imm);
```

## C6.2.175 IC

Instruction cache operation

For more information, see op0== 0b01 , cache maintenance, TLB maintenance, and address translation instructions.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

```
IC <ic_op>{, <Xt>}
```

## is equivalent to

```
SYS #<op1>, C7, <Cm>, #<op2>{, <Xt>}
```

and is the preferred disassembly when SysOp(op1, '0111', CRm, op2) == Sys\_IC .

## Assembler Symbols

## &lt;ic\_op&gt;

Is an IC operation name, as listed for the IC system instruction pages, encoded in 'op1:CRm:op2':

|   op1 |   CRm |   op2 | <ic_op>   |
|-------|-------|-------|-----------|
|   000 |  0001 |   000 | IALLUIS   |
|   000 |  0101 |   000 | IALLU     |
|   011 |  0101 |   001 | IVAU      |

<!-- image -->

Is the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in the 'Rt' field.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.176 IRG

Insert random tag

This instruction inserts a random Logical Address Tag into the address in the first source register, and writes the result to the destination register. Any tags specified in the optional second source register or in GCR\_EL1.Exclude are excluded from the selection of the random Logical Address Tag.

## Integer

(FEAT\_MTE)

<!-- image -->

## Encoding

```
IRG <Xd|SP>, <Xn|SP>{, <Xm>}
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

## &lt;Xd|SP&gt;

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field. Defaults to XZR if absent.

## Operation

```
constant bits(64) operand = if n == 31 then SP[64] else X[n, 64]; constant bits(64) exclude_reg = X[m, 64]; constant bits(16) exclude = exclude_reg<15:0> OR GCR_EL1.Exclude; constant bits(4) rtag = AArch64.ChooseTagOrZero(exclude); constant bits(64) result = AArch64.AddressWithAllocationTag(operand, rtag); if d == 31 then SP[64] = result; else X[d, 64] = result;
```

## C6.2.177 ISB

Instruction synchronization barrier

This instruction flushes the pipeline in the PE and is a context synchronization event. For more information, see Instruction Synchronization Barrier (ISB).

<!-- image -->

## Encoding

ISB {&lt;option&gt;|#&lt;imm&gt;}

## Decode for this encoding

// no additional decoding required

## Assembler Symbols

## &lt;option&gt;

Specifies an optional limitation on the barrier operation. Values are:

SY Full system barrier operation, encoded as CRm = 0b1111 . Can be omitted.

All other encodings of 'CRm' are reserved. The corresponding instructions execute as full system barrier operations, but must not be relied upon by software.

## &lt;imm&gt;

Is an optional 4-bit unsigned immediate, in the range 0 to 15, defaulting to 15 and encoded in the 'CRm' field.

## Operation

```
InstructionSynchronizationBarrier(); if IsFeatureImplemented(FEAT_BRBE) && BRBEBranchOnISB() then BRBEISB();
```

## C6.2.178 LD64B

Single-copy atomic 64-byte Load

This instruction derives an address from a base register value, loads eight 64-bit doublewords from a memory location, and writes them to consecutive registers. The load starts at register Xt , with the data being read as

X(t+7)::X(t+6)::X(t+5)::X(t+4)::X(t+3)::X(t+2)::X(t+1)::Xt = Data[511:0] . The data is loaded atomically and is required to be 64-byte aligned.

It is IMPLEMENTATION DEFINED which memory locations support this instruction. A memory location that supports LD64B also supports ST64B .

For more information, including about the memory types accessible and how the accesses are performed, see Single-copy atomic 64-byte load/store.

## Integer

(FEAT\_LS64)

<!-- image -->

## Encoding

```
LD64B <Xt>, [<Xn|SP>
```

```
{, #0}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LS64) then EndOfDecode(Decode_UNDEF); if Rt<4:3> == '11' || Rt<0> == '1' then EndOfDecode(Decode_UNDEF); constant boolean withstatus = FALSE; constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean tagchecked = n != 31;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LD64B.

## Assembler Symbols

&lt;Xt&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
CheckLDST64BEnabled(); bits(512) data; bits(64) address; bits(64) value; constant AccessDescriptor accdesc = CreateAccDescLS64(MemOp_LOAD, withstatus, tagchecked); if n == 31 then CheckSPAlignment();
```

```
address = SP[64]; else address = X[n, 64]; data = MemLoad64B(address, accdesc); for i = 0 to 7 value = data<63+64*i : 64*i>; if BigEndian(accdesc.acctype) then value = BigEndianReverse(value); X[t+i, 64] = value;
```

## C6.2.179 LDADD, LDADDA, LDADDAL, LDADDL

Atomic add on word or doubleword

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not one of WZR or XZR , LDADDA and LDADDAL load from memory with acquire semantics.
- LDADDL and LDADDAL store to memory with release semantics.
- LDADD has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STADD, STADDL.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

```
Applies when (size == 10 && A == 0 && R == 0)
```

```
LDADD <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire variant

```
Applies when (size == 10 && A == 1 && R ==
```

```
LDADDA
```

```
0) <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire-release variant

```
Applies when (size == 10 && A == 1 && R ==
```

```
LDADDAL
```

```
1) <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit release variant

Applies when (size == 10 &amp;&amp; A == 0 &amp;&amp; R == 1)

```
LDADDL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 64-bit no memory ordering variant

```
Applies when (size == 11 && A == 0 && R ==
```

```
LDADD <Xs>,
```

```
0) <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire variant

```
Applies when (size == 11 && A == 1 && R == 0) LDADDA <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire-release variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDADDAL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && A == 0 && R == 1) LDADDL <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Alias Conditions

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

| Alias         | Is preferred when         |
|---------------|---------------------------|
| STADD, STADDL | A == '0' && Rt == '11111' |

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_ADD, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS constant bits(datasize) value = X[s, datasize]; constant bits(datasize) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.180 LDADDB, LDADDAB, LDADDALB, LDADDLB

Atomic add on byte

This instruction atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDADDAB and LDADDALB load from memory with acquire semantics.
- LDADDLB and LDADDALB store to memory with release semantics.
- LDADDB has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STADDB, STADDLB.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

Applies when

(A == 0

&amp;&amp;

R

==

0)

```
LDADDB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0)
```

```
LDADDAB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R == 1)
```

```
LDADDALB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R ==
```

```
LDADDLB
```

```
1) <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_ADD, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(8) comparevalue = bits(8) UNKNOWN; // Irrelevant when not executing CAS constant bits(8) value = X[s, 8]; constant bits(8) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias           | Is preferred when         |
|-----------------|---------------------------|
| STADDB, STADDLB | A == '0' && Rt == '11111' |

## C6.2.181 LDADDH, LDADDAH, LDADDALH, LDADDLH

Atomic add on halfword

This instruction atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDADDAH and LDADDALH load from memory with acquire semantics.
- LDADDLH and LDADDALH store to memory with release semantics.
- LDADDH has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STADDH, STADDLH.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

Applies when

(A == 0

&amp;&amp;

R

==

0)

```
LDADDH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDADDAH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R == 1)
```

```
LDADDALH
```

```
<Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R == 1)
```

```
LDADDLH <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_ADD, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(16) comparevalue = bits(16) UNKNOWN; // Irrelevant when not executing CAS constant bits(16) value = X[s, 16]; constant bits(16) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias           | Is preferred when         |
|-----------------|---------------------------|
| STADDH, STADDLH | A == '0' && Rt == '11111' |

## C6.2.182 LDAPR

Load-acquire RCpc register

This instruction derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from the derived address in memory, and writes it to a register.

If the destination register is not one of WZR or XZR , LDAPR loads from memory with AcquirePC semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

It has encodings from 2 classes: Post-index and No offset

## Post-index

(FEAT\_LRCPC3)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when 10)
```

```
(size == LDAPR <Wt>, [<Xn|SP>], #4
```

## Encoding for the 64-bit variant

```
Applies when 11)
```

```
(size == LDAPR <Xt>, [<Xn|SP>], #8
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LRCPC3) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); boolean wback = TRUE; constant boolean acquirepc = t != 31; constant integer regsize = if size == '11' then 64 else 32; constant integer datasize = 8 << UInt(size); constant integer offset = 1 << UInt(size); constant boolean tagchecked = TRUE; boolean wb_unknown = FALSE; if n == t && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD); assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_WBSUPPRESS wback = FALSE; // writeback is suppressed when Constraint_UNKNOWN wb_unknown = TRUE; // writeback is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

## No offset

(FEAT\_LRCPC)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) LDAPR <Wt>, [<Xn|SP>
```

```
{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) LDAPR <Xt>, [<Xn|SP> {, #0}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LRCPC) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean wback = FALSE; constant integer offset = 0; constant boolean wb_unknown = FALSE; constant integer elsize = 8 << UInt(size); constant integer regsize = if elsize == 64 then 64 else 32; constant integer datasize = elsize; constant boolean acquirepc = t != 31; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Operation

```
bits(64) address; bits(datasize) data; constant integer dbytes = datasize DIV 8; constant AccessDescriptor accdesc = CreateAccDescLDAcqPC(tagchecked, acquirepc, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else
```

```
address = X[n, 64]; data = Mem[address, dbytes, accdesc]; X[t, regsize] = ZeroExtend(data, regsize); if wback then if wb_unknown then address = bits(64) UNKNOWN; else address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.183 LDAPRB

Load-acquire RCpc register byte

This instruction derives an address from a base register value, loads a byte from the derived address in memory, zero-extends it and writes it to a register.

If the destination register is not one of WZR or XZR , LDAPRB loads from memory with AcquirePC semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Integer

(FEAT\_LRCPC)

<!-- image -->

## Encoding

```
LDAPRB <Wt>, [<Xn|SP> {, #0}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LRCPC) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquirepc = t != 31; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; bits(8) data; constant AccessDescriptor accdesc = CreateAccDescLDAcqPC(tagchecked, acquirepc, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; data = Mem[address, 1, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.184 LDAPRH

Load-acquire RCpc register halfword

This instruction derives an address from a base register value, loads a halfword from the derived address in memory, zero-extends it and writes it to a register.

If the destination register is not one of WZR or XZR , LDAPRH loads from memory with AcquirePC semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Integer

(FEAT\_LRCPC)

<!-- image -->

## Encoding

```
LDAPRH <Wt>, [<Xn|SP> {, #0}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LRCPC) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquirepc = t != 31; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; bits(16) data; constant AccessDescriptor accdesc = CreateAccDescLDAcqPC(tagchecked, acquirepc, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; data = Mem[address, 2, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.185 LDAPUR

Load-acquire RCpc register (unscaled)

This instruction calculates an address from a base register and an immediate offset, loads a 32-bit word or 64-bit doubleword from memory, zero-extends it, and writes it to a register.

If the destination register is not one of WZR or XZR , LDAPUR loads from memory with AcquirePC semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Unscaled offset

(FEAT\_LRCPC2)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) LDAPUR
```

```
<Wt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) LDAPUR
```

```
<Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LRCPC2) then constant integer scale = UInt(size); constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8 << scale; constant integer{} regsize = if datasize == 64 then 64 else constant boolean acquirepc = t != 31; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
32;
```

```
CreateAccDescLDAcqPC(tagchecked, acquirepc, t);
```

## C6.2.186 LDAPURB

Load-acquire RCpc register byte (unscaled)

This instruction calculates an address from a base register and an immediate offset, loads a byte from memory, zero-extends it, and writes it to a register.

If the destination register is not one of WZR or XZR , LDAPURB loads from memory with AcquirePC semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Unscaled offset

(FEAT\_LRCPC2)

<!-- image -->

## Encoding

```
LDAPURB <Wt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LRCPC2) then constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8; constant boolean acquirepc = t != 31; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
CreateAccDescLDAcqPC(tagchecked, acquirepc, t);
```

## C6.2.187 LDAPURH

Load-acquire RCpc register halfword (unscaled)

This instruction calculates an address from a base register and an immediate offset, loads a halfword from memory, zero-extends it, and writes it to a register.

If the destination register is not one of WZR or XZR , LDAPURH loads from memory with AcquirePC semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Unscaled offset

(FEAT\_LRCPC2)

<!-- image -->

## Encoding

```
LDAPURH <Wt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LRCPC2) then constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 16; constant boolean acquirepc = t != 31; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
CreateAccDescLDAcqPC(tagchecked, acquirepc, t);
```

## C6.2.188 LDAPURSB

Load-acquire RCpc register signed byte (unscaled)

This instruction calculates an address from a base register and an immediate offset, loads a signed byte from memory, sign-extends it, and writes it to a register.

If the destination register is not one of WZR or XZR , LDAPURSB loads from memory with AcquirePC semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Unscaled offset

(FEAT\_LRCPC2)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 11) LDAPURSB <Wt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDAPURSB <Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LRCPC2) then constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8; constant integer{} regsize = 64 >> constant boolean acquirepc = t != 31; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, regsize] = SignExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
UInt(opc<0>);
```

```
CreateAccDescLDAcqPC(tagchecked, acquirepc, t);
```

## C6.2.189 LDAPURSH

Load-acquire RCpc register signed halfword (unscaled)

This instruction calculates an address from a base register and an immediate offset, loads a signed halfword from memory, sign-extends it, and writes it to a register.

If the destination register is not one of WZR or XZR , LDAPURSH loads from memory with AcquirePC semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Unscaled offset

(FEAT\_LRCPC2)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 11) LDAPURSH <Wt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDAPURSH <Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LRCPC2) then constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 16; constant integer{} regsize = 64 >> constant boolean acquirepc = t != 31; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, regsize] = SignExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
UInt(opc<0>);
```

```
CreateAccDescLDAcqPC(tagchecked, acquirepc, t);
```

## C6.2.190 LDAPURSW

Load-acquire RCpc register signed word (unscaled)

This instruction calculates an address from a base register and an immediate offset, loads a signed word from memory, sign-extends it, and writes it to a register.

If the destination register is not one of WZR or XZR , LDAPURSW loads from memory with AcquirePC semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Unscaled offset

(FEAT\_LRCPC2)

<!-- image -->

## Encoding

```
LDAPURSW <Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LRCPC2) then constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 32; constant boolean acquirepc = t != 31; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, 64] = SignExtend(data, 64);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
CreateAccDescLDAcqPC(tagchecked, acquirepc, t);
```

## C6.2.191 LDAR

## Load-acquire register

This instruction derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register.

If the destination register is not one of WZR or XZR , LDAR loads from memory with Acquire semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == LDAR
```

```
10) <Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) LDAR <Xt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer elsize = 8 << UInt(size); constant integer regsize = if elsize == 64 then 64 else constant boolean acquire = t != 31; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

&lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

&lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Operation

```
bits(64) address; constant integer dbytes = elsize DIV 8; constant AccessDescriptor accdesc = CreateAccDescAcqRel(MemOp_LOAD, tagchecked, acquire, t); if n == 31 then CheckSPAlignment();
```

```
32;
```

```
address = SP[64]; else address = X[n, 64]; constant bits(elsize) data = Mem[address, dbytes, accdesc]; X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.192 LDARB

Load-acquire register byte

This instruction derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register.

If the destination register is not one of WZR or XZR , LDARB loads from memory with Acquire semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDARB <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = t != 31; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = CreateAccDescAcqRel(MemOp_LOAD, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(8) data = Mem[address, 1, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

o0

## C6.2.193 LDARH

Load-acquire register halfword

This instruction derives an address from a base register value, loads a halfword from memory, zero-extends it, and writes it to a register.

If the destination register is not one of WZR or XZR , LDARH loads from memory with Acquire semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDARH <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = t != 31; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = CreateAccDescAcqRel(MemOp_LOAD, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(16) data = Mem[address, 2, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

o0

## C6.2.194 LDATXR

Load-acquire unprivileged exclusive register

This instruction derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

Note

For the purposes of the Exclusives monitors, and the forward progress guarantees for Load-Exclusive and Store-Exclusive loops, LDATXR is equivalent to LDXR .

For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LSUI)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sz == 0) LDATXR
```

```
<Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (sz == 1) LDATXR
```

```
<Xt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer elsize = 32 << UInt(sz); constant integer regsize = if elsize == 64 then 64 else 32; constant boolean acqrel = t != 31; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

&lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Operation

```
bits(64) address; bits(elsize) data; constant integer dbytes = elsize DIV 8; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; AArch64.SetExclusiveMonitors(address, dbytes, accdesc); data = Mem[address, dbytes, accdesc]; X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.195 LDAXP

Load-acquire exclusive pair of registers

This instruction derives an address from a base register value, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. For information on single-copy atomicity and alignment requirements, see Requirements for single-copy atomicity and Alignment of data accesses. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores.

If the destination registers are not both WZR or not both XZR , LDAXP loads from memory with Acquire semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sz == 0) LDAXP
```

```
<Wt1>, <Wt2>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (sz == 1) LDAXP
```

```
<Xt1>, <Xt2>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant integer elsize = 32 << UInt(sz); constant integer datasize = elsize * 2; constant boolean acqrel = t != 31 && t2 != 31; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDAXP.

## Assembler Symbols

&lt;Wt1&gt;

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Wt2&gt;

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

&lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## Operation

```
bits(64) address; bits(datasize) data; constant integer dbytes = datasize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant boolean ispair = elsize == 64; // When elsize is 32, the access is single-copy atomic constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked, privileged, ispair, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; AArch64.SetExclusiveMonitors(address, dbytes, accdesc); data = Mem[address, dbytes, accdesc]; if rt_unknown then // ConstrainedUNPREDICTABLE case X[t, datasize] = bits(datasize) UNKNOWN; // In this case t = t2 elsif BigEndian(accdesc.acctype) then X[t, elsize] = data<elsize +: elsize>; X[t2, elsize] = data<0 +: elsize>; else X[t, elsize] = data<0 +: elsize>; X[t2, elsize] = data<elsize +: elsize>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.196 LDAXR

Load-acquire exclusive register

This instruction derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores.

If the destination register is not one of WZR or XZR , LDAXR loads from memory with Acquire semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) LDAXR <Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) LDAXR <Xt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer elsize = 8 << UInt(size); constant integer regsize = if elsize == 64 then 64 else constant boolean acqrel = t != 31; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xt&gt;

```
32;
```

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Operation

```
bits(64) address; bits(elsize) data; constant integer dbytes = elsize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; AArch64.SetExclusiveMonitors(address, dbytes, accdesc); data = Mem[address, dbytes, accdesc]; X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.197 LDAXRB

Load-acquire exclusive register byte

This instruction derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores.

If the destination register is not one of WZR or XZR , LDAXRB loads from memory with Acquire semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDAXRB <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acqrel = t != 31; constant boolean tagchecked =
```

```
n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; bits(8) data; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; AArch64.SetExclusiveMonitors(address, 1, accdesc); data = Mem[address, 1, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.198 LDAXRH

Load-acquire exclusive register halfword

This instruction derives an address from a base register value, loads a halfword from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores.

If the destination register is not one of WZR or XZR , LDAXRH loads from memory with Acquire semantics.

For more information about memory ordering semantics, see Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDAXRH <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acqrel = t != 31; constant boolean tagchecked =
```

```
n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; bits(16) data; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; AArch64.SetExclusiveMonitors(address, 2, accdesc); data = Mem[address, 2, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.199 LDCLR, LDCLRA, LDCLRAL, LDCLRL

Atomic bit clear on word or doubleword

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not one of WZR or XZR , LDCLRA and LDCLRAL load from memory with acquire semantics.
- LDCLRL and LDCLRAL store to memory with release semantics.
- LDCLR has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STCLR, STCLRL.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

LDCLR

&lt;Ws&gt;,

(size ==

10

&amp;&amp;

A

==

0 &amp;&amp;

&lt;Wt&gt;, [&lt;Xn|SP&gt;]

## Encoding for the 32-bit acquire variant

```
Applies when (size == 10 && A == 1 && R == 0) LDCLRA <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire-release variant

```
Applies when (size == 10 && A == 1 && R == 1) LDCLRAL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit release variant

```
Applies when (size == 10 && A == 0 && R == 1) LDCLRL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 64-bit no memory ordering variant

```
Applies when (size == 11 && A == 0 && R == 0) LDCLR <Xs>, <Xt>, [<Xn|SP>]
```

R ==

0)

## Encoding for the 64-bit acquire variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDCLRA
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire-release variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDCLRAL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && A == 0 && R ==
```

```
LDCLRL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

<!-- image -->

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Alias Conditions

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

| Alias         | Is preferred when         |
|---------------|---------------------------|
| STCLR, STCLRL | A == '0' && Rt == '11111' |

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_BIC, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS constant bits(datasize) value = X[s, datasize]; constant bits(datasize) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.200 LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB

Atomic bit clear on byte

This instruction atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDCLRAB and LDCLRALB load from memory with acquire semantics.
- LDCLRLB and LDCLRALB store to memory with release semantics.
- LDCLRB has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STCLRB, STCLRLB.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R == 0) LDCLRB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDCLRAB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R == 1) LDCLRALB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R == 1) LDCLRLB <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_BIC, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(8) comparevalue = bits(8) UNKNOWN; // Irrelevant when not executing CAS constant bits(8) value = X[s, 8]; constant bits(8) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias           | Is preferred when         |
|-----------------|---------------------------|
| STCLRB, STCLRLB | A == '0' && Rt == '11111' |

## C6.2.201 LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH

Atomic bit clear on halfword

This instruction atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDCLRAH and LDCLRALH load from memory with acquire semantics.
- LDCLRLH and LDCLRALH store to memory with release semantics.
- LDCLRH has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STCLRH, STCLRLH.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R ==
```

```
0) LDCLRH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDCLRAH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R == 1) LDCLRALH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R == 1) LDCLRLH <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_BIC, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(16) comparevalue = bits(16) UNKNOWN; // Irrelevant when not executing CAS constant bits(16) value = X[s, 16]; constant bits(16) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias           | Is preferred when         |
|-----------------|---------------------------|
| STCLRH, STCLRLH | A == '0' && Rt == '11111' |

## C6.2.202 LDCLRP, LDCLRPA, LDCLRPAL, LDCLRPL

Atomic bit clear on quadword

This instruction atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers.

- LDCLRPA and LDCLRPAL load from memory with acquire semantics.
- LDCLRPL and LDCLRPAL store to memory with release semantics.
- LDCLRP has neither acquire nor release semantics.

## Integer

(FEAT\_LSE128)

<!-- image -->

## Encoding for the LDCLRP variant

Applies when

(A == 0

&amp;&amp;

R

==

0)

```
LDCLRP <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the LDCLRPA variant

```
0)
```

```
Applies when (A == 1 && R == LDCLRPA <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the LDCLRPAL variant

```
Applies when (A == 1 && R == 1) LDCLRPAL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the LDCLRPL variant

Applies when (A == 0 &amp;&amp; R == 1)

```
LDCLRPL
```

```
<Xt1>, <Xt2>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE128) then EndOfDecode(Decode_UNDEF); if Rt == '11111' then EndOfDecode(Decode_UNDEF); if Rt2 == '11111' then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LSE128OVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
```

```
case c of when Constraint_UNKNOWN rt_unknown = TRUE; // result when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

```
is UNKNOWN
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly CONSTRAINED UNPREDICTABLE behavior for A64 instructions.

## Assembler Symbols

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; constant bits(64) value1 = X[t, 64]; constant bits(64) value2 = X[t2, 64]; bits(128) data; bits(128) store_value; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_BIC, acquire, release, tagchecked, privileged, t, t2, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; store_value = if BigEndian(accdesc.acctype) then value1:value2 else value2:value1; constant bits(128) comparevalue = bits(128) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, store_value, accdesc); if rt_unknown then data = bits(128) UNKNOWN; if BigEndian(accdesc.acctype) then X[t, 64] = data<127:64>; X[t2, 64] = data<63:0>; else X[t, 64] = data<63:0>; X[t2, 64] = data<127:64>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.203 LDEOR, LDEORA, LDEORAL, LDEORL

Atomic exclusive-OR on word or doubleword

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not one of WZR or XZR , LDEORA and LDEORAL load from memory with acquire semantics.
- LDEORL and LDEORAL store to memory with release semantics.
- LDEOR has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STEOR, STEORL.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

LDEOR

&lt;Ws&gt;,

(size ==

10

&amp;&amp;

A

==

0 &amp;&amp;

&lt;Wt&gt;, [&lt;Xn|SP&gt;]

## Encoding for the 32-bit acquire variant

```
Applies when (size == 10 && A == 1 && R == 0) LDEORA <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire-release variant

```
Applies when (size == 10 && A == 1 && R == 1) LDEORAL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit release variant

```
Applies when (size == 10 && A == 0 && R == 1) LDEORL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 64-bit no memory ordering variant

```
Applies when (size == 11 && A == 0 && R == 0) LDEOR <Xs>, <Xt>, [<Xn|SP>]
```

R ==

0)

## Encoding for the 64-bit acquire variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDEORA
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire-release variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDEORAL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && A == 0 && R == 1)
```

```
LDEORL <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

<!-- image -->

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Alias Conditions

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

| Alias         | Is preferred when         |
|---------------|---------------------------|
| STEOR, STEORL | A == '0' && Rt == '11111' |

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_EOR, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS constant bits(datasize) value = X[s, datasize]; constant bits(datasize) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.204 LDEORB, LDEORAB, LDEORALB, LDEORLB

Atomic exclusive-OR on byte

This instruction atomically loads an 8-bit byte from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDEORAB and LDEORALB load from memory with acquire semantics.
- LDEORLB and LDEORALB store to memory with release semantics.
- LDEORB has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STEORB, STEORLB.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

Applies when

(A == 0

&amp;&amp;

R

==

0)

```
LDEORB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when
```

```
LDEORAB
```

```
(A == 1 && R == 0) <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R == 1)
```

```
LDEORALB
```

```
<Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R ==
```

```
LDEORLB
```

```
1) <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_EOR, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(8) comparevalue = bits(8) UNKNOWN; // Irrelevant when not executing CAS constant bits(8) value = X[s, 8]; constant bits(8) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias           | Is preferred when         |
|-----------------|---------------------------|
| STEORB, STEORLB | A == '0' && Rt == '11111' |

## C6.2.205 LDEORH, LDEORAH, LDEORALH, LDEORLH

Atomic exclusive-OR on halfword

This instruction atomically loads a 16-bit halfword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDEORAH and LDEORALH load from memory with acquire semantics.
- LDEORLH and LDEORALH store to memory with release semantics.
- LDEORH has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STEORH, STEORLH.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R ==
```

```
0) LDEORH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDEORAH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R == 1) LDEORALH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R == 1) LDEORLH <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_EOR, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(16) comparevalue = bits(16) UNKNOWN; // Irrelevant when not executing CAS constant bits(16) value = X[s, 16]; constant bits(16) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias           | Is preferred when         |
|-----------------|---------------------------|
| STEORH, STEORLH | A == '0' && Rt == '11111' |

## C6.2.206 LDG

## Load Allocation Tag

This instruction loads an Allocation Tag from a memory address, generates a Logical Address Tag from the Allocation Tag and merges it into the destination register. The address used for the load is calculated from the base register and an immediate signed offset scaled by the Tag Granule.

## Integer

(FEAT\_MTE)

<!-- image -->

## Encoding

```
LDG
```

```
<Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
```

## Assembler Symbols

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the 'imm9' field.

## Operation

```
bits(64) address; bits(4) tag; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant boolean stzgm = FALSE; constant AccessDescriptor accdesc address = AddressAdd(address, offset, accdesc); address = Align(address, TAG_GRANULE); tag = AArch64.MemTag[address, accdesc]; X[t, 64] = AArch64.AddressWithAllocationTag(X[t, 64], tag);
```

```
= CreateAccDescLDGSTG(MemOp_LOAD, stzgm, t);
```

## C6.2.207 LDGM

## Load tag multiple

This instruction reads a naturally aligned block of N Allocation Tags, where the size of N is identified in GMID\_EL1.BS, and writes the Allocation Tag read from address A to the destination register at 4*A&lt;7:4&gt;+3:4*A&lt;7:4&gt;. Bits of the destination register not written with an Allocation Tag are set to 0.

This instruction is UNDEFINED at EL0.

This instruction generates an Unchecked access.

## Integer

(FEAT\_MTE2)

<!-- image -->

## Encoding

```
LDGM <Xt>, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE2) then constant integer t = UInt(Rt); constant integer n = UInt(Rn);
```

## Assembler Symbols

<!-- image -->

&lt;Xt&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if PSTATE.EL == EL0 then UNDEFINED; bits(64) data = Zeros(64); bits(64) address; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant integer size = 4 * (2 ^ (UInt(GMID_EL1.BS))); address = Align(address, size); constant integer count = size >> LOG2_TAG_GRANULE; integer index = UInt(address<LOG2_TAG_GRANULE+3:LOG2_TAG_GRANULE>); constant boolean stzgm = FALSE; constant AccessDescriptor accdesc for i = 0 to count-1 constant bits(4) tag = AArch64.MemTag[address, accdesc];
```

```
EndOfDecode(Decode_UNDEF);
```

```
= CreateAccDescLDGSTG(MemOp_LOAD, stzgm, t);
```

```
Elem[data, index, 4] = tag; address = AddressIncrement(address, TAG_GRANULE, accdesc); index = index + 1; X[t, 64] = data;
```

## C6.2.208 LDIAPP

Load-Acquire RCpc ordered pair of registers

This instruction calculates an address from a base register value and an optional offset, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. For information on single-copy atomicity and alignment requirements, see Requirements for single-copy atomicity and Alignment of data accesses. The instruction also has memory ordering semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release, except that:

- The Memory effects associated with Xt1/Wt1 are Ordered-before the Memory effects associated with Xt2/Wt2.
- If the destination registers are not both WZR or not both XZR , LDIAPP loads from memory with Acquire semantics.
- There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
- The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

For information about addressing modes, see Load/Store addressing modes.

## Integer

(FEAT\_LRCPC3)

<!-- image -->

## Encoding for the 32-bit post-index variant

```
Applies when
```

```
(size == 10 && opc2 == 0000) LDIAPP <Wt1>, <Wt2>, [<Xn|SP>], #8
```

## Encoding for the 32-bit variant

```
Applies when (size == 10 && opc2 == 0001) LDIAPP <Wt1>, <Wt2>, [<Xn|SP>]
```

## Encoding for the 64-bit post-index variant

```
Applies when (size == 11 && opc2 == 0000) LDIAPP <Xt1>, <Xt2>, [<Xn|SP>], #16
```

## Encoding for the 64-bit variant

```
Applies when (size == 11 && opc2 == 0001) LDIAPP <Xt1>, <Xt2>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LRCPC3) then constant boolean ispair = TRUE; constant boolean postindex = opc2<0> == '0'; boolean wback = opc2<0> == '0';
```

LDIAPP has the same CONSTRAINED UNPREDICTABLE behavior as LDP . For information about this CONSTRAINED UNPREDICTABLE behavior, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDP and LDIAPP.

## Assembler Symbols

## &lt;Wt1&gt;

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Wt2&gt;

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant integer{} scale = 2 + UInt(size<0>); constant integer{} datasize = 8 << scale; constant integer offset = if opc2<0> == '0' then (2 << scale) else 0; constant boolean acqrel = t != 31 && t2 != 31; constant boolean tagchecked = wback || n != 31; boolean rt_unknown = FALSE; boolean wb_unknown = FALSE; if wback && (t == n || t2 == n) && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD); assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_WBSUPPRESS wback = FALSE; // writeback is suppressed when Constraint_UNKNOWN wb_unknown = TRUE; // writeback is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

## Operation

```
bits(64) address; bits(datasize) data1; bits(datasize) data2; constant integer dbytes = datasize DIV 8; constant AccessDescriptor accdesc = CreateAccDescLDAcqPC(tagchecked, ispair, acqrel, t, t2); if n == 31 then
```

```
CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); bits(2*datasize) full_data; full_data = Mem[address, 2*dbytes, accdesc]; if BigEndian(accdesc.acctype) then data2 = full_data<(datasize-1):0>; data1 = full_data<(2*datasize-1):datasize>; else data1 = full_data<(datasize-1):0>; data2 = full_data<(2*datasize-1):datasize>; if rt_unknown then data1 = bits(datasize) UNKNOWN; data2 = bits(datasize) UNKNOWN; X[t, datasize] = data1; X[t2, datasize] = data2; if wback then if wb_unknown then address = bits(64) UNKNOWN; elsif postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.209 LDLAR

## Load LOAcquire register

This instruction loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register.

If the destination register is not one of WZR or XZR , LDLAR loads from memory with Acquire semantics.

For more information about memory ordering semantics, see Load LOAcquire, Store LORelease and Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LOR)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) LDLAR <Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) LDLAR <Xt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LOR) then EndOfDecode(Decode_UNDEF);
```

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer elsize = 8 << UInt(size); constant integer regsize = if elsize == 64 then 64 else 32; constant boolean acquire = t != 31; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Operation

```
bits(64) address; constant integer dbytes = elsize DIV 8; constant AccessDescriptor accdesc = CreateAccDescLOR(MemOp_LOAD, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(elsize) data = Mem[address, dbytes, accdesc]; X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.210 LDLARB

Load LOAcquire register byte

This instruction loads a byte from memory, zero-extends it and writes it to a register.

If the destination register is not one of WZR or XZR , LDLARB loads from memory with Acquire semantics.

For more information about memory ordering semantics, see Load LOAcquire, Store LORelease and Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LOR)

<!-- image -->

## Encoding

```
LDLARB <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LOR) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = t != 31; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

&lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = CreateAccDescLOR(MemOp_LOAD, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(8) data = Mem[address, 1, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.211 LDLARH

Load LOAcquire register halfword

This instruction loads a halfword from memory, zero-extends it, and writes it to a register.

If the destination register is not one of WZR or XZR , LDLARH loads from memory with Acquire semantics.

For more information about memory ordering semantics, see Load LOAcquire, Store LORelease and Load-Acquire, Load-AcquirePC, and Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LOR)

<!-- image -->

## Encoding

```
LDLARH <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LOR) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = t != 31; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

&lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = CreateAccDescLOR(MemOp_LOAD, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(16) data = Mem[address, 2, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

o0

## C6.2.212 LDNP

Load pair of registers, with non-temporal hint

This instruction calculates an address from a base register value and an immediate offset, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers.

For information about addressing modes, see Load/Store addressing modes. For information about non-temporal pair instructions, see Load/Store non-temporal pair.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) LDNP
```

```
<Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDNP
```

```
<Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for all variants of this encoding

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = TRUE; constant integer scale = 2 + UInt(opc<1>); constant integer datasize = 8 << scale; constant bits(64) offset = LSL(SignExtend(imm7, 64), scale); constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // Result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDNP.

## Assembler Symbols

&lt;Wt1&gt;

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

&lt;Wt2&gt;

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the '32-bit' variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/4.

For the '64-bit' variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/8.

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

&lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## Operation

```
bits(64) address; constant integer dbytes = datasize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, ispair, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(2*datasize) data = Mem[address, 2 * dbytes, accdesc]; if rt_unknown then X[t, datasize] = bits(datasize) UNKNOWN; elsif BigEndian(accdesc.acctype) then X[t2, datasize] = data<(datasize-1):0>; X[t, datasize] = data<(2*datasize-1):datasize>; else X[t, datasize] = data<(datasize-1):0>; X[t2, datasize] = data<(2*datasize-1):datasize>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.213 LDP

## Load pair of registers

This instruction calculates an address from a base register value and an immediate offset, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. For information about addressing modes, see Load/Store addressing modes.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) LDP <Wt1>, <Wt2>, [<Xn|SP>], #<imm>
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>
```

## Decode for all variants of this encoding

```
boolean wback = TRUE; constant boolean postindex =
```

## Pre-index

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) LDP
```

```
<Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDP <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!
```

## Decode for all variants of this encoding

```
boolean wback = TRUE; constant boolean postindex =
```

```
FALSE;
```

```
TRUE;
```

## Signed offset

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) LDP
```

```
<Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for all variants of this encoding

```
boolean wback = FALSE; constant boolean postindex = FALSE;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDP.

## Assembler Symbols

## &lt;Wt1&gt;

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Wt2&gt;

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the 'Post-index 32-bit' and 'Pre-index 32-bit' variants: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the 'imm7' field as &lt;imm&gt;/4.

For the 'Post-index 64-bit' and 'Pre-index 64-bit' variants: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the 'imm7' field as &lt;imm&gt;/8.

For the 'Signed offset 32-bit' variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/4.

For the 'Signed offset 64-bit' variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/8.

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = FALSE; constant integer{} scale = 2 + UInt(opc<1>); constant integer{} datasize = 8 << scale; constant bits(64) offset = LSL(SignExtend(imm7, 64), scale); constant boolean tagchecked = wback || n != 31; boolean rt_unknown = FALSE; boolean wb_unknown = FALSE; if wback && (t == n || t2 == n) && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD); assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_WBSUPPRESS wback = FALSE; // Writeback is suppressed when Constraint_UNKNOWN wb_unknown = TRUE; // Writeback is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // Result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

```
Operation bits(64) address; bits(datasize) data1; bits(datasize) data2; constant integer dbytes = datasize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, ispair, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); constant bits(2*datasize) data = Mem[address, 2 * dbytes, accdesc]; if rt_unknown then data1 = bits(datasize) UNKNOWN; data2 = bits(datasize) UNKNOWN; elsif BigEndian(accdesc.acctype) then data2 = data<(datasize-1):0>; data1 = data<(2*datasize-1):datasize>; else data1 = data<(datasize-1):0>; data2 = data<(2*datasize-1):datasize>;
```

```
X[t, datasize] = data1; X[t2, datasize] = data2; if wback then if wb_unknown then address = bits(64) UNKNOWN; elsif postindex then address = AddressAdd(address, offset, if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
accdesc);
```

## C6.2.214 LDPSW

Load pair of registers signed word

This instruction calculates an address from a base register value and an immediate offset, loads two 32-bit words from memory, sign-extends them, and writes them to two registers. For information about addressing modes, see Load/Store addressing modes.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

<!-- image -->

## Encoding

```
LDPSW <Xt1>, <Xt2>, [<Xn|SP>], #<imm>
```

## Decode for this encoding

```
boolean wback = TRUE; constant boolean postindex = TRUE;
```

## Pre-index

<!-- image -->

## Encoding

```
LDPSW <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!
```

## Decode for this encoding

```
boolean wback = TRUE; constant boolean postindex = FALSE;
```

## Signed offset

<!-- image -->

## Encoding

```
LDPSW <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
boolean wback = FALSE; constant boolean postindex =
```

```
FALSE;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDPSW.

## Assembler Symbols

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the 'Post-index' and 'Pre-index' variants: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the 'imm7' field as &lt;imm&gt;/4.

For the 'Signed offset' variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/4.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = FALSE; constant integer{} scale = 2 + UInt(opc<1>); constant integer{} datasize = 32; constant bits(64) offset = LSL(SignExtend(imm7, 64), scale); constant boolean tagchecked = wback || n != 31; boolean rt_unknown = FALSE; boolean wb_unknown = FALSE; if wback && (t == n || t2 == n) && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD); assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_WBSUPPRESS wback = FALSE; // Writeback is suppressed when Constraint_UNKNOWN wb_unknown = TRUE; // Writeback is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // Result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

## Operation

```
bits(64) address; bits(datasize) data1; bits(datasize) data2; constant integer dbytes = datasize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, ispair, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); constant bits(2*datasize) data = Mem[address, 2 * dbytes, accdesc]; if rt_unknown then data1 = bits(datasize) UNKNOWN; data2 = bits(datasize) UNKNOWN; elsif BigEndian(accdesc.acctype) then data2 = data<(datasize-1):0>; data1 = data<(2*datasize-1):datasize>; else data1 = data<(datasize-1):0>; data2 = data<(2*datasize-1):datasize>; X[t, 64] = SignExtend(data1, 64); X[t2, 64] = SignExtend(data2, 64); if wback then if wb_unknown then address = bits(64) UNKNOWN; elsif postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.215 LDR (immediate)

Load register (immediate)

This instruction loads a word or doubleword from memory and writes it to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about addressing modes, see Load/Store addressing modes. The Unsigned offset variant scales the immediate offset value by the size of the value accessed before adding it to the base register value.

It has encodings from 3 classes: Post-index, Pre-index, and Unsigned offset

## Post-index

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) LDR <Wt>, [<Xn|SP>], #<simm>
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) LDR <Xt>, [<Xn|SP>], #<simm>
```

## Decode for all variants of this encoding

```
boolean wback = TRUE; constant boolean postindex = TRUE; constant integer scale = UInt(size); constant bits(64) offset
```

## Pre-index

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) LDR <Wt>, [<Xn|SP>, #<simm>]!
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) LDR <Xt>, [<Xn|SP>, #<simm>]!
```

```
= SignExtend(imm9, 64);
```

## Decode for all variants of this encoding

```
boolean wback = TRUE; constant boolean postindex = FALSE; constant integer scale = UInt(size); constant bits(64) offset
```

## Unsigned offset

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) LDR <Wt>, [<Xn|SP>{, #<pimm>}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) LDR <Xt>, [<Xn|SP>{, #<pimm>}]
```

## Decode for all variants of this encoding

```
boolean wback = FALSE; constant boolean postindex = FALSE; constant integer scale = UInt(size); constant bits(64) offset = LSL(ZeroExtend(imm12, 64),
```

```
scale);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDR (immediate).

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the signed immediate byte offset, in the range -256 to 255, encoded in the 'imm9' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;pimm&gt;

For the '32-bit' variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/4.

For the '64-bit' variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/8.

```
= SignExtend(imm9, 64);
```

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8 << scale; constant integer{} regsize = if datasize == 64 then 64 else 32; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31; Constraint c; boolean wb_unknown = FALSE; if wback && n == t && n != 31 then c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD); assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_WBSUPPRESS wback = FALSE; // Writeback is suppressed when Constraint_UNKNOWN wb_unknown = TRUE; // Writeback is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, regsize] = ZeroExtend(data, regsize); if wback then if wb_unknown then address = bits(64) UNKNOWN; elsif postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.216 LDR (literal)

## Load register (literal)

This instruction calculates an address from the PC value and an immediate offset, loads a word from memory, and writes it to a register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc ==
```

```
00)
```

```
LDR <Wt>, <label>
```

## Encoding for the 64-bit variant

Applies when (opc ==

```
LDR
```

```
01) <Xt>, <label>
```

## Decode for all variants of this encoding

```
constant integer t = UInt(Rt); constant integer size = 4 << UInt(opc<0>); constant boolean nontemporal = FALSE; constant boolean tagchecked = FALSE; constant bits(64) offset
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as 'imm19' times 4.

<!-- image -->

```
= SignExtend(imm19:'00', 64);
```

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Operation

```
constant bits(64) address = PC64 + offset; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); X[t, size * 8] = Mem[address, size, accdesc];
```

## C6.2.217 LDR (register)

## Load register (register)

This instruction calculates an address from a base register value and an offset register value, loads a word from memory, and writes it to a register. The offset register value can optionally be shifted and extended. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) LDR <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) LDR <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>
```

## Decode for all variants of this encoding

```
if option<1> == '0' then EndOfDecode(Decode_UNDEF); // sub-word index constant ExtendType extend_type = DecodeRegExtend(option); constant integer scale = UInt(size); constant integer shift = if S == '1' then scale else 0;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

When option&lt;0&gt; is set to 0, is the 32-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;Xm&gt;

When option&lt;0&gt; is set to 1, is the 64-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;extend&gt;

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option when &lt;amount&gt; is omitted, encoded in 'option':

```
{<amount>}}]
```

```
{<amount>}}]
```

## &lt;amount&gt;

For the '32-bit' variant: is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #2         |

For the '64-bit' variant: is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #3         |

<!-- image -->

&lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer{} datasize = 8 << scale; constant integer{} regsize = if datasize == 64 then 64 else 32; constant boolean nontemporal = FALSE; constant boolean tagchecked = TRUE;
```

## Operation

```
constant bits(64) offset = ExtendReg(m, extend_type, shift, 64); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64];
```

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |
|      011 | LSL        |
|      110 | SXTW       |
|      111 | SXTX       |

```
address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.218 LDRAA, LDRAB

Load register, with pointer authentication

This instruction authenticates an address from a base register using a modifier of zero and the specified key, adds an immediate offset to the authenticated address, and loads a 64-bit doubleword from memory at this resulting address into a register.

Key A is used for LDRAA . Key B is used for LDRAB .

If the authentication passes, the PE behaves the same as for an LDR instruction. For information on behavior if the authentication fails, see Faulting on pointer authentication.

The authenticated address is not written back to the base register, unless the pre-indexed variant of the instruction is used. In this case, the address that is written back to the base register does not include the pointer authentication code.

For information about addressing modes, see Load/Store addressing modes.

## PAC

(FEAT\_PAuth)

<!-- image -->

## Encoding for the Key A, offset variant

```
Applies when (M == 0 && W == 0) LDRAA <Xt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the Key A, pre-indexed variant

```
Applies when (M == 0 && W == 1) LDRAA <Xt>, [<Xn|SP>{, #<simm>}]!
```

## Encoding for the Key B, offset variant

```
0)
```

```
Applies when (M == 1 && W == LDRAB <Xt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the Key B, pre-indexed variant

```
Applies when (M == 1 && W == 1) LDRAB <Xt>, [<Xn|SP>{, #<simm>}]!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); boolean wback = W == '1'; constant boolean use_key_a = M == '0'; constant bits(10) S10 = S:imm9; constant bits(64) offset = LSL(SignExtend(S10, 64), 3); constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31;
```

```
boolean wb_unknown = FALSE; if wback && n == t && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD); assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_WBSUPPRESS wback = FALSE; // writeback is suppressed when Constraint_UNKNOWN wb_unknown = TRUE; // writeback is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

## Assembler Symbols

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, a multiple of 8 in the range -4096 to 4088, defaulting to 0 and encoded in the 'S:imm9' field as &lt;simm&gt;/8.

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant boolean auth_then_branch = TRUE; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then address = SP[64]; else address = X[n, 64]; if use_key_a then address = AuthDA(address, X[31, 64], auth_then_branch); else address = AuthDB(address, X[31, 64], auth_then_branch); if n == 31 then CheckSPAlignment(); address = AddressAdd(address, offset, accdesc); X[t, 64] = Mem[address, 8, accdesc]; if wback then if wb_unknown then address = bits(64) UNKNOWN; if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.219 LDRB (immediate)

Load register byte (immediate)

This instruction loads a byte from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about addressing modes, see Load/Store addressing modes.

It has encodings from 3 classes: Post-index, Pre-index, and Unsigned offset

## Post-index

<!-- image -->

## Encoding

```
LDRB <Wt>, [<Xn|SP>], #<simm>
```

## Decode for this encoding

```
boolean wback = TRUE; constant boolean postindex = TRUE; constant bits(64) offset
```

## Pre-index

<!-- image -->

## Encoding

<!-- image -->

## Decode for this encoding

```
boolean wback = TRUE; constant boolean postindex = FALSE; constant bits(64) offset = SignExtend(imm9, 64);
```

## Unsigned offset

<!-- image -->

## Encoding

<!-- image -->

```
= SignExtend(imm9, 64);
```

## Decode for this encoding

```
boolean wback = FALSE; constant boolean postindex = FALSE; constant bits(64) offset
```

```
= LSL(ZeroExtend(imm12, 64), 0);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDRH (immediate).

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the signed immediate byte offset, in the range -256 to 255, encoded in the 'imm9' field.

## &lt;pimm&gt;

Is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the 'imm12' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31; Constraint c; boolean wb_unknown = FALSE; if wback && n == t && n != 31 then c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD); assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_WBSUPPRESS wback = FALSE; // Writeback is suppressed when Constraint_UNKNOWN wb_unknown = TRUE; // Writeback is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); constant bits(8) data = Mem[address, 1, accdesc];
```

```
X[t, 32] = ZeroExtend(data, 32); if wback then if wb_unknown then address = bits(64) UNKNOWN; elsif postindex then address = AddressAdd(address, offset, if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
accdesc);
```

## C6.2.220 LDRB (register)

Load register byte (register)

This instruction calculates an address from a base register value and an offset register value, loads a byte from memory, zero-extends it, and writes it to a register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the Extended register variant

Applies when (option !=

```
LDRB <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend>
```

```
011) {<amount>}]
```

## Encoding for the Shifted register variant

Applies when (option ==

```
LDRB <Wt>, [<Xn|SP>, <Xm>{, LSL
```

```
011) <amount>}]
```

## Decode for all variants of this encoding

```
// sub-word index = DecodeRegExtend(option);
```

```
if option<1> == '0' then EndOfDecode(Decode_UNDEF); constant ExtendType extend_type constant integer shift = 0;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

When option&lt;0&gt; is set to 0, is the 32-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;Xm&gt;

When option&lt;0&gt; is set to 1, is the 64-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;extend&gt;

Is the index extend specifier, encoded in 'option':

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |
|      110 | SXTW       |
|      111 | SXTX       |

## &lt;amount&gt;

Is the index shift amount, it must be #0 , encoded in 'S' as 0 if omitted, or as 1 if present.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean nontemporal = FALSE; constant boolean tagchecked = TRUE;
```

## Operation

```
constant bits(64) offset = ExtendReg(m, extend_type, shift, 64); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(8) data = Mem[address, 1, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.221 LDRH (immediate)

Load register halfword (immediate)

This instruction loads a halfword from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about addressing modes, see Load/Store addressing modes.

It has encodings from 3 classes: Post-index, Pre-index, and Unsigned offset

## Post-index

<!-- image -->

## Encoding

```
LDRH <Wt>, [<Xn|SP>], #<simm>
```

## Decode for this encoding

```
boolean wback = TRUE; constant boolean postindex = TRUE; constant bits(64) offset
```

## Pre-index

<!-- image -->

## Encoding

<!-- image -->

## Decode for this encoding

```
boolean wback = TRUE; constant boolean postindex = FALSE; constant bits(64) offset = SignExtend(imm9, 64);
```

## Unsigned offset

<!-- image -->

## Encoding

<!-- image -->

```
= SignExtend(imm9, 64);
```

## Decode for this encoding

```
boolean wback = FALSE; constant boolean postindex = FALSE; constant bits(64) offset
```

```
= LSL(ZeroExtend(imm12, 64), 1);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDRH (immediate).

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the signed immediate byte offset, in the range -256 to 255, encoded in the 'imm9' field.

## &lt;pimm&gt;

Is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/2.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31; Constraint c; boolean wb_unknown = FALSE; if wback && n == t && n != 31 then c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD); assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_WBSUPPRESS wback = FALSE; // Writeback is suppressed when Constraint_UNKNOWN wb_unknown = TRUE; // Writeback is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); constant bits(16) data = Mem[address, 2, accdesc];
```

```
X[t, 32] = ZeroExtend(data, 32); if wback then if wb_unknown then address = bits(64) UNKNOWN; elsif postindex then address = AddressAdd(address, offset, if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
accdesc);
```

## C6.2.222 LDRH (register)

Load register halfword (register)

This instruction calculates an address from a base register value and an offset register value, loads a halfword from memory, zero-extends it, and writes it to a register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDRH <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]
```

## Decode for this encoding

```
if option<1> == '0' then EndOfDecode(Decode_UNDEF); // sub-word constant ExtendType extend_type = DecodeRegExtend(option); constant integer shift = if S == '1' then 1 else 0;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

When option&lt;0&gt; is set to 0, is the 32-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;Xm&gt;

When option&lt;0&gt; is set to 1, is the 64-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;extend&gt;

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option when &lt;amount&gt; is omitted, encoded in 'option':

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |
|      011 | LSL        |
|      110 | SXTW       |
|      111 | SXTX       |

```
index
```

## &lt;amount&gt;

Is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #1         |

## Shared Decode

```
= FALSE;
```

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean nontemporal constant boolean tagchecked = TRUE;
```

## Operation

```
constant bits(64) offset = ExtendReg(m, extend_type, shift, 64); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(16) data = Mem[address, 2, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.223 LDRSB (immediate)

Load register signed byte (immediate)

This instruction loads a byte from memory, sign-extends it to either 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about addressing modes, see Load/Store addressing modes.

It has encodings from 3 classes: Post-index, Pre-index, and Unsigned offset

## Post-index

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 11) LDRSB <Wt>, [<Xn|SP>], #<simm>
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDRSB
```

```
<Xt>, [<Xn|SP>], #<simm>
```

## Decode for all variants of this encoding

```
boolean wback = TRUE; constant boolean postindex = TRUE; constant bits(64) offset
```

## Pre-index

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 11) LDRSB <Wt>, [<Xn|SP>, #<simm>]!
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDRSB <Xt>, [<Xn|SP>, #<simm>]!
```

```
= SignExtend(imm9, 64);
```

## Decode for all variants of this encoding

```
boolean wback = TRUE; constant boolean postindex = FALSE; constant bits(64) offset
```

## Unsigned offset

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 11) LDRSB
```

```
<Wt>, [<Xn|SP>{, #<pimm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDRSB <Xt>, [<Xn|SP>{, #<pimm>}]
```

## Decode for all variants of this encoding

```
boolean wback = FALSE; constant boolean postindex = FALSE; constant bits(64) offset = LSL(ZeroExtend(imm12, 64), 0);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDRSB (immediate).

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the signed immediate byte offset, in the range -256 to 255, encoded in the 'imm9' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;pimm&gt;

Is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the 'imm12' field.

```
= SignExtend(imm9, 64);
```

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} regsize = 64 >> UInt(opc<0>); constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31; Constraint c; boolean wb_unknown = FALSE; if wback && n == t && n != 31 then c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD); assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_WBSUPPRESS wback = FALSE; // Writeback is suppressed when Constraint_UNKNOWN wb_unknown = TRUE; // Writeback is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); constant bits(8) data = Mem[address, 1, accdesc]; X[t, regsize] = SignExtend(data, regsize); if wback then if wb_unknown then address = bits(64) UNKNOWN; elsif postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.224 LDRSB (register)

Load register signed byte (register)

This instruction calculates an address from a base register value and an offset register value, loads a byte from memory, sign-extends it, and writes it to a register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit with extended register offset variant

Applies when (opc == 11 &amp;&amp; option !=

```
LDRSB <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend>
```

```
011) {<amount>}]
```

## Encoding for the 32-bit with shifted register offset variant

011)

```
Applies when (opc == 11 && option == LDRSB <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]
```

## Encoding for the 64-bit with extended register offset variant

```
Applies when (opc == 10 && option != 011) LDRSB <Xt>, [<Xn|SP>, (<Wm>|<Xm>), <extend>
```

```
{<amount>}]
```

## Encoding for the 64-bit with shifted register offset variant

```
Applies when (opc == 10 && option == 011) LDRSB <Xt>, [<Xn|SP>, <Xm>{, LSL <amount>}]
```

## Decode for all variants of this encoding

```
// sub-word index = DecodeRegExtend(option);
```

```
if option<1> == '0' then EndOfDecode(Decode_UNDEF); constant ExtendType extend_type constant integer shift = 0;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

When option&lt;0&gt; is set to 0, is the 32-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;Xm&gt;

When option&lt;0&gt; is set to 1, is the 64-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;extend&gt;

Is the index extend specifier, encoded in 'option':

## &lt;amount&gt;

Is the index shift amount, it must be #0 , encoded in 'S' as 0 if omitted, or as 1 if present.

<!-- image -->

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer{} regsize = 64 >> UInt(opc<0>); constant boolean nontemporal = FALSE; constant boolean tagchecked = TRUE;
```

## Operation

```
constant bits(64) offset = ExtendReg(m, extend_type, shift, 64); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(8) data = Mem[address, 1, accdesc]; X[t, regsize] = SignExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |
|      110 | SXTW       |
|      111 | SXTX       |

## C6.2.225 LDRSH (immediate)

Load register signed halfword (immediate)

This instruction loads a halfword from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about addressing modes, see Load/Store addressing modes.

It has encodings from 3 classes: Post-index, Pre-index, and Unsigned offset

## Post-index

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 11) LDRSH <Wt>, [<Xn|SP>], #<simm>
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDRSH
```

```
<Xt>, [<Xn|SP>], #<simm>
```

## Decode for all variants of this encoding

```
boolean wback = TRUE; constant boolean postindex = TRUE; constant bits(64) offset
```

## Pre-index

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 11) LDRSH <Wt>, [<Xn|SP>, #<simm>]!
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDRSH <Xt>, [<Xn|SP>, #<simm>]!
```

```
= SignExtend(imm9, 64);
```

## Decode for all variants of this encoding

```
boolean wback = TRUE; constant boolean postindex = FALSE; constant bits(64) offset
```

## Unsigned offset

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 11) LDRSH
```

```
<Wt>, [<Xn|SP>{, #<pimm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDRSH <Xt>, [<Xn|SP>{, #<pimm>}]
```

## Decode for all variants of this encoding

```
boolean wback = FALSE; constant boolean postindex = FALSE; constant bits(64) offset
```

```
= LSL(ZeroExtend(imm12, 64), 1);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDRSH (immediate).

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the signed immediate byte offset, in the range -256 to 255, encoded in the 'imm9' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;pimm&gt;

Is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/2.

```
= SignExtend(imm9, 64);
```

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} regsize = 64 >> UInt(opc<0>); constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31; Constraint c; boolean wb_unknown = FALSE; if wback && n == t && n != 31 then c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD); assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_WBSUPPRESS wback = FALSE; // Writeback is suppressed when Constraint_UNKNOWN wb_unknown = TRUE; // Writeback is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); constant bits(16) data = Mem[address, 2, accdesc]; X[t, regsize] = SignExtend(data, regsize); if wback then if wb_unknown then address = bits(64) UNKNOWN; elsif postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.226 LDRSH (register)

Load register signed halfword (register)

This instruction calculates an address from a base register value and an offset register value, loads a halfword from memory, sign-extends it, and writes it to a register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 11) LDRSH <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDRSH <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>
```

## Decode for all variants of this encoding

```
if option<1> == '0' then EndOfDecode(Decode_UNDEF); // sub-word index constant ExtendType extend_type = DecodeRegExtend(option); constant integer shift = if S == '1' then 1 else 0;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

When option&lt;0&gt; is set to 0, is the 32-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;Xm&gt;

When option&lt;0&gt; is set to 1, is the 64-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;extend&gt;

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option when &lt;amount&gt; is omitted, encoded in 'option':

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |

```
{<amount>}}]
```

```
{<amount>}}]
```

## &lt;amount&gt;

Is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #1         |

<!-- image -->

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer{} regsize = 64 >> UInt(opc<0>); constant boolean nontemporal = FALSE; constant boolean tagchecked = TRUE;
```

## Operation

```
constant bits(64) offset = ExtendReg(m, extend_type, shift, 64); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(16) data = Mem[address, 2, accdesc]; X[t, regsize] = SignExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   option | <extend>   |
|----------|------------|
|      011 | LSL        |
|      110 | SXTW       |
|      111 | SXTX       |

## C6.2.227 LDRSW (immediate)

Load register signed word (immediate)

This instruction loads a word from memory, sign-extends it to 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about addressing modes, see Load/Store addressing modes.

It has encodings from 3 classes: Post-index, Pre-index, and Unsigned offset

## Post-index

<!-- image -->

## Encoding

```
LDRSW <Xt>, [<Xn|SP>], #<simm>
```

## Decode for this encoding

```
boolean wback = TRUE; constant boolean postindex = TRUE; constant bits(64) offset
```

## Pre-index

<!-- image -->

## Encoding

```
LDRSW <Xt>, [<Xn|SP>, #<simm>]!
```

## Decode for this encoding

```
boolean wback = TRUE; constant boolean postindex = FALSE; constant bits(64) offset
```

## Unsigned offset

<!-- image -->

## Encoding

<!-- image -->

```
= SignExtend(imm9, 64);
```

```
= SignExtend(imm9, 64);
```

## Decode for this encoding

```
boolean wback = FALSE; constant boolean postindex = FALSE; constant bits(64) offset
```

```
= LSL(ZeroExtend(imm12, 64), 2);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDRSW (immediate).

## Assembler Symbols

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the signed immediate byte offset, in the range -256 to 255, encoded in the 'imm9' field.

## &lt;pimm&gt;

Is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/4.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31; Constraint c; boolean wb_unknown = FALSE; if wback && n == t && n != 31 then c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD); assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_WBSUPPRESS wback = FALSE; // Writeback is suppressed when Constraint_UNKNOWN wb_unknown = TRUE; // Writeback is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); constant bits(32) data = Mem[address, 4, accdesc];
```

```
X[t, 64] = SignExtend(data, 64); if wback then if wb_unknown then address = bits(64) UNKNOWN; elsif postindex then address = AddressAdd(address, offset, if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
accdesc);
```

## C6.2.228 LDRSW (literal)

Load register signed word (literal)

This instruction calculates an address from the PC value and an immediate offset, loads a word from memory, and writes it to a register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDRSW <Xt>, <label>
```

## Decode for this encoding

```
constant integer t = UInt(Rt); constant boolean nontemporal = FALSE; constant boolean tagchecked = FALSE; constant bits(64) offset
```

```
= SignExtend(imm19:'00', 64);
```

## Assembler Symbols

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;label&gt;

Is the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as 'imm19' times 4.

## Operation

```
constant bits(64) address = PC64 + offset; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); constant bits(32) data = Mem[address, 4, accdesc]; X[t, 64] = SignExtend(data, 64);
```

## C6.2.229 LDRSW (register)

Load register signed word (register)

This instruction calculates an address from a base register value and an offset register value, loads a word from memory, sign-extends it to form a 64-bit value, and writes it to a register. The offset register value can be shifted left by 0 or 2 bits. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDRSW <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]
```

## Decode for this encoding

```
if option<1> == '0' then EndOfDecode(Decode_UNDEF); constant ExtendType extend_type constant integer shift = if S == '1' then 2 else 0;
```

## Assembler Symbols

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

When option&lt;0&gt; is set to 0, is the 32-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;Xm&gt;

When option&lt;0&gt; is set to 1, is the 64-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;extend&gt;

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option when &lt;amount&gt; is omitted, encoded in 'option':

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |
|      011 | LSL        |
|      110 | SXTW       |
|      111 | SXTX       |

```
// sub-word index = DecodeRegExtend(option);
```

## &lt;amount&gt;

Is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #2         |

## Shared Decode

```
= FALSE;
```

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean nontemporal constant boolean tagchecked = TRUE;
```

## Operation

```
constant bits(64) offset = ExtendReg(m, extend_type, shift, 64); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(32) data = Mem[address, 4, accdesc]; X[t, 64] = SignExtend(data, 64);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.230 LDSET, LDSETA, LDSETAL, LDSETL

Atomic bit set on word or doubleword

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not one of WZR or XZR , LDSETA and LDSETAL load from memory with acquire semantics.
- LDSETL and LDSETAL store to memory with release semantics.
- LDSET has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STSET, STSETL.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

LDSET

&lt;Ws&gt;,

(size ==

10

&amp;&amp;

A

==

0 &amp;&amp;

&lt;Wt&gt;, [&lt;Xn|SP&gt;]

## Encoding for the 32-bit acquire variant

```
Applies when (size == 10 && A == 1 && R == 0) LDSETA <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire-release variant

```
Applies when (size == 10 && A == 1 && R == 1) LDSETAL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit release variant

```
Applies when (size == 10 && A == 0 && R == 1) LDSETL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 64-bit no memory ordering variant

```
Applies when (size == 11 && A == 0 && R == 0)
```

```
LDSET <Xs>, <Xt>, [<Xn|SP>]
```

R ==

0)

## Encoding for the 64-bit acquire variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDSETA
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire-release variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDSETAL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && A == 0 && R ==
```

```
LDSETL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

<!-- image -->

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Alias Conditions

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

| Alias         | Is preferred when         |
|---------------|---------------------------|
| STSET, STSETL | A == '0' && Rt == '11111' |

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_ORR, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS constant bits(datasize) value = X[s, datasize]; constant bits(datasize) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.231 LDSETB, LDSETAB, LDSETALB, LDSETLB

Atomic bit set on byte

This instruction atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDSETAB and LDSETALB load from memory with acquire semantics.
- LDSETLB and LDSETALB store to memory with release semantics.
- LDSETB has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STSETB, STSETLB.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

Applies when

(A == 0

&amp;&amp;

R

==

0)

```
LDSETB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0)
```

```
LDSETAB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R ==
```

```
1)
```

```
LDSETALB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R ==
```

```
LDSETLB
```

```
1) <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_ORR, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(8) comparevalue = bits(8) UNKNOWN; // Irrelevant when not executing CAS constant bits(8) value = X[s, 8]; constant bits(8) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias           | Is preferred when         |
|-----------------|---------------------------|
| STSETB, STSETLB | A == '0' && Rt == '11111' |

## C6.2.232 LDSETH, LDSETAH, LDSETALH, LDSETLH

Atomic bit set on halfword

This instruction atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDSETAH and LDSETALH load from memory with acquire semantics.
- LDSETLH and LDSETALH store to memory with release semantics.
- LDSETH has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STSETH, STSETLH.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R == 0)
```

```
LDSETH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when
```

```
LDSETAH
```

```
(A == 1 && R == 0) <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R == 1)
```

```
LDSETALH
```

```
<Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R ==
```

```
LDSETLH
```

```
1) <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_ORR, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(16) comparevalue = bits(16) UNKNOWN; // Irrelevant when not executing CAS constant bits(16) value = X[s, 16]; constant bits(16) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias           | Is preferred when         |
|-----------------|---------------------------|
| STSETH, STSETLH | A == '0' && Rt == '11111' |

## C6.2.233 LDSETP, LDSETPA, LDSETPAL, LDSETPL

Atomic bit set on quadword

This instruction atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers.

- LDSETPA and LDSETPAL load from memory with acquire semantics.
- LDSETPL and LDSETPAL store to memory with release semantics.
- LDSETP has neither acquire nor release semantics.

## Integer

(FEAT\_LSE128)

<!-- image -->

## Encoding for the LDSETP variant

Applies when

(A == 0

&amp;&amp;

R

==

0)

```
LDSETP <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the LDSETPA variant

```
0)
```

```
Applies when (A == 1 && R == LDSETPA <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the LDSETPAL variant

```
Applies when (A == 1 && R == 1) LDSETPAL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the LDSETPL variant

```
1)
```

```
Applies when (A == 0 && R == LDSETPL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE128) then EndOfDecode(Decode_UNDEF); if Rt == '11111' then EndOfDecode(Decode_UNDEF); if Rt2 == '11111' then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LSE128OVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
```

```
case c of when Constraint_UNKNOWN rt_unknown = TRUE; // result when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

```
is UNKNOWN
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly CONSTRAINED UNPREDICTABLE behavior for A64 instructions.

## Assembler Symbols

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; constant bits(64) value1 = X[t, 64]; constant bits(64) value2 = X[t2, 64]; bits(128) data; bits(128) store_value; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_ORR, acquire, release, tagchecked, privileged, t, t2, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; store_value = if BigEndian(accdesc.acctype) then value1:value2 else value2:value1; constant bits(128) comparevalue = bits(128) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, store_value, accdesc); if rt_unknown then data = bits(128) UNKNOWN; if BigEndian(accdesc.acctype) then X[t, 64] = data<127:64>; X[t2, 64] = data<63:0>; else X[t, 64] = data<63:0>; X[t2, 64] = data<127:64>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.234 LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL

Atomic signed maximum on word or doubleword

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.

- If the destination register is not one of WZR or XZR , LDSMAXA and LDSMAXAL load from memory with acquire semantics.
- LDSMAXL and LDSMAXAL store to memory with release semantics.
- LDSMAX has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STSMAX, STSMAXL.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

LDSMAX

(size ==

10

&amp;&amp;

A

==

0 &amp;&amp;

&lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;]

## Encoding for the 32-bit acquire variant

```
Applies when (size == 10 && A == 1 && R == 0) LDSMAXA <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire-release variant

```
Applies when (size == 10 && A == 1 && R == 1) LDSMAXAL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit release variant

```
Applies when (size == 10 && A == 0 && R ==
```

```
LDSMAXL
```

```
1) <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 64-bit no memory ordering variant

```
Applies when (size == 11 && A == 0 && R == 0)
```

```
LDSMAX <Xs>, <Xt>, [<Xn|SP>]
```

R ==

0)

## Encoding for the 64-bit acquire variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDSMAXA
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire-release variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDSMAXAL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && A == 0 && R == 1)
```

```
LDSMAXL <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

<!-- image -->

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Alias Conditions

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

| Alias           | Is preferred when         |
|-----------------|---------------------------|
| STSMAX, STSMAXL | A == '0' && Rt == '11111' |

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_SMAX, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS constant bits(datasize) value = X[s, datasize]; constant bits(datasize) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.235 LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB

Atomic signed maximum on byte

This instruction atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDSMAXAB and LDSMAXALB load from memory with acquire semantics.
- LDSMAXLB and LDSMAXALB store to memory with release semantics.
- LDSMAXB has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STSMAXB, STSMAXLB.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R == 0)
```

```
LDSMAXB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDSMAXAB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
1)
```

```
Applies when (A == 1 && R == LDSMAXALB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R == 1) LDSMAXLB <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_SMAX, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(8) comparevalue = bits(8) UNKNOWN; // Irrelevant when not executing CAS constant bits(8) value = X[s, 8]; constant bits(8) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

STSMAXB, STSMAXLB

## Is preferred when

A == '0' &amp;&amp; Rt == '11111'

## C6.2.236 LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH

Atomic signed maximum on halfword

This instruction atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDSMAXAH and LDSMAXALH load from memory with acquire semantics.
- LDSMAXLH and LDSMAXALH store to memory with release semantics.
- LDSMAXH has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STSMAXH, STSMAXLH.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R == 0)
```

```
LDSMAXH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDSMAXAH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
1)
```

```
Applies when (A == 1 && R == LDSMAXALH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R == 1) LDSMAXLH <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_SMAX, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(16) comparevalue = bits(16) UNKNOWN; // Irrelevant when not executing CAS constant bits(16) value = X[s, 16]; constant bits(16) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

STSMAXH, STSMAXLH

## Is preferred when

A == '0' &amp;&amp; Rt == '11111'

## C6.2.237 LDSMIN, LDSMINA, LDSMINAL, LDSMINL

Atomic signed minimum on word or doubleword

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.

- If the destination register is not one of WZR or XZR , LDSMINA and LDSMINAL load from memory with acquire semantics.
- LDSMINL and LDSMINAL store to memory with release semantics.
- LDSMIN has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STSMIN, STSMINL.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

LDSMIN

(size ==

10

&amp;&amp;

A

==

0 &amp;&amp;

&lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;]

## Encoding for the 32-bit acquire variant

```
Applies when (size == 10 && A == 1 && R == 0) LDSMINA <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire-release variant

```
Applies when (size == 10 && A == 1 && R == 1) LDSMINAL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit release variant

```
Applies when (size == 10 && A == 0 && R ==
```

```
LDSMINL
```

```
1) <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 64-bit no memory ordering variant

```
Applies when (size == 11 && A == 0 && R == 0)
```

```
LDSMIN <Xs>, <Xt>, [<Xn|SP>]
```

R ==

0)

## Encoding for the 64-bit acquire variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDSMINA
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire-release variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDSMINAL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && A == 0 && R == 1)
```

```
LDSMINL <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

<!-- image -->

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Alias Conditions

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

| Alias           | Is preferred when         |
|-----------------|---------------------------|
| STSMIN, STSMINL | A == '0' && Rt == '11111' |

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_SMIN, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS constant bits(datasize) value = X[s, datasize]; constant bits(datasize) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.238 LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB

Atomic signed minimum on byte

This instruction atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDSMINAB and LDSMINALB load from memory with acquire semantics.
- LDSMINLB and LDSMINALB store to memory with release semantics.
- LDSMINB has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STSMINB, STSMINLB.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R == 0)
```

```
LDSMINB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDSMINAB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
1)
```

```
Applies when (A == 1 && R == LDSMINALB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R == 1) LDSMINLB <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_SMIN, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(8) comparevalue = bits(8) UNKNOWN; // Irrelevant when not executing CAS constant bits(8) value = X[s, 8]; constant bits(8) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

STSMINB, STSMINLB

## Is preferred when

A == '0' &amp;&amp; Rt == '11111'

## C6.2.239 LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH

Atomic signed minimum on halfword

This instruction atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDSMINAH and LDSMINALH load from memory with acquire semantics.
- LDSMINLH and LDSMINALH store to memory with release semantics.
- LDSMINH has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STSMINH, STSMINLH.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R == 0)
```

```
LDSMINH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDSMINAH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
1)
```

```
Applies when (A == 1 && R == LDSMINALH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R == 1) LDSMINLH <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_SMIN, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(16) comparevalue = bits(16) UNKNOWN; // Irrelevant when not executing CAS constant bits(16) value = X[s, 16]; constant bits(16) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

STSMINH, STSMINLH

## Is preferred when

A == '0' &amp;&amp; Rt == '11111'

## C6.2.240 LDTADD, LDTADDA, LDTADDAL, LDTADDL

Atomic add unprivileged

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not one of WZR , or XZR , LDTADDA and LDTADDAL load from memory with acquire semantics.
- LDTADDL and LDTADDAL store to memory with release semantics.
- LDTADD has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

This instruction is used by the alias STTADD, STTADDL.

## Integer

(FEAT\_LSUI)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

```
Applies when (sz == 0 && A == 0 && R == 0) LDTADD <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire variant

```
Applies when (sz == 0 && A == 1 && R == 0) LDTADDA <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire-release variant

```
Applies when (sz == 0 && A == 1 && R == 1) LDTADDAL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit release variant

```
Applies when (sz == 0 && A == 0 && R == 1) LDTADDL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 64-bit no memory ordering variant

```
Applies when (sz == 1 && A == 0 && R ==
```

```
LDTADD
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire variant

```
Applies when (sz == 1 && A == 1 && R ==
```

```
LDTADDA
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire-release variant

```
Applies when (sz == 1 && A == 1 && R ==
```

```
LDTADDAL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit release variant

```
Applies when (sz == 1 && A == 0 && R ==
```

```
LDTADDL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LSUI) then constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sz); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_ADD, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS constant bits(datasize) value = X[s, datasize]; constant bits(datasize) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

STTADD, STTADDL

## Is preferred when

A == '0' &amp;&amp; Rt == '11111'

## C6.2.241 LDTCLR, LDTCLRA, LDTCLRAL, LDTCLRL

Atomic bit clear unprivileged

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not one of WZR , or XZR , LDTCLRA and LDTCLRAL load from memory with acquire semantics.
- LDTCLRL and LDTCLRAL store to memory with release semantics.
- LDTCLR has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

This instruction is used by the alias STTCLR, STTCLRL.

## Integer

(FEAT\_LSUI)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

(sz

==

0

&amp;&amp;

A

==

0 &amp;&amp; R

```
LDTCLR <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire variant

```
Applies when (sz == 0 && A == 1 && R == 0) LDTCLRA <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire-release variant

```
Applies when (sz == 0 && A == 1 && R == 1) LDTCLRAL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit release variant

Applies when

(sz

==

0

LDTCLRL

&amp;&amp;

A

==

&lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;]

0 &amp;&amp; R

==

1)

==

0)

## Encoding for the 64-bit no memory ordering variant

```
Applies when (sz == 1 && A == 0 && R ==
```

```
LDTCLR
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire variant

```
Applies when (sz == 1 && A == 1 && R ==
```

```
LDTCLRA
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire-release variant

```
Applies when (sz == 1 && A == 1 && R ==
```

```
LDTCLRAL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit release variant

```
Applies when (sz == 1 && A == 0 && R ==
```

```
LDTCLRL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LSUI) then constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sz); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_BIC, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS constant bits(datasize) value = X[s, datasize]; constant bits(datasize) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

STTCLR, STTCLRL

## Is preferred when

A == '0' &amp;&amp; Rt == '11111'

## C6.2.242 LDTNP

Load unprivileged pair of registers, with non-temporal hint

This instruction calculates an address from a base register value and an immediate offset, loads two 64-bit doublewords from memory, and writes them to two registers. For information about addressing modes, see Load/Store addressing modes. For information about non-temporal pair instructions, see Load/Store non-temporal pair.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Signed offset

(FEAT\_LSUI)

<!-- image -->

## Encoding

```
LDTNP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = TRUE; constant integer datasize = 64; constant bits(64) offset = LSL(SignExtend(imm7, 64), 3); constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // Result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

LDTNP has the same CONSTRAINED UNPREDICTABLE behavior as LDNP . See Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDNP.

## Assembler Symbols

&lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

<!-- image -->

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/8.

## Operation

```
bits(64) address; constant integer dbytes = datasize DIV 8; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, ispair, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(2*datasize) data = Mem[address, 2 * dbytes, accdesc]; if rt_unknown then X[t, datasize] = bits(datasize) UNKNOWN; elsif BigEndian(accdesc.acctype) then X[t2, datasize] = data<(datasize-1):0>; X[t, datasize] = data<(2*datasize-1):datasize>; else X[t, datasize] = data<(datasize-1):0>; X[t2, datasize] = data<(2*datasize-1):datasize>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.243 LDTP

Load unprivileged pair of registers

This instruction calculates an address from a base register value and an immediate offset, loads two 64-bit doublewords from memory, and writes them to two registers.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

For information about addressing modes, see Load/Store addressing modes.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

(FEAT\_LSUI)

<!-- image -->

## Encoding

```
LDTP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then boolean wback = TRUE; constant boolean postindex = TRUE;
```

## Pre-index

(FEAT\_LSUI)

<!-- image -->

## Encoding

```
LDTP <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); boolean wback = TRUE; constant boolean postindex = FALSE;
```

```
EndOfDecode(Decode_UNDEF);
```

## Signed offset

(FEAT\_LSUI)

<!-- image -->

## Encoding

```
LDTP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then boolean wback = FALSE; constant boolean postindex = FALSE;
```

```
EndOfDecode(Decode_UNDEF);
```

LDTP has the same CONSTRAINED UNPREDICTABLE behavior as LDP . See Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDP.

## Assembler Symbols

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the 'Load/store register pair (post-indexed)' and 'Load/store register pair (pre-indexed)' variants: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the 'imm7' field as &lt;imm&gt;/8.

For the 'Load/store register pair (offset)' variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/8.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = FALSE; constant integer{} scale = 2 + UInt(opc<1>); constant integer{} datasize = 64; constant bits(64) offset = LSL(SignExtend(imm7, 64), scale); constant boolean tagchecked = wback || n != 31; boolean rt_unknown = FALSE; boolean wb_unknown = FALSE; if wback && (t == n || t2 == n) && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD); assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_WBSUPPRESS wback = FALSE; // Writeback is suppressed
```

```
when Constraint_UNKNOWN wb_unknown = TRUE; // Writeback is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // Result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end Operation CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged,
```

```
bits(64) address; bits(datasize) data1; bits(datasize) data2; constant integer dbytes = datasize DIV 8; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant boolean ispair = TRUE; constant AccessDescriptor accdesc = tagchecked, ispair, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); constant bits(2*datasize) data = Mem[address, 2 * dbytes, accdesc]; if rt_unknown then data1 = bits(datasize) UNKNOWN; data2 = bits(datasize) UNKNOWN; elsif BigEndian(accdesc.acctype) then data2 = data<(datasize-1):0>; data1 = data<(2*datasize-1):datasize>; else data1 = data<(datasize-1):0>; data2 = data<(2*datasize-1):datasize>; X[t, datasize] = data1; X[t2, datasize] = data2; if wback then if wb_unknown then address = bits(64) UNKNOWN; elsif postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.244 LDTR

## Load register (unprivileged)

This instruction loads a word or doubleword from memory, and writes it to a register. The address that is used for the load is calculated from a base register and an immediate offset.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (size ==

```
10) LDTR <Wt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

Applies when (size ==

```
11)
```

```
LDTR <Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
constant integer scale = UInt(size); constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8 << scale; constant integer{} regsize = if datasize == 64 then 64 else constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
32;
```

## C6.2.245 LDTRB

Load register byte (unprivileged)

This instruction loads a byte from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDTRB <Wt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8; constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.246 LDTRH

Load register halfword (unprivileged)

This instruction loads a halfword from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDTRH <Wt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 16; constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.247 LDTRSB

Load register signed byte (unprivileged)

This instruction loads a byte from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 11) LDTRSB <Wt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDTRSB <Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8; constant integer{} regsize = 64 >> constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, regsize] = SignExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
UInt(opc<0>);
```

## C6.2.248 LDTRSH

Load register signed halfword (unprivileged)

This instruction loads a halfword from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

<!-- image -->

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDTRSH <Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 16; constant integer{} regsize = 64 >> constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, regsize] = SignExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
UInt(opc<0>);
```

## C6.2.249 LDTRSW

Load register signed word (unprivileged)

This instruction loads a word from memory, sign-extends it to 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDTRSW <Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 32; constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, 64] = SignExtend(data, 64);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.250 LDTSET, LDTSETA, LDTSETAL, LDTSETL

Atomic bit set unprivileged

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register.

- If the destination register is not one of WZR , or XZR , LDTSETA and LDTSETAL load from memory with acquire semantics.
- LDTSETL and LDTSETAL store to memory with release semantics.
- LDTSET has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

This instruction is used by the alias STTSET, STTSETL.

## Integer

(FEAT\_LSUI)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

(sz

==

0

&amp;&amp;

A

==

0 &amp;&amp; R

```
LDTSET <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire variant

```
Applies when (sz == 0 && A == 1 && R == 0) LDTSETA <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire-release variant

```
Applies when (sz == 0 && A == 1 && R == 1) LDTSETAL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit release variant

Applies when

(sz

==

0

LDTSETL

&amp;&amp;

A

==

&lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;]

0 &amp;&amp; R

==

1)

==

0)

## Encoding for the 64-bit no memory ordering variant

```
Applies when (sz == 1 && A == 0 && R ==
```

```
LDTSET
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire variant

```
Applies when (sz == 1 && A == 1 && R ==
```

```
LDTSETA
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire-release variant

```
Applies when (sz == 1 && A == 1 && R ==
```

```
LDTSETAL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit release variant

```
Applies when (sz == 1 && A == 0 && R ==
```

```
LDTSETL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_LSUI) then constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sz); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_ORR, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS constant bits(datasize) value = X[s, datasize]; constant bits(datasize) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

STTSET, STTSETL

## Is preferred when

A == '0' &amp;&amp; Rt == '11111'

## C6.2.251 LDTXR

Load unprivileged exclusive register

This instruction derives an address from a base register value, loads a 32-bit word or a 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

Note

For the purposes of the Exclusives monitors, and the forward progress guarantees for Load-Exclusive and Store-Exclusive loops, LDTXR is equivalent to LDXR .

For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LSUI)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sz == 0) LDTXR
```

```
<Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (sz == 1) LDTXR
```

```
<Xt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer elsize = 32 << UInt(sz); constant integer regsize = if elsize == 64 then 64 else 32; constant boolean acqrel = FALSE; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

&lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Operation

```
bits(64) address; bits(elsize) data; constant integer dbytes = elsize DIV 8; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; AArch64.SetExclusiveMonitors(address, dbytes, accdesc); data = Mem[address, dbytes, accdesc]; X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.252 LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL

Atomic unsigned maximum on word or doubleword

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.

- If the destination register is not one of WZR or XZR , LDUMAXA and LDUMAXAL load from memory with acquire semantics.
- LDUMAXL and LDUMAXAL store to memory with release semantics.
- LDUMAX has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STUMAX, STUMAXL.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

LDUMAX

(size ==

10

&amp;&amp;

A

==

0 &amp;&amp;

&lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;]

## Encoding for the 32-bit acquire variant

```
Applies when (size == 10 && A == 1 && R == 0) LDUMAXA <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire-release variant

```
Applies when (size == 10 && A == 1 && R == 1) LDUMAXAL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit release variant

```
Applies when (size == 10 && A == 0 && R ==
```

```
LDUMAXL
```

```
1) <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 64-bit no memory ordering variant

```
Applies when (size == 11 && A == 0 && R == 0)
```

```
LDUMAX <Xs>, <Xt>, [<Xn|SP>]
```

R ==

0)

## Encoding for the 64-bit acquire variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDUMAXA
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire-release variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDUMAXAL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && A == 0 && R == 1)
```

```
LDUMAXL <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

<!-- image -->

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Alias Conditions

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

| Alias           | Is preferred when         |
|-----------------|---------------------------|
| STUMAX, STUMAXL | A == '0' && Rt == '11111' |

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_UMAX, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS constant bits(datasize) value = X[s, datasize]; constant bits(datasize) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.253 LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB

Atomic unsigned maximum on byte

This instruction atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDUMAXAB and LDUMAXALB load from memory with acquire semantics.
- LDUMAXLB and LDUMAXALB store to memory with release semantics.
- LDUMAXB has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STUMAXB, STUMAXLB.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R == 0)
```

```
LDUMAXB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDUMAXAB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
1)
```

```
Applies when (A == 1 && R == LDUMAXALB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R == 1) LDUMAXLB <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_UMAX, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(8) comparevalue = bits(8) UNKNOWN; // Irrelevant when not executing CAS constant bits(8) value = X[s, 8]; constant bits(8) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

STUMAXB, STUMAXLB

## Is preferred when

A == '0' &amp;&amp; Rt == '11111'

## C6.2.254 LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH

Atomic unsigned maximum on halfword

This instruction atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDUMAXAH and LDUMAXALH load from memory with acquire semantics.
- LDUMAXLH and LDUMAXALH store to memory with release semantics.
- LDUMAXH has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STUMAXH, STUMAXLH.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R == 0)
```

```
LDUMAXH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDUMAXAH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
Applies when (A == 1 && R == 1) LDUMAXALH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R == 1) LDUMAXLH <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_UMAX, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(16) comparevalue = bits(16) UNKNOWN; // Irrelevant when not executing CAS constant bits(16) value = X[s, 16]; constant bits(16) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

STUMAXH, STUMAXLH

## Is preferred when

A == '0' &amp;&amp; Rt == '11111'

## C6.2.255 LDUMIN, LDUMINA, LDUMINAL, LDUMINL

Atomic unsigned minimum on word or doubleword

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.

- If the destination register is not one of WZR or XZR , LDUMINA and LDUMINAL load from memory with acquire semantics.
- LDUMINL and LDUMINAL store to memory with release semantics.
- LDUMIN has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STUMIN, STUMINL.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

LDUMIN

(size ==

10

&amp;&amp;

A

==

0 &amp;&amp;

&lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;]

## Encoding for the 32-bit acquire variant

```
Applies when (size == 10 && A == 1 && R == 0) LDUMINA <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit acquire-release variant

```
Applies when (size == 10 && A == 1 && R == 1) LDUMINAL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit release variant

```
Applies when (size == 10 && A == 0 && R ==
```

```
LDUMINL
```

```
1) <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 64-bit no memory ordering variant

```
Applies when (size == 11 && A == 0 && R == 0)
```

```
LDUMIN <Xs>, <Xt>, [<Xn|SP>]
```

R ==

0)

## Encoding for the 64-bit acquire variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDUMINA
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit acquire-release variant

```
Applies when (size == 11 && A == 1 && R ==
```

```
LDUMINAL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && A == 0 && R == 1)
```

```
LDUMINL <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

<!-- image -->

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Alias Conditions

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

| Alias           | Is preferred when         |
|-----------------|---------------------------|
| STUMIN, STUMINL | A == '0' && Rt == '11111' |

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_UMIN, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS constant bits(datasize) value = X[s, datasize]; constant bits(datasize) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.256 LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB

Atomic unsigned minimum on byte

This instruction atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDUMINAB and LDUMINALB load from memory with acquire semantics.
- LDUMINLB and LDUMINALB store to memory with release semantics.
- LDUMINB has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STUMINB, STUMINLB.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R == 0)
```

```
LDUMINB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDUMINAB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
1)
```

```
Applies when (A == 1 && R == LDUMINALB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R == 1) LDUMINLB <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_UMIN, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(8) comparevalue = bits(8) UNKNOWN; // Irrelevant when not executing CAS constant bits(8) value = X[s, 8]; constant bits(8) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

STUMINB, STUMINLB

## Is preferred when

A == '0' &amp;&amp; Rt == '11111'

## C6.2.257 LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH

Atomic unsigned minimum on halfword

This instruction atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , LDUMINAH and LDUMINALH load from memory with acquire semantics.
- LDUMINLH and LDUMINALH store to memory with release semantics.
- LDUMINH has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This instruction is used by the alias STUMINH, STUMINLH.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (A == 0 && R == 0)
```

```
LDUMINH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire variant

```
Applies when (A == 1 && R == 0) LDUMINAH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Acquire-release variant

```
1)
```

```
Applies when (A == 1 && R == LDUMINALH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the Release variant

```
Applies when (A == 0 && R == 1) LDUMINLH <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_UMIN, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(16) comparevalue = bits(16) UNKNOWN; // Irrelevant when not executing CAS constant bits(16) value = X[s, 16]; constant bits(16) data = MemAtomic(address, comparevalue, value, accdesc); if t != 31 then X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

STUMINH, STUMINLH

## Is preferred when

A == '0' &amp;&amp; Rt == '11111'

## C6.2.258 LDUR

## Load register (unscaled)

This instruction calculates an address from a base register and an immediate offset, loads a 32-bit word or 64-bit doubleword from memory, zero-extends it, and writes it to a register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) LDUR <Wt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) LDUR <Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
constant integer scale = UInt(size); constant bits(64) offset
```

```
= SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

<!-- image -->

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant integer{} datasize = 8 << scale; constant integer{} regsize = if datasize == 64 then 64 else 32; constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.259 LDURB

Load register byte (unscaled)

This instruction calculates an address from a base register and an immediate offset, loads a byte from memory, zero-extends it, and writes it to a register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDURB <Wt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Shared Decode

```
constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant integer{} datasize = 8; constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.260 LDURH

Load register halfword (unscaled)

This instruction calculates an address from a base register and an immediate offset, loads a halfword from memory, zero-extends it, and writes it to a register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDURH <Wt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Shared Decode

```
constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant integer{} datasize = 16; constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.261 LDURSB

Load register signed byte (unscaled)

This instruction calculates an address from a base register and an immediate offset, loads a signed byte from memory, sign-extends it, and writes it to a register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 11) LDURSB
```

```
<Wt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDURSB <Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant integer{} datasize = 8; constant integer{} regsize = 64 >> constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

```
UInt(opc<0>);
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, regsize] = SignExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.262 LDURSH

Load register signed halfword (unscaled)

This instruction calculates an address from a base register and an immediate offset, loads a signed halfword from memory, sign-extends it, and writes it to a register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 11) LDURSH
```

```
<Wt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) LDURSH
```

```
<Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant integer{} datasize = 16; constant integer{} regsize = 64 >> UInt(opc<0>); constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, regsize] = SignExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.263 LDURSW

Load register signed word (unscaled)

This instruction calculates an address from a base register and an immediate offset, loads a signed word from memory, sign-extends it, and writes it to a register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDURSW <Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Shared Decode

```
constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant integer{} datasize = 32; constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(datasize) data = Mem[address, datasize DIV 8, accdesc]; X[t, 64] = SignExtend(data, 64);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.264 LDXP

## Load exclusive pair of registers

This instruction derives an address from a base register value, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. For information on single-copy atomicity and alignment requirements, see Requirements for single-copy atomicity and Alignment of data accesses. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sz == 0) LDXP
```

```
<Wt1>, <Wt2>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (sz == 1) LDXP
```

```
<Xt1>, <Xt2>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant integer elsize = 32 << UInt(sz); constant integer datasize = elsize * 2; constant boolean acqrel = FALSE; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDXP.

## Assembler Symbols

## &lt;Wt1&gt;

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Wt2&gt;

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

&lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## Operation

```
bits(64) address; bits(datasize) data; constant integer dbytes = datasize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant boolean ispair = elsize == 64; // When elsize is 32, the access is single-copy atomic constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked, privileged, ispair, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; AArch64.SetExclusiveMonitors(address, dbytes, accdesc); data = Mem[address, dbytes, accdesc]; if rt_unknown then // ConstrainedUNPREDICTABLE case X[t, datasize] = bits(datasize) UNKNOWN; // In this case t = t2 elsif BigEndian(accdesc.acctype) then X[t, elsize] = data<elsize +: elsize>; X[t2, elsize] = data<0 +: elsize>; else X[t, elsize] = data<0 +: elsize>; X[t2, elsize] = data<elsize +: elsize>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.265 LDXR

Load exclusive register

This instruction derives an address from a base register value, loads a 32-bit word or a 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == LDXR
```

```
10) <Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (size == LDXR
```

```
11) <Xt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer elsize = 8 << UInt(size); constant integer regsize = if elsize == 64 then 64 else constant boolean acqrel = FALSE; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

&lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

&lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Operation

```
bits(64) address; bits(elsize) data; constant integer dbytes = elsize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked, privileged, t);
```

```
32;
```

```
if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; AArch64.SetExclusiveMonitors(address, dbytes, accdesc); data = Mem[address, dbytes, accdesc]; X[t, regsize] = ZeroExtend(data, regsize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.266 LDXRB

Load exclusive register byte

This instruction derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDXRB <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acqrel = FALSE; constant boolean tagchecked =
```

```
n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; bits(8) data; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; AArch64.SetExclusiveMonitors(address, 1, accdesc); data = Mem[address, 1, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.267 LDXRH

## Load exclusive register halfword

This instruction derives an address from a base register value, loads a halfword from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
LDXRH <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acqrel = FALSE; constant boolean tagchecked =
```

```
n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; bits(16) data; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; AArch64.SetExclusiveMonitors(address, 2, accdesc); data = Mem[address, 2, accdesc]; X[t, 32] = ZeroExtend(data, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.268 LSL (register)

Logical shift left (register)

This instruction shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The value of the second source register modulo the register size in bits gives the number of bits by which the first source register is left-shifted.

This is an alias of LSLV. This means:

- The encodings in this description are named to match the encodings of LSLV.
- The description of LSLV gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) LSL <Wd>, <Wn>, <Wm>
```

## is equivalent to

```
LSLV <Wd>, <Wn>, <Wm>
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (sf == 1) LSL <Xd>, <Xn>, <Xm>
```

```
is equivalent to
```

```
LSLV <Xd>, <Xn>, <Xm>
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the 'Rm' field.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the 'Rm' field.

## Operation

The description of LSLV gives the operational pseudocode for this instruction.

## Operational Information

The description of LSLV gives the operational information for this instruction.

## C6.2.269 LSL (immediate)

Logical shift left (immediate)

This instruction shifts a register value left by an immediate number of bits, shifting in zeros, and writes the result to the destination register.

This is an alias of UBFM. This means:

- The encodings in this description are named to match the encodings of UBFM.
- The description of UBFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0 &amp;&amp; imms != 011111)

```
LSL <Wd>, <Wn>, #<shift>
```

## is equivalent to

```
UBFM <Wd>, <Wn>, #(-<shift> MOD 32), #(31-<shift>)
```

and is the preferred disassembly when UInt(imms) + 1 == UInt(immr) .

## Encoding for the 64-bit variant

Applies when (sf == 1 &amp;&amp; N == 1 &amp;&amp; imms != 111111)

```
LSL <Xd>, <Xn>, #<shift>
```

## is equivalent to

```
UBFM <Xd>, <Xn>, #(-<shift> MOD 64), #(63-<shift>)
```

and is the preferred disassembly when UInt(imms) + 1 == UInt(immr) .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31.

For the '64-bit' variant: is the shift amount, in the range 0 to 63.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

## Operation

The description of UBFM gives the operational pseudocode for this instruction.

## Operational Information

The description of UBFM gives the operational information for this instruction.

## C6.2.270 LSLV

Logical shift left variable

This instruction shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The value of the second source register modulo the register size in bits gives the number of bits by which the first source register is left-shifted.

This instruction is used by the alias LSL (register).

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
LSLV <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

Applies when 1)

```
(sf == LSLV <Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type =
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the 'Rm' field.

```
DecodeShift(op2);
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand2 = X[m, datasize]; X[d, datasize] = ShiftReg(n, shift_type, UInt(operand2) MOD datasize, datasize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias          | Is preferred when   |
|----------------|---------------------|
| LSL (register) | Unconditionally     |

## C6.2.271 LSR (register)

Logical shift right (register)

This instruction shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The value of the second source register modulo the register size in bits gives the number of bits by which the first source register is right-shifted.

This is an alias of LSRV. This means:

- The encodings in this description are named to match the encodings of LSRV.
- The description of LSRV gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) LSR <Wd>, <Wn>, <Wm>
```

## is equivalent to

```
LSRV <Wd>, <Wn>, <Wm>
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (sf == 1) LSR <Xd>, <Xn>, <Xm>
```

```
is equivalent to
```

```
LSRV <Xd>, <Xn>, <Xm>
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the 'Rm' field.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the 'Rm' field.

## Operation

The description of LSRV gives the operational pseudocode for this instruction.

## Operational Information

The description of LSRV gives the operational information for this instruction.

## C6.2.272 LSR (immediate)

Logical shift right (immediate)

This instruction shifts a register value right by an immediate number of bits, shifting in zeros, and writes the result to the destination register.

This is an alias of UBFM. This means:

- The encodings in this description are named to match the encodings of UBFM.
- The description of UBFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0 &amp;&amp; imms == 011111)

```
LSR <Wd>, <Wn>, #<shift>
```

## is equivalent to

```
UBFM <Wd>, <Wn>, #<shift>, #31
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (sf == 1 && N == 1 && imms == 111111) LSR <Xd>, <Xn>, #<shift>
```

## is equivalent to

```
UBFM <Xd>, <Xn>, #<shift>, #63
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;shift&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, encoded in the 'immr' field.

For the '64-bit' variant: is the shift amount, in the range 0 to 63, encoded in the 'immr' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

## Operation

The description of UBFM gives the operational pseudocode for this instruction.

## Operational Information

The description of UBFM gives the operational information for this instruction.

## C6.2.273 LSRV

Logical shift right variable

This instruction shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The value of the second source register modulo the register size in bits gives the number of bits by which the first source register is right-shifted.

This instruction is used by the alias LSR (register).

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
LSRV <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

Applies when 1)

```
(sf == LSRV <Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type =
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the 'Rm' field.

```
DecodeShift(op2);
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand2 = X[m, datasize]; X[d, datasize] = ShiftReg(n, shift_type, UInt(operand2) MOD datasize, datasize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias   | Is preferred when   |
|---------|---------------------|
| LSR     | Unconditionally     |

## C6.2.274 MADD

## Multiply-add

This instruction multiplies two register values, adds a third register value, and writes the result to the destination register.

This instruction is used by the alias MUL.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) MADD <Wd>, <Wn>, <Wm>, <Wa>
```

## Encoding for the 64-bit variant

Applies when

```
(sf == 1) MADD <Xd>, <Xn>, <Xm>, <Xa>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer a = UInt(Ra); constant integer datasize = 32 << UInt(sf);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Wa&gt;

Is the 32-bit name of the third general-purpose source register holding the addend, encoded in the 'Ra' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

<!-- image -->

Is the 64-bit name of the third general-purpose source register holding the addend, encoded in the 'Ra' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = X[m, datasize]; constant bits(datasize) operand3 = X[a, datasize]; constant integer result = UInt(operand3) + (UInt(operand1) * UInt(operand2)); X[d, datasize] = result<datasize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias   | Is preferred when   |
|---------|---------------------|
| MUL     | Ra == '11111'       |

## C6.2.275 MADDPT

Multiply-add checked pointer

This instruction multiplies two register values, adds a third register value, and writes the result to the destination register. The intermediate product is treated as the offset.

If the operation would have generated a result where the most significant 8 bits of the result register differ from the most significant 8 bits of the base register, then the result is modified such that it is likely to be non-canonical when used as an address.

If the intermediate product cannot be correctly represented as a 64-bit two's complement value, then the result is modified such that it is likely to be non-canonical when used as an address.

## Integer

(FEAT\_CPA)

<!-- image -->

## Encoding

```
MADDPT <Xd>, <Xn>, <Xm>, <Xa>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_CPA) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer a = UInt(Ra);
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Xa&gt;

Is the 64-bit name of the third general-purpose source register holding the addend, encoded in the 'Ra' field.

## Operation

```
constant bits(64) operand1 = X[n, 64]; constant bits(64) operand2 = X[m, 64]; constant bits(64) operand3 = X[a, 64]; bits(64) result; constant integer product = SInt(operand1) *
```

```
SInt(operand2);
```

```
// Signed and unsigned twos complement arithmetic are equivalent if only a // fixed number of bits are considered. result = operand3 + product<63:0>; constant boolean overflow = (product != SInt(product<63:0>)); result = PointerMultiplyAddCheck(result, operand3, overflow); X[d, 64] = result;
```

## C6.2.276 MNEG

## Multiply-negate

This instruction multiplies two register values, negates the product, and writes the result to the destination register.

This is an alias of MSUB. This means:

- The encodings in this description are named to match the encodings of MSUB.
- The description of MSUB gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
MNEG <Wd>, <Wn>, <Wm>
```

## is equivalent to

```
MSUB <Wd>, <Wn>, <Wm>, WZR
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

1)

```
Applies when (sf == MNEG <Xd>, <Xn>, <Xm>
```

## is equivalent to

```
MSUB <Xd>, <Xn>, <Xm>, XZR
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## Operation

The description of MSUB gives the operational pseudocode for this instruction.

## Operational Information

The description of MSUB gives the operational information for this instruction.

## C6.2.277 MOV (to/from SP)

Move register value to or from SP

This instruction copies the value of a register to or from the stack pointer.

This is an alias of ADD (immediate). This means:

- The encodings in this description are named to match the encodings of ADD (immediate).
- The description of ADD (immediate) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0) MOV <Wd|WSP>, <Wn|WSP>
```

## is equivalent to

```
ADD <Wd|WSP>, <Wn|WSP>, #0
```

and is the preferred disassembly when Rd == '11111' || Rn == '11111' .

## Encoding for the 64-bit variant

Applies when (sf ==

```
1) MOV <Xd|SP>, <Xn|SP>
```

## is equivalent to

```
ADD <Xd|SP>, <Xn|SP>, #0
```

and is the preferred disassembly when Rd == '11111' || Rn == '11111' .

## Assembler Symbols

## &lt;Wd|WSP&gt;

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Wn|WSP&gt;

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;Xd|SP&gt;

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of ADD (immediate) gives the operational pseudocode for this instruction.

## Operational Information

The description of ADD (immediate) gives the operational information for this instruction.

## C6.2.278 MOV (inverted wide immediate)

Move inverted wide immediate value

This instruction moves an inverted 16-bit immediate value to a register.

This is an alias of MOVN. This means:

- The encodings in this description are named to match the encodings of MOVN.
- The description of MOVN gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when

(sf

== 0 &amp;&amp; hw == 0x)

MOV

&lt;Wd&gt;, #&lt;imm&gt;

## is equivalent to

```
MOVN <Wd>, #<imm16>, LSL #<shift>
```

and is the preferred disassembly when !(IsZero(imm16) &amp;&amp; hw != '00') &amp;&amp; !IsOnes(imm16) .

## Encoding for the 64-bit variant

Applies when (sf ==

```
1) MOV <Xd>, #<imm>
```

## is equivalent to

```
MOVN <Xd>, #<imm16>, LSL #<shift>
```

and is the preferred disassembly when !(IsZero(imm16) &amp;&amp; hw != '00') .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;imm&gt;

For the '32-bit' variant: is a 32-bit immediate, the bitwise inverse of which can be encoded in 'imm16:hw', but excluding 0xffff0000 and 0x0000 ffff

For the '64-bit' variant: is a 64-bit immediate, the bitwise inverse of which can be encoded in 'imm16:hw'.

<!-- image -->

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

The description of MOVN gives the operational pseudocode for this instruction.

## C6.2.279 MOV (wide immediate)

Move wide immediate value

This instruction moves a 16-bit immediate value to a register.

This is an alias of MOVZ. This means:

- The encodings in this description are named to match the encodings of MOVZ.
- The description of MOVZ gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when

(sf

== 0 &amp;&amp; hw == 0x)

MOV

&lt;Wd&gt;, #&lt;imm&gt;

## is equivalent to

```
MOVZ <Wd>, #<imm16>, LSL #<shift>
```

and is the preferred disassembly when !(IsZero(imm16) &amp;&amp; hw != '00') .

## Encoding for the 64-bit variant

Applies when (sf ==

```
1) MOV <Xd>, #<imm>
```

## is equivalent to

```
MOVZ <Xd>, #<imm16>, LSL #<shift>
```

and is the preferred disassembly when !(IsZero(imm16) &amp;&amp; hw != '00') .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;imm&gt;

For the '32-bit' variant: is a 32-bit immediate which can be encoded in 'imm16:hw'.

For the '64-bit' variant: is a 64-bit immediate which can be encoded in 'imm16:hw'.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

The description of MOVZ gives the operational pseudocode for this instruction.

## C6.2.280 MOV (bitmask immediate)

Move bitmask immediate value

This instruction writes a bitmask immediate value to a register.

This is an alias of ORR (immediate). This means:

- The encodings in this description are named to match the encodings of ORR (immediate).
- The description of ORR (immediate) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0 && N == 0) MOV <Wd|WSP>, #<imm>
```

## is equivalent to

```
ORR <Wd|WSP>, WZR, #<imm>
```

and is the preferred disassembly when !MoveWidePreferred(sf, N, imms, immr) .

## Encoding for the 64-bit variant

```
Applies when (sf == 1) MOV <Xd|SP>, #<imm>
```

## is equivalent to

```
ORR <Xd|SP>, XZR, #<imm>
```

and is the preferred disassembly when !MoveWidePreferred(sf, N, imms, immr) .

## Assembler Symbols

## &lt;Wd|WSP&gt;

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;imm&gt;

For the '32-bit' variant: is the bitmask immediate, encoded in 'imms:immr', but excluding values which could be encoded by MOVZ or MOVN.

For the '64-bit' variant: is the bitmask immediate, encoded in 'N:imms:immr', but excluding values which could be encoded by MOVZ or MOVN.

## &lt;Xd|SP&gt;

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## Operation

The description of ORR (immediate) gives the operational pseudocode for this instruction.

## Operational Information

The description of ORR (immediate) gives the operational information for this instruction.

## C6.2.281 MOV (register)

Move register value

This instruction copies the value in a source register to the destination register.

This is an alias of ORR (shifted register). This means:

- The encodings in this description are named to match the encodings of ORR (shifted register).
- The description of ORR (shifted register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0) MOV <Wd>, <Wm> is equivalent to ORR <Wd>, WZR, <Wm>
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

Applies when (sf ==

```
1) MOV <Xd>, <Xm>
```

## is equivalent to

```
ORR <Xd>, XZR, <Xm>
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wm&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rm' field.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rm' field.

## Operation

The description of ORR (shifted register) gives the operational pseudocode for this instruction.

## Operational Information

The description of ORR (shifted register) gives the operational information for this instruction.

## C6.2.282 MOVK

## Move wide with keep

This instruction moves an optionally-shifted 16-bit immediate value into a register, keeping other bits unchanged.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0 && hw == 0x) MOVK <Wd>, #<imm>{, LSL #<shift>}
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) MOVK <Xd>, #<imm>{,
```

```
LSL #<shift>}
```

## Decode for all variants of this encoding

```
'1' then EndOfDecode(Decode_UNDEF);
```

```
if sf == '0' && hw<1> == constant integer d = UInt(Rd); constant integer datasize = 32 << UInt(sf); constant bits(16) imm = imm16; constant integer pos = UInt(hw) << 4;
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;imm&gt;

Is the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the 'imm16' field.

## &lt;shift&gt;

For the '32-bit' variant: is the amount by which to shift the immediate left, either 0 (the default) or 16, encoded in the 'hw' field as &lt;shift&gt;/16.

For the '64-bit' variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the 'hw' field as &lt;shift&gt;/16.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

```
bits(datasize) result = result<pos+15:pos> = imm; X[d, datasize] = result;
```

```
X[d, datasize];
```

## C6.2.283 MOVN

## Move wide with NOT

This instruction moves the inverse of an optionally-shifted 16-bit immediate value to a register.

This instruction is used by the alias MOV (inverted wide immediate).

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf

```
MOVN <Wd>, #<imm>{,
```

```
== 0 && hw == 0x) LSL #<shift>}
```

## Encoding for the 64-bit variant

Applies when

```
(sf == 1)
```

```
MOVN <Xd>, #<imm>{,
```

```
LSL #<shift>}
```

## Decode for all variants of this encoding

```
'1' then EndOfDecode(Decode_UNDEF);
```

```
if sf == '0' && hw<1> == constant integer d = UInt(Rd); constant integer datasize = 32 << UInt(sf); constant bits(16) imm = imm16; constant integer pos = UInt(hw) << 4;
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;imm&gt;

Is the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the 'imm16' field.

## &lt;shift&gt;

For the '32-bit' variant: is the amount by which to shift the immediate left, either 0 (the default) or 16, encoded in the 'hw' field as &lt;shift&gt;/16.

For the '64-bit' variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the 'hw' field as &lt;shift&gt;/16.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Alias Conditions

| Alias                         | Of variant   | Is preferred when                                |
|-------------------------------|--------------|--------------------------------------------------|
| MOV (inverted wide immediate) | 32-bit       | !(IsZero(imm16) && hw != '00') && !IsOnes(imm16) |
| MOV (inverted wide immediate) | 64-bit       | !(IsZero(imm16) && hw != '00')                   |

## Operation

| bits(datasize) result = Zeros(datasize);   |
|--------------------------------------------|
| result<pos+15:pos> = imm;                  |
| X[d, datasize] = NOT(result);              |

## C6.2.284 MOVZ

Move wide with zero

This instruction moves an optionally-shifted 16-bit immediate value to a register.

This instruction is used by the alias MOV (wide immediate).

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf

```
MOVZ <Wd>, #<imm>{,
```

```
== 0 && hw == 0x) LSL #<shift>}
```

## Encoding for the 64-bit variant

Applies when

```
(sf == 1)
```

```
MOVZ <Xd>, #<imm>{,
```

```
LSL #<shift>}
```

## Decode for all variants of this encoding

```
'1' then EndOfDecode(Decode_UNDEF);
```

```
if sf == '0' && hw<1> == constant integer d = UInt(Rd); constant integer datasize = 32 << UInt(sf); constant bits(16) imm = imm16; constant integer pos = UInt(hw) << 4;
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;imm&gt;

Is the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the 'imm16' field.

## &lt;shift&gt;

For the '32-bit' variant: is the amount by which to shift the immediate left, either 0 (the default) or 16, encoded in the 'hw' field as &lt;shift&gt;/16.

For the '64-bit' variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the 'hw' field as &lt;shift&gt;/16.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Alias Conditions

## Alias

MOV (wide immediate)

## Operation

Zeros(datasize);

```
bits(datasize) result = result<pos+15:pos> = imm; X[d, datasize] = result;
```

## Is preferred when

!(IsZero(imm16) &amp;&amp; hw != '00')

## C6.2.285 MRRS

Move System register to two adjacent general-purpose registers

This instruction allows the PE to read an AArch64 128-bit System register into two adjacent 64-bit general-purpose registers.

## System

(FEAT\_SYSREG128)

<!-- image -->

## Encoding

```
MRRS <Xt>, <Xt+1>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SYSREG128) then EndOfDecode(Decode_UNDEF); if Rt<0> == '1' then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt+1); constant bits(1) sys_L = L; constant bits(2) sys_op0 = '1' : o0; constant bits(3) sys_op1 = op1; constant bits(3) sys_op2 = op2; constant bits(4) sys_crn = CRn; constant bits(4) sys_crm = CRm;
```

## Assembler Symbols

&lt;Xt&gt;

Is the 64-bit name of the first general-purpose destination register, encoded in the 'Rt' field.

## &lt;Xt+1&gt;

Is the 64-bit name of the second general-purpose destination register, encoded as 'Rt' +1.

## &lt;systemreg&gt;

Is a System register name, encoded in 'o0:op1:CRn:CRm:op2'.

## &lt;op0&gt;

Is an unsigned immediate, encoded in 'o0':

|   o0 |   <op0> |
|------|---------|
|    0 |       2 |
|    1 |       3 |

## &lt;op1&gt;

## Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the 'op1' field. &lt;Cn&gt; Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the 'CRn' field. &lt;Cm&gt; Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the 'CRm' field. &lt;op2&gt; Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the 'op2' field.

## Operation

AArch64.SysRegRead128(sys\_op0, sys\_op1, sys\_crn, sys\_crm, sys\_op2, t, t2);

## C6.2.286 MRS

Move System register to general-purpose register

This instruction allows the PE to read an AArch64 System register into a general-purpose register.

<!-- image -->

## Encoding

MRS &lt;Xt&gt;, (&lt;systemreg&gt;|S&lt;op0&gt;\_&lt;op1&gt;\_&lt;Cn&gt;\_&lt;Cm&gt;\_&lt;op2&gt;)

## Decode for this encoding

```
constant integer t constant bits(1) sys_L = L; constant bits(2) sys_op0 = '1' : constant bits(3) sys_op1 = op1; constant bits(3) sys_op2 = op2; constant bits(4) sys_crn = CRn; constant bits(4) sys_crm = CRm;
```

```
= UInt(Rt); o0;
```

## Assembler Symbols

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rt' field.

## &lt;systemreg&gt;

Is a System register name, encoded in 'o0:op1:CRn:CRm:op2'.

The System register names are defined in AArch64 System Register Descriptions.

## &lt;op0&gt;

Is an unsigned immediate, encoded in 'o0':

## &lt;op1&gt;

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the 'op1' field.

## &lt;Cn&gt;

Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the 'CRn' field.

## &lt;Cm&gt;

Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the 'CRm' field.

L

|   o0 |   <op0> |
|------|---------|
|    0 |       2 |
|    1 |       3 |

&lt;op2&gt;

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the 'op2' field.

## Operation

AArch64.SysRegRead(sys\_op0, sys\_op1, sys\_crn, sys\_crm, sys\_op2, t);

## C6.2.287 MSR (immediate)

Move immediate value to special register

This instruction moves an immediate value to selected bits of the PSTATE. For more information, see Process state, PSTATE.

The bits that can be written by this instruction are:

- PSTATE.D, PSTATE.A, PSTATE.I, PSTATE.F, and PSTATE.SP.
- If FEAT\_SSBS is implemented, PSTATE.SSBS.
- If FEAT\_PAN is implemented, PSTATE.PAN.
- If FEAT\_UAO is implemented, PSTATE.UAO.
- If FEAT\_DIT is implemented, PSTATE.DIT.
- If FEAT\_MTE is implemented, PSTATE.TCO.
- If FEAT\_NMI is implemented, PSTATE.ALLINT.
- If FEAT\_SME is implemented, PSTATE.SM and PSTATE.ZA.
- If FEAT\_EBEP is implemented, PSTATE.PM.

If FEAT\_MTE is implemented and FEAT\_MTE2 is not implemented, it is IMPLEMENTATION DEFINED whether writes to PSTATE.TCO by this instruction are ignored.

This instruction is used by the aliases SMSTART and SMSTOP.

<!-- image -->

## Encoding

```
Applies when (!(op1 == 000 && op2 IN {00x, 010}))
```

```
MSR
```

```
<pstatefield>, #<imm>
```

## Decode for this encoding

```
if op1 == '000' && op2 == '000' then SEE "CFINV"; if op1 == '000' && op2 == '001' then SEE "XAFLAG"; if op1 == '000' && op2 == '010' then SEE "AXFLAG"; bits(2) min_EL; boolean need_secure = FALSE; case op1 of when '00x' min_EL = EL1; when '010' min_EL = EL1; when '011' min_EL = EL0; when '100' min_EL = EL2; when '101' if !IsFeatureImplemented(FEAT_VHE) then EndOfDecode(Decode_UNDEF); min_EL = EL2; when '110' min_EL = EL3; when '111' min_EL = EL1; need_secure = TRUE;
```

```
constant bits(4) operand = CRm; PSTATEField field; case op1:op2 of when '000 011' if !IsFeatureImplemented(FEAT_UAO) then EndOfDecode(Decode_UNDEF); field = PSTATEField_UAO; when '000 100' if !IsFeatureImplemented(FEAT_PAN) then EndOfDecode(Decode_UNDEF); field = PSTATEField_PAN; when '000 101' field = PSTATEField_SP; when '001 000' case CRm of when '000x' if !IsFeatureImplemented(FEAT_NMI) then EndOfDecode(Decode_UNDEF); field = PSTATEField_ALLINT; when '001x' if !IsFeatureImplemented(FEAT_EBEP) then EndOfDecode(Decode_UNDEF); field = PSTATEField_PM; otherwise EndOfDecode(Decode_UNDEF); when '011 010' if !IsFeatureImplemented(FEAT_DIT) then EndOfDecode(Decode_UNDEF); field = PSTATEField_DIT; when '011 011' case CRm of when '001x' if !IsFeatureImplemented(FEAT_SME) then EndOfDecode(Decode_UNDEF); field = PSTATEField_SVCRSM; when '010x' if !IsFeatureImplemented(FEAT_SME) then EndOfDecode(Decode_UNDEF); field = PSTATEField_SVCRZA; when '011x' if !IsFeatureImplemented(FEAT_SME) then EndOfDecode(Decode_UNDEF); field = PSTATEField_SVCRSMZA; otherwise EndOfDecode(Decode_UNDEF); when '011 100' if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); field = PSTATEField_TCO; when '011 110' field = PSTATEField_DAIFSet; when '011 111' field = PSTATEField_DAIFClr; when '011 001' if !IsFeatureImplemented(FEAT_SSBS) then EndOfDecode(Decode_UNDEF); field = PSTATEField_SSBS; otherwise EndOfDecode(Decode_UNDEF);
```

## Assembler Symbols

## &lt;pstatefield&gt;

Is a PSTATE field name. For the MSR instruction, this is encoded in 'CRm:op1:op2':

| CRm   |   op1 |   op2 | <pstatefield>   | Architectural Feature   |
|-------|-------|-------|-----------------|-------------------------|
| 000x  |   001 |   000 | ALLINT          | FEAT_NMI                |
| 000x  |   011 |   011 | RESERVED        | -                       |
| 001x  |   001 |   000 | PM              | FEAT_EBEP               |
| 001x  |   011 |   011 | SVCRSM          | FEAT_SME                |
| 010x  |   011 |   011 | SVCRZA          | FEAT_SME                |

| CRm   | op1   | op2   | <pstatefield>   | Architectural Feature   |
|-------|-------|-------|-----------------|-------------------------|
| 01xx  | 001   | 000   | RESERVED        | -                       |
| 011x  | 011   | 011   | SVCRSMZA        | FEAT_SME                |
| xxxx  | 000   | 011   | UAO             | FEAT_UAO                |
| xxxx  | 000   | 100   | PAN             | FEAT_PAN                |
| xxxx  | 000   | 101   | SPSel           | -                       |
| xxxx  | 000   | 11x   | RESERVED        | -                       |
| xxxx  | 001   | 001   | RESERVED        | -                       |
| xxxx  | 001   | 01x   | RESERVED        | -                       |
| xxxx  | 001   | 1xx   | RESERVED        | -                       |
| xxxx  | 010   | xxx   | RESERVED        | -                       |
| xxxx  | 011   | 000   | RESERVED        | -                       |
| xxxx  | 011   | 001   | SSBS            | FEAT_SSBS               |
| xxxx  | 011   | 010   | DIT             | FEAT_DIT                |
| xxxx  | 011   | 100   | TCO             | FEAT_MTE                |
| xxxx  | 011   | 101   | RESERVED        | -                       |
| xxxx  | 011   | 110   | DAIFSet         | -                       |
| xxxx  | 011   | 111   | DAIFClr         | -                       |
| xxxx  | 1xx   | xxx   | RESERVED        | -                       |
| 1xxx  | 001   | 000   | RESERVED        | -                       |
| 1xxx  | 011   | 011   | RESERVED        | -                       |

For the SMSTART and SMSTOP aliases, this is encoded in 'CRm&lt;2:1&gt;', where 0b01 specifies SVCRSM, 0b10 specifies SVCRZA, and 0b11 specifies SVCRSMZA.

## &lt;imm&gt;

Is a 4-bit unsigned immediate, in the range 0 to 15, encoded in the 'CRm' field. Restricted to the range 0 to 1, encoded in 'CRm&lt;0&gt;', when &lt;pstatefield&gt; is ALLINT, PM, SVCRSM, SVCRSMZA, or SVCRZA.

## Alias Conditions

## Operation

```
if UInt(PSTATE.EL) < UInt(min_EL) then UNDEFINED; if need_secure && CurrentSecurityState() != SS_Secure then UNDEFINED; case field of when PSTATEField_SSBS PSTATE.SSBS = operand<0>; when PSTATEField_SP
```

| Alias   | Is preferred when                            |
|---------|----------------------------------------------|
| SMSTART | op1 == '011' && CRm IN {'0xx1'}              |
| SMSTOP  | op1 == '011' && CRm IN {'0xx0'} op2 == '011' |

```
PSTATE.SP = operand<0>; when PSTATEField_DAIFSet AArch64.CheckDAIFAccess(PSTATEField_DAIFSet); PSTATE.D = PSTATE.D OR operand<3>; PSTATE.A = PSTATE.A OR operand<2>; PSTATE.I = PSTATE.I OR operand<1>; PSTATE.F = PSTATE.F OR operand<0>; when PSTATEField_DAIFClr AArch64.CheckDAIFAccess(PSTATEField_DAIFClr); PSTATE.D = PSTATE.D AND NOT(operand<3>); PSTATE.A = PSTATE.A AND NOT(operand<2>); PSTATE.I = PSTATE.I AND NOT(operand<1>); PSTATE.F = PSTATE.F AND NOT(operand<0>); when PSTATEField_PAN PSTATE.PAN = operand<0>; when PSTATEField_UAO PSTATE.UAO = operand<0>; when PSTATEField_DIT PSTATE.DIT = operand<0>; when PSTATEField_TCO PSTATE.TCO = operand<0>; when PSTATEField_ALLINT if (PSTATE.EL == EL1 && IsHCRXEL2Enabled() && HCRX_EL2.TALLINT == '1' && operand<0> == '1') then AArch64.SystemAccessTrap(EL2, \texttt{0x18}); PSTATE.ALLINT = operand<0>; when PSTATEField_SVCRSM CheckSMEAccess(); SetPSTATE_SM(operand<0>); when PSTATEField_SVCRZA CheckSMEAccess(); SetPSTATE_ZA(operand<0>); when PSTATEField_SVCRSMZA CheckSMEAccess(); SetPSTATE_SM(operand<0>); SetPSTATE_ZA(operand<0>); when PSTATEField_PM PSTATE.PM = operand<0>;
```

## C6.2.288 MSR (register)

Move general-purpose register to System register

This instruction allows the PE to write an AArch64 System register from a general-purpose register.

<!-- image -->

## Encoding

MSR (&lt;systemreg&gt;|S&lt;op0&gt;\_&lt;op1&gt;\_&lt;Cn&gt;\_&lt;Cm&gt;\_&lt;op2&gt;), &lt;Xt&gt;

## Decode for this encoding

```
constant integer t constant bits(1) sys_L = L; constant bits(2) sys_op0 = '1' : constant bits(3) sys_op1 = op1; constant bits(3) sys_op2 = op2; constant bits(4) sys_crn = CRn; constant bits(4) sys_crm = CRm;
```

```
= UInt(Rt); o0;
```

## Assembler Symbols

## &lt;systemreg&gt;

Is a System register name, encoded in 'o0:op1:CRn:CRm:op2'.

The System register names are defined in AArch64 System Register Descriptions.

## &lt;op0&gt;

Is an unsigned immediate, encoded in 'o0':

## &lt;op1&gt;

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the 'op1' field.

## &lt;Cn&gt;

Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the 'CRn' field.

## &lt;Cm&gt;

Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the 'CRm' field.

## &lt;op2&gt;

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the 'op2' field.

L

|   o0 |   <op0> |
|------|---------|
|    0 |       2 |
|    1 |       3 |

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rt' field.

## Operation

AArch64.SysRegWrite(sys\_op0, sys\_op1, sys\_crn, sys\_crm, sys\_op2, t);

## C6.2.289 MSRR

Move two adjacent general-purpose registers to System register

This instruction allows the PE to write an AArch64 128-bit System register from two adjacent 64-bit general-purpose registers.

## System

(FEAT\_SYSREG128)

<!-- image -->

## Encoding

MSRR (&lt;systemreg&gt;|S&lt;op0&gt;\_&lt;op1&gt;\_&lt;Cn&gt;\_&lt;Cm&gt;\_&lt;op2&gt;), &lt;Xt&gt;, &lt;Xt+1&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SYSREG128) then EndOfDecode(Decode_UNDEF); if Rt<0> == '1' then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt+1); constant bits(1) sys_L = L; constant bits(2) sys_op0 = '1' : o0; constant bits(3) sys_op1 = op1; constant bits(3) sys_op2 = op2; constant bits(4) sys_crn = CRn; constant bits(4) sys_crm = CRm;
```

## Assembler Symbols

&lt;systemreg&gt;

Is a System register name, encoded in 'o0:op1:CRn:CRm:op2'.

&lt;op0&gt;

Is an unsigned immediate, encoded in 'o0':

|   o0 |   <op0> |
|------|---------|
|    0 |       2 |
|    1 |       3 |

```
<op1> Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the 'op1' field. <Cn>
```

Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the 'CRn' field.

## &lt;Cm&gt;

Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the 'CRm' field.

&lt;op2&gt;

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the 'op2' field.

## &lt;Xt&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rt' field.

## &lt;Xt+1&gt;

Is the 64-bit name of the second general-purpose source register, encoded as 'Rt' +1.

## Operation

AArch64.SysRegWrite128(sys\_op0, sys\_op1, sys\_crn, sys\_crm, sys\_op2, t, t2);

## C6.2.290 MSUB

## Multiply-subtract

This instruction multiplies two register values, subtracts the product from a third register value, and writes the result to the destination register.

This instruction is used by the alias MNEG.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) MSUB <Wd>, <Wn>, <Wm>, <Wa>
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) MSUB <Xd>, <Xn>, <Xm>, <Xa>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer a = UInt(Ra); constant integer datasize = 32 <<
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Wa&gt;

Is the 32-bit name of the third general-purpose source register holding the minuend, encoded in the 'Ra' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

```
UInt(sf);
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

<!-- image -->

Is the 64-bit name of the third general-purpose source register holding the minuend, encoded in the 'Ra' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = X[m, datasize]; constant bits(datasize) operand3 = X[a, datasize]; constant integer result = UInt(operand3) - (UInt(operand1) * UInt(operand2)); X[d, datasize] = result<datasize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias   | Is preferred when   |
|---------|---------------------|
| MNEG    | Ra == '11111'       |

## C6.2.291 MSUBPT

## Multiply-subtract checked pointer

This instruction multiplies two register values, subtracts the product from a third register value, and writes the result to the destination register. The intermediate product is treated as the offset.

If the operation would have generated a result where the most significant 8 bits of the result register differ from the most significant 8 bits of the base register, then the result is modified such that it is likely to be non-canonical when used as an address.

If the intermediate product cannot be correctly represented as a 64-bit two's complement value, then the result is modified such that it is likely to be non-canonical when used as an address.

## Integer

(FEAT\_CPA)

<!-- image -->

## Encoding

```
MSUBPT <Xd>, <Xn>, <Xm>, <Xa>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_CPA) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer a = UInt(Ra);
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Xa&gt;

Is the 64-bit name of the third general-purpose source register holding the minuend, encoded in the 'Ra' field.

## Operation

```
constant bits(64) operand1 = X[n, 64]; constant bits(64) operand2 = X[m, 64]; constant bits(64) operand3 = X[a, 64]; bits(64) result; constant integer product = SInt(operand1) *
```

```
SInt(operand2);
```

```
// Signed and unsigned twos complement arithmetic are equivalent if only a // fixed number of bits are considered. result = operand3 - product<63:0>; constant boolean overflow = (product != SInt(product<63:0>)); result = PointerMultiplyAddCheck(result, operand3, overflow); X[d, 64] = result;
```

## C6.2.292 MUL

## Multiply

This instruction multiplies two register values and writes the result to the destination register.

This is an alias of MADD. This means:

- The encodings in this description are named to match the encodings of MADD.
- The description of MADD gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
MUL <Wd>, <Wn>, <Wm>
```

## is equivalent to

```
MADD <Wd>, <Wn>, <Wm>, WZR
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

Applies when (sf == 1)

```
MUL <Xd>, <Xn>, <Xm>
```

## is equivalent to

```
MADD <Xd>, <Xn>, <Xm>, XZR
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## Operation

The description of MADD gives the operational pseudocode for this instruction.

## Operational Information

The description of MADD gives the operational information for this instruction.

## C6.2.293 MVN

Bitwise NOT

This instruction writes the bitwise inverse of a register value to the destination register.

This is an alias of ORN (shifted register). This means:

- The encodings in this description are named to match the encodings of ORN (shifted register).
- The description of ORN (shifted register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0)
```

```
MVN <Wd>, <Wm>{, <shift> #<amount>} is equivalent to ORN <Wd>, WZR, <Wm>{, <shift> #<amount>}
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

Applies when (sf ==

```
MVN <Xd>, <Xm>{, <shift>
```

```
1) #<amount>}
```

## is equivalent to

```
ORN <Xd>, XZR, <Xm>{, <shift> #<amount>}
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wm&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in 'shift':

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

|   shift | <shift>   |
|---------|-----------|
|      01 | LSR       |
|      10 | ASR       |
|      11 | ROR       |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rm' field.

## Operation

The description of ORN (shifted register) gives the operational pseudocode for this instruction.

## Operational Information

The description of ORN (shifted register) gives the operational information for this instruction.

## C6.2.294 NEG (shifted register)

Negate (shifted register)

This instruction negates an optionally-shifted register value, and writes the result to the destination register.

This is an alias of SUB (shifted register). This means:

- The encodings in this description are named to match the encodings of SUB (shifted register).
- The description of SUB (shifted register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) NEG <Wd>, <Wm>{, <shift> #<amount>} is equivalent to SUB <Wd>, WZR, <Wm>{, <shift> #<amount>}
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (sf == 1) NEG <Xd>, <Xm>{, <shift>
```

```
#<amount>}
```

is equivalent to

```
SUB <Xd>, XZR, <Xm>{, <shift> #<amount>}
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wm&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded in 'shift':

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

|   shift | <shift>   |
|---------|-----------|
|      01 | LSR       |
|      10 | ASR       |
|      11 | RESERVED  |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rm' field.

## Operation

The description of SUB (shifted register) gives the operational pseudocode for this instruction.

## Operational Information

The description of SUB (shifted register) gives the operational information for this instruction.

## C6.2.295 NEGS

Negate, setting flags

This instruction negates an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result.

This is an alias of SUBS (shifted register). This means:

- The encodings in this description are named to match the encodings of SUBS (shifted register).
- The description of SUBS (shifted register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0) NEGS <Wd>, <Wm>{, <shift> #<amount>} is equivalent to SUBS <Wd>, WZR, <Wm>{, <shift> #<amount>}
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (sf == 1) NEGS <Xd>, <Xm>{, <shift> #<amount>} is equivalent to SUBS <Xd>, XZR, <Xm>{, <shift> #<amount>}
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wm&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded in 'shift':

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |
|      10 | ASR       |
|      11 | RESERVED  |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rm' field.

## Operation

The description of SUBS (shifted register) gives the operational pseudocode for this instruction.

## Operational Information

The description of SUBS (shifted register) gives the operational information for this instruction.

## C6.2.296 NGC

Negate with carry

This instruction negates the sum of a register value and the value of NOT (Carry flag), and writes the result to the destination register.

This is an alias of SBC. This means:

- The encodings in this description are named to match the encodings of SBC.
- The description of SBC gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

NGC

&lt;Wd&gt;, &lt;Wm&gt;

## is equivalent to

```
SBC <Wd>, WZR, <Wm>
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

Applies when (sf ==

```
1) NGC <Xd>, <Xm>
```

## is equivalent to

```
SBC <Xd>, XZR, <Xm>
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wm&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rm' field.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rm' field.

## Operation

The description of SBC gives the operational pseudocode for this instruction.

## Operational Information

The description of SBC gives the operational information for this instruction.

## C6.2.297 NGCS

Negate with carry, setting flags

This instruction negates the sum of a register value and the value of NOT (Carry flag), and writes the result to the destination register. It updates the condition flags based on the result.

This is an alias of SBCS. This means:

- The encodings in this description are named to match the encodings of SBCS.
- The description of SBCS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

NGCS

&lt;Wd&gt;, &lt;Wm&gt;

## is equivalent to

```
SBCS <Wd>, WZR, <Wm>
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

Applies when (sf ==

```
1) NGCS <Xd>, <Xm>
```

## is equivalent to

```
SBCS <Xd>, XZR, <Xm>
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wm&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rm' field.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rm' field.

## Operation

The description of SBCS gives the operational pseudocode for this instruction.

## Operational Information

The description of SBCS gives the operational information for this instruction.

## C6.2.298 NOP

## No operation

This instruction does nothing, other than advance the value of the program counter by 4. This instruction can be used for instruction alignment purposes.

Note

The timing effects of including a NOP instruction in a program are not guaranteed. It can increase execution time, leave it unchanged, or even reduce it. Therefore, NOP instructions are not suitable for timing loops.

<!-- image -->

<!-- image -->

## Encoding

NOP

## Decode for this encoding

// Empty.

## Operation

return; // Do nothing

## C6.2.299 ORN (shifted register)

Bitwise OR NOT (shifted register)

This instruction performs a bitwise (inclusive) OR of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register.

This instruction is used by the alias MVN.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) ORN <Wd>, <Wn>, <Wm>{, <shift>
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) ORN <Xd>, <Xn>, <Xm>{, <shift>
```

```
#<amount>}
```

```
#<amount>}
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if sf == '0' && imm6<5> == '1' then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type = DecodeShift(shift); constant integer shift_amount = UInt(imm6);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in 'shift':

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount, X[d, datasize] = operand1 OR NOT(operand2);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   shift | <shift>   |
|---------|-----------|
|      10 | ASR       |
|      11 | ROR       |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

| Alias   | Is preferred when   |
|---------|---------------------|
| MVN     | Rn == '11111'       |

```
datasize);
```

## C6.2.300 ORR (immediate)

Bitwise OR (immediate)

This instruction performs a bitwise (inclusive) OR of a register value and an immediate value, and writes the result to the destination register.

This instruction is used by the alias MOV (bitmask immediate).

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N ==

```
ORR
```

```
0) <Wd|WSP>, <Wn>, #<imm>
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
1)
```

```
ORR <Xd|SP>, <Xn>, #<imm>
```

## Decode for all variants of this encoding

```
if sf == '0' && N != '0' then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); bits(datasize) imm; (imm, -) = DecodeBitMasks(N, imms, immr, TRUE, datasize);
```

## Assembler Symbols

## &lt;Wd|WSP&gt;

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;imm&gt;

For the '32-bit' variant: is the bitmask immediate, encoded in 'imms:immr'.

For the '64-bit' variant: is the bitmask immediate, encoded in 'N:imms:immr'.

## &lt;Xd|SP&gt;

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Alias

## Is preferred when

```
MOV (bitmask immediate) Rn == '11111' && !MoveWidePreferred(sf, N, imms, immr)
```

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = imm; constant bits(datasize) result = operand1 OR if d == 31 then SP[64] = ZeroExtend(result, 64); else X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias Conditions

```
operand2;
```

## C6.2.301 ORR (shifted register)

Bitwise OR (shifted register)

This instruction performs a bitwise (inclusive) OR of a register value and an optionally-shifted register value, and writes the result to the destination register.

This instruction is used by the alias MOV (register).

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) ORR <Wd>, <Wn>, <Wm>{, <shift>
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) ORR <Xd>, <Xn>, <Xm>{, <shift>
```

```
#<amount>}
```

```
#<amount>}
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if sf == '0' && imm6<5> == '1' then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type = DecodeShift(shift); constant integer shift_amount = UInt(imm6);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in 'shift':

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Alias Conditions

```
Alias Is preferred when MOV (register) shift == '00' && imm6 == '000000' && Rn == '11111'
```

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount, datasize); X[d, datasize] = operand1 OR operand2;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   shift | <shift>   |
|---------|-----------|
|      10 | ASR       |
|      11 | ROR       |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.302 PACDA, PACDZA

Pointer Authentication Code for data address, using key A

This instruction computes and inserts a Pointer Authentication Code for a data address, using a modifier and key A.

The address is in the general-purpose register that is specified by &lt;Xd&gt; .

The modifier is:

- In the general-purpose register or stack pointer that is specified by &lt;Xn|SP&gt; for PACDA .
- The value zero, for PACDZA .

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding for the PACDA variant

```
(Z == 0)
```

```
Applies when PACDA <Xd>, <Xn|SP>
```

## Encoding for the PACDZA variant

```
Applies when (Z == 1 && Rn == 11111)
```

PACDZA

&lt;Xd&gt;

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_PAuth) then boolean source_is_sp = FALSE; constant integer d = UInt(Rd); constant integer n = UInt(Rn); if Z == '0' then // PACDA if n == 31 then source_is_sp = TRUE; else // PACDZA if n != 31 then EndOfDecode(Decode_UNDEF);
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if source_is_sp then X[d, 64] = AddPACDA(X[d, 64], SP[64]); else X[d, 64] = AddPACDA(X[d, 64], X[n, 64]);
```

## C6.2.303 PACDB, PACDZB

Pointer Authentication Code for data address, using key B

This instruction computes and inserts a Pointer Authentication Code for a data address, using a modifier and key B.

The address is in the general-purpose register that is specified by &lt;Xd&gt; .

The modifier is:

- In the general-purpose register or stack pointer that is specified by &lt;Xn|SP&gt; for PACDB .
- The value zero, for PACDZB .

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding for the PACDB variant

```
(Z == 0)
```

```
Applies when PACDB <Xd>, <Xn|SP>
```

## Encoding for the PACDZB variant

```
Applies when (Z == 1 && Rn == 11111)
```

PACDZB

&lt;Xd&gt;

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_PAuth) then boolean source_is_sp = FALSE; constant integer d = UInt(Rd); constant integer n = UInt(Rn); if Z == '0' then // PACDB if n == 31 then source_is_sp = TRUE; else // PACDZB if n != 31 then EndOfDecode(Decode_UNDEF);
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if source_is_sp then X[d, 64] = AddPACDB(X[d, 64], SP[64]); else X[d, 64] = AddPACDB(X[d, 64], X[n, 64]);
```

## C6.2.304 PACGA

Pointer Authentication Code, using generic key

This instruction computes the Pointer Authentication Code for a 64-bit value in the first source register, using a modifier in the second source register, and the generic key. The computed Pointer Authentication Code is written to the most significant 32 bits of the destination register, and the least significant 32 bits of the destination register are set to zero.

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding

```
PACGA <Xd>, <Xn>,
```

```
<Xm|SP>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then EndOfDecode(Decode_UNDEF); boolean source_is_sp = FALSE; constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); if m == 31 then source_is_sp = TRUE;
```

## Assembler Symbols

&lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

&lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm|SP&gt;

Is the 64-bit name of the second general-purpose source register or stack pointer, encoded in the 'Rm' field.

## Operation

```
if source_is_sp then X[d, 64] = AddPACGA(X[n, 64], SP[64]); else X[d, 64] = AddPACGA(X[n, 64], X[m, 64]);
```

## C6.2.305 PACIA, PACIA1716, PACIASP, PACIAZ, PACIZA

Pointer Authentication Code for instruction address, using key A

This instruction computes and inserts a Pointer Authentication Code for an instruction address, using a modifier and key A.

The address is:

- In the general-purpose register that is specified by &lt;Xd&gt; for PACIA and PACIZA .
- In X17, for PACIA1716 .
- In X30, for PACIASP and PACIAZ .

The modifier is:

- In the general-purpose register or stack pointer that is specified by &lt;Xn|SP&gt; for PACIA .
- The value zero, for PACIZA and PACIAZ .
- In X16, for PACIA1716 .
- In SP, for PACIASP .

If FEAT\_PAuth\_LR is implemented and PSTATE.PACM is 1, then PACIA1716 and PACIASP include a second modifier that is:

- In X15, for PACIA1716 .
- The value of PC, for PACIASP .

A PACIASP instruction has an implicit BTI instruction. The implicit BTI instruction of a PACIASP instruction is always compatible with PSTATE.BTYPE == 0b01 and PSTATE.BTYPE == 0b10 . Controls in SCTLR\_ELx configure whether the implicit BTI instruction of a PACIASP instruction is compatible with PSTATE.BTYPE == 0b11 . For more information, see PSTATE.BTYPE.

It has encodings from 2 classes: Integer and System

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding for the PACIA variant

```
Applies when (Z == 0) PACIA <Xd>, <Xn|SP>
```

## Encoding for the PACIZA variant

Applies when

(Z == 1

PACIZA

&lt;Xd&gt;

&amp;&amp;

Rn

==

11111)

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_PAuth) then boolean source_is_sp = FALSE; constant boolean pacia1716 = FALSE; constant integer d = UInt(Rd); constant integer n = UInt(Rn); if Z == '0' then // PACIA if n == 31 then source_is_sp = TRUE; else // PACIZA if n != 31 then EndOfDecode(Decode_UNDEF);
```

## System

(FEAT\_PAuth)

<!-- image -->

## Encoding for the PACIA1716 variant

```
Applies when (CRm == 0001 && op2 == 000)
```

PACIA1716

## Encoding for the PACIASP variant

```
Applies when (CRm == 0011 && op2 == 001)
```

PACIASP

## Encoding for the PACIAZ variant

```
Applies when (CRm == 0011 && op2 == 000)
```

PACIAZ

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then EndOfDecode(Decode_NOP); integer d; integer n; boolean source_is_sp = FALSE; boolean pacia1716 = FALSE; case CRm:op2 of when '0011 000' // PACIAZ d = 30; n = 31; when '0011 001' // PACIASP d = 30; source_is_sp = TRUE; if IsFeatureImplemented(FEAT_BTI) then // Check for branch target compatibility between PSTATE.BTYPE // and implicit branch target of PACIASP instruction. constant PACInstType pacinst = PACIxSP; SetBTypeCompatible(BTypeCompatible_PAC(pacinst)); when '0001 000' // PACIA1716 d = 17;
```

```
n = 16; pacia1716 = TRUE;
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if source_is_sp then if IsFeatureImplemented(FEAT_PAuth_LR) && PSTATE.PACM == '1' then X[d, 64] = AddPACIA2(X[d, 64], SP[64], PC64); else X[d, 64] = AddPACIA(X[d, 64], SP[64]); else if IsFeatureImplemented(FEAT_PAuth_LR) && PSTATE.PACM == '1' && pacia1716 then X[d, 64] = AddPACIA2(X[d, 64], X[n, 64], X[15, 64]); else X[d, 64] = AddPACIA(X[d, 64], X[n, 64]);
```

## C6.2.306 PACIA171615

Pointer Authentication Code for instruction address, using key A

This instruction computes and inserts a pointer authentication code for an instruction address, using two modifiers and key A. The address is in X17. The 64-bit value of modifier1 is the value in X16. The 64-bit value of modifier2 is the value in X15.

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding

PACIA171615

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_PAuth\_LR) then EndOfDecode(Decode\_UNDEF);

## Operation

X[17, 64] = AddPACIA2(X[17, 64], X[16, 64], X[15, 64]);

## C6.2.307 PACIASPPC

Pointer Authentication Code for return address, using key A

This instruction computes and inserts a Pointer Authentication Code for an instruction address, using two modifiers and key A.

The address is in X30.

The first modifier is in SP.

The second modifier is the value of PC.

A PACIASPPC instruction has an implicit BTI instruction. The implicit BTI instruction of a PACIASPPC instruction is always compatible with PSTATE.BTYPE == 0b01 and PSTATE.BTYPE == 0b10 . Controls in SCTLR\_ELx configure whether the implicit BTI instruction of a PACIASPPC instruction is compatible with PSTATE.BTYPE == 0b11 . For more information, see PSTATE.BTYPE.

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding

PACIASPPC

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_PAuth_LR) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = 30; if IsFeatureImplemented(FEAT_BTI) then // Check for branch target compatibility between PSTATE.BTYPE // and implicit branch target of PACIxSPPC instruction. constant PACInstType pacinst = PACIxSPPC; SetBTypeCompatible(BTypeCompatible_PAC(pacinst));
```

## Operation

```
X[d, 64] = AddPACIA2(X[d, 64], SP[64], PC64);
```

## C6.2.308 PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZB

Pointer Authentication Code for instruction address, using key B

This instruction computes and inserts a Pointer Authentication Code for an instruction address, using a modifier and key B.

The address is:

- In the general-purpose register that is specified by &lt;Xd&gt; for PACIB and PACIZB .
- In X17, for PACIB1716 .
- In X30, for PACIBSP and PACIBZ .

The modifier is:

- In the general-purpose register or stack pointer that is specified by &lt;Xn|SP&gt; for PACIB .
- The value zero, for PACIZB and PACIBZ .
- In X16, for PACIB1716 .
- In SP, for PACIBSP .

If FEAT\_PAuth\_LR is implemented and PSTATE.PACM is 1, then PACIB1716 and PACIBSP include a second modifier that is:

- In X15, for PACIB1716 .
- The value of PC, for PACIBSP .

A PACIBSP instruction has an implicit BTI instruction. The implicit BTI instruction of a PACIBSP instruction is always compatible with PSTATE.BTYPE == 0b01 and PSTATE.BTYPE == 0b10 . Controls in SCTLR\_ELx configure whether the implicit BTI instruction of a PACIBSP instruction is compatible with PSTATE.BTYPE == 0b11 . For more information, see PSTATE.BTYPE.

It has encodings from 2 classes: Integer and System

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding for the PACIB variant

```
Applies when (Z == 0) PACIB <Xd>, <Xn|SP>
```

## Encoding for the PACIZB variant

Applies when

(Z == 1

PACIZB

&lt;Xd&gt;

&amp;&amp;

Rn

==

11111)

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then EndOfDecode(Decode_UNDEF); boolean source_is_sp = FALSE; constant boolean pacib1716 = FALSE; constant integer d = UInt(Rd); constant integer n = UInt(Rn); if Z == '0' then // PACIB if n == 31 then source_is_sp = TRUE; else // PACIZB if n != 31 then EndOfDecode(Decode_UNDEF);
```

## System

(FEAT\_PAuth)

<!-- image -->

## Encoding for the PACIB1716 variant

```
Applies when (CRm == 0001 && op2 == 010)
```

PACIB1716

## Encoding for the PACIBSP variant

```
Applies when (CRm == 0011 && op2 == 011)
```

PACIBSP

## Encoding for the PACIBZ variant

```
Applies when (CRm == 0011 && op2 == 010)
```

PACIBZ

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then EndOfDecode(Decode_NOP); integer d; integer n; boolean source_is_sp = FALSE; boolean pacib1716 = FALSE; case CRm:op2 of when '0011 010' // PACIBZ d = 30; n = 31; when '0011 011' // PACIBSP d = 30; source_is_sp = TRUE; if IsFeatureImplemented(FEAT_BTI) then // Check for branch target compatibility between PSTATE.BTYPE // and implicit branch target of PACIBSP instruction. constant PACInstType pacinst = PACIxSP; SetBTypeCompatible(BTypeCompatible_PAC(pacinst)); when '0001 010' // PACIB1716 d = 17;
```

```
n = 16; pacib1716 = TRUE;
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if source_is_sp then if IsFeatureImplemented(FEAT_PAuth_LR) && PSTATE.PACM == '1' then X[d, 64] = AddPACIB2(X[d, 64], SP[64], PC64); else X[d, 64] = AddPACIB(X[d, 64], SP[64]); else if IsFeatureImplemented(FEAT_PAuth_LR) && PSTATE.PACM == '1' && pacib1716 then X[d, 64] = AddPACIB2(X[d, 64], X[n, 64], X[15, 64]); else X[d, 64] = AddPACIB(X[d, 64], X[n, 64]);
```

## C6.2.309 PACIB171615

Pointer Authentication Code for instruction address, using key B

This instruction computes and inserts a pointer authentication code for an instruction address, using two modifiers and key B. The address is in X17. The 64-bit value of modifier1 is the value in X16. The 64-bit value of modifier2 is the value in X15.

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding

PACIB171615

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_PAuth\_LR) then EndOfDecode(Decode\_UNDEF);

## Operation

X[17, 64] = AddPACIB2(X[17, 64], X[16, 64], X[15, 64]);

## C6.2.310 PACIBSPPC

Pointer Authentication Code for return address, using key B

This instruction computes and inserts a Pointer Authentication Code for an instruction address, using two modifiers and key B.

The address is in X30.

The first modifier is in SP.

The second modifier is the value of PC.

A PACIBSPPC instruction has an implicit BTI instruction. The implicit BTI instruction of a PACIBSPPC instruction is always compatible with PSTATE.BTYPE == 0b01 and PSTATE.BTYPE == 0b10 . Controls in SCTLR\_ELx configure whether the implicit BTI instruction of a PACIBSPPC instruction is compatible with PSTATE.BTYPE == 0b11 . For more information, see PSTATE.BTYPE.

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding

PACIBSPPC

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_PAuth_LR) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = 30; if IsFeatureImplemented(FEAT_BTI) then // Check for branch target compatibility between PSTATE.BTYPE // and implicit branch target of PACIxSPPC instruction. constant PACInstType pacinst = PACIxSPPC; SetBTypeCompatible(BTypeCompatible_PAC(pacinst));
```

## Operation

```
X[d, 64] = AddPACIB2(X[d, 64], SP[64], PC64);
```

## C6.2.311 PACM

Pointer authentication modifier

This instruction is used to set the value of PSTATE.PACM to 1.

If FEAT\_PAuth\_LR is not implemented, this instruction behaves as a NOP.

## System

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding

PACM

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_PAuth\_LR) then EndOfDecode(Decode\_NOP);

## Operation

PSTATE.PACM = if IsPACMEnabled() then '1' else '0';

## C6.2.312 PACNBIASPPC

Pointer Authentication Code for return address, using key A, not a branch target

This instruction computes and inserts a Pointer Authentication Code for an instruction address, using two modifiers and key A.

The address is in X30.

The first modifier is in SP.

The second modifier is the value of PC.

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding

PACNBIASPPC

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_PAuth\_LR) then EndOfDecode(Decode\_UNDEF);

```
constant integer d = 30;
```

## Operation

X[d, 64] = AddPACIA2(X[d, 64], SP[64], PC64);

## C6.2.313 PACNBIBSPPC

Pointer Authentication Code for return address, using key B, not a branch target

This instruction computes and inserts a Pointer Authentication Code for an instruction address, using two modifiers and key B.

The address is in X30.

The first modifier is in SP.

The second modifier is the value of PC.

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding

PACNBIBSPPC

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_PAuth\_LR) then EndOfDecode(Decode\_UNDEF);

```
constant integer d = 30;
```

## Operation

X[d, 64] = AddPACIB2(X[d, 64], SP[64], PC64);

## C6.2.314 PRFM (immediate)

Prefetch memory (immediate)

This instruction signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The address for data memory accesses is calculated from a base register value and an immediate offset. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as making the cache line containing the specified address available at the level of cache specified by the instruction.

The &lt;prfop&gt; operand specifies the prefetch hint as follows:

- Access type:
- When FEAT\_PCDPHINT is implemented, IR for intent to read on update.
- PLD for prefetch for load.
- PLI for prefetch for execute.
- PST for prefetch for store.
- Target cache level:
- L1 for Level 1 cache.
- L2 for Level 2 cache.
- L3 for Level 3 cache.
- When FEAT\_PRFMSLC is implemented, SLC for system level cache.
- Policy:
- KEEP for retained or temporal prefetch, allocated in the cache normally.
- STRMfor streaming or non-temporal prefetch, for data that is used only once.

The effect of a PRFM instruction is IMPLEMENTATION DEFINED. For more information, see Prefetch memory.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
PRFM
```

```
(<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]
```

## Decode for this encoding

```
= LSL(ZeroExtend(imm12, 64), 3);
```

```
constant bits(64) offset constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant boolean nontemporal = FALSE; constant boolean tagchecked = FALSE;
```

## Assembler Symbols

## &lt;prfop&gt;

Is the prefetch operation, encoded in 'Rt':

|    Rt | <prfop>   | Architectural Feature   |
|-------|-----------|-------------------------|
| 00000 | PLDL1KEEP | -                       |
| 00001 | PLDL1STRM | -                       |

|    Rt | <prfop>    | Architectural Feature   |
|-------|------------|-------------------------|
| 00010 | PLDL2KEEP  | -                       |
| 00011 | PLDL2STRM  | -                       |
| 00100 | PLDL3KEEP  | -                       |
| 00101 | PLDL3STRM  | -                       |
| 00110 | PLDSLCKEEP | FEAT_PRFMSLC            |
| 00111 | PLDSLCSTRM | FEAT_PRFMSLC            |
| 01000 | PLIL1KEEP  | -                       |
| 01001 | PLIL1STRM  | -                       |
| 01010 | PLIL2KEEP  | -                       |
| 01011 | PLIL2STRM  | -                       |
| 01100 | PLIL3KEEP  | -                       |
| 01101 | PLIL3STRM  | -                       |
| 01110 | PLISLCKEEP | FEAT_PRFMSLC            |
| 01111 | PLISLCSTRM | FEAT_PRFMSLC            |
| 10000 | PSTL1KEEP  | -                       |
| 10001 | PSTL1STRM  | -                       |
| 10010 | PSTL2KEEP  | -                       |
| 10011 | PSTL2STRM  | -                       |
| 10100 | PSTL3KEEP  | -                       |
| 10101 | PSTL3STRM  | -                       |
| 10110 | PSTSLCKEEP | FEAT_PRFMSLC            |
| 10111 | PSTSLCSTRM | FEAT_PRFMSLC            |
| 11000 | IR         | FEAT_PCDPHINT           |

For other encodings of the 'Rt' field, use &lt;imm5&gt;.

## &lt;imm5&gt;

Is the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the 'Rt' field.

This syntax is only for encodings that are not accessible using &lt;prfop&gt; .

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;pimm&gt;

Is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/8.

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_PREFETCH, nontemporal, privileged, tagchecked, t); if n == 31 then
```

```
address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Prefetch(address, t<4:0>);
```

## C6.2.315 PRFM (literal)

## Prefetch memory (literal)

This instruction signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The address for data memory accesses is calculated from the PC value and an immediate offset. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as making the cache line containing the specified address available at the level of cache specified by the instruction.

The &lt;prfop&gt; operand specifies the prefetch hint as follows:

- Access type:
- PLD for prefetch for load.
- PLI for prefetch for execute.
- PST for prefetch for store.
- Target cache level:
- L1 for Level 1 cache.
- L2 for Level 2 cache.
- L3 for Level 3 cache.
- When FEAT\_PRFMSLC is implemented, SLC for system level cache.
- Policy:
- KEEP for retained or temporal prefetch, allocated in the cache normally.
- STRMfor streaming or non-temporal prefetch, for data that is used only once.

The effect of a PRFM instruction is IMPLEMENTATION DEFINED. For more information, see Prefetch memory.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
PRFM (<prfop>|#<imm5>), <label>
```

## Decode for this encoding

```
constant integer t = UInt(Rt); constant bits(64) offset = SignExtend(imm19:'00', 64);
```

## Assembler Symbols

## &lt;prfop&gt;

Is the prefetch operation, encoded in 'Rt':

|    Rt | <prfop>   | Architectural Feature   |
|-------|-----------|-------------------------|
| 00000 | PLDL1KEEP | -                       |
| 00001 | PLDL1STRM | -                       |
| 00010 | PLDL2KEEP | -                       |
| 00011 | PLDL2STRM | -                       |

|    Rt | <prfop>    | Architectural Feature   |
|-------|------------|-------------------------|
| 00100 | PLDL3KEEP  | -                       |
| 00101 | PLDL3STRM  | -                       |
| 00110 | PLDSLCKEEP | FEAT_PRFMSLC            |
| 00111 | PLDSLCSTRM | FEAT_PRFMSLC            |
| 01000 | PLIL1KEEP  | -                       |
| 01001 | PLIL1STRM  | -                       |
| 01010 | PLIL2KEEP  | -                       |
| 01011 | PLIL2STRM  | -                       |
| 01100 | PLIL3KEEP  | -                       |
| 01101 | PLIL3STRM  | -                       |
| 01110 | PLISLCKEEP | FEAT_PRFMSLC            |
| 01111 | PLISLCSTRM | FEAT_PRFMSLC            |
| 10000 | PSTL1KEEP  | -                       |
| 10001 | PSTL1STRM  | -                       |
| 10010 | PSTL2KEEP  | -                       |
| 10011 | PSTL2STRM  | -                       |
| 10100 | PSTL3KEEP  | -                       |
| 10101 | PSTL3STRM  | -                       |
| 10110 | PSTSLCKEEP | FEAT_PRFMSLC            |
| 10111 | PSTSLCSTRM | FEAT_PRFMSLC            |

For other encodings of the 'Rt' field, use &lt;imm5&gt;.

## &lt;imm5&gt;

Is the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the 'Rt' field.

This syntax is only for encodings that are not accessible using &lt;prfop&gt; .

## &lt;label&gt;

Is the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as 'imm19' times 4.

## Operation

```
constant bits(64) address = PC64 Prefetch(address, t<4:0>);
```

```
+ offset;
```

## C6.2.316 PRFM (register)

Prefetch memory (register)

This instruction signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The address for data memory accesses is calculated from a base register value and an offset register value. The offset register value can optionally be shifted and extended. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as making the cache line containing the specified address available at the level of cache specified by the instruction.

The &lt;prfop&gt; operand specifies the prefetch hint as follows:

- Access type:
- PLD for prefetch for load.
- PLI for prefetch for execute.
- PST for prefetch for store.
- Target cache level:
- L1 for Level 1 cache.
- L2 for Level 2 cache.
- L3 for Level 3 cache.
- When FEAT\_PRFMSLC is implemented, SLC for system level cache.
- Policy:
- KEEP for retained or temporal prefetch, allocated in the cache normally.
- STRMfor streaming or non-temporal prefetch, for data that is used only once.

The effect of a PRFM instruction is IMPLEMENTATION DEFINED. For more information, see Prefetch memory.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
PRFM (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]
```

## Decode for this encoding

```
if option<1> == '0' then EndOfDecode(Decode_UNDEF); // sub-word index constant ExtendType extend_type = DecodeRegExtend(option); constant integer shift = if S == '1' then 3 else 0; constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant integer m = UInt(Rm); constant boolean nontemporal = FALSE; constant boolean tagchecked = FALSE;
```

## Assembler Symbols

## &lt;prfop&gt;

Is the prefetch operation, encoded in 'Rt':

|    Rt | <prfop>    | Architectural Feature   |
|-------|------------|-------------------------|
| 00000 | PLDL1KEEP  | -                       |
| 00001 | PLDL1STRM  | -                       |
| 00010 | PLDL2KEEP  | -                       |
| 00011 | PLDL2STRM  | -                       |
| 00100 | PLDL3KEEP  | -                       |
| 00101 | PLDL3STRM  | -                       |
| 00110 | PLDSLCKEEP | FEAT_PRFMSLC            |
| 00111 | PLDSLCSTRM | FEAT_PRFMSLC            |
| 01000 | PLIL1KEEP  | -                       |
| 01001 | PLIL1STRM  | -                       |
| 01010 | PLIL2KEEP  | -                       |
| 01011 | PLIL2STRM  | -                       |
| 01100 | PLIL3KEEP  | -                       |
| 01101 | PLIL3STRM  | -                       |
| 01110 | PLISLCKEEP | FEAT_PRFMSLC            |
| 01111 | PLISLCSTRM | FEAT_PRFMSLC            |
| 10000 | PSTL1KEEP  | -                       |
| 10001 | PSTL1STRM  | -                       |
| 10010 | PSTL2KEEP  | -                       |
| 10011 | PSTL2STRM  | -                       |
| 10100 | PSTL3KEEP  | -                       |
| 10101 | PSTL3STRM  | -                       |
| 10110 | PSTSLCKEEP | FEAT_PRFMSLC            |
| 10111 | PSTSLCSTRM | FEAT_PRFMSLC            |

For other encodings of the 'Rt' field, use &lt;imm5&gt;.

## &lt;imm5&gt;

Is the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the 'Rt' field.

This syntax is only for encodings that are not accessible using &lt;prfop&gt; .

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

When option&lt;0&gt; is set to 0, is the 32-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;Xm&gt;

When option&lt;0&gt; is set to 1, is the 64-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;extend&gt;

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option when &lt;amount&gt; is omitted, encoded in 'option':

## &lt;amount&gt;

Is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #3         |

## Operation

```
bits(64) address; constant bits(64) offset = ExtendReg(m, extend_type, shift, 64); constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_PREFETCH, nontemporal, privileged, tagchecked, t); if n == 31 then address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Prefetch(address, t<4:0>);
```

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |
|      011 | LSL        |
|      110 | SXTW       |
|      111 | SXTX       |

## C6.2.317 PRFUM

Prefetch memory (unscaled offset)

This instruction signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as making the cache line containing the specified address available at the level of cache specified by the instruction.

The &lt;prfop&gt; operand specifies the prefetch hint as follows:

- Access type:
- PLD for prefetch for load.
- PLI for prefetch for execute.
- PST for prefetch for store.
- Target cache level:
- L1 for Level 1 cache.
- L2 for Level 2 cache.
- L3 for Level 3 cache.
- When FEAT\_PRFMSLC is implemented, SLC for system level cache.
- Policy:
- KEEP for retained or temporal prefetch, allocated in the cache normally.
- STRMfor streaming or non-temporal prefetch, for data that is used only once.

The effect of a PRFUM instruction is IMPLEMENTATION DEFINED. For more information, see Prefetch memory.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
PRFUM (<prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
= SignExtend(imm9, 64);
```

```
constant bits(64) offset constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant boolean nontemporal = FALSE; constant boolean tagchecked = FALSE;
```

## Assembler Symbols

## &lt;prfop&gt;

Is the prefetch operation, encoded in 'Rt':

|    Rt | <prfop>   | Architectural Feature   |
|-------|-----------|-------------------------|
| 00000 | PLDL1KEEP | -                       |
| 00001 | PLDL1STRM | -                       |
| 00010 | PLDL2KEEP | -                       |

|    Rt | <prfop>    | Architectural Feature   |
|-------|------------|-------------------------|
| 00011 | PLDL2STRM  | -                       |
| 00100 | PLDL3KEEP  | -                       |
| 00101 | PLDL3STRM  | -                       |
| 00110 | PLDSLCKEEP | FEAT_PRFMSLC            |
| 00111 | PLDSLCSTRM | FEAT_PRFMSLC            |
| 01000 | PLIL1KEEP  | -                       |
| 01001 | PLIL1STRM  | -                       |
| 01010 | PLIL2KEEP  | -                       |
| 01011 | PLIL2STRM  | -                       |
| 01100 | PLIL3KEEP  | -                       |
| 01101 | PLIL3STRM  | -                       |
| 01110 | PLISLCKEEP | FEAT_PRFMSLC            |
| 01111 | PLISLCSTRM | FEAT_PRFMSLC            |
| 10000 | PSTL1KEEP  | -                       |
| 10001 | PSTL1STRM  | -                       |
| 10010 | PSTL2KEEP  | -                       |
| 10011 | PSTL2STRM  | -                       |
| 10100 | PSTL3KEEP  | -                       |
| 10101 | PSTL3STRM  | -                       |
| 10110 | PSTSLCKEEP | FEAT_PRFMSLC            |
| 10111 | PSTSLCSTRM | FEAT_PRFMSLC            |

For other encodings of the 'Rt' field, use &lt;imm5&gt;.

## &lt;imm5&gt;

Is the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the 'Rt' field.

This syntax is only for encodings that are not accessible using &lt;prfop&gt; .

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_PREFETCH, nontemporal, privileged, tagchecked, t); if n == 31 then address = SP[64]; else address = X[n, 64];
```

address = AddressAdd(address, offset, accdesc); Prefetch(address, t&lt;4:0&gt;);

## C6.2.318 PSB

Profiling synchronization barrier

This instruction is a barrier that ensures that all existing profiling data for the current PE has been formatted, and profiling buffer addresses have been translated such that all writes to the profiling buffer have been initiated. A following DSB instruction completes when the writes to the profiling buffer have completed.

If FEAT\_SPE is not implemented, this instruction executes as a NOP .

## System

(FEAT\_SPE)

<!-- image -->

## Encoding

PSB CSYNC

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SPE) then EndOfDecode(Decode_NOP);
```

## Operation

```
if IsFeatureImplemented(FEAT_FGT) && IsFeatureImplemented(FEAT_SPEv1p5) then constant boolean trap_to_el2 = (PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && HFGITR_EL2.PSBCSYNC == '1'); if trap_to_el2 then ExceptionRecord except = ExceptionSyndrome(Exception_LDST64BTrap); // to be renamed except.syndrome.iss = \texttt{0x3}<24:0>; constant bits(64) preferred_exception_return = ThisInstrAddr(64); constant integer vect_offset = \texttt{0x0}; AArch64.TakeException(EL2, except, preferred_exception_return, vect_offset);
```

ProfilingSynchronizationBarrier();

## C6.2.319 PSSBB

Physical speculative store bypass barrier

This instruction is a memory barrier that prevents speculative loads from bypassing earlier stores to the same physical address under certain conditions. For more information and details of the semantics, see Physical Speculative Store Bypass Barrier (PSSBB).

This is an alias of DSB. This means:

- The encodings in this description are named to match the encodings of DSB.
- The description of DSB gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

| PSSBB            |
|------------------|
| is equivalent to |
| DSB #4           |

and is always the preferred disassembly.

## Operation

The description of DSB gives the operational pseudocode for this instruction.

## C6.2.320 RBIT

## Reverse bits

This instruction reverses the bit order in a register.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) RBIT <Wd>, <Wn>
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) RBIT <Xd>, <Xn>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 <<
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand = bits(datasize) result; for i = 0 to datasize-1 result<(datasize-1)-i> = operand<i>; X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
UInt(sf);
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

```
X[n, datasize];
```

## C6.2.321 RCWCAS, RCWCASA, RCWCASAL, RCWCASL

Read check write compare and swap doubleword in memory

This instruction reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the compare fails or the RCW Checks fail, the architecture permits writing the value read from the location to memory. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory.

- If the destination register is not XZR , RCWCASA and RCWCASAL load from memory with acquire semantics.
- RCWCASL and RCWCASAL store to memory with release semantics.
- RCWCAS has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_THE)

<!-- image -->

## Encoding for the RCWCAS variant

```
Applies when (A == 0 && R == 0) RCWCAS <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWCASA variant

```
Applies when (A == 1 && R == 0) RCWCASA <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWCASAL variant

```
Applies when (A == 1 && R == 1) RCWCASAL <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWCASL variant

```
Applies when
```

```
RCWCASL
```

```
(A == 0 && R == 1) <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean soft = FALSE; constant boolean acquire = A == '1' && t != 31; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register to be compared and loaded, encoded in the 'Rs' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be conditionally stored, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; constant bits(64) newdata = X[t, 64]; constant bits(64) compdata = X[s, 64]; bits(64) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_CAS, soft, acquire, release, tagchecked, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; X[s, 64] = readdata; // Return the old value when s!=31
```

## C6.2.322 RCWCASP, RCWCASPA, RCWCASPAL, RCWCASPL

Read check write compare and swap quadword in memory

This instruction reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the compare fails or the RCW Checks fail, the architecture permits writing the value read from the location to memory. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory.

- RCWCASPA and RCWCASPAL load from memory with acquire semantics.
- RCWCASPL and RCWCASPAL store to memory with release semantics.
- RCWCASP has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_D128 &amp;&amp; FEAT\_THE)

<!-- image -->

## Encoding for the RCWCASP variant

```
Applies when (A == 0 && R == 0) RCWCASP <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>]
```

## Encoding for the RCWCASPA variant

```
Applies when (A == 1 && R == 0) RCWCASPA <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>]
```

## Encoding for the RCWCASPAL variant

```
Applies when (A == 1 && R == 1) RCWCASPAL <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>]
```

## Encoding for the RCWCASPL variant

```
Applies when (A == 0 && R == 1) RCWCASPL <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_D128) || !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); if Rs<0> == '1' then EndOfDecode(Decode_UNDEF); if Rt<0> == '1' then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean soft = FALSE; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Xs&gt;

Is the 64-bit name of the first general-purpose register to be compared and loaded, encoded in the 'Rs' field. &lt;Xs&gt; must be an even-numbered register.

## &lt;X(s+1)&gt;

Is the 64-bit name of the second general-purpose register to be compared and loaded.

## &lt;Xt&gt;

Is the 64-bit name of the first general-purpose register to be conditionally stored, encoded in the 'Rt' field. &lt;Xt&gt; must be an even-numbered register.

## &lt;X(t+1)&gt;

Is the 64-bit name of the second general-purpose register to be conditionally stored.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if !IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; bits(128) newdata; bits(128) compdata; bits(128) readdata; bits(4) nzcv; constant bits(64) s1 = X[s, 64]; constant bits(64) s2 = X[s+1, 64]; constant bits(64) t1 = X[t, 64]; constant bits(64) t2 = X[t+1, 64]; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_CAS, soft, acquire, release, tagchecked, t, t+1, s, s+1); compdata = if BigEndian(accdesc.acctype) then s1:s2 else s2:s1; newdata = if BigEndian(accdesc.acctype) then t1:t2 else t2:t1; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
```

```
PSTATE.<N,Z,C,V> = nzcv; if BigEndian(accdesc.acctype) then X[s, 64] = readdata<127:64>; X[s+1, 64] = readdata<63:0>; else X[s, 64] = readdata<63:0>; X[s+1, 64] = readdata<127:64>;
```

## C6.2.323 RCWCLR, RCWCLRA, RCWCLRAL, RCWCLRL

Read check write atomic bit clear on doubleword in memory

This instruction atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory.

- If the destination register is not XZR , RCWCLRA and RCWCLRAL load from memory with acquire semantics.
- RCWCLRL and RCWCLRAL store to memory with release semantics.
- RCWCLR has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_THE)

<!-- image -->

## Encoding for the RCWCLR variant

Applies when

(A == 0

RCWCLR

&amp;&amp;

R

==

0)

&lt;Xs&gt;, &lt;Xt&gt;, [&lt;Xn|SP&gt;]

## Encoding for the RCWCLRA variant

```
Applies when (A == 1 && R == 0) RCWCLRA <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWCLRAL variant

```
Applies when (A == 1 && R == 1) RCWCLRAL <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWCLRL variant

```
Applies when (A == 0 && R == 1) RCWCLRL <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean soft = FALSE; constant boolean acquire = A == '1' && t != 31; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register to be stored, encoded in the 'Rs' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; constant bits(64) newdata = X[s, 64]; bits(64) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_BIC, soft, acquire, release, tagchecked, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(64) compdata = bits(64) UNKNOWN; // Irrelevant when not executing CAS (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; X[t, 64] = readdata; // Return the old value when t!=31
```

## C6.2.324 RCWCLRP, RCWCLRPA, RCWCLRPAL, RCWCLRPL

Read check write atomic bit clear on quadword in memory

This instruction atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory.

- RCWCLRPA and RCWCLRPAL load from memory with acquire semantics.
- RCWCLRPL and RCWCLRPAL store to memory with release semantics.
- RCWCLRP has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_D128 &amp;&amp; FEAT\_THE)

<!-- image -->

## Encoding for the RCWCLRP variant

0)

```
Applies when (A == 0 && R == RCWCLRP <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWCLRPA variant

0)

```
Applies when (A == 1 && R == RCWCLRPA <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWCLRPAL variant

```
Applies when (A == 1 && R == 1) RCWCLRPAL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWCLRPL variant

1)

```
Applies when (A == 0 && R == RCWCLRPL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_D128) || !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); if Rt == '11111' then EndOfDecode(Decode_UNDEF); if Rt2 == '11111' then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean soft = FALSE; constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LSE128OVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly CONSTRAINED UNPREDICTABLE behavior for A64 instructions.

## Assembler Symbols

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if !IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; bits(64) value1; bits(64) value2; bits(128) newdata; bits(128) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_BIC, soft, acquire, release, tagchecked, t, t2, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; value1 = X[t, 64]; value2 = X[t2, 64]; newdata = if BigEndian(accdesc.acctype) then value1:value2 else value2:value1; constant bits(128) compdata = bits(128) UNKNOWN; // Irrelevant when not executing CAS
```

```
(nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; if rt_unknown then readdata = bits(128) UNKNOWN; if BigEndian(accdesc.acctype) then X[t, 64] = readdata<127:64>; X[t2, 64] = readdata<63:0>; else X[t, 64] = readdata<63:0>; X[t2, 64] = readdata<127:64>;
```

## C6.2.325 RCWSCAS, RCWSCASA, RCWSCASAL, RCWSCASL

Read check write software compare and swap doubleword in memory

This instruction reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the compare fails, the RCW Checks fail, or the RCWS Checks fail, the architecture permits writing the value read from the location to memory. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory.

- If the destination register is not XZR , RCWSCASA and RCWSCASAL load from memory with acquire semantics.
- RCWSCASL and RCWSCASAL store to memory with release semantics.
- RCWSCAS has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_THE)

<!-- image -->

## Encoding for the RCWSCAS variant

```
Applies when (A == 0 && R == 0) RCWSCAS <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSCASA variant

```
Applies when (A == 1 && R == 0) RCWSCASA <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSCASAL variant

```
Applies when (A == 1 && R == 1) RCWSCASAL <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSCASL variant

```
Applies when
```

```
RCWSCASL
```

```
(A == 0 && R == 1) <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean soft = TRUE; constant boolean acquire = A == '1' && t != 31; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register to be compared and loaded, encoded in the 'Rs' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be conditionally stored, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; constant bits(64) newdata = X[t, 64]; constant bits(64) compdata = X[s, 64]; bits(64) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_CAS, soft, acquire, release, tagchecked, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; X[s, 64] = readdata; // Return the old value when s!=31
```

## C6.2.326 RCWSCASP, RCWSCASPA, RCWSCASPAL, RCWSCASPL

Read check write software compare and swap quadword in memory

This instruction reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the compare fails, the RCW Checks fail, or the RCWS Checks fail, the architecture permits writing the value read from the location to memory. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory.

- RCWSCASPA and RCWSCASPAL load from memory with acquire semantics.
- RCWSCASPL and RCWSCASPAL store to memory with release semantics.
- RCWSCASP has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_D128 &amp;&amp; FEAT\_THE)

<!-- image -->

## Encoding for the RCWSCASP variant

```
Applies when (A == 0 && R == 0) RCWSCASP
```

```
<Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>]
```

## Encoding for the RCWSCASPA variant

```
Applies when (A == 1 && R == 0) RCWSCASPA <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>]
```

## Encoding for the RCWSCASPAL variant

```
Applies when (A == 1 && R == 1) RCWSCASPAL <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>]
```

## Encoding for the RCWSCASPL variant

```
Applies when (A == 0 && R == 1)
```

```
RCWSCASPL <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_D128) || !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); if Rs<0> == '1' then EndOfDecode(Decode_UNDEF); if Rt<0> == '1' then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean soft = TRUE; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Xs&gt;

Is the 64-bit name of the first general-purpose register to be compared and loaded, encoded in the 'Rs' field. &lt;Xs&gt; must be an even-numbered register.

## &lt;X(s+1)&gt;

Is the 64-bit name of the second general-purpose register to be compared and loaded.

## &lt;Xt&gt;

Is the 64-bit name of the first general-purpose register to be conditionally stored, encoded in the 'Rt' field. &lt;Xt&gt; must be an even-numbered register.

## &lt;X(t+1)&gt;

Is the 64-bit name of the second general-purpose register to be conditionally stored.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if !IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; bits(128) newdata; bits(128) compdata; bits(128) readdata; bits(4) nzcv; constant bits(64) s1 = X[s, 64]; constant bits(64) s2 = X[s+1, 64]; constant bits(64) t1 = X[t, 64]; constant bits(64) t2 = X[t+1, 64]; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_CAS, soft, acquire, release, tagchecked, t, t+1, s, s+1); compdata = if BigEndian(accdesc.acctype) then s1:s2 else s2:s1; newdata = if BigEndian(accdesc.acctype) then t1:t2 else t2:t1; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
```

```
PSTATE.<N,Z,C,V> = nzcv; if BigEndian(accdesc.acctype) then X[s, 64] = readdata<127:64>; X[s+1, 64] = readdata<63:0>; else X[s, 64] = readdata<63:0>; X[s+1, 64] = readdata<127:64>;
```

## C6.2.327 RCWSCLR, RCWSCLRA, RCWSCLRAL, RCWSCLRL

Read check write software atomic bit clear on doubleword in memory

This instruction atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory.

- If the destination register is not XZR , RCWSCLRA and RCWSCLRAL load from memory with acquire semantics.
- RCWSCLRL and RCWSCLRAL store to memory with release semantics.
- RCWSCLR has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_THE)

<!-- image -->

## Encoding for the RCWSCLR variant

Applies when

(A == 0

RCWSCLR

&amp;&amp;

R

==

0)

&lt;Xs&gt;, &lt;Xt&gt;, [&lt;Xn|SP&gt;]

## Encoding for the RCWSCLRA variant

```
Applies when (A == 1 && R == 0) RCWSCLRA <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSCLRAL variant

```
1)
```

```
Applies when (A == 1 && R == RCWSCLRAL <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSCLRL variant

```
Applies when (A == 0 && R == 1) RCWSCLRL <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean soft = TRUE; constant boolean acquire = A == '1' && t != 31; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register to be stored, encoded in the 'Rs' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; constant bits(64) newdata = X[s, 64]; bits(64) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_BIC, soft, acquire, release, tagchecked, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(64) compdata = bits(64) UNKNOWN; // Irrelevant when not executing CAS (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; X[t, 64] = readdata; // Return the old value when t!=31
```

## C6.2.328 RCWSCLRP, RCWSCLRPA, RCWSCLRPAL, RCWSCLRPL

Read check write software atomic bit clear on quadword in memory

This instruction atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory.

- RCWSCLRPA and RCWSCLRPAL load from memory with acquire semantics.
- RCWSCLRPL and RCWSCLRPAL store to memory with release semantics.
- RCWSCLRP has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_D128 &amp;&amp; FEAT\_THE)

<!-- image -->

## Encoding for the RCWSCLRP variant

```
Applies when (A == 0 && R == 0) RCWSCLRP <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSCLRPA variant

```
Applies when (A == 1 && R == 0) RCWSCLRPA <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSCLRPAL variant

```
Applies when (A == 1 && R == 1) RCWSCLRPAL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSCLRPL variant

```
Applies when (A == 0 && R == 1) RCWSCLRPL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_D128) || !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); if Rt == '11111' then EndOfDecode(Decode_UNDEF); if Rt2 == '11111' then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean soft = TRUE; constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LSE128OVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly CONSTRAINED UNPREDICTABLE behavior for A64 instructions.

## Assembler Symbols

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if !IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; bits(64) value1; bits(64) value2; bits(128) newdata; bits(128) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_BIC, soft, acquire, release, tagchecked, t, t2, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; value1 = X[t, 64]; value2 = X[t2, 64]; newdata = if BigEndian(accdesc.acctype) then value1:value2 else value2:value1; constant bits(128) compdata = bits(128) UNKNOWN; // Irrelevant when not executing CAS
```

```
(nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; if rt_unknown then readdata = bits(128) UNKNOWN; if BigEndian(accdesc.acctype) then X[t, 64] = readdata<127:64>; X[t2, 64] = readdata<63:0>; else X[t, 64] = readdata<63:0>; X[t2, 64] = readdata<127:64>;
```

## C6.2.329 RCWSET, RCWSETA, RCWSETAL, RCWSETL

Read check write atomic bit set on doubleword in memory

This instruction atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory.

- If the destination register is not XZR , RCWSETA and RCWSETAL load from memory with acquire semantics.
- RCWSETL and RCWSETAL store to memory with release semantics.
- RCWSET has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_THE)

<!-- image -->

## Encoding for the RCWSET variant

Applies when

(A == 0

RCWSET

&amp;&amp;

R

==

0)

&lt;Xs&gt;, &lt;Xt&gt;, [&lt;Xn|SP&gt;]

## Encoding for the RCWSETA variant

```
Applies when (A == 1 && R == 0) RCWSETA <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSETAL variant

```
Applies when (A == 1 && R == 1) RCWSETAL <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSETL variant

```
Applies when (A == 0 && R == 1) RCWSETL <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean soft = FALSE; constant boolean acquire = A == '1' && t != 31; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register to be stored, encoded in the 'Rs' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; constant bits(64) newdata = X[s, 64]; bits(64) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_ORR, soft, acquire, release, tagchecked, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(64) compdata = bits(64) UNKNOWN; // Irrelevant when not executing CAS (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; X[t, 64] = readdata; // Return the old value when t!=31
```

## C6.2.330 RCWSETP, RCWSETPA, RCWSETPAL, RCWSETPL

Read check write atomic bit set on quadword in memory

This instruction atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory.

- RCWSETPA and RCWSETPAL load from memory with acquire semantics.
- RCWSETPL and RCWSETPAL store to memory with release semantics.
- RCWSETP has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_D128 &amp;&amp; FEAT\_THE)

<!-- image -->

## Encoding for the RCWSETP variant

0)

```
Applies when (A == 0 && R == RCWSETP <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSETPA variant

0)

```
Applies when (A == 1 && R == RCWSETPA <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSETPAL variant

```
Applies when (A == 1 && R == 1) RCWSETPAL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSETPL variant

Applies when (A == 0 &amp;&amp; R == 1)

```
RCWSETPL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_D128) || !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); if Rt == '11111' then EndOfDecode(Decode_UNDEF); if Rt2 == '11111' then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean soft = FALSE; constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LSE128OVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly CONSTRAINED UNPREDICTABLE behavior for A64 instructions.

## Assembler Symbols

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if !IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; bits(64) value1; bits(64) value2; bits(128) newdata; bits(128) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_ORR, soft, acquire, release, tagchecked, t, t2, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; value1 = X[t, 64]; value2 = X[t2, 64]; newdata = if BigEndian(accdesc.acctype) then value1:value2 else value2:value1; constant bits(128) compdata = bits(128) UNKNOWN; // Irrelevant when not executing CAS
```

```
(nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; if rt_unknown then readdata = bits(128) UNKNOWN; if BigEndian(accdesc.acctype) then X[t, 64] = readdata<127:64>; X[t2, 64] = readdata<63:0>; else X[t, 64] = readdata<63:0>; X[t2, 64] = readdata<127:64>;
```

## C6.2.331 RCWSSET, RCWSSETA, RCWSSETAL, RCWSSETL

Read check write software atomic bit set on doubleword in memory

This instruction atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory.

- If the destination register is not XZR , RCWSSETA and RCWSSETAL load from memory with acquire semantics.
- RCWSSETL and RCWSSETAL store to memory with release semantics.
- RCWSSET has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_THE)

<!-- image -->

## Encoding for the RCWSSET variant

```
Applies when (A == 0 && R == 0)
```

```
RCWSSET <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSSETA variant

```
Applies when (A == 1 && R == 0) RCWSSETA <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSSETAL variant

```
1)
```

```
Applies when (A == 1 && R == RCWSSETAL <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSSETL variant

```
Applies when (A == 0 && R == 1) RCWSSETL <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean soft = TRUE; constant boolean acquire = A == '1' && t != 31; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register to be stored, encoded in the 'Rs' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; constant bits(64) newdata = X[s, 64]; bits(64) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_ORR, soft, acquire, release, tagchecked, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(64) compdata = bits(64) UNKNOWN; // Irrelevant when not executing CAS (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; X[t, 64] = readdata; // Return the old value when t!=31
```

## C6.2.332 RCWSSETP, RCWSSETPA, RCWSSETPAL, RCWSSETPL

Read check write software atomic bit set on quadword in memory

This instruction atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory.

- RCWSSETPA and RCWSSETPAL load from memory with acquire semantics.
- RCWSSETPL and RCWSSETPAL store to memory with release semantics.
- RCWSSETP has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_D128 &amp;&amp; FEAT\_THE)

<!-- image -->

## Encoding for the RCWSSETP variant

0)

```
Applies when (A == 0 && R == RCWSSETP <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSSETPA variant

```
Applies when (A == 1 && R == 0) RCWSSETPA <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSSETPAL variant

```
Applies when (A == 1 && R == 1) RCWSSETPAL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSSETPL variant

```
Applies when (A == 0 && R == 1) RCWSSETPL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_D128) || !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); if Rt == '11111' then EndOfDecode(Decode_UNDEF); if Rt2 == '11111' then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean soft = TRUE; constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LSE128OVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly CONSTRAINED UNPREDICTABLE behavior for A64 instructions.

## Assembler Symbols

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if !IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; bits(64) value1; bits(64) value2; bits(128) newdata; bits(128) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_ORR, soft, acquire, release, tagchecked, t, t2, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; value1 = X[t, 64]; value2 = X[t2, 64]; newdata = if BigEndian(accdesc.acctype) then value1:value2 else value2:value1; constant bits(128) compdata = bits(128) UNKNOWN; // Irrelevant when not executing CAS
```

```
(nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; if rt_unknown then readdata = bits(128) UNKNOWN; if BigEndian(accdesc.acctype) then X[t, 64] = readdata<127:64>; X[t2, 64] = readdata<63:0>; else X[t, 64] = readdata<63:0>; X[t2, 64] = readdata<127:64>;
```

## C6.2.333 RCWSSWP, RCWSSWPA, RCWSSWPAL, RCWSSWPL

Read check write software swap doubleword in memory

This instruction atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory.

- If the destination register is not XZR , RCWSSWPA and RCWSSWPAL load from memory with acquire semantics.
- RCWSSWPL and RCWSSWPAL store to memory with release semantics.
- RCWSSWP has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_THE)

<!-- image -->

## Encoding for the RCWSSWP variant

Applies when

(A == 0

RCWSSWP

&amp;&amp;

R

==

0)

&lt;Xs&gt;, &lt;Xt&gt;, [&lt;Xn|SP&gt;]

## Encoding for the RCWSSWPA variant

```
Applies when (A == 1 && R == 0) RCWSSWPA <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSSWPAL variant

```
1)
```

```
Applies when (A == 1 && R == RCWSSWPAL <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSSWPL variant

```
Applies when (A == 0 && R == 1) RCWSSWPL <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean soft = TRUE; constant boolean acquire = A == '1' && t != 31; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register to be stored, encoded in the 'Rs' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; constant bits(64) newdata = X[s, 64]; bits(64) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_SWP, soft, acquire, release, tagchecked, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(64) compdata = bits(64) UNKNOWN; // Irrelevant when not executing CAS (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; X[t, 64] = readdata; // Return the old value when t!=31
```

## C6.2.334 RCWSSWPP, RCWSSWPPA, RCWSSWPPAL, RCWSSWPPL

Read check write software swap quadword in memory

This instruction atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWSChecks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory.

- RCWSSWPPA and RCWSSWPPAL load from memory with acquire semantics.
- RCWSSWPPL and RCWSSWPPAL store to memory with release semantics.
- RCWSSWPP has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_D128 &amp;&amp; FEAT\_THE)

<!-- image -->

## Encoding for the RCWSSWPP variant

```
Applies when (A == 0 && R == 0) RCWSSWPP <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSSWPPA variant

```
Applies when (A == 1 && R == 0) RCWSSWPPA <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSSWPPAL variant

```
Applies when (A == 1 && R == 1) RCWSSWPPAL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSSWPPL variant

Applies when

```
(A == 0 && R == 1) RCWSSWPPL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_D128) || !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); if Rt == '11111' then EndOfDecode(Decode_UNDEF); if Rt2 == '11111' then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean soft = TRUE; constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LSE128OVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly CONSTRAINED UNPREDICTABLE behavior for A64 instructions.

## Assembler Symbols

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if !IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; bits(64) value1; bits(64) value2; bits(128) newdata; bits(128) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_SWP, soft, acquire, release, tagchecked, t, t2, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; value1 = X[t, 64]; value2 = X[t2, 64]; newdata = if BigEndian(accdesc.acctype) then value1:value2 else value2:value1; constant bits(128) compdata = bits(128) UNKNOWN; // Irrelevant when not executing CAS
```

```
(nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; if rt_unknown then readdata = bits(128) UNKNOWN; if BigEndian(accdesc.acctype) then X[t, 64] = readdata<127:64>; X[t2, 64] = readdata<63:0>; else X[t, 64] = readdata<63:0>; X[t2, 64] = readdata<127:64>;
```

## C6.2.335 RCWSWP, RCWSWPA, RCWSWPAL, RCWSWPL

Read check write swap doubleword in memory

This instruction atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory.

- If the destination register is not XZR , RCWSWPA and RCWSWPAL load from memory with acquire semantics.
- RCWSWPL and RCWSWPAL store to memory with release semantics.
- RCWSWP has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_THE)

<!-- image -->

## Encoding for the RCWSWP variant

Applies when

(A == 0

RCWSWP

&amp;&amp;

R

==

0)

&lt;Xs&gt;, &lt;Xt&gt;, [&lt;Xn|SP&gt;]

## Encoding for the RCWSWPA variant

```
Applies when (A == 1 && R == 0) RCWSWPA <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSWPAL variant

```
Applies when (A == 1 && R == 1) RCWSWPAL <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the RCWSWPL variant

```
Applies when (A == 0 && R == 1) RCWSWPL <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean soft = FALSE; constant boolean acquire = A == '1' && t != 31; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register to be stored, encoded in the 'Rs' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; constant bits(64) newdata = X[s, 64]; bits(64) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_SWP, soft, acquire, release, tagchecked, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(64) compdata = bits(64) UNKNOWN; // Irrelevant when not executing CAS (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; X[t, 64] = readdata; // Return the old value when t!=31
```

## C6.2.336 RCWSWPP, RCWSWPPA, RCWSWPPAL, RCWSWPPL

Read check write swap quadword in memory

This instruction atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory.

- RCWSWPPA and RCWSWPPAL load from memory with acquire semantics.
- RCWSWPPL and RCWSWPPAL store to memory with release semantics.
- RCWSWPP has neither acquire nor release semantics.

## Note

This instruction is for performing atomic updates of translation table entries and not for general use.

## Integer

(FEAT\_D128 &amp;&amp; FEAT\_THE)

<!-- image -->

## Encoding for the RCWSWPP variant

```
Applies when (A == 0 && R == 0) RCWSWPP <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSWPPA variant

```
Applies when (A == 1 && R == 0) RCWSWPPA <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSWPPAL variant

```
Applies when (A == 1 && R == 1) RCWSWPPAL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the RCWSWPPL variant

1)

```
Applies when (A == 0 && R == RCWSWPPL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_D128) || !IsFeatureImplemented(FEAT_THE) then EndOfDecode(Decode_UNDEF); if Rt == '11111' then EndOfDecode(Decode_UNDEF); if Rt2 == '11111' then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean soft = FALSE; constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then constant Constraint c = ConstrainUnpredictable(Unpredictable_LSE128OVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly CONSTRAINED UNPREDICTABLE behavior for A64 instructions.

## Assembler Symbols

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if !IsD128Enabled(PSTATE.EL) then UNDEFINED; bits(64) address; bits(64) value1; bits(64) value2; bits(128) newdata; bits(128) readdata; bits(4) nzcv; constant AccessDescriptor accdesc = CreateAccDescRCW(MemAtomicOp_SWP, soft, acquire, release, tagchecked, t, t2, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; value1 = X[t, 64]; value2 = X[t2, 64]; newdata = if BigEndian(accdesc.acctype) then value1:value2 else value2:value1; constant bits(128) compdata = bits(128) UNKNOWN; // Irrelevant when not executing CAS
```

```
(nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc); PSTATE.<N,Z,C,V> = nzcv; if rt_unknown then readdata = bits(128) UNKNOWN; if BigEndian(accdesc.acctype) then X[t, 64] = readdata<127:64>; X[t2, 64] = readdata<63:0>; else X[t, 64] = readdata<63:0>; X[t2, 64] = readdata<127:64>;
```

## C6.2.337 RET

Return from subroutine

This instruction branches unconditionally to an address in a register. This instruction provides a hint that this is a subroutine return.

<!-- image -->

## Encoding

<!-- image -->

## Decode for this encoding

```
constant integer n = UInt(Rn);
```

## Assembler Symbols

<!-- image -->

Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the 'Rn' field. Defaults to X30 if absent.

## Operation

```
bits(64) target = X[n, 64]; if IsFeatureImplemented(FEAT_GCS) && GCSPCREnabled(PSTATE.EL) then target = LoadCheckGCSRecord(target, GCSInstType_PRET); SetCurrentGCSPointer(GetCurrentGCSPointer() + 8); // Value in BTypeNext will be used to set PSTATE.BTYPE BTypeNext = '00'; constant boolean branch_conditional = FALSE; BranchTo(target, BranchType_RET, branch_conditional);
```

## C6.2.338 RETAA, RETAB

Return from subroutine, with pointer authentication

This instruction authenticates the address that is held in LR, using SP as the modifier and the specified key, and branches to the authenticated address.

Key A is used for RETAA . Key B is used for RETAB .

If the authentication passes, the PE continues execution at the target of the branch. For information on behavior if the authentication fails, see Faulting on pointer authentication.

The authenticated address is not written back to LR.

This instruction provides a hint that this is a subroutine return.

If FEAT\_PAuth\_LR is implemented and PSTATE.PACM is 1, then RETAA and RETAB include a second modifier that is in X16.

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding for the RETAA variant

```
Applies when (M == 0)
```

RETAA

## Encoding for the RETAB variant

```
Applies when (M == 1)
```

RETAB

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then constant boolean use_key_a = (M == '0'); constant boolean auth_then_branch = TRUE;
```

## Operation

```
GCSInstruction inst_type; bits(64) target = X[30, 64]; constant bits(64) modifier = SP[64]; bits(64) modifier2; boolean use_modifier2 = FALSE; if IsFeatureImplemented(FEAT_PAuth_LR) && PSTATE.PACM == '1' then modifier2 = X[16, 64]; use_modifier2 = TRUE; if use_key_a then if use_modifier2 && IsFeatureImplemented(FEAT_PAuth_LR) then target = AuthIA2(target, modifier, modifier2, auth_then_branch); else
```

```
EndOfDecode(Decode_UNDEF);
```

```
target = AuthIA(target, modifier, auth_then_branch); else if use_modifier2 && IsFeatureImplemented(FEAT_PAuth_LR) then target = AuthIB2(target, modifier, modifier2, auth_then_branch); else target = AuthIB(target, modifier, auth_then_branch); if IsFeatureImplemented(FEAT_GCS) && GCSPCREnabled(PSTATE.EL) then inst_type = if use_key_a then GCSInstType_PRETAA else GCSInstType_PRETAB; target = LoadCheckGCSRecord(target, inst_type); SetCurrentGCSPointer(GetCurrentGCSPointer() + 8); // Value in BTypeNext will be used to set PSTATE.BTYPE BTypeNext = '00'; constant boolean branch_conditional = FALSE; BranchTo(target, BranchType_RET, branch_conditional);
```

## C6.2.339 RETAASPPC, RETABSPPC

Return from subroutine, with enhanced pointer authentication using an immediate offset

This instruction authenticates the address that is held in LR, using SP as the first modifier, the specified immediate subtracted from PC as the second modifier, and the specified key, and branches to the authenticated address.

Key A is used for RETAASPPC . Key B is used for RETABSPPC .

If the authentication passes, the PE continues execution at the target of the branch. For information on behavior if the authentication fails, see Faulting on pointer authentication.

The authenticated address is not written back to LR.

This instruction provides a hint that this is a subroutine return.

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding for the RETAASPPC variant

```
Applies when (opc == 000)
```

```
RETAASPPC <label>
```

## Encoding for the RETABSPPC variant

```
Applies when (opc == 001) RETABSPPC <label>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth_LR) then EndOfDecode(Decode_UNDEF);
```

```
constant boolean use_key_a = opc<0> == '0'; constant bits(64) offset = ZeroExtend(imm16:'00', 64); constant boolean auth_then_branch = TRUE;
```

## Assembler Symbols

## &lt;label&gt;

Is the program label whose address is to be calculated. Its negative offset from the address of this instruction, a multiple of 4 in the range -262140 to 0, is encoded as an unsigned value in the 'imm16' field as &lt;label&gt;/4.

## Operation

```
GCSInstruction inst_type; bits(64) target = X[30, 64]; constant bits(64) modifier = SP[64]; constant bits(64) modifier2 = PC64 -offset; if use_key_a then target =
```

```
AuthIA2(target, modifier, modifier2, auth_then_branch); else
```

```
target = AuthIB2(target, modifier, modifier2, auth_then_branch); if IsFeatureImplemented(FEAT_GCS) && GCSPCREnabled(PSTATE.EL) then inst_type = if use_key_a then GCSInstType_PRETAA else GCSInstType_PRETAB; target = LoadCheckGCSRecord(target, inst_type); SetCurrentGCSPointer(GetCurrentGCSPointer() + 8); // Value in BTypeNext will be used to set PSTATE.BTYPE BTypeNext = '00'; constant boolean branch_conditional = FALSE; BranchTo(target, BranchType_RET, branch_conditional);
```

## C6.2.340 RETAASPPCR, RETABSPPCR

Return from subroutine, with enhanced pointer authentication using a register

This instruction authenticates the address that is held in LR, using SP as the first modifier, the value in the specified register as the second modifier, and the specified key, and branches to the authenticated address.

Key A is used for RETAASPPCR . Key B is used for RETABSPPCR .

If the authentication passes, the PE continues execution at the target of the branch. For information on behavior if the authentication fails, see Faulting on pointer authentication.

The authenticated address is not written back to LR.

This instruction provides a hint that this is a subroutine return.

## Integer

(FEAT\_PAuth\_LR)

<!-- image -->

## Encoding for the RETAASPPCR variant

```
(M == 0)
```

```
Applies when RETAASPPCR <Xm>
```

## Encoding for the RETABSPPCR variant

```
(M == 1)
```

```
Applies when RETABSPPCR <Xm>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth_LR) then EndOfDecode(Decode_UNDEF); constant integer m = UInt(Rm); constant boolean use_key_a = M == '0'; constant boolean auth_then_branch = TRUE;
```

## Assembler Symbols

&lt;Xm&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rm' field.

## Operation

```
GCSInstruction inst_type; bits(64) target = X[30, 64]; constant bits(64) modifier = SP[64]; constant bits(64) modifier2 = X[m, 64]; if use_key_a then target = AuthIA2(target, modifier, modifier2, auth_then_branch); else target = AuthIB2(target, modifier, modifier2, auth_then_branch);
```

```
if IsFeatureImplemented(FEAT_GCS) && GCSPCREnabled(PSTATE.EL) then inst_type = if use_key_a then GCSInstType_PRETAA else GCSInstType_PRETAB; target = LoadCheckGCSRecord(target, inst_type); SetCurrentGCSPointer(GetCurrentGCSPointer() + 8); // Value in BTypeNext will be used to set PSTATE.BTYPE BTypeNext = '00'; constant boolean branch_conditional = FALSE; BranchTo(target, BranchType_RET, branch_conditional);
```

## C6.2.341 REV

## Reverse bytes

This instruction reverses the byte order in a register.

This instruction is used by the pseudo-instruction REV64.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0 && opc == 10)
```

```
REV <Wd>, <Wn>
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1 && opc == 11)
```

```
REV <Xd>, <Xn>
```

## Decode for all variants of this encoding

```
'0' then EndOfDecode(Decode_UNDEF);
```

```
if opc == '11' && sf == constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant integer container_size = 8 << UInt(opc);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand = X[n, datasize]; bits(datasize) result; constant integer containers = datasize DIV container_size; for c = 0 to containers-1 constant bits(container_size) container = Elem[operand, c, container_size]; Elem[result, c, container_size] = Reverse(container, 8); X[d, datasize] = result;
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.342 REV16

Reverse bytes in 16-bit halfwords

This instruction reverses the byte order in each 16-bit halfword of a register.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) REV16 <Wd>, <Wn>
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) REV16 <Xd>, <Xn>
```

## Decode for all variants of this encoding

```
'0' then EndOfDecode(Decode_UNDEF);
```

```
if opc == '11' && sf == constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant integer container_size = 8 << UInt(opc);
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand = X[n, datasize]; bits(datasize) result; constant integer containers = datasize DIV container_size; for c = 0 to containers-1 constant bits(container_size) container = Elem[operand, c, container_size]; Elem[result, c, container_size] = Reverse(container, 8); X[d, datasize] = result;
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.343 REV32

Reverse bytes in 32-bit words

This instruction reverses the byte order in each 32-bit word of a register.

<!-- image -->

## Encoding

```
REV32 <Xd>, <Xn>
```

## Decode for this encoding

```
'0' then EndOfDecode(Decode_UNDEF);
```

```
if opc == '11' && sf == constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant integer container_size = 8 << UInt(opc);
```

## Assembler Symbols

&lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

&lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand = X[n, datasize]; bits(datasize) result; constant integer containers = datasize DIV container_size; for c = 0 to containers-1 constant bits(container_size) container = Elem[operand, c, container_size]; Elem[result, c, container_size] = Reverse(container, 8); X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.344 REV64

## Reverse bytes

This instruction reverses the byte order in a 64-bit general-purpose register.

When assembling for Armv8.2, an assembler must support this pseudo-instruction. It is OPTIONAL whether an assembler supports this pseudo-instruction when assembling for an architecture earlier than Armv8.2.

This is a pseudo-instruction of REV. This means:

- The encodings in this description are named to match the encodings of REV.
- The assembler syntax is used only for assembly, and is not used on disassembly.
- The description of REV gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

REV64

&lt;Xd&gt;,

&lt;Xn&gt;

## is equivalent to

REV

&lt;Xd&gt;, &lt;Xn&gt;

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

The description of REV gives the operational pseudocode for this instruction.

## Operational Information

The description of REV gives the operational information for this instruction.

## C6.2.345 RMIF

Rotate, mask insert flags

This instruction performs a rotation right of a value held in a general-purpose register by an immediate value, and then inserts a selection of the bottom four bits of the result of the rotation into the PSTATE flags, under the control of a second immediate mask.

## Integer

(FEAT\_FlagM)

<!-- image -->

## Encoding

```
RMIF <Xn>, #<shift>, #<mask>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_FlagM) then EndOfDecode(Decode_UNDEF); constant integer imm = UInt(imm6); constant bits(4) flagmask = mask; constant integer n = UInt(Rn);
```

## Assembler Symbols

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;shift&gt;

Is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;mask&gt;

Is the flag bit mask, an immediate in the range 0 to 15, which selects the bits that are inserted into the NZCV condition flags, encoded in the 'mask' field.

## Operation

```
constant bits(64) reg = X[n, 64]; constant bits(4) flags = (reg:reg)<imm+3:imm>; if flagmask<3> == '1' then PSTATE.N = flags<3>; if flagmask<2> == '1' then PSTATE.Z = flags<2>; if flagmask<1> == '1' then PSTATE.C = flags<1>; if flagmask<0> == '1' then PSTATE.V = flags<0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.346 ROR (immediate)

Rotate right (immediate)

This instruction provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left.

This is an alias of EXTR. This means:

- The encodings in this description are named to match the encodings of EXTR.
- The description of EXTR gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0 &amp;&amp; imms == 0xxxxx)

```
ROR <Wd>, <Ws>, #<shift>
```

## is equivalent to

```
EXTR <Wd>, <Ws>, <Ws>, #<shift>
```

and is the preferred disassembly when Rn == Rm .

## Encoding for the 64-bit variant

Applies when (sf == 1 &amp;&amp; N == 1) ROR &lt;Xd&gt;, &lt;Xs&gt;, #&lt;shift&gt;

## is equivalent to

```
EXTR <Xd>, <Xs>, <Xs>, #<shift>
```

and is the preferred disassembly when Rn == Rm .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' and 'Rm' fields.

## &lt;shift&gt;

For the '32-bit' variant: is the amount by which to rotate, in the range 0 to 31, encoded in the 'imms' field.

For the '64-bit' variant: is the amount by which to rotate, in the range 0 to 63, encoded in the 'imms' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' and 'Rm' fields.

## &lt;Xd&gt;

<!-- image -->

## Operation

The description of EXTR gives the operational pseudocode for this instruction.

## Operational Information

The description of EXTR gives the operational information for this instruction.

## C6.2.347 ROR (register)

Rotate right (register)

This instruction provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. The value of the second source register modulo the register size in bits gives the number of bits by which the first source register is right-shifted.

This is an alias of RORV. This means:

- The encodings in this description are named to match the encodings of RORV.
- The description of RORV gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) ROR <Wd>, <Wn>, <Wm>
```

## is equivalent to

```
RORV <Wd>, <Wn>, <Wm>
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (sf == 1) ROR <Xd>, <Xn>, <Xm>
```

```
is equivalent to
```

```
RORV <Xd>, <Xn>, <Xm>
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the 'Rm' field.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the 'Rm' field.

## Operation

The description of RORV gives the operational pseudocode for this instruction.

## Operational Information

The description of RORV gives the operational information for this instruction.

## C6.2.348 RORV

Rotate right variable

This instruction provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. The value of the second source register modulo the register size in bits gives the number of bits by which the first source register is right-shifted.

This instruction is used by the alias ROR (register).

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
RORV <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

Applies when 1)

```
(sf == RORV <Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type =
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the 'Rm' field.

```
DecodeShift(op2);
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand2 = X[m, datasize]; X[d, datasize] = ShiftReg(n, shift_type, UInt(operand2) MOD datasize, datasize);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias   | Is preferred when   |
|---------|---------------------|
| ROR     | Unconditionally     |

## C6.2.349 RPRFM

## Range prefetch memory

This instruction signals the memory system that data memory accesses from a specified range of addresses are likely to occur in the near future. The instruction may also signal the memory system about the likelihood of data reuse of the specified range of addresses. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as prefetching locations within the specified address ranges into one or more caches. The memory system may also exploit the data reuse hints to decide whether to retain the data in other caches upon eviction from the innermost caches or to discard it.

The effect of an RPRFM instruction is IMPLEMENTATION DEFINED. For more information, see Prefetch memory.

An RPRFM instruction specifies the type of accesses and range of addresses using the following parameters:

- 'Access type', encoded in Rt&lt;0&gt; , specifies:
- PLD for prefetch for load.
- PST for prefetch for store.
- 'Policy', encoded in Rt&lt;2:1&gt; , specifies:
- KEEP for retained or temporal prefetch, allocated in the cache normally.
- STRMfor streaming or non-temporal prefetch, for data that is used only once. If a streaming prefetch is specified, then the 'ReuseDistance' parameter is ignored.
- 'BaseAddress', in the 64-bit base register, holds the initial block address for the accesses.
- 'ReuseDistance', in the metadata register bits[63:60], indicates the maximum number of bytes to be accessed by this PE before executing the next RPRFM instruction that specifies the same range. This includes the total number of bytes inside and outside of the range that will be accessed by the same PE. This parameter can be used to influence cache eviction and replacement policies, in order to retain the data in the most optimal levels of the memory hierarchy after each access. If software cannot easily determine the amount of other memory that will be accessed, these bits can be set to zero to indicate that 'ReuseDistance' is not known. Otherwise, these four bits encode decreasing powers of two in the range 512MiB ( 0b0001 ) to 32KiB ( 0b1111 ).
- 'Stride', in the metadata register bits[59:38], is a signed, two's complement integer encoding of the number of bytes to advance the block address after 'Length' bytes have been accessed, in the range -2MiB to +2MiB-1B. A negative value indicates that the block address is advanced in a descending direction.
- 'Count', in the metadata register bits[37:22], is an unsigned integer encoding of the number of blocks of data to be accessed minus 1, representing the range 1 to 65536 blocks. If 'Count' is 0, then the 'Stride' parameter is ignored and only a single block of contiguous bytes from 'BaseAddress' to ('BaseAddress' + 'Length' - 1) is described.
- 'Length', in the metadata register bits[21:0], is a signed, two's complement integer encoding of the number of contiguous bytes to be accessed starting from the current block address, without changing the block address, in the range -2MiB to +2MiB-1B. A negative value indicates that the bytes are accessed in a descending direction.

Note

Software is expected to honor the parameters it provides to the RPRFM instruction, and the same PE should access all locations in the range, in the direction specified by the sign of the 'Length' and 'Stride' parameters. A range prefetch is considered active on a PE until all locations in the range have been accessed by the PE. A range prefetch might also be inactivated by the PE prior to completion, for example due to a software context switch or lack of hardware resources. Software should not specify overlapping addresses in multiple active ranges. If a range is expected to be accessed by both load and store instructions (read-modify-write), then a single range with an 'Access type' parameter of PST (prefetch for store) should be specified.

## Integer

(FEAT\_RPRFM)

<!-- image -->

## Encoding

<!-- image -->

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_RPRFM) then EndOfDecode(Decode_NOP); constant bits(6) operation = option<2>:option<0>:S:Rt<2:0>; constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

## &lt;rprfop&gt;

Is the range prefetch operation, encoded in 'option:S:Rt':

|   option |   S |    Rt | <rprfop>   |
|----------|-----|-------|------------|
|      010 |   0 | 11000 | PLDKEEP    |
|      010 |   0 | 11001 | PSTKEEP    |
|      010 |   0 | 11100 | PLDSTRM    |
|      010 |   0 | 11101 | PSTSTRM    |

For other encodings, use &lt;imm6&gt;.

## &lt;imm6&gt;

Is the range prefetch operation encoding as an immediate, in the range 0 to 63, encoded in 'option&lt;2&gt;:option&lt;0&gt;:S:Rt&lt;2:0&gt;'. This syntax is only for encodings that are not representable using &lt;rprfop&gt; .

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose register that holds an encoding of the metadata, encoded in the 'Rm' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
constant bits(64) address = if n == 31 then SP[64] else X[n, 64]; constant bits(64) metadata = X[m, 64]; constant integer stride = SInt(metadata<59:38>); constant integer count = UInt(metadata<37:22>) + 1; constant integer length = SInt(metadata<21:0>); integer reuse; if metadata<63:60> == '0000' then reuse = -1; // Not known else reuse = 32768 << (15 -UInt(metadata<63:60>)); Hint_RangePrefetch(address, length, stride, count, reuse,
```

```
operation);
```

## C6.2.350 SB

Speculation barrier

This instruction is a barrier that controls speculation. For more information and details of the semantics, see Speculation Barrier (SB).

## System

(FEAT\_SB)

<!-- image -->

## Encoding

SB

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_SB) then EndOfDecode(Decode\_UNDEF);

## Operation

SpeculationBarrier();

## C6.2.351 SBC

Subtract with carry

This instruction subtracts a register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register.

This instruction is used by the alias NGC.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
SBC <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

Applies when (sf == 1)

```
SBC
```

```
<Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 <<
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

```
UInt(sf);
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = NOT(X[m, datasize]); bits(datasize) result; (result, -) = AddWithCarry(operand1, operand2, X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias   | Is preferred when   |
|---------|---------------------|
| NGC     | Rn == '11111'       |

```
PSTATE.C);
```

## C6.2.352 SBCS

Subtract with carry, setting flags

This instruction subtracts a register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register. It updates the condition flags based on the result.

This instruction is used by the alias NGCS.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
SBCS <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

Applies when (sf == 1)

```
SBCS <Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 <<
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

```
UInt(sf);
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = NOT(X[m, datasize]); bits(datasize) result; bits(4) nzcv; (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C); X[d, datasize] = result; PSTATE.<N,Z,C,V> = nzcv;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| Alias   | Is preferred when   |
|---------|---------------------|
| NGCS    | Rn == '11111'       |

## C6.2.353 SBFIZ

Signed bitfield insert in zeros

This instruction copies a bitfield of &lt;width&gt; bits from the least significant bits of the source register to bit position &lt;lsb&gt; of the destination register, setting the destination bits below the bitfield to zero, and the bits above the bitfield to a copy of the most significant bit of the bitfield.

This is an alias of SBFM. This means:

- The encodings in this description are named to match the encodings of SBFM.
- The description of SBFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0 && N == 0) SBFIZ <Wd>, <Wn>, #<lsb>, #<width>
```

## is equivalent to

```
SBFM <Wd>, <Wn>, #(-<lsb> MOD 32), #(<width>-1)
```

and is the preferred disassembly when UInt(imms) &lt; UInt(immr) .

## Encoding for the 64-bit variant

```
Applies when (sf == 1 && N == 1)
```

```
SBFIZ <Xd>, <Xn>, #<lsb>, #<width>
```

## is equivalent to

```
SBFM <Xd>, <Xn>, #(-<lsb> MOD 64), #(<width>-1)
```

and is the preferred disassembly when UInt(imms) &lt; UInt(immr) .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;lsb&gt;

For the '32-bit' variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.

For the '64-bit' variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.

## &lt;width&gt;

For the '32-bit' variant: is the width of the bitfield, in the range 1 to 32-&lt;lsb&gt;.

For the '64-bit' variant: is the width of the bitfield, in the range 1 to 64-&lt;lsb&gt;.

<!-- image -->

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

The description of SBFM gives the operational pseudocode for this instruction.

## Operational Information

The description of SBFM gives the operational information for this instruction.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.354 SBFM

Signed bitfield move

This instruction is usually accessed via one of its aliases, which are always preferred for disassembly.

If &lt;imms&gt; is greater than or equal to &lt;immr&gt; , this copies a bitfield of ( &lt;imms&gt; -&lt;immr&gt; +1) bits starting from bit position &lt;immr&gt; in the source register to the least significant bits of the destination register.

If &lt;imms&gt; is less than &lt;immr&gt; , this copies a bitfield of ( &lt;imms&gt; +1) bits from the least significant bits of the source register to bit position (regsize&lt;immr&gt; ) of the destination register, where regsize is the destination register size of 32 or 64 bits.

In both cases, the destination bits below the bitfield are set to zero, and the bits above the bitfield are set to a copy of the most significant bit of the bitfield.

This instruction is used by the aliases ASR (immediate), SBFIZ, SBFX, SXTB, SXTH, and SXTW.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0 && N == SBFM <Wd>, <Wn>, #<immr>, #<imms>
```

0)

## Encoding for the 64-bit variant

1)

```
Applies when (sf == 1 && N == SBFM <Xd>, <Xn>, #<immr>, #<imms>
```

## Decode for all variants of this encoding

```
if sf == '1' && N != '1' then EndOfDecode(Decode_UNDEF); if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant integer s = UInt(imms); constant integer r = UInt(immr); bits(datasize) wmask; bits(datasize) tmask; (wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE, datasize);
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;immr&gt;

For the '32-bit' variant: is the right rotate amount, in the range 0 to 31, encoded in the 'immr' field.

For the '64-bit' variant: is the right rotate amount, in the range 0 to 63, encoded in the 'immr' field.

## &lt;imms&gt;

For the '32-bit' variant: is the leftmost bit number to be moved from the source, in the range 0 to 31, encoded in the 'imms' field.

For the '64-bit' variant: is the leftmost bit number to be moved from the source, in the range 0 to 63, encoded in the 'imms' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Alias Conditions

| Alias           | Of variant   | Is preferred when                    |
|-----------------|--------------|--------------------------------------|
| ASR (immediate) | 32-bit       | imms == '011111'                     |
| ASR (immediate) | 64-bit       | imms == '111111'                     |
| SBFIZ           |              | UInt(imms) < UInt(immr)              |
| SBFX            |              | BFXPreferred(sf, opc<1>, imms, immr) |
| SXTB            |              | immr == '000000' && imms == '000111' |
| SXTH            |              | immr == '000000' && imms == '001111' |
| SXTW            |              | immr == '000000' && imms == '011111' |

## Operation

```
constant bits(datasize) src = X[n, datasize]; // Perform bitfield move on low bits constant bits(datasize) bot = ROR(src, r) AND wmask; constant bits(datasize) top = Replicate(src<s>, datasize); // Combine extension bits and result bits X[d, datasize] = (top AND NOT(tmask)) OR (bot AND tmask);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.355 SBFX

## Signed bitfield extract

This instruction copies a bitfield of &lt;width&gt; bits starting from bit position &lt;lsb&gt; in the source register to the least significant bits of the destination register, and sets destination bits above the bitfield to a copy of the most significant bit of the bitfield.

This is an alias of SBFM. This means:

- The encodings in this description are named to match the encodings of SBFM.
- The description of SBFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0)

```
SBFX <Wd>, <Wn>, #<lsb>, #<width>
```

```
is equivalent to
```

```
SBFM <Wd>, <Wn>, #<lsb>, #(<lsb>+<width>-1)
```

and is the preferred disassembly when BFXPreferred(sf, opc[1], imms, immr) .

## Encoding for the 64-bit variant

Applies when (sf == 1 &amp;&amp; N == 1)

```
SBFX <Xd>, <Xn>, #<lsb>, #<width>
```

## is equivalent to

```
SBFM <Xd>, <Xn>, #<lsb>, #(<lsb>+<width>-1)
```

and is the preferred disassembly when BFXPreferred(sf, opc[1], imms, immr) .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;lsb&gt;

For the '32-bit' variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.

For the '64-bit' variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.

## &lt;width&gt;

For the '32-bit' variant: is the width of the bitfield, in the range 1 to 32-&lt;lsb&gt;.

For the '64-bit' variant: is the width of the bitfield, in the range 1 to 64-&lt;lsb&gt;.

<!-- image -->

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

The description of SBFM gives the operational pseudocode for this instruction.

## Operational Information

The description of SBFM gives the operational information for this instruction.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.356 SDIV

## Signed divide

This instruction divides the first signed source register value by the second signed source register value, and writes the result to the destination register. Dividing by zero writes the value zero to the destination register. The condition flags are not affected.

<!-- image -->

## Encoding for the 32-bit variant

0)

```
Applies when (sf == SDIV <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

```
1)
```

```
Applies when (sf == SDIV <Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 <<
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

```
UInt(sf);
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = X[m, datasize]; constant integer dividend = SInt(operand1); constant integer divisor = SInt(operand2); integer result; if divisor == 0 then result = 0; elsif (dividend < 0) == (divisor < 0) then result = Abs(dividend) DIV Abs(divisor); // same signs - positive result else result = -(Abs(dividend) DIV Abs(divisor)); // different signs - negative X[d, datasize] = result<datasize-1:0>;
```

```
result
```

## C6.2.357 SETF8, SETF16

Evaluation of 8-bit or 16-bit flag values

This instruction sets the PSTATE.NZV flags based on the value in the specified general-purpose register. SETF8 treats the value as an 8-bit value. SETF16 treats the value as a 16-bit value.

The PSTATE.C flag is not affected by these instructions.

## Integer

(FEAT\_FlagM)

<!-- image -->

## Encoding for the SETF8 variant

```
Applies when (sz == 0) SETF8 <Wn>
```

## Encoding for the SETF16 variant

```
Applies when (sz ==
```

```
1) SETF16 <Wn>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_FlagM) then constant integer size = 8 << UInt(sz); constant integer n = UInt(Rn);
```

## Assembler Symbols

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(32) reg = X[n, 32]; PSTATE.N = reg<size-1>; PSTATE.Z = if (reg<size-1:0> == Zeros(size)) then '1' else '0'; PSTATE.V = reg<size> EOR reg<size-1>; //PSTATE.C unchanged;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
EndOfDecode(Decode_UNDEF);
```

## C6.2.358 SETGP, SETGM, SETGE

Memory set with tag setting

These instructions set a requested number of bytes in memory to the value in the least significant byte of the source data register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register that holds the first address to be set. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGP, then SETGM, and then SETGE.

SETGP performs some preconditioning of the arguments suitable for using the SETGM instruction, and sets an IMPLEMENTATION DEFINED portion of the requested number of bytes. SETGM sets a further IMPLEMENTATION DEFINED portion of the remaining bytes. SETGE sets any final remaining bytes.

Note

The ability to set an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being set are divided between the different instructions.

For more information on exceptions specific to memory set instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory set: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For SETGP:

- If Xn&lt;63&gt; == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0 .

On completion of SETGP, option A:

- Xn holds -1 times the number of bytes in the saturated set size remaining to be set.
- Xd holds the original Xd + saturated set size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of SETGP, option B:

- Xn holds the number of bytes in the saturated set size remaining to be set.
- Xd holds the lowest address that has not been set.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For SETGM, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.
- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be set.

For SETGM, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address that has not been set.

For SETGE, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.
- Xd holds the lowest address to be set - Xn.

- On completion of the instruction, Xn holds 0.

For SETGE, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds 0.
- Xd holds the lowest address that has not been set.

## Integer

(FEAT\_MOPS &amp;&amp; FEAT\_MTE)

<!-- image -->

## Encoding for the Prologue variant

Applies when (op2 == 0000)

```
SETGP [<Xd>]!, <Xn>!, <Xs>
```

## Encoding for the Main variant

```
Applies when (op2 == 0100) SETGM [<Xd>]!, <Xn>!, <Xs>
```

## Encoding for the Epilogue variant

Applies when 1000)

```
(op2 == SETGE [<Xd>]!, <Xn>!, <Xs>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || !IsFeatureImplemented(FEAT_MTE) || sz != '00' then EndOfDecode(Decode_UNDEF); SETParams memset; memset.d = UInt(Rd); memset.s = UInt(Rs); memset.n = UInt(Rn); constant bits(2) options = op2<1:0>; constant boolean nontemporal = options<1> == '1'; case op2<3:2> of when '00' memset.stage = MOPSStage_Prologue; when '01' memset.stage = MOPSStage_Main; when '10' memset.stage = MOPSStage_Epilogue; otherwise EndOfDecode(Decode_UNDEF);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set SET* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the destination address (an integer multiple of 16) and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address (an integer multiple of 16) and for option B is updated by the instruction, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set (an integer multiple of 16) and is updated by the instruction, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set (an integer multiple of 16) and is updated by the instruction, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set (an integer multiple of 16) and is set to zero on completion of the instruction, encoded in the 'Rn' field.

For the 'Main' and 'Prologue' variants: is the 64-bit name of the general-purpose register that holds the source data in bits&lt;7:0&gt;, encoded in the 'Rs' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds the source data, encoded in the 'Rs' field.

## Operation

```
CheckMOPSEnabled(); CheckSETConstrainedUnpredictable(memset.n, memset.d, memset.s); constant bits(8) data = X[memset.s, 8]; MOPSBlockSize B = 0; memset.is_setg = TRUE; memset.nzcv = PSTATE.<N,Z,C,V>; memset.toaddress = X[memset.d, 64]; if memset.stage == MOPSStage_Prologue then memset.setsize = UInt(X[memset.n, 64]); else memset.setsize = SInt(X[memset.n, 64]); memset.implements_option_a = SETGOptionA(); constant boolean privileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor accdesc = CreateAccDescSTGMOPS(privileged, nontemporal); if memset.stage == MOPSStage_Prologue then if memset.setsize > ArchMaxMOPSSETGSize then memset.setsize = ArchMaxMOPSSETGSize; if ((memset.setsize != 0 && !IsAligned(memset.toaddress, TAG_GRANULE)) || !IsAligned(memset.setsize<63:0>, TAG_GRANULE)) then constant FaultRecord fault = AlignmentFault(accdesc, memset.toaddress); AArch64.Abort(fault); if memset.implements_option_a then memset.nzcv = '0000'; memset.toaddress = memset.toaddress + memset.setsize; memset.setsize = 0 -memset.setsize; else
```

<!-- image -->

## &lt;Xs&gt;

```
memset.nzcv = '0010'; memset.stagesetsize = MemSetStageSize(memset); if memset.stage != MOPSStage_Prologue then CheckMemSetParams(memset, options); bits(64) fault_address; if memset.implements_option_a then fault_address = memset.toaddress + memset.setsize; else fault_address = memset.toaddress; if (memset.setsize != 0 && (memset.stagesetsize != 0 || MemStageSetZeroSizeCheck()) && !IsAligned(memset.toaddress, TAG_GRANULE)) then constant FaultRecord fault = AlignmentFault(accdesc, fault_address); AArch64.Abort(fault); if ((memset.stagesetsize != 0 || MemStageSetZeroSizeCheck()) && !IsAligned(memset.setsize<63:0>, TAG_GRANULE)) then constant FaultRecord fault = AlignmentFault(accdesc, fault_address); AArch64.Abort(fault); integer tags_set; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; AddressDescriptor tagmemaddrdesc; PhysMemRetStatus tagmemstatus; boolean fault = FALSE; boolean tagfault = FALSE; if memset.implements_option_a then while memset.stagesetsize < 0 && !fault && !tagfault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, TAG_GRANULE); assert B <= -1 * memset.stagesetsize && B<3:0> == '0000'; (-, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress + memset.setsize, data, B, accdesc); constant bits(4) tag = AArch64.AllocationTagFromAddress(memset.toaddress + memset.setsize); (tags_set, tagmemaddrdesc, tagmemstatus) = MemSetTags(memset.toaddress + memset.setsize, tag, B, accdesc); fault = IsFault(memaddrdesc) || IsFault(memstatus); tagfault = IsFault(tagmemaddrdesc) || IsFault(tagmemstatus); if !fault && !tagfault then memset.setsize = memset.setsize + B; memset.stagesetsize = memset.stagesetsize + B; else while memset.stagesetsize > 0 && !fault && !tagfault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, TAG_GRANULE); assert B <= memset.stagesetsize && B<3:0> == '0000'; (-, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress, data, B, accdesc); constant bits(4) tag = AArch64.AllocationTagFromAddress(memset.toaddress); (tags_set, tagmemaddrdesc, tagmemstatus) = MemSetTags(memset.toaddress, tag, B, accdesc); fault = IsFault(memaddrdesc) || IsFault(memstatus); tagfault = IsFault(tagmemaddrdesc) || IsFault(tagmemstatus); if !fault && !tagfault then memset.toaddress = memset.toaddress + B;
```

```
memset.setsize = memset.setsize -B; memset.stagesetsize = memset.stagesetsize -B; UpdateSetRegisters(memset, fault || tagfault, tags_set * TAG_GRANULE); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant boolean iswrite = TRUE; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); elsif tagfault then if IsFault(tagmemaddrdesc) then AArch64.Abort(tagmemaddrdesc.fault); else constant boolean iswrite = TRUE; HandleExternalAbort(tagmemstatus, iswrite, tagmemaddrdesc, 1, accdesc); if memset.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memset.nzcv;
```

## C6.2.359 SETGPN, SETGMN, SETGEN

Memory set with tag setting, non-temporal

These instructions set a requested number of bytes in memory to the value in the least significant byte of the source data register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register that holds the first address to be set. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPN, then SETGMN, and then SETGEN.

SETGPN performs some preconditioning of the arguments suitable for using the SETGMN instruction, and sets an IMPLEMENTATION DEFINED portion of the requested number of bytes. SETGMN sets a further IMPLEMENTATION DEFINED portion of the remaining bytes. SETGEN sets any final remaining bytes.

Note

The ability to set an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being set are divided between the different instructions.

For more information on exceptions specific to memory set instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory set: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For SETGPN:

- If Xn&lt;63&gt; == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0 .

On completion of SETGPN, option A:

- Xn holds -1 times the number of bytes in the saturated set size remaining to be set.
- Xd holds the original Xd + saturated set size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of SETGPN, option B:

- Xn holds the number of bytes in the saturated set size remaining to be set.
- Xd holds the lowest address that has not been set.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For SETGMN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.
- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be set.

For SETGMN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address that has not been set.

For SETGEN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.

- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds 0.

For SETGEN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds 0.
- Xd holds the lowest address that has not been set.

## Integer

(FEAT\_MOPS &amp;&amp; FEAT\_MTE)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op2 == 0010) SETGPN [<Xd>]!, <Xn>!, <Xs>
```

## Encoding for the Main variant

```
Applies when (op2 == 0110) SETGMN [<Xd>]!, <Xn>!, <Xs>
```

## Encoding for the Epilogue variant

```
Applies when (op2 == SETGEN [<Xd>]!, <Xn>!,
```

```
1010) <Xs>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || !IsFeatureImplemented(FEAT_MTE) || sz != '00' then EndOfDecode(Decode_UNDEF); SETParams memset; memset.d = UInt(Rd); memset.s = UInt(Rs); memset.n = UInt(Rn); constant bits(2) options = op2<1:0>; constant boolean nontemporal = options<1> == '1'; case op2<3:2> of when '00' memset.stage = MOPSStage_Prologue; when '01' memset.stage = MOPSStage_Main; when '10' memset.stage = MOPSStage_Epilogue; otherwise EndOfDecode(Decode_UNDEF);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set SET* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the destination address (an integer multiple of 16) and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address (an integer multiple of 16) and for option B is updated by the instruction, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set (an integer multiple of 16) and is updated by the instruction, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set (an integer multiple of 16) and is updated by the instruction, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set (an integer multiple of 16) and is set to zero on completion of the instruction, encoded in the 'Rn' field.

For the 'Main' and 'Prologue' variants: is the 64-bit name of the general-purpose register that holds the source data in bits&lt;7:0&gt;, encoded in the 'Rs' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds the source data, encoded in the 'Rs' field.

## Operation

```
CheckMOPSEnabled(); CheckSETConstrainedUnpredictable(memset.n, memset.d, memset.s); constant bits(8) data = X[memset.s, 8]; MOPSBlockSize B = 0; memset.is_setg = TRUE; memset.nzcv = PSTATE.<N,Z,C,V>; memset.toaddress = X[memset.d, 64]; if memset.stage == MOPSStage_Prologue then memset.setsize = UInt(X[memset.n, 64]); else memset.setsize = SInt(X[memset.n, 64]); memset.implements_option_a = SETGOptionA(); constant boolean privileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor accdesc = CreateAccDescSTGMOPS(privileged, nontemporal); if memset.stage == MOPSStage_Prologue then if memset.setsize > ArchMaxMOPSSETGSize then memset.setsize = ArchMaxMOPSSETGSize; if ((memset.setsize != 0 && !IsAligned(memset.toaddress, TAG_GRANULE)) || !IsAligned(memset.setsize<63:0>, TAG_GRANULE)) then constant FaultRecord fault = AlignmentFault(accdesc, memset.toaddress); AArch64.Abort(fault); if memset.implements_option_a then memset.nzcv = '0000'; memset.toaddress = memset.toaddress + memset.setsize; memset.setsize = 0 -memset.setsize; else
```

<!-- image -->

## &lt;Xs&gt;

```
memset.nzcv = '0010'; memset.stagesetsize = MemSetStageSize(memset); if memset.stage != MOPSStage_Prologue then CheckMemSetParams(memset, options); bits(64) fault_address; if memset.implements_option_a then fault_address = memset.toaddress + memset.setsize; else fault_address = memset.toaddress; if (memset.setsize != 0 && (memset.stagesetsize != 0 || MemStageSetZeroSizeCheck()) && !IsAligned(memset.toaddress, TAG_GRANULE)) then constant FaultRecord fault = AlignmentFault(accdesc, fault_address); AArch64.Abort(fault); if ((memset.stagesetsize != 0 || MemStageSetZeroSizeCheck()) && !IsAligned(memset.setsize<63:0>, TAG_GRANULE)) then constant FaultRecord fault = AlignmentFault(accdesc, fault_address); AArch64.Abort(fault); integer tags_set; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; AddressDescriptor tagmemaddrdesc; PhysMemRetStatus tagmemstatus; boolean fault = FALSE; boolean tagfault = FALSE; if memset.implements_option_a then while memset.stagesetsize < 0 && !fault && !tagfault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, TAG_GRANULE); assert B <= -1 * memset.stagesetsize && B<3:0> == '0000'; (-, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress + memset.setsize, data, B, accdesc); constant bits(4) tag = AArch64.AllocationTagFromAddress(memset.toaddress + memset.setsize); (tags_set, tagmemaddrdesc, tagmemstatus) = MemSetTags(memset.toaddress + memset.setsize, tag, B, accdesc); fault = IsFault(memaddrdesc) || IsFault(memstatus); tagfault = IsFault(tagmemaddrdesc) || IsFault(tagmemstatus); if !fault && !tagfault then memset.setsize = memset.setsize + B; memset.stagesetsize = memset.stagesetsize + B; else while memset.stagesetsize > 0 && !fault && !tagfault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, TAG_GRANULE); assert B <= memset.stagesetsize && B<3:0> == '0000'; (-, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress, data, B, accdesc); constant bits(4) tag = AArch64.AllocationTagFromAddress(memset.toaddress); (tags_set, tagmemaddrdesc, tagmemstatus) = MemSetTags(memset.toaddress, tag, B, accdesc); fault = IsFault(memaddrdesc) || IsFault(memstatus); tagfault = IsFault(tagmemaddrdesc) || IsFault(tagmemstatus); if !fault && !tagfault then memset.toaddress = memset.toaddress + B;
```

```
memset.setsize = memset.setsize -B; memset.stagesetsize = memset.stagesetsize -B; UpdateSetRegisters(memset, fault || tagfault, tags_set * TAG_GRANULE); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant boolean iswrite = TRUE; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); elsif tagfault then if IsFault(tagmemaddrdesc) then AArch64.Abort(tagmemaddrdesc.fault); else constant boolean iswrite = TRUE; HandleExternalAbort(tagmemstatus, iswrite, tagmemaddrdesc, 1, accdesc); if memset.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memset.nzcv;
```

## C6.2.360 SETGPT, SETGMT, SETGET

Memory set with tag setting, unprivileged

These instructions set a requested number of bytes in memory to the value in the least significant byte of the source data register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register that holds the first address to be set. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPT, then SETGMT, and then SETGET.

SETGPT performs some preconditioning of the arguments suitable for using the SETGMT instruction, and sets an IMPLEMENTATION DEFINED portion of the requested number of bytes. SETGMT sets a further IMPLEMENTATION DEFINED portion of the remaining bytes. SETGET sets any final remaining bytes.

Note

The ability to set an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being set are divided between the different instructions.

For more information on exceptions specific to memory set instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory set: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For SETGPT:

- If Xn&lt;63&gt; == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0 .

On completion of SETGPT, option A:

- Xn holds -1 times the number of bytes in the saturated set size remaining to be set.
- Xd holds the original Xd + saturated set size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of SETGPT, option B:

- Xn holds the number of bytes in the saturated set size remaining to be set.
- Xd holds the lowest address that has not been set.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For SETGMT, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.
- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be set.

For SETGMT, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address that has not been set.

For SETGET, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.

- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds 0.

For SETGET, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds 0.
- Xd holds the lowest address that has not been set.

Explicit Memory Write effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Write effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS &amp;&amp; FEAT\_MTE)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op2 == SETGPT [<Xd>]!, <Xn>!,
```

```
0001) <Xs>
```

## Encoding for the Main variant

```
Applies when (op2 == SETGMT [<Xd>]!, <Xn>!,
```

```
0101) <Xs>
```

## Encoding for the Epilogue variant

```
Applies when (op2 == SETGET [<Xd>]!, <Xn>!,
```

```
1001) <Xs>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || !IsFeatureImplemented(FEAT_MTE) || sz != '00' then EndOfDecode(Decode_UNDEF); SETParams memset; memset.d = UInt(Rd); memset.s = UInt(Rs); memset.n = UInt(Rn); constant bits(2) options = op2<1:0>; constant boolean nontemporal = options<1> == '1'; case op2<3:2> of
```

```
when '00' memset.stage = MOPSStage_Prologue; when '01' memset.stage = MOPSStage_Main; when '10' memset.stage = MOPSStage_Epilogue; otherwise EndOfDecode(Decode_UNDEF);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set SET* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the destination address (an integer multiple of 16) and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address (an integer multiple of 16) and for option B is updated by the instruction, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set (an integer multiple of 16) and is updated by the instruction, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set (an integer multiple of 16) and is updated by the instruction, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set (an integer multiple of 16) and is set to zero on completion of the instruction, encoded in the 'Rn' field.

For the 'Main' and 'Prologue' variants: is the 64-bit name of the general-purpose register that holds the source data in bits&lt;7:0&gt;, encoded in the 'Rs' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds the source data, encoded in the 'Rs' field.

## Operation

```
CheckMOPSEnabled(); CheckSETConstrainedUnpredictable(memset.n, memset.d, memset.s); constant bits(8) data = X[memset.s, 8]; MOPSBlockSize B = 0; memset.is_setg = TRUE; memset.nzcv = PSTATE.<N,Z,C,V>; memset.toaddress = X[memset.d, 64]; if memset.stage == MOPSStage_Prologue then memset.setsize = UInt(X[memset.n, 64]); else memset.setsize = SInt(X[memset.n, 64]); memset.implements_option_a = SETGOptionA(); constant boolean privileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor accdesc = CreateAccDescSTGMOPS(privileged, nontemporal); if memset.stage == MOPSStage_Prologue then if memset.setsize > ArchMaxMOPSSETGSize then memset.setsize = ArchMaxMOPSSETGSize;
```

## &lt;Xn&gt;

## &lt;Xs&gt;

```
if ((memset.setsize != 0 && !IsAligned(memset.toaddress, TAG_GRANULE)) || !IsAligned(memset.setsize<63:0>, TAG_GRANULE)) then constant FaultRecord fault = AlignmentFault(accdesc, memset.toaddress); AArch64.Abort(fault); if memset.implements_option_a then memset.nzcv = '0000'; memset.toaddress = memset.toaddress + memset.setsize; memset.setsize = 0 -memset.setsize; else memset.nzcv = '0010'; memset.stagesetsize = MemSetStageSize(memset); if memset.stage != MOPSStage_Prologue then CheckMemSetParams(memset, options); bits(64) fault_address; if memset.implements_option_a then fault_address = memset.toaddress + memset.setsize; else fault_address = memset.toaddress; if (memset.setsize != 0 && (memset.stagesetsize != 0 || MemStageSetZeroSizeCheck()) && !IsAligned(memset.toaddress, TAG_GRANULE)) then constant FaultRecord fault = AlignmentFault(accdesc, fault_address); AArch64.Abort(fault); if ((memset.stagesetsize != 0 || MemStageSetZeroSizeCheck()) && !IsAligned(memset.setsize<63:0>, TAG_GRANULE)) then constant FaultRecord fault = AlignmentFault(accdesc, fault_address); AArch64.Abort(fault); integer tags_set; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; AddressDescriptor tagmemaddrdesc; PhysMemRetStatus tagmemstatus; boolean fault = FALSE; boolean tagfault = FALSE; if memset.implements_option_a then while memset.stagesetsize < 0 && !fault && !tagfault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, TAG_GRANULE); assert B <= -1 * memset.stagesetsize && B<3:0> == '0000'; (-, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress + memset.setsize, data, B, accdesc); constant bits(4) tag = AArch64.AllocationTagFromAddress(memset.toaddress + memset.setsize); (tags_set, tagmemaddrdesc, tagmemstatus) = MemSetTags(memset.toaddress + memset.setsize, tag, B, accdesc); fault = IsFault(memaddrdesc) || IsFault(memstatus); tagfault = IsFault(tagmemaddrdesc) || IsFault(tagmemstatus); if !fault && !tagfault then memset.setsize = memset.setsize + B; memset.stagesetsize = memset.stagesetsize + B; else while memset.stagesetsize > 0 && !fault && !tagfault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, TAG_GRANULE); assert B <= memset.stagesetsize && B<3:0> == '0000';
```

```
(-, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress, data, B, accdesc); constant bits(4) tag = AArch64.AllocationTagFromAddress(memset.toaddress); (tags_set, tagmemaddrdesc, tagmemstatus) = MemSetTags(memset.toaddress, tag, B, accdesc); fault = IsFault(memaddrdesc) || IsFault(memstatus); tagfault = IsFault(tagmemaddrdesc) || IsFault(tagmemstatus); if !fault && !tagfault then memset.toaddress = memset.toaddress + B; memset.setsize = memset.setsize -B; memset.stagesetsize = memset.stagesetsize -B; UpdateSetRegisters(memset, fault || tagfault, tags_set * TAG_GRANULE); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant boolean iswrite = TRUE; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); elsif tagfault then if IsFault(tagmemaddrdesc) then AArch64.Abort(tagmemaddrdesc.fault); else constant boolean iswrite = TRUE; HandleExternalAbort(tagmemstatus, iswrite, tagmemaddrdesc, 1, accdesc); if memset.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memset.nzcv;
```

## C6.2.361 SETGPTN, SETGMTN, SETGETN

Memory set with tag setting, unprivileged and non-temporal

These instructions set a requested number of bytes in memory to the value in the least significant byte of the source data register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register that holds the first address to be set. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPTN, then SETGMTN, and then SETGETN.

SETGPTN performs some preconditioning of the arguments suitable for using the SETGMTN instruction, and sets an IMPLEMENTATION DEFINED portion of the requested number of bytes. SETGMTN sets a further IMPLEMENTATION DEFINED portion of the remaining bytes. SETGETN sets any final remaining bytes.

Note

The ability to set an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being set are divided between the different instructions.

For more information on exceptions specific to memory set instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory set: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For SETGPTN:

- If Xn&lt;63&gt; == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0 .

On completion of SETGPTN, option A:

- Xn holds -1 times the number of bytes in the saturated set size remaining to be set.
- Xd holds the original Xd + saturated set size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of SETGPTN, option B:

- Xn holds the number of bytes in the saturated set size remaining to be set.
- Xd holds the lowest address that has not been set.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For SETGMTN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.
- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be set.

For SETGMTN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address that has not been set.

For SETGETN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.

- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds 0.

For SETGETN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds 0.
- Xd holds the lowest address that has not been set.

Explicit Memory Write effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Write effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS &amp;&amp; FEAT\_MTE)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op2 == 0011) SETGPTN [<Xd>]!, <Xn>!,
```

```
<Xs>
```

## Encoding for the Main variant

```
Applies when (op2 == 0111) SETGMTN [<Xd>]!, <Xn>!, <Xs>
```

## Encoding for the Epilogue variant

```
Applies when (op2 == 1011) SETGETN [<Xd>]!, <Xn>!,
```

```
<Xs>
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_MOPS) || !IsFeatureImplemented(FEAT_MTE) || sz != '00' then EndOfDecode(Decode_UNDEF); SETParams memset; memset.d = UInt(Rd); memset.s = UInt(Rs); memset.n = UInt(Rn); constant bits(2) options = op2<1:0>; constant boolean nontemporal = options<1> == '1'; case op2<3:2> of
```

```
when '00' memset.stage = MOPSStage_Prologue; when '01' memset.stage = MOPSStage_Main; when '10' memset.stage = MOPSStage_Epilogue; otherwise EndOfDecode(Decode_UNDEF);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set SET* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the destination address (an integer multiple of 16) and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address (an integer multiple of 16) and for option B is updated by the instruction, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set (an integer multiple of 16) and is updated by the instruction, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set (an integer multiple of 16) and is updated by the instruction, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set (an integer multiple of 16) and is set to zero on completion of the instruction, encoded in the 'Rn' field.

For the 'Main' and 'Prologue' variants: is the 64-bit name of the general-purpose register that holds the source data in bits&lt;7:0&gt;, encoded in the 'Rs' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds the source data, encoded in the 'Rs' field.

## Operation

```
CheckMOPSEnabled(); CheckSETConstrainedUnpredictable(memset.n, memset.d, memset.s); constant bits(8) data = X[memset.s, 8]; MOPSBlockSize B = 0; memset.is_setg = TRUE; memset.nzcv = PSTATE.<N,Z,C,V>; memset.toaddress = X[memset.d, 64]; if memset.stage == MOPSStage_Prologue then memset.setsize = UInt(X[memset.n, 64]); else memset.setsize = SInt(X[memset.n, 64]); memset.implements_option_a = SETGOptionA(); constant boolean privileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor accdesc = CreateAccDescSTGMOPS(privileged, nontemporal); if memset.stage == MOPSStage_Prologue then if memset.setsize > ArchMaxMOPSSETGSize then memset.setsize = ArchMaxMOPSSETGSize;
```

## &lt;Xn&gt;

## &lt;Xs&gt;

```
if ((memset.setsize != 0 && !IsAligned(memset.toaddress, TAG_GRANULE)) || !IsAligned(memset.setsize<63:0>, TAG_GRANULE)) then constant FaultRecord fault = AlignmentFault(accdesc, memset.toaddress); AArch64.Abort(fault); if memset.implements_option_a then memset.nzcv = '0000'; memset.toaddress = memset.toaddress + memset.setsize; memset.setsize = 0 -memset.setsize; else memset.nzcv = '0010'; memset.stagesetsize = MemSetStageSize(memset); if memset.stage != MOPSStage_Prologue then CheckMemSetParams(memset, options); bits(64) fault_address; if memset.implements_option_a then fault_address = memset.toaddress + memset.setsize; else fault_address = memset.toaddress; if (memset.setsize != 0 && (memset.stagesetsize != 0 || MemStageSetZeroSizeCheck()) && !IsAligned(memset.toaddress, TAG_GRANULE)) then constant FaultRecord fault = AlignmentFault(accdesc, fault_address); AArch64.Abort(fault); if ((memset.stagesetsize != 0 || MemStageSetZeroSizeCheck()) && !IsAligned(memset.setsize<63:0>, TAG_GRANULE)) then constant FaultRecord fault = AlignmentFault(accdesc, fault_address); AArch64.Abort(fault); integer tags_set; AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; AddressDescriptor tagmemaddrdesc; PhysMemRetStatus tagmemstatus; boolean fault = FALSE; boolean tagfault = FALSE; if memset.implements_option_a then while memset.stagesetsize < 0 && !fault && !tagfault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, TAG_GRANULE); assert B <= -1 * memset.stagesetsize && B<3:0> == '0000'; (-, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress + memset.setsize, data, B, accdesc); constant bits(4) tag = AArch64.AllocationTagFromAddress(memset.toaddress + memset.setsize); (tags_set, tagmemaddrdesc, tagmemstatus) = MemSetTags(memset.toaddress + memset.setsize, tag, B, accdesc); fault = IsFault(memaddrdesc) || IsFault(memstatus); tagfault = IsFault(tagmemaddrdesc) || IsFault(tagmemstatus); if !fault && !tagfault then memset.setsize = memset.setsize + B; memset.stagesetsize = memset.stagesetsize + B; else while memset.stagesetsize > 0 && !fault && !tagfault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, TAG_GRANULE); assert B <= memset.stagesetsize && B<3:0> == '0000';
```

```
(-, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress, data, B, accdesc); constant bits(4) tag = AArch64.AllocationTagFromAddress(memset.toaddress); (tags_set, tagmemaddrdesc, tagmemstatus) = MemSetTags(memset.toaddress, tag, B, accdesc); fault = IsFault(memaddrdesc) || IsFault(memstatus); tagfault = IsFault(tagmemaddrdesc) || IsFault(tagmemstatus); if !fault && !tagfault then memset.toaddress = memset.toaddress + B; memset.setsize = memset.setsize -B; memset.stagesetsize = memset.stagesetsize -B; UpdateSetRegisters(memset, fault || tagfault, tags_set * TAG_GRANULE); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant boolean iswrite = TRUE; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); elsif tagfault then if IsFault(tagmemaddrdesc) then AArch64.Abort(tagmemaddrdesc.fault); else constant boolean iswrite = TRUE; HandleExternalAbort(tagmemstatus, iswrite, tagmemaddrdesc, 1, accdesc); if memset.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memset.nzcv;
```

## C6.2.362 SETP, SETM, SETE

Memory set

These instructions set a required number of bytes in memory to the value in the least significant byte of the source data register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETP, then SETM, and then SETE.

SETP performs some preconditioning of the arguments suitable for using the SETM instruction, and sets an IMPLEMENTATION DEFINED portion of the requested number of bytes. SETM sets a further IMPLEMENTATION DEFINED portion of the remaining bytes. SETE sets any final remaining bytes.

Note

The ability to set an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being set are divided between the different instructions.

For more information on exceptions specific to memory set instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory set: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For SETP:

- If Xn&lt;63&gt; == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of SETP, option A:

- Xn holds -1 times the number of bytes in the saturated set size remaining to be set.
- Xd holds the original Xd + saturated set size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of SETP, option B:

- Xn holds the number of bytes in the saturated set size remaining to be set.
- Xd holds the lowest address that has not been set.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For SETM, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.
- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be set.

For SETM, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address that has not been set.

For SETE, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.
- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds 0.

For SETE, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds 0.
- Xd holds the lowest address that has not been set.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

Applies when 0000)

```
(op2 == SETP [<Xd>]!, <Xn>!, <Xs>
```

## Encoding for the Main variant

```
Applies when (op2 == 0100) SETM [<Xd>]!, <Xn>!, <Xs>
```

## Encoding for the Epilogue variant

```
1000)
```

```
Applies when (op2 == SETE [<Xd>]!, <Xn>!, <Xs>
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != SETParams memset; memset.d = UInt(Rd); memset.s = UInt(Rs); memset.n = UInt(Rn); constant bits(2) options = op2<1:0>; constant boolean nontemporal = options<1> == '1'; case op2<3:2> of when '00' memset.stage = MOPSStage_Prologue; when '01' memset.stage = MOPSStage_Main; when '10' memset.stage = MOPSStage_Epilogue; otherwise EndOfDecode(Decode_UNDEF);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set SET* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address and for option B is updated by the instruction, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set and is updated by the instruction, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set and is updated by the instruction, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## &lt;Xn&gt;

<!-- image -->

Is the 64-bit name of the general-purpose register that holds the source data, encoded in the 'Rs' field.

## Operation

```
CheckMOPSEnabled(); CheckSETConstrainedUnpredictable(memset.n, memset.d, memset.s); constant bits(8) data = X[memset.s, 8]; MOPSBlockSize B = 0; memset.is_setg = FALSE; memset.nzcv = PSTATE.<N,Z,C,V>; memset.toaddress = X[memset.d, 64]; if memset.stage == MOPSStage_Prologue then memset.setsize = UInt(X[memset.n, 64]); else memset.setsize = SInt(X[memset.n, 64]); memset.implements_option_a = SETOptionA(); constant boolean privileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor accdesc = CreateAccDescMOPS(MemOp_STORE, privileged, nontemporal); if memset.stage == MOPSStage_Prologue then if memset.setsize > ArchMaxMOPSBlockSize then memset.setsize = ArchMaxMOPSBlockSize; if memset.implements_option_a then memset.nzcv = '0000'; memset.toaddress = memset.toaddress + memset.setsize; memset.setsize = 0 -memset.setsize; else memset.nzcv = '0010'; memset.stagesetsize = MemSetStageSize(memset); if memset.stage != MOPSStage_Prologue then CheckMemSetParams(memset, options); AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; integer memory_set; boolean fault = FALSE;
```

```
if memset.implements_option_a then while memset.stagesetsize < 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, 1); assert B <= -1 * memset.stagesetsize; (memory_set, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress + memset.setsize, data, B, accdesc); if memory_set != B then fault = TRUE; else memset.setsize = memset.setsize + B; memset.stagesetsize = memset.stagesetsize + B; else while memset.stagesetsize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, 1); assert B <= memset.stagesetsize; (memory_set, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress, data, B, accdesc); if memory_set != B then fault = TRUE; else memset.toaddress = memset.toaddress + B; memset.setsize = memset.setsize -B; memset.stagesetsize = memset.stagesetsize -B; UpdateSetRegisters(memset, fault, memory_set); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant boolean iswrite = TRUE; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memset.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memset.nzcv;
```

## C6.2.363 SETPN, SETMN, SETEN

Memory set, non-temporal

These instructions set a required number of bytes in memory to the value in the least significant byte of the source data register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPN, then SETMN, and then SETEN.

SETPN performs some preconditioning of the arguments suitable for using the SETMN instruction, and sets an IMPLEMENTATION DEFINED portion of the requested number of bytes. SETMN sets a further IMPLEMENTATION DEFINED portion of the remaining bytes. SETEN sets any final remaining bytes.

Note

The ability to set an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being set are divided between the different instructions.

For more information on exceptions specific to memory set instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory set: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For SETPN:

- If Xn&lt;63&gt; == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of SETPN, option A:

- Xn holds -1 times the number of bytes in the saturated set size remaining to be set.
- Xd holds the original Xd + saturated set size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of SETPN, option B:

- Xn holds the number of bytes in the saturated set size remaining to be set.
- Xd holds the lowest address that has not been set.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For SETMN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.
- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be set.

For SETMN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address that has not been set.

For SETEN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.
- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds 0.

For SETEN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds 0.
- Xd holds the lowest address that has not been set.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

Applies when 0010)

```
(op2 == SETPN [<Xd>]!, <Xn>!, <Xs>
```

## Encoding for the Main variant

```
Applies when (op2 == 0110) SETMN [<Xd>]!, <Xn>!, <Xs>
```

## Encoding for the Epilogue variant

```
Applies when (op2 == 1010) SETEN [<Xd>]!, <Xn>!, <Xs>
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != SETParams memset; memset.d = UInt(Rd); memset.s = UInt(Rs); memset.n = UInt(Rn); constant bits(2) options = op2<1:0>; constant boolean nontemporal = options<1> == '1'; case op2<3:2> of when '00' memset.stage = MOPSStage_Prologue; when '01' memset.stage = MOPSStage_Main; when '10' memset.stage = MOPSStage_Epilogue; otherwise EndOfDecode(Decode_UNDEF);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set SET* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address and for option B is updated by the instruction, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set and is updated by the instruction, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set and is updated by the instruction, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set and is set to zero on completion of the instruction, encoded in the 'Rn' field.

## &lt;Xn&gt;

<!-- image -->

Is the 64-bit name of the general-purpose register that holds the source data, encoded in the 'Rs' field.

## Operation

```
CheckMOPSEnabled(); CheckSETConstrainedUnpredictable(memset.n, memset.d, memset.s); constant bits(8) data = X[memset.s, 8]; MOPSBlockSize B = 0; memset.is_setg = FALSE; memset.nzcv = PSTATE.<N,Z,C,V>; memset.toaddress = X[memset.d, 64]; if memset.stage == MOPSStage_Prologue then memset.setsize = UInt(X[memset.n, 64]); else memset.setsize = SInt(X[memset.n, 64]); memset.implements_option_a = SETOptionA(); constant boolean privileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor accdesc = CreateAccDescMOPS(MemOp_STORE, privileged, nontemporal); if memset.stage == MOPSStage_Prologue then if memset.setsize > ArchMaxMOPSBlockSize then memset.setsize = ArchMaxMOPSBlockSize; if memset.implements_option_a then memset.nzcv = '0000'; memset.toaddress = memset.toaddress + memset.setsize; memset.setsize = 0 -memset.setsize; else memset.nzcv = '0010'; memset.stagesetsize = MemSetStageSize(memset); if memset.stage != MOPSStage_Prologue then CheckMemSetParams(memset, options); AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; integer memory_set; boolean fault = FALSE;
```

```
if memset.implements_option_a then while memset.stagesetsize < 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, 1); assert B <= -1 * memset.stagesetsize; (memory_set, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress + memset.setsize, data, B, accdesc); if memory_set != B then fault = TRUE; else memset.setsize = memset.setsize + B; memset.stagesetsize = memset.stagesetsize + B; else while memset.stagesetsize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, 1); assert B <= memset.stagesetsize; (memory_set, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress, data, B, accdesc); if memory_set != B then fault = TRUE; else memset.toaddress = memset.toaddress + B; memset.setsize = memset.setsize -B; memset.stagesetsize = memset.stagesetsize -B; UpdateSetRegisters(memset, fault, memory_set); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant boolean iswrite = TRUE; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memset.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memset.nzcv;
```

## C6.2.364 SETPT, SETMT, SETET

Memory set, unprivileged

These instructions set a required number of bytes in memory to the value in the least significant byte of the source data register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPT, then SETMT, and then SETET.

SETPT performs some preconditioning of the arguments suitable for using the SETMT instruction, and sets an IMPLEMENTATION DEFINED portion of the requested number of bytes. SETMT sets a further IMPLEMENTATION DEFINED portion of the remaining bytes. SETET sets any final remaining bytes.

Note

The ability to set an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being set are divided between the different instructions.

For more information on exceptions specific to memory set instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory set: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For SETPT:

- If Xn&lt;63&gt; == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of SETPT, option A:

- Xn holds -1 times the number of bytes in the saturated set size remaining to be set.
- Xd holds the original Xd + saturated set size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of SETPT, option B:

- Xn holds the number of bytes in the saturated set size remaining to be set.
- Xd holds the lowest address that has not been set.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For SETMT, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.
- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be set.

For SETMT, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address that has not been set.

For SETET, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.
- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds 0.

For SETET, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds 0.
- Xd holds the lowest address that has not been set.

Explicit Memory Write effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Write effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op2 == 0001) SETPT [<Xd>]!, <Xn>!, <Xs>
```

## Encoding for the Main variant

```
Applies when (op2 == 0101) SETMT [<Xd>]!, <Xn>!, <Xs>
```

## Encoding for the Epilogue variant

```
Applies when (op2 == 1001) SETET [<Xd>]!, <Xn>!, <Xs>
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != SETParams memset; memset.d = UInt(Rd); memset.s = UInt(Rs); memset.n = UInt(Rn); constant bits(2) options = op2<1:0>; constant boolean nontemporal = options<1> == '1'; case op2<3:2> of when '00' memset.stage = MOPSStage_Prologue; when '01' memset.stage = MOPSStage_Main; when '10' memset.stage = MOPSStage_Epilogue; otherwise EndOfDecode(Decode_UNDEF);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set SET* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address and for option B is updated by the instruction, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set and is updated by the instruction, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set and is updated by the instruction, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set and is set to zero on completion of the instruction, encoded in the 'Rn' field.

<!-- image -->

<!-- image -->

Is the 64-bit name of the general-purpose register that holds the source data, encoded in the 'Rs' field.

## Operation

```
CheckMOPSEnabled(); CheckSETConstrainedUnpredictable(memset.n, memset.d, memset.s); constant bits(8) data = X[memset.s, 8]; MOPSBlockSize B = 0; memset.is_setg = FALSE; memset.nzcv = PSTATE.<N,Z,C,V>; memset.toaddress = X[memset.d, 64]; if memset.stage == MOPSStage_Prologue then memset.setsize = UInt(X[memset.n, 64]); else memset.setsize = SInt(X[memset.n, 64]); memset.implements_option_a = SETOptionA(); constant boolean privileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor accdesc = CreateAccDescMOPS(MemOp_STORE, privileged, nontemporal); if memset.stage == MOPSStage_Prologue then if memset.setsize > ArchMaxMOPSBlockSize then memset.setsize = ArchMaxMOPSBlockSize; if memset.implements_option_a then memset.nzcv = '0000'; memset.toaddress = memset.toaddress + memset.setsize; memset.setsize = 0 -memset.setsize; else memset.nzcv = '0010'; memset.stagesetsize = MemSetStageSize(memset); if memset.stage != MOPSStage_Prologue then CheckMemSetParams(memset, options);
```

```
AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; integer memory_set; boolean fault = FALSE; if memset.implements_option_a then while memset.stagesetsize < 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, 1); assert B <= -1 * memset.stagesetsize; (memory_set, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress + memset.setsize, data, B, accdesc); if memory_set != B then fault = TRUE; else memset.setsize = memset.setsize + B; memset.stagesetsize = memset.stagesetsize + B; else while memset.stagesetsize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, 1); assert B <= memset.stagesetsize; (memory_set, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress, data, B, accdesc); if memory_set != B then fault = TRUE; else memset.toaddress = memset.toaddress + B; memset.setsize = memset.setsize -B; memset.stagesetsize = memset.stagesetsize -B; UpdateSetRegisters(memset, fault, memory_set); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant boolean iswrite = TRUE; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memset.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memset.nzcv;
```

## C6.2.365 SETPTN, SETMTN, SETETN

Memory set, unprivileged and non-temporal

These instructions set a required number of bytes in memory to the value in the least significant byte of the source data register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPTN, then SETMTN, and then SETETN.

SETPTN performs some preconditioning of the arguments suitable for using the SETMTN instruction, and sets an IMPLEMENTATION DEFINED portion of the requested number of bytes. SETMTN sets a further IMPLEMENTATION DEFINED portion of the remaining bytes. SETETN sets any final remaining bytes.

Note

The ability to set an IMPLEMENTATION DEFINED number of bytes allows an implementation to optimize how the bytes being set are divided between the different instructions.

For more information on exceptions specific to memory set instructions, see Memory Copy and Memory Set exceptions.

The architecture supports two algorithms for the memory set: option A and option B. Which algorithm is used is IMPLEMENTATION DEFINED.

Note

Portable software should not assume that the choice of algorithm is constant.

For SETPTN:

- If Xn&lt;63&gt; == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF .

On completion of SETPTN, option A:

- Xn holds -1 times the number of bytes in the saturated set size remaining to be set.
- Xd holds the original Xd + saturated set size.
- PSTATE.{N,Z,C,V} are set to {0,0,0,0}.

On completion of SETPTN, option B:

- Xn holds the number of bytes in the saturated set size remaining to be set.
- Xd holds the lowest address that has not been set.
- PSTATE.{N,Z,C,V} are set to {0,0,1,0}.

For SETMTN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.
- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds -1 times the number of bytes remaining to be set.

For SETMTN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address that has not been set.

For SETETN, option A, when PSTATE.C = 0:

- Xn holds a signed 64-bit integer.
- Xn holds -1 times the number of bytes remaining to be set.
- Xd holds the lowest address to be set - Xn.
- On completion of the instruction, Xn holds 0.

For SETETN, option B, when PSTATE.C = 1:

- Xn holds the number of bytes remaining to be set.
- Xd holds the lowest address to be set.
- On completion of the instruction:
- Xn holds 0.
- Xd holds the lowest address that has not been set.

Explicit Memory Write effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory Write effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_MOPS)

<!-- image -->

## Encoding for the Prologue variant

```
Applies when (op2 == SETPTN [<Xd>]!, <Xn>!,
```

```
0011) <Xs>
```

## Encoding for the Main variant

```
Applies when (op2 == SETMTN [<Xd>]!, <Xn>!,
```

```
0111) <Xs>
```

## Encoding for the Epilogue variant

```
Applies when (op2 == 1011) SETETN [<Xd>]!, <Xn>!, <Xs>
```

## Decode for all variants of this encoding

```
'00' then EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_MOPS) || sz != SETParams memset; memset.d = UInt(Rd); memset.s = UInt(Rs); memset.n = UInt(Rn); constant bits(2) options = op2<1:0>; constant boolean nontemporal = options<1> == '1'; case op2<3:2> of when '00' memset.stage = MOPSStage_Prologue; when '01' memset.stage = MOPSStage_Main; when '10' memset.stage = MOPSStage_Epilogue; otherwise EndOfDecode(Decode_UNDEF);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly Memory Copy and Memory Set SET* and Crossing a page boundary with different memory types or Shareability attributes.

## Assembler Symbols

## &lt;Xd&gt;

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the 'Rd' field.

For the 'Epilogue' and 'Main' variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address and for option B is updated by the instruction, encoded in the 'Rd' field.

For the 'Prologue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set and is updated by the instruction, encoded in the 'Rn' field.

For the 'Main' variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set and is updated by the instruction, encoded in the 'Rn' field.

For the 'Epilogue' variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set and is set to zero on completion of the instruction, encoded in the 'Rn' field.

<!-- image -->

<!-- image -->

Is the 64-bit name of the general-purpose register that holds the source data, encoded in the 'Rs' field.

## Operation

```
CheckMOPSEnabled(); CheckSETConstrainedUnpredictable(memset.n, memset.d, memset.s); constant bits(8) data = X[memset.s, 8]; MOPSBlockSize B = 0; memset.is_setg = FALSE; memset.nzcv = PSTATE.<N,Z,C,V>; memset.toaddress = X[memset.d, 64]; if memset.stage == MOPSStage_Prologue then memset.setsize = UInt(X[memset.n, 64]); else memset.setsize = SInt(X[memset.n, 64]); memset.implements_option_a = SETOptionA(); constant boolean privileged = (if options<0> == '1' then AArch64.IsUnprivAccessPriv() else PSTATE.EL != EL0); constant AccessDescriptor accdesc = CreateAccDescMOPS(MemOp_STORE, privileged, nontemporal); if memset.stage == MOPSStage_Prologue then if memset.setsize > ArchMaxMOPSBlockSize then memset.setsize = ArchMaxMOPSBlockSize; if memset.implements_option_a then memset.nzcv = '0000'; memset.toaddress = memset.toaddress + memset.setsize; memset.setsize = 0 -memset.setsize; else memset.nzcv = '0010'; memset.stagesetsize = MemSetStageSize(memset); if memset.stage != MOPSStage_Prologue then CheckMemSetParams(memset, options);
```

```
AddressDescriptor memaddrdesc; PhysMemRetStatus memstatus; integer memory_set; boolean fault = FALSE; if memset.implements_option_a then while memset.stagesetsize < 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, 1); assert B <= -1 * memset.stagesetsize; (memory_set, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress + memset.setsize, data, B, accdesc); if memory_set != B then fault = TRUE; else memset.setsize = memset.setsize + B; memset.stagesetsize = memset.stagesetsize + B; else while memset.stagesetsize > 0 && !fault do // IMP DEF selection of the block size that is worked on. While many // implementations might make this constant, that is not assumed. B = SETSizeChoice(memset, 1); assert B <= memset.stagesetsize; (memory_set, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress, data, B, accdesc); if memory_set != B then fault = TRUE; else memset.toaddress = memset.toaddress + B; memset.setsize = memset.setsize -B; memset.stagesetsize = memset.stagesetsize -B; UpdateSetRegisters(memset, fault, memory_set); if fault then if IsFault(memaddrdesc) then AArch64.Abort(memaddrdesc.fault); else constant boolean iswrite = TRUE; HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc); if memset.stage == MOPSStage_Prologue then PSTATE.<N,Z,C,V> = memset.nzcv;
```

## C6.2.366 SEV

## Send event

This instruction is a hint instruction that causes an event to be signaled to all PEs in the multiprocessor system. For more information, see Wait for Event mechanism and Send event.

<!-- image -->

## Encoding

SEV

## Decode for this encoding

// Empty.

## Operation

SendEvent();

## C6.2.367 SEVL

## Send event local

This instruction is a hint instruction that causes an event to be signaled locally without requiring the event to be signaled to other PEs in the multiprocessor system. It can prime a wait-loop that starts with a WFE instruction.

<!-- image -->

<!-- image -->

## Encoding

SEVL

## Decode for this encoding

// Empty.

## Operation

SendEventLocal();

## C6.2.368 SMADDL

Signed multiply-add long

This instruction multiplies two 32-bit register values, adds a 64-bit register value, and writes the result to the 64-bit destination register.

This instruction is used by the alias SMULL.

<!-- image -->

## Encoding

SMADDL

&lt;Xd&gt;,

&lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;

## Decode for this encoding

```
constant integer d = constant integer n = constant integer m = constant integer a =
```

```
UInt(Rd); UInt(Rn); UInt(Rm); UInt(Ra);
```

## Assembler Symbols

&lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Xa&gt;

Is the 64-bit name of the third general-purpose source register holding the addend, encoded in the 'Ra' field.

## Alias Conditions

## Operation

```
constant bits(32) operand1 = X[n, 32]; constant bits(32) operand2 = X[m, 32]; constant bits(64) operand3 = X[a, 64]; constant integer result = SInt(operand3) + (SInt(operand1) * SInt(operand2)); X[d, 64] = result<63:0>;
```

<!-- image -->

| Alias   | Is preferred when   |
|---------|---------------------|
| SMULL   | Ra == '11111'       |

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.369 SMAX (immediate)

Signed maximum (immediate)

This instruction determines the signed maximum of the source register value and immediate, and writes the result to the destination register.

## Integer

(FEAT\_CSSC)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) SMAX <Wd>, <Wn>, #<simm>
```

## Encoding for the 64-bit variant

Applies when

```
(sf == 1) SMAX <Xd>, <Xn>, #<simm>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CSSC) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant integer imm = SInt(imm8);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;simm&gt;

Is a signed immediate, in the range -128 to 127, encoded in the 'imm8' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant integer result = Max(SInt(operand1), imm); X[d, datasize] = result<datasize-1:0>;
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.370 SMAX (register)

Signed maximum (register)

This instruction determines the signed maximum of the two source register values and writes the result to the destination register.

## Integer

(FEAT\_CSSC)

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
SMAX <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

Applies when (sf == 1)

```
SMAX
```

```
<Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CSSC) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf);
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = X[m, datasize]; constant integer result = X[d, datasize] = result<datasize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
Max(SInt(operand1), SInt(operand2));
```

## C6.2.371 SMC

Secure monitor call

This instruction causes an exception to EL3.

SMC is available only for software executing at EL1 or higher. It is UNDEFINED at EL0.

If the values of HCR\_EL2.TSC and SCR\_EL3.SMD are both 0, execution of an SMC instruction at EL1 or higher generates a Secure Monitor Call exception, recording it in ESR\_ELx, using the EC syndrome value 0x17 , that is taken to EL3.

If the value of HCR\_EL2.TSC is 1 and EL2 is enabled in the current Security state, execution of an SMC instruction at EL1 generates an exception that is taken to EL2, regardless of the value of SCR\_EL3.SMD.

If the value of HCR\_EL2.TSC is 0 and the value of SCR\_EL3.SMD is 1, the SMC instruction is UNDEFINED.

<!-- image -->

## Encoding

SMC

#&lt;imm&gt;

## Decode for this encoding

```
constant bits(16) imm = imm16;
```

## Assembler Symbols

&lt;imm&gt;

Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the 'imm16' field.

## Operation

```
if PSTATE.EL == EL0 then UNDEFINED; AArch64.CheckForSMCUndefOrTrap(imm);
```

AArch64.CallSecureMonitor(imm);

## C6.2.372 SMIN (immediate)

Signed minimum (immediate)

This instruction determines the signed minimum of the source register value and immediate, and writes the result to the destination register.

## Integer

(FEAT\_CSSC)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) SMIN <Wd>, <Wn>, #<simm>
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) SMIN <Xd>, <Xn>, #<simm>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CSSC) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant integer imm = SInt(imm8);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;simm&gt;

Is a signed immediate, in the range -128 to 127, encoded in the 'imm8' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant integer result = Min(SInt(operand1), imm); X[d, datasize] = result<datasize-1:0>;
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.373 SMIN (register)

Signed minimum (register)

This instruction determines the signed minimum of the two source register values and writes the result to the destination register.

## Integer

(FEAT\_CSSC)

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
SMIN <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

Applies when (sf == 1)

```
SMIN
```

```
<Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CSSC) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf);
```

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = X[m, datasize]; constant integer result = X[d, datasize] = result<datasize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
Min(SInt(operand1), SInt(operand2));
```

## C6.2.374 SMNEGL

Signed multiply-negate long

This instruction multiplies two 32-bit register values, negates the product, and writes the result to the 64-bit destination register.

This is an alias of SMSUBL. This means:

- The encodings in this description are named to match the encodings of SMSUBL.
- The description of SMSUBL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

```
SMNEGL <Xd>, <Wn>, <Wm>
```

## is equivalent to

```
SMSUBL <Xd>, <Wn>, <Wm>, XZR
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## Operation

The description of SMSUBL gives the operational pseudocode for this instruction.

## Operational Information

The description of SMSUBL gives the operational information for this instruction.

## C6.2.375 SMSTART

Enables access to Streaming SVE mode and SME architectural state

This instruction enables access to Streaming SVE mode and SME architectural state.

SMSTART enters Streaming SVE mode, and enables the SME ZA storage.

SMSTART SM enters Streaming SVE mode, but does not enable the SME ZA storage.

SMSTART ZA enables the SME ZA storage, but does not cause an entry to Streaming SVE mode.

This is an alias of MSR (immediate). This means:

- The encodings in this description are named to match the encodings of MSR (immediate).
- The description of MSR (immediate) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_SME)

<!-- image -->

## Encoding

| SMSTART          | {<option>}        |
|------------------|-------------------|
| is equivalent to | is equivalent to  |
| MSR              | <pstatefield>, #1 |

and is always the preferred disassembly.

## Assembler Symbols

## &lt;option&gt;

Is an optional mode, encoded in 'CRm&lt;2:1&gt;':

|   CRm<2:1> | <option>   | Description                     |
|------------|------------|---------------------------------|
|         00 | RESERVED   | •                               |
|         01 | SM         | Maps to <pstatefield> SVCRSM.   |
|         10 | ZA         | Maps to <pstatefield> SVCRZA.   |
|         11 | [absent]   | Maps to <pstatefield> SVCRSMZA. |

## Operation

The description of MSR (immediate) gives the operational pseudocode for this instruction.

## C6.2.376 SMSTOP

Disables access to Streaming SVE mode and SME architectural state

This instruction disables access to Streaming SVE mode and SME architectural state.

SMSTOP exits Streaming SVE mode, and disables the SME ZA storage.

SMSTOP SM exits Streaming SVE mode, but does not disable the SME ZA storage.

SMSTOP ZA disables the SME ZA storage, but does not cause an exit from Streaming SVE mode.

This is an alias of MSR (immediate). This means:

- The encodings in this description are named to match the encodings of MSR (immediate).
- The description of MSR (immediate) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_SME)

<!-- image -->

## Encoding

| SMSTOP           | {<option>}        |
|------------------|-------------------|
| is equivalent to | is equivalent to  |
| MSR              | <pstatefield>, #0 |

and is always the preferred disassembly.

## Assembler Symbols

## &lt;option&gt;

Is an optional mode, encoded in 'CRm&lt;2:1&gt;':

|   CRm<2:1> | <option>   | Description                     |
|------------|------------|---------------------------------|
|         00 | RESERVED   | •                               |
|         01 | SM         | Maps to <pstatefield> SVCRSM.   |
|         10 | ZA         | Maps to <pstatefield> SVCRZA.   |
|         11 | [absent]   | Maps to <pstatefield> SVCRSMZA. |

## Operation

The description of MSR (immediate) gives the operational pseudocode for this instruction.

## C6.2.377 SMSUBL

Signed multiply-subtract long

This instruction multiplies two 32-bit register values, subtracts the product from a 64-bit register value, and writes the result to the 64-bit destination register.

This instruction is used by the alias SMNEGL.

<!-- image -->

## Encoding

SMSUBL

&lt;Xd&gt;,

&lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;

## Decode for this encoding

```
constant integer d = constant integer n = constant integer m = constant integer a =
```

```
UInt(Rd); UInt(Rn); UInt(Rm); UInt(Ra);
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Xa&gt;

Is the 64-bit name of the third general-purpose source register holding the minuend, encoded in the 'Ra' field.

## Alias Conditions

## Operation

```
constant bits(32) operand1 = X[n, 32]; constant bits(32) operand2 = X[m, 32]; constant bits(64) operand3 = X[a, 64]; constant integer result = SInt(operand3) - (SInt(operand1) * SInt(operand2)); X[d, 64] = result<63:0>;
```

| Alias   | Is preferred when   |
|---------|---------------------|
| SMNEGL  | Ra == '11111'       |

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.378 SMULH

Signed multiply high

This instruction multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the 64-bit destination register.

<!-- image -->

## Encoding

```
SMULH <Xd>, <Xn>, <Xm>
```

## Decode for this encoding

```
constant integer d = constant integer n = constant integer m =
```

```
UInt(Rd); UInt(Rn); UInt(Rm);
```

## Assembler Symbols

&lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

&lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

<!-- image -->

&lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## Operation

```
constant bits(64) operand1 = X[n, 64]; constant bits(64) operand2 = X[m, 64]; constant integer result = SInt(operand1) * X[d, 64] = result<127:64>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
SInt(operand2);
```

## C6.2.379 SMULL

Signed multiply long

This instruction multiplies two 32-bit register values, and writes the result to the 64-bit destination register.

This is an alias of SMADDL. This means:

- The encodings in this description are named to match the encodings of SMADDL.
- The description of SMADDL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

<!-- image -->

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## Operation

The description of SMADDL gives the operational pseudocode for this instruction.

## Operational Information

The description of SMADDL gives the operational information for this instruction.

## C6.2.380 SSBB

Speculative store bypass barrier

This instruction is a memory barrier that prevents speculative loads from bypassing earlier stores to the same virtual address under certain conditions. For more information and details of the semantics, see Speculative Store Bypass Barrier (SSBB).

This is an alias of DSB. This means:

- The encodings in this description are named to match the encodings of DSB.
- The description of DSB gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

| SSBB             |
|------------------|
| is equivalent to |
| DSB #0           |

and is always the preferred disassembly.

## Operation

The description of DSB gives the operational pseudocode for this instruction.

## C6.2.381 ST2G

Store Allocation Tags

This instruction stores an Allocation Tag to two Tag Granules of memory. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag Granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.

This instruction generates an Unchecked access.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

(FEAT\_MTE)

<!-- image -->

## Encoding

```
ST2G <Xt|SP>, [<Xn|SP>], #<simm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE); constant boolean writeback = TRUE; constant boolean postindex = TRUE;
```

## Pre-index

(FEAT\_MTE)

<!-- image -->

## Encoding

```
ST2G <Xt|SP>, [<Xn|SP>, #<simm>]!
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE); constant boolean writeback = TRUE; constant boolean postindex = FALSE;
```

## Signed offset

(FEAT\_MTE)

<!-- image -->

## Encoding

```
ST2G <Xt|SP>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE); constant boolean writeback = FALSE; constant boolean postindex = FALSE;
```

## Assembler Symbols

## &lt;Xt|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the 'imm9' field.

## Operation

```
bits(64) address; bits(64) address2; constant bits(64) data = if t == 31 then SP[64] else X[t, 64]; constant bits(4) tag = AArch64.AllocationTagFromAddress(data); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant boolean stzgm = FALSE; constant AccessDescriptor accdesc = CreateAccDescLDGSTG(MemOp_STORE, stzgm, t); if !postindex then address = AddressAdd(address, offset, accdesc); address2 = AddressIncrement(address, TAG_GRANULE, accdesc); AArch64.MemTag[address , accdesc] = tag; AArch64.MemTag[address2, accdesc] = tag; if writeback then
```

```
if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## C6.2.382 ST64B

Single-copy atomic 64-byte store without status result

This instruction stores eight 64-bit doublewords from consecutive registers to a memory location. The store starts at register Xt , with the data being formed as Data[511:0] =

X(t+7)::X(t+6)::X(t+5)::X(t+4)::X(t+3)::X(t+2)::X(t+1)::Xt . The data is stored atomically and is required to be 64-byte aligned.

It is IMPLEMENTATION DEFINED which memory locations support this instruction. A memory location that supports ST64B also supports LD64B .

For more information, including about the memory types accessible and how the accesses are performed, see Single-copy atomic 64-byte load/store.

## Integer

(FEAT\_LS64)

<!-- image -->

## Encoding

```
ST64B <Xt>, [<Xn|SP>
```

```
{, #0}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LS64) then EndOfDecode(Decode_UNDEF); if Rt<4:3> == '11' || Rt<0> == '1' then EndOfDecode(Decode_UNDEF); constant boolean withstatus = FALSE; constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean tagchecked = n != 31;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly ST64B.

## Assembler Symbols

&lt;Xt&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
CheckLDST64BEnabled(); bits(512) data; bits(64) address; bits(64) value; constant AccessDescriptor accdesc = CreateAccDescLS64(MemOp_STORE, withstatus, tagchecked); for i = 0 to 7
```

```
value = X[t+i, 64]; if BigEndian(accdesc.acctype) then value = BigEndianReverse(value); data<63+64*i : 64*i> = value; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; MemStore64B(address, data, accdesc);
```

## C6.2.383 ST64BV

Single-copy atomic 64-byte store with status result

This instruction stores eight 64-bit doublewords from consecutive registers to a memory location, and writes the status result of the store to a register. The store starts at register Xt , with the data being formed as Data[511:0] = X(t+7)::X(t+6)::X(t+5)::X(t+4)::X(t+3)::X(t+2)::X(t+1)::Xt . The data is stored atomically and is required to be 64-byte aligned.

It is IMPLEMENTATION DEFINED which memory locations support this instruction. A memory location that supports ST64BV also supports ST64BV0 .

For more information, including about the memory types accessible and how the accesses are performed, see Single-copy atomic 64-byte load/store.

## Integer

(FEAT\_LS64\_V)

<!-- image -->

## Encoding

```
ST64BV <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LS64_V) then EndOfDecode(Decode_UNDEF); if Rt<4:3> == '11' || Rt<0> == '1' then EndOfDecode(Decode_UNDEF); constant boolean withstatus = TRUE; constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean tagchecked = n != 31;
```

## Assembler Symbols

<!-- image -->

Is the 64-bit name of the general-purpose register into which the status result of this instruction is written, encoded in the 'Rs' field.

The value returned is:

0xFFFFFFFF \_FFFFFFFF If the memory location accessed does not support this instruction. In this case, the value at the memory location is UNKNOWN.

!= 0xFFFFFFFF \_FFFFFFFF If the memory location accessed does support this instruction. In this case, the peripheral that provides the response defines the returned value and provides information on the state of the memory update at the memory location.

If XZR is used, then the return value is ignored.

## &lt;Xt&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
CheckST64BVEnabled(); bits(512) data; bits(64) address; bits(64) value; constant AccessDescriptor accdesc = CreateAccDescLS64(MemOp_STORE, withstatus, tagchecked); for i = 0 to 7 value = X[t+i, 64]; if BigEndian(accdesc.acctype) then value = BigEndianReverse(value); data<63+64*i : 64*i> = value; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(64) status = MemStore64BWithRet(address, data, accdesc); if s != 31 then X[s, 64] = status;
```

## C6.2.384 ST64BV0

Single-copy atomic 64-byte EL0 store with status result

This instruction stores eight 64-bit doublewords from consecutive registers to a memory location, with the bottom 32 bits taken from ACCDATA\_EL1, and writes the status result of the store to a register. The store starts at register Xt , with the data being formed as Data[511:0] =

X(t+7)::X(t+6)::X(t+5)::X(t+4)::X(t+3)::X(t+2)::X(t+1)::Xt[63:32]::ACCDATA\_EL1()[31:0] . The data is stored atomically and is required to be 64-byte aligned.

It is IMPLEMENTATION DEFINED which memory locations support this instruction. A memory location that supports ST64BV0 also supports ST64BV .

For more information, including about the memory types accessible and how the accesses are performed, see Single-copy atomic 64-byte load/store.

## Integer

(FEAT\_LS64\_ACCDATA)

<!-- image -->

## Encoding

```
ST64BV0 <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LS64_ACCDATA) then EndOfDecode(Decode_UNDEF); if Rt<4:3> == '11' || Rt<0> == '1' then EndOfDecode(Decode_UNDEF); constant boolean withstatus = TRUE; constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean tagchecked = n != 31;
```

## Assembler Symbols

<!-- image -->

Is the 64-bit name of the general-purpose register into which the status result of this instruction is written, encoded in the 'Rs' field.

The value returned is:

0xFFFFFFFF \_FFFFFFFF If the memory location accessed does not support this instruction. In this case, the value at the memory location is UNKNOWN.

!= 0xFFFFFFFF \_FFFFFFFF If the memory location accessed does support this instruction. In this case, the peripheral that provides the response defines the returned value and provides information on the state of the memory update at the memory location.

If XZR is used, then the return value is ignored.

## &lt;Xt&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
CheckST64BV0Enabled(); bits(512) data; bits(64) address; bits(64) value; constant AccessDescriptor accdesc = CreateAccDescLS64(MemOp_STORE, withstatus, tagchecked); constant bits(64) Xt = X[t, 64]; value<31:0> = ACCDATA_EL1<31:0>; value<63:32> = Xt<63:32>; if BigEndian(accdesc.acctype) then value = BigEndianReverse(value); data<63:0> = value; for i = 1 to 7 value = X[t+i, 64]; if BigEndian(accdesc.acctype) then value = BigEndianReverse(value); data<63+64*i : 64*i> = value; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant bits(64) status = MemStore64BWithRet(address, data, accdesc); if s != 31 then X[s, 64] = status;
```

## C6.2.385 STADD, STADDL

Atomic add on word or doubleword, without return

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory.

- STADD does not have release semantics.
- STADDL stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDADD, LDADDA, LDADDAL, LDADDL. This means:

- The encodings in this description are named to match the encodings of LDADD, LDADDA, LDADDAL, LDADDL.
- The description of LDADD, LDADDA, LDADDAL, LDADDL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

(size ==

STADD

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

is equivalent to

LDADD

&lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;]

and is always the preferred disassembly.

## Encoding for the 32-bit release variant

Applies when

(size ==

```
STADDL <Ws>, [<Xn|SP>]
```

is equivalent to

```
LDADDL <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 64-bit no memory ordering variant

Applies when

(size ==

```
STADD <Xs>, [<Xn|SP>]
```

is equivalent to

```
LDADD <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

11

&amp;&amp;

R

==

0)

10

&amp;&amp;

R

==

1)

10

&amp;&amp;

R

==

0)

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && R == 1) STADDL <Xs>, [<Xn|SP>] is equivalent to LDADDL <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

The description of LDADD, LDADDA, LDADDAL, LDADDL gives the operational pseudocode for this instruction.

## Operational Information

The description of LDADD, LDADDA, LDADDAL, LDADDL gives the operational information for this instruction.

## C6.2.386 STADDB, STADDLB

Atomic add on byte, without return

This instruction atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory.

- STADDB does not have release semantics.
- STADDLB stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDADDB, LDADDAB, LDADDALB, LDADDLB. This means:

- The encodings in this description are named to match the encodings of LDADDB, LDADDAB, LDADDALB, LDADDLB.
- The description of LDADDB, LDADDAB, LDADDALB, LDADDLB gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STADDB <Ws>, [<Xn|SP>] is equivalent to LDADDB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STADDLB <Ws>, [<Xn|SP>] is equivalent to LDADDLB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDADDB, LDADDAB, LDADDALB, LDADDLB gives the operational pseudocode for this instruction.

## Operational Information

The description of LDADDB, LDADDAB, LDADDALB, LDADDLB gives the operational information for this instruction.

## C6.2.387 STADDH, STADDLH

Atomic add on halfword, without return

This instruction atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory.

- STADDH does not have release semantics.
- STADDLH stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDADDH, LDADDAH, LDADDALH, LDADDLH. This means:

- The encodings in this description are named to match the encodings of LDADDH, LDADDAH, LDADDALH, LDADDLH.
- The description of LDADDH, LDADDAH, LDADDALH, LDADDLH gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STADDH <Ws>, [<Xn|SP>] is equivalent to LDADDH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STADDLH <Ws>, [<Xn|SP>] is equivalent to LDADDLH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDADDH, LDADDAH, LDADDALH, LDADDLH gives the operational pseudocode for this instruction.

## Operational Information

The description of LDADDH, LDADDAH, LDADDALH, LDADDLH gives the operational information for this instruction.

## C6.2.388 STCLR, STCLRL

Atomic bit clear on word or doubleword, without return

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.

- STCLR does not have release semantics.
- STCLRL stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDCLR, LDCLRA, LDCLRAL, LDCLRL. This means:

- The encodings in this description are named to match the encodings of LDCLR, LDCLRA, LDCLRAL, LDCLRL.
- The description of LDCLR, LDCLRA, LDCLRAL, LDCLRL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

(size ==

STCLR

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

is equivalent to

LDCLR

&lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;]

and is always the preferred disassembly.

## Encoding for the 32-bit release variant

Applies when

(size ==

```
STCLRL <Ws>, [<Xn|SP>]
```

is equivalent to

```
LDCLRL <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 64-bit no memory ordering variant

Applies when

(size ==

```
STCLR <Xs>, [<Xn|SP>]
```

is equivalent to

```
LDCLR <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

11

&amp;&amp;

R

==

0)

10

&amp;&amp;

R

==

1)

10

&amp;&amp;

R

==

0)

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && R == 1) STCLRL <Xs>, [<Xn|SP>] is equivalent to LDCLRL <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

The description of LDCLR, LDCLRA, LDCLRAL, LDCLRL gives the operational pseudocode for this instruction.

## Operational Information

The description of LDCLR, LDCLRA, LDCLRAL, LDCLRL gives the operational information for this instruction.

## C6.2.389 STCLRB, STCLRLB

Atomic bit clear on byte, without return

This instruction atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.

- STCLRB does not have release semantics.
- STCLRLB stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB. This means:

- The encodings in this description are named to match the encodings of LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB.
- The description of LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STCLRB <Ws>, [<Xn|SP>] is equivalent to LDCLRB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STCLRLB <Ws>, [<Xn|SP>] is equivalent to LDCLRLB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB gives the operational pseudocode for this instruction.

## Operational Information

The description of LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB gives the operational information for this instruction.

## C6.2.390 STCLRH, STCLRLH

Atomic bit clear on halfword, without return

This instruction atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.

- STCLRH does not have release semantics.
- STCLRLH stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH. This means:

- The encodings in this description are named to match the encodings of LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH.
- The description of LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STCLRH <Ws>, [<Xn|SP>] is equivalent to LDCLRH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STCLRLH <Ws>, [<Xn|SP>] is equivalent to LDCLRLH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH gives the operational pseudocode for this instruction.

## Operational Information

The description of LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH gives the operational information for this instruction.

## C6.2.391 STEOR, STEORL

Atomic exclusive-OR on word or doubleword, without return

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory.

- STEOR does not have release semantics.
- STEORL stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDEOR, LDEORA, LDEORAL, LDEORL. This means:

- The encodings in this description are named to match the encodings of LDEOR, LDEORA, LDEORAL, LDEORL.
- The description of LDEOR, LDEORA, LDEORAL, LDEORL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

(size ==

STEOR

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

is equivalent to

```
LDEOR <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 32-bit release variant

Applies when

(size ==

```
STEORL <Ws>, [<Xn|SP>]
```

is equivalent to

```
LDEORL <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 64-bit no memory ordering variant

Applies when

(size ==

```
STEOR <Xs>, [<Xn|SP>]
```

is equivalent to

```
LDEOR <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

11

&amp;&amp;

R

==

0)

10

&amp;&amp;

R

==

1)

10

&amp;&amp;

R

==

0)

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && R == 1) STEORL <Xs>, [<Xn|SP>] is equivalent to LDEORL <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

The description of LDEOR, LDEORA, LDEORAL, LDEORL gives the operational pseudocode for this instruction.

## Operational Information

The description of LDEOR, LDEORA, LDEORAL, LDEORL gives the operational information for this instruction.

## C6.2.392 STEORB, STEORLB

Atomic exclusive-OR on byte, without return

This instruction atomically loads an 8-bit byte from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory.

- STEORB does not have release semantics.
- STEORLB stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDEORB, LDEORAB, LDEORALB, LDEORLB. This means:

- The encodings in this description are named to match the encodings of LDEORB, LDEORAB, LDEORALB, LDEORLB.
- The description of LDEORB, LDEORAB, LDEORALB, LDEORLB gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STEORB <Ws>, [<Xn|SP>] is equivalent to LDEORB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STEORLB <Ws>, [<Xn|SP>] is equivalent to LDEORLB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDEORB, LDEORAB, LDEORALB, LDEORLB gives the operational pseudocode for this instruction.

## Operational Information

The description of LDEORB, LDEORAB, LDEORALB, LDEORLB gives the operational information for this instruction.

## C6.2.393 STEORH, STEORLH

Atomic exclusive-OR on halfword, without return

This instruction atomically loads a 16-bit halfword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory.

- STEORH does not have release semantics.
- STEORLH stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDEORH, LDEORAH, LDEORALH, LDEORLH. This means:

- The encodings in this description are named to match the encodings of LDEORH, LDEORAH, LDEORALH, LDEORLH.
- The description of LDEORH, LDEORAH, LDEORALH, LDEORLH gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STEORH <Ws>, [<Xn|SP>] is equivalent to LDEORH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STEORLH <Ws>, [<Xn|SP>] is equivalent to LDEORLH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDEORH, LDEORAH, LDEORALH, LDEORLH gives the operational pseudocode for this instruction.

## Operational Information

The description of LDEORH, LDEORAH, LDEORALH, LDEORLH gives the operational information for this instruction.

## C6.2.394 STG

Store Allocation Tag

This instruction stores an Allocation Tag to memory. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag Granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.

This instruction generates an Unchecked access.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

(FEAT\_MTE)

<!-- image -->

## Encoding

```
STG <Xt|SP>, [<Xn|SP>], #<simm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE); constant boolean writeback = TRUE; constant boolean postindex = TRUE;
```

## Pre-index

(FEAT\_MTE)

<!-- image -->

## Encoding

```
STG <Xt|SP>, [<Xn|SP>, #<simm>]!
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE); constant boolean writeback = TRUE; constant boolean postindex = FALSE;
```

## Signed offset

(FEAT\_MTE)

<!-- image -->

## Encoding

```
STG <Xt|SP>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE); constant boolean writeback = FALSE; constant boolean postindex = FALSE;
```

## Assembler Symbols

## &lt;Xt|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the 'imm9' field.

## Operation

```
bits(64) address; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant boolean stzgm = FALSE; constant AccessDescriptor accdesc = CreateAccDescLDGSTG(MemOp_STORE, stzgm, t); if !postindex then address = AddressAdd(address, offset, accdesc); constant bits(64) data = if t == 31 then SP[64] else X[t, 64]; constant bits(4) tag = AArch64.AllocationTagFromAddress(data); AArch64.MemTag[address, accdesc] = tag; if writeback then if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then
```

```
SP[64] = address; else X[n, 64] = address;
```

## C6.2.395 STGM

Store Allocation Tag multiple

This instruction writes a naturally aligned block of N Allocation Tags, where the size of N is identified in GMID\_EL1.BS, and the Allocation Tag written to address A is taken from the source register at 4*A&lt;7:4&gt;+3:4*A&lt;7:4&gt;.

This instruction is UNDEFINED at EL0.

This instruction generates an Unchecked access.

## Integer

(FEAT\_MTE2)

<!-- image -->

## Encoding

```
STGM <Xt>, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE2) then constant integer t = UInt(Rt); constant integer n = UInt(Rn);
```

## Assembler Symbols

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if PSTATE.EL == EL0 then UNDEFINED; constant bits(64) data = X[t, 64]; bits(64) address; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant integer size = 4 * (2 ^ (UInt(GMID_EL1.BS))); address = Align(address, size); constant integer count = size >> LOG2_TAG_GRANULE; integer index = UInt(address<LOG2_TAG_GRANULE+3:LOG2_TAG_GRANULE>); constant bits(64) curraddress = address; constant boolean stzgm = FALSE; constant AccessDescriptor accdesc = CreateAccDescLDGSTG(MemOp_STORE, stzgm, t); for i = 0 to count-1 constant bits(4) tag = Elem[data, index, 4];
```

```
EndOfDecode(Decode_UNDEF);
```

```
AArch64.MemTag[address, accdesc] = tag; address = AddressIncrement(address, TAG_GRANULE, accdesc); index = index + 1;
```

## C6.2.396 STGP

Store Allocation Tag and pair of registers

This instruction stores an Allocation Tag and two 64-bit doublewords to memory, from two registers. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag Granule. The Allocation Tag is calculated from the Logical Address Tag in the base register.

This instruction generates an Unchecked access.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

(FEAT\_MTE)

<!-- image -->

## Encoding

```
STGP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE); constant boolean writeback = TRUE; constant boolean postindex = TRUE;
```

## Pre-index

(FEAT\_MTE)

<!-- image -->

## Encoding

```
STGP <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(simm7, 64), constant boolean writeback = TRUE; constant boolean postindex = FALSE;
```

```
LOG2_TAG_GRANULE);
```

## Signed offset

(FEAT\_MTE)

<!-- image -->

## Encoding

```
STGP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE); constant boolean writeback = FALSE; constant boolean postindex = FALSE;
```

## Assembler Symbols

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the 'Post-index' and 'Pre-index' variants: is the signed immediate offset, a multiple of 16 in the range -1024 to 1008, encoded in the 'simm7' field.

For the 'Signed offset' variant: is the optional signed immediate offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the 'simm7' field.

## Operation

```
bits(64) address; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant boolean stzgm = FALSE; constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescLDGSTG(MemOp_STORE, stzgm, ispair, t, t2); if !postindex then address = AddressAdd(address, offset, accdesc);
```

```
if !IsAligned(address, TAG_GRANULE) then constant FaultRecord fault = AlignmentFault(accdesc, address); AArch64.Abort(fault); constant bits(128) data = (if BigEndian(accdesc.acctype) then X[t, 64]:X[t2, 64] else X[t2, 64]:X[t, 64]); Mem[address, 16, accdesc] = data; AArch64.MemTag[address, accdesc] = AArch64.AllocationTagFromAddress(address); if writeback then if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## C6.2.397 STILP

Store-release ordered pair of registers

This instruction calculates an address from a base register value and an optional offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information on single-copy atomicity and alignment requirements, see Requirements for single-copy atomicity and Alignment of data accesses. The instruction also has memory ordering semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release, with the additional requirement that:

- When using the pre-index addressing mode, the Memory effects associated with Xt2/Wt2 are Ordered-before the Memory effects associated with Xt1/Wt1.
- For all other addressing modes, the Memory effects associated with Xt1/Wt1 are Ordered-before the Memory effects associated with Xt2/Wt2.

For information about addressing modes, see Load/Store addressing modes.

## Integer

(FEAT\_LRCPC3)

<!-- image -->

## Encoding for the 32-bit pre-index variant

```
Applies when (size == 10 && opc2 == 0000) STILP <Wt1>, <Wt2>, [<Xn|SP>, #-8]!
```

## Encoding for the 32-bit variant

```
Applies when (size == 10 && opc2 == 0001) STILP <Wt1>, <Wt2>, [<Xn|SP>]
```

## Encoding for the 64-bit pre-index variant

```
== 0000)
```

```
Applies when (size == 11 && opc2 STILP <Xt1>, <Xt2>, [<Xn|SP>, #-16]!
```

## Encoding for the 64-bit variant

```
Applies when (size == 11 && opc2 == 0001) STILP <Xt1>, <Xt2>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LRCPC3) then constant boolean ispair = TRUE; constant boolean wback = opc2<0> == '0';
```

```
EndOfDecode(Decode_UNDEF);
```

STILP has the same CONSTRAINED UNPREDICTABLE behavior as STP . For information about this CONSTRAINED UNPREDICTABLE behavior, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly STP and STILP.

## Assembler Symbols

## &lt;Wt1&gt;

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Wt2&gt;

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant integer{} scale = 2 + UInt(size<0>); constant integer{} datasize = 8 << scale; constant integer offset = if opc2<0> == '0' then -1 * (2 << scale) else 0; constant boolean acqrel = FALSE; constant boolean tagchecked = wback || n != 31; boolean rt_unknown = FALSE; if wback && (t == n || t2 == n) && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST); assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_NONE rt_unknown = FALSE; // value stored is pre-writeback when Constraint_UNKNOWN rt_unknown = TRUE; // value stored is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

## Operation

```
bits(64) address; bits(datasize) data1; bits(datasize) data2; constant integer dbytes = datasize DIV 8; AccessDescriptor accdesc = CreateAccDescAcqRel(MemOp_STORE, tagchecked, ispair, acqrel, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); if rt_unknown && t == n then data1 = bits(datasize) UNKNOWN; else data1 = X[t, datasize];
```

```
if rt_unknown && t2 == n then data2 = bits(datasize) UNKNOWN; else data2 = X[t2, datasize]; bits(2*datasize) full_data; if BigEndian(accdesc.acctype) then full_data = data1:data2; else full_data = data2:data1; accdesc.highestaddressfirst = offset < 0; Mem[address, 2*dbytes, accdesc] = full_data; if wback then if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.398 STLLR

## Store LORelease register

This instruction stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LOR)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) STLLR <Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) STLLR <Xt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LOR) then EndOfDecode(Decode_UNDEF);
```

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer elsize = 8 << UInt(size); constant boolean acquire = FALSE; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

&lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Operation

```
bits(64) address; constant integer dbytes = elsize DIV 8; constant AccessDescriptor accdesc = CreateAccDescLOR(MemOp_STORE, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; Mem[address, dbytes, accdesc] = X[t, elsize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.399 STLLRB

Store LORelease register byte

This instruction stores a byte from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LOR)

<!-- image -->

## Encoding

```
STLLRB <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LOR) then EndOfDecode(Decode_UNDEF);
```

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = FALSE; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

&lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

<!-- image -->

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = CreateAccDescLOR(MemOp_STORE, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; Mem[address, 1, accdesc] = X[t, 8];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.400 STLLRH

Store LORelease register halfword

This instruction stores a halfword from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LOR)

<!-- image -->

## Encoding

```
STLLRH <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LOR) then EndOfDecode(Decode_UNDEF);
```

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = FALSE; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

&lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

<!-- image -->

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = CreateAccDescLOR(MemOp_STORE, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; Mem[address, 2, accdesc] = X[t, 16];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.401 STLR

## Store-release register

This instruction stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about addressing modes, see Load/Store addressing modes.

It has encodings from 2 classes: No offset and Pre-index

## No offset

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) STLR <Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) STLR <Xt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
UInt(size);
```

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean wback = FALSE; constant integer offset = 0; constant boolean rt_unknown = FALSE; constant integer elsize = 8 << constant integer datasize = elsize; constant boolean acquire = FALSE; constant boolean tagchecked = n != 31;
```

## Pre-index

## (FEAT\_LRCPC3)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) STLR <Wt>, [<Xn|SP>, #-4]!
```

## Encoding for the 64-bit variant

```
Applies when (size == STLR
```

```
11) <Xt>, [<Xn|SP>, #-8]!
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LRCPC3) then EndOfDecode(Decode_UNDEF); constant boolean wback = TRUE; constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant integer offset = -1 * (1 << UInt(size)); constant boolean acquire = FALSE; constant boolean tagchecked = TRUE; boolean rt_unknown = FALSE; if n == t && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST); assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_NONE rt_unknown = FALSE; // value stored is original value when Constraint_UNKNOWN rt_unknown = TRUE; // value stored is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Operation

```
bits(64) address; constant integer dbytes = datasize DIV 8; constant AccessDescriptor accdesc = CreateAccDescAcqRel(MemOp_STORE, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); bits(datasize) data; if rt_unknown then data = bits(datasize) UNKNOWN; else data = X[t, datasize]; Mem[address, dbytes, accdesc] = data; if wback then if n == 31 then
```

```
SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.402 STLRB

Store-release register byte

This instruction stores a byte from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

STLRB

&lt;Wt&gt;, [&lt;Xn|SP&gt;{, #0}]

## Decode for this encoding

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = FALSE; constant boolean tagchecked =
```

```
n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = CreateAccDescAcqRel(MemOp_STORE, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; Mem[address, 1, accdesc] = X[t, 8];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.403 STLRH

## Store-release register halfword

This instruction stores a halfword from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

STLRH

&lt;Wt&gt;, [&lt;Xn|SP&gt;{, #0}]

## Decode for this encoding

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = FALSE; constant boolean tagchecked =
```

```
n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = CreateAccDescAcqRel(MemOp_STORE, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; Mem[address, 2, accdesc] = X[t, 16];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.404 STLTXR

Store-release unprivileged exclusive register

This instruction stores a 32-bit word or a 64-bit doubleword to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

Note

For the purposes of the Exclusives monitors, and the forward progress guarantees for Load-Exclusive and Store-Exclusive loops, STLTXR is equivalent to STXR .

For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LSUI)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sz == 0) STLTXR <Ws>,
```

```
<Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (sz == 1) STLTXR <Ws>, <Xt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer elsize = 32 << UInt(sz); constant boolean acqrel = TRUE; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; boolean rn_unknown = FALSE; if s == t then constant Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
```

```
case c of value
```

```
when Constraint_UNKNOWN rt_unknown = TRUE; // store UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); if s == n && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rn_unknown = TRUE; // address is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

STLTXR has the same CONSTRAINED UNPREDICTABLE behavior as STLXR . See Architectural Constraints on UNPREDICTABLE behaviors, and particularly STLXR.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rs' field. The value returned is:

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

Aborts and alignment

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Ws&gt; is not updated.

Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort exception to be generated, subject to the following rules:

- If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.
- Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
bits(64) address; bits(elsize) data; constant integer dbytes = elsize DIV 8; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; elsif rn_unknown then
```

```
address = bits(64) UNKNOWN; else address = X[n, 64]; if rt_unknown then data = bits(elsize) UNKNOWN; else data = X[t, elsize]; bit status = '1'; // Check whether the Exclusives monitors are set to include the // physical memory locations corresponding to virtual address // range [address, address+dbytes-1]. // If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, // if accessed, would generate a synchronous Data Abort exception, it is // IMPLEMENTATION DEFINED whether the exception is generated. // It is a limitation of this model that synchronous Data Aborts are never // generated in this case, as Mem[] is not called. // If FEAT_SPE is implemented, it is also IMPLEMENTATION DEFINED whether or not the // physical address packet is output when permitted and when // AArch64.ExclusiveMonitorPass() returns FALSE for a Store Exclusive instruction. // This behavior is not reflected here due to the previously stated limitation. if AArch64.ExclusiveMonitorsPass(address, dbytes, accdesc) then // This atomic write will be rejected if it does not refer // to the same physical locations after address translation. Mem[address, dbytes, accdesc] = data; status = ExclusiveMonitorsStatus(); X[s, 32] = ZeroExtend(status, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.405 STLUR

Store-release register (unscaled)

This instruction calculates an address from a base register value and an immediate offset, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register.

The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release

For information about addressing modes, see Load/Store addressing modes.

## Unscaled offset (FEAT\_LRCPC2)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) STLUR
```

```
<Wt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

Applies when

```
STLUR
```

```
(size == 11) <Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LRCPC2) then EndOfDecode(Decode_UNDEF); constant integer scale = UInt(size); constant bits(64) offset = SignExtend(imm9, 64); constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant integer datasize = 8 << scale; constant boolean acquire = FALSE; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

<!-- image -->

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = CreateAccDescAcqRel(MemOp_STORE, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Mem[address, datasize DIV 8, accdesc] = X[t, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.406 STLURB

Store-release register byte (unscaled)

This instruction calculates an address from a base register value and an immediate offset, and stores a byte to the calculated address, from a 32-bit register.

The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release For information about addressing modes, see Load/Store addressing modes.

## Unscaled offset (FEAT\_LRCPC2)

<!-- image -->

## Encoding

```
STLURB <Wt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LRCPC2) then EndOfDecode(Decode_UNDEF); constant bits(64) offset = SignExtend(imm9, 64); constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant integer datasize = 8; constant boolean acquire = FALSE; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = CreateAccDescAcqRel(MemOp_STORE, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc);
```

Mem[address, datasize DIV 8, accdesc] = X[t, datasize];

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.407 STLURH

Store-release register halfword (unscaled)

This instruction calculates an address from a base register value and an immediate offset, and stores a halfword to the calculated address, from a 32-bit register.

The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release For information about addressing modes, see Load/Store addressing modes.

## Unscaled offset (FEAT\_LRCPC2)

<!-- image -->

## Encoding

```
STLURH <Wt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LRCPC2) then EndOfDecode(Decode_UNDEF); constant bits(64) offset = SignExtend(imm9, 64); constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant integer datasize = 16; constant boolean acquire = FALSE; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Operation

```
bits(64) address; constant AccessDescriptor accdesc = CreateAccDescAcqRel(MemOp_STORE, tagchecked, acquire, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc);
```

Mem[address, datasize DIV 8, accdesc] = X[t, datasize];

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.408 STLXP

Store-release exclusive pair of registers

This instruction stores two 32-bit words or two 64-bit doublewords to a memory location if the PE has exclusive access to the memory address, from two registers, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. For information on single-copy atomicity and alignment requirements, see Requirements for single-copy atomicity and Alignment of data accesses. If a 64-bit pair Store-Exclusive succeeds, it causes a single-copy atomic update of the 128-bit memory location being updated. The instruction also has memory ordering semantics, as described in Load-Acquire, Store-Release. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sz == 0) STLXP <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (sz == 1) STLXP <Ws>, <Xt1>,
```

```
<Xt2>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant integer elsize = 32 << UInt(sz); constant integer datasize = elsize * 2; constant boolean acqrel = TRUE; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; boolean rn_unknown = FALSE; if s == t || (s == t2) then constant Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // store UNKNOWN value when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); if s == n && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rn_unknown = TRUE; // address is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly STLXP.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rs' field. The value returned is:

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

## &lt;Wt1&gt;

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Wt2&gt;

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

Aborts and alignment

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Ws&gt; is not updated.

Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort exception to be generated, subject to the following rules:

- If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.
- Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
bits(64) address; bits(datasize) data; constant integer dbytes = datasize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant boolean ispair = FALSE; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked, privileged, ispair, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; elsif rn_unknown then address = bits(64) UNKNOWN; else address = X[n, 64]; if rt_unknown then data = bits(datasize) UNKNOWN; else
```

```
constant bits(datasize DIV 2) el1 = X[t, datasize DIV 2]; constant bits(datasize DIV 2) el2 = X[t2, datasize DIV 2]; data = if BigEndian(accdesc.acctype) then el1:el2 else el2:el1; bit status = '1'; // Check whether the Exclusives monitors are set to include the // physical memory locations corresponding to virtual address // range [address, address+dbytes-1]. // If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, // if accessed, would generate a synchronous Data Abort exception, it is // IMPLEMENTATION DEFINED whether the exception is generated. // It is a limitation of this model that synchronous Data Aborts are never // generated in this case, as Mem[] is not called. // If FEAT_SPE is implemented, it is also IMPLEMENTATION DEFINED whether or not the // physical address packet is output when permitted and when // AArch64.ExclusiveMonitorPass() returns FALSE for a Store Exclusive instruction. // This behavior is not reflected here due to the previously stated limitation. if AArch64.ExclusiveMonitorsPass(address, dbytes, accdesc) then // This atomic write will be rejected if it does not refer // to the same physical locations after address translation. Mem[address, dbytes, accdesc] = data; status = ExclusiveMonitorsStatus(); X[s, 32] = ZeroExtend(status, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.409 STLXR

Store-release exclusive register

This instruction stores a 32-bit word or a 64-bit doubleword to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) STLXR <Ws>,
```

```
<Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

Applies when

```
<Xt>, [<Xn|SP>{, #0}]
```

```
(size == 11) STLXR <Ws>,
```

## Decode for all variants of this encoding

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer elsize = 8 << UInt(size); constant boolean acqrel = TRUE; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; boolean rn_unknown = FALSE; if s == t then constant Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // store UNKNOWN value when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); if s == n && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rn_unknown = TRUE; // address is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly STLXR.

## Assembler Symbols

&lt;Ws&gt;

Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rs' field. The value returned is:

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xt&gt;

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

Aborts and alignment

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Ws&gt; is not updated.

Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort exception to be generated, subject to the following rules:

- If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.
- Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
bits(64) address; bits(elsize) data; constant integer dbytes = elsize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; elsif rn_unknown then address = bits(64) UNKNOWN; else address = X[n, 64]; if rt_unknown then data = bits(elsize) UNKNOWN; else data = X[t, elsize]; bit status = '1'; // Check whether the Exclusives monitors are set to include the // physical memory locations corresponding to virtual address // range [address, address+dbytes-1]. // If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, // if accessed, would generate a synchronous Data Abort exception, it is // IMPLEMENTATION DEFINED whether the exception is generated. // It is a limitation of this model that synchronous Data Aborts are never // generated in this case, as Mem[] is not called. // If FEAT_SPE is implemented, it is also IMPLEMENTATION DEFINED whether or not the // physical address packet is output when permitted and when // AArch64.ExclusiveMonitorPass() returns FALSE for a Store Exclusive instruction. // This behavior is not reflected here due to the previously stated limitation.
```

```
if AArch64.ExclusiveMonitorsPass(address, dbytes, accdesc) then // This atomic write will be rejected if it does not refer // to the same physical locations after address translation. Mem[address, dbytes, accdesc] = data; status = ExclusiveMonitorsStatus(); X[s, 32] = ZeroExtend(status, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.410 STLXRB

Store-release exclusive register byte

This instruction stores a byte from a 32-bit register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
STLXRB <Ws>, <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acqrel = TRUE; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; boolean rn_unknown = FALSE; if s == t then constant Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // store UNKNOWN value when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); if s == n && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rn_unknown = TRUE; // address is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly STLXRB.

## Assembler Symbols

&lt;Ws&gt;

Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rs' field. The value returned is:

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

&lt;Wt&gt;

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

Aborts

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Ws&gt; is not updated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
bits(64) address; bits(8) data; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; elsif rn_unknown then address = bits(64) UNKNOWN; else address = X[n, 64]; if rt_unknown then data = bits(8) UNKNOWN; else data = X[t, 8]; bit status = '1'; // Check whether the Exclusives monitors are set to include the // physical memory locations corresponding to virtual address // range [address, address+dbytes-1]. // If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, // if accessed, would generate a synchronous Data Abort exception, it is // IMPLEMENTATION DEFINED whether the exception is generated. // It is a limitation of this model that synchronous Data Aborts are never // generated in this case, as Mem[] is not called. // If FEAT_SPE is implemented, it is also IMPLEMENTATION DEFINED whether or not the // physical address packet is output when permitted and when // AArch64.ExclusiveMonitorPass() returns FALSE for a Store Exclusive instruction. // This behavior is not reflected here due to the previously stated limitation. if AArch64.ExclusiveMonitorsPass(address, 1, accdesc) then // This atomic write will be rejected if it does not refer // to the same physical locations after address translation. Mem[address, 1, accdesc] = data; status = ExclusiveMonitorsStatus(); X[s, 32] = ZeroExtend(status, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.411 STLXRH

Store-release exclusive register halfword

This instruction stores a halfword from a 32-bit register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
STLXRH <Ws>, <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acqrel = TRUE; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; boolean rn_unknown = FALSE; if s == t then constant Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // store UNKNOWN value when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); if s == n && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rn_unknown = TRUE; // address is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly STLXRH.

## Assembler Symbols

&lt;Ws&gt;

Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rs' field. The value returned is:

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

&lt;Wt&gt;

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

Aborts and alignment

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Ws&gt; is not updated.

Anon halfword-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject to the following rules:

- If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.
- Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
bits(64) address; bits(16) data; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; elsif rn_unknown then address = bits(64) UNKNOWN; else address = X[n, 64]; if rt_unknown then data = bits(16) UNKNOWN; else data = X[t, 16]; bit status = '1'; // Check whether the Exclusives monitors are set to include the // physical memory locations corresponding to virtual address // range [address, address+dbytes-1]. // If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, // if accessed, would generate a synchronous Data Abort exception, it is // IMPLEMENTATION DEFINED whether the exception is generated. // It is a limitation of this model that synchronous Data Aborts are never // generated in this case, as Mem[] is not called. // If FEAT_SPE is implemented, it is also IMPLEMENTATION DEFINED whether or not the // physical address packet is output when permitted and when // AArch64.ExclusiveMonitorPass() returns FALSE for a Store Exclusive instruction. // This behavior is not reflected here due to the previously stated limitation. if AArch64.ExclusiveMonitorsPass(address, 2, accdesc) then // This atomic write will be rejected if it does not refer // to the same physical locations after address translation. Mem[address, 2, accdesc] = data; status = ExclusiveMonitorsStatus(); X[s, 32] = ZeroExtend(status, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.412 STNP

Store pair of registers, with non-temporal hint

This instruction calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information about addressing modes, see Load/Store addressing modes. For information about non-temporal pair instructions, see Load/Store non-temporal pair.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) STNP
```

```
<Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) STNP
```

```
<Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for all variants of this encoding

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = TRUE; constant integer scale = 2 + UInt(opc<1>); constant integer datasize = 8 << scale; constant bits(64) offset = LSL(SignExtend(imm7, 64), scale); constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Wt1&gt;

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Wt2&gt;

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the '32-bit' variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/4.

For the '64-bit' variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/8.

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

<!-- image -->

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## Operation

```
bits(64) address; constant integer dbytes = datasize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, ispair, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(2*datasize) data = (if BigEndian(accdesc.acctype) then X[t, datasize]:X[t2, datasize] else X[t2, datasize]:X[t, datasize]); Mem[address, 2 * dbytes, accdesc] = data;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.413 STP

Store pair of registers

This instruction calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information about addressing modes, see Load/Store addressing modes.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) STP <Wt1>, <Wt2>, [<Xn|SP>], #<imm>
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) STP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>
```

## Decode for all variants of this encoding

```
constant boolean wback = TRUE; constant boolean postindex = TRUE;
```

## Pre-index

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) STP
```

```
<Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) STP <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!
```

## Decode for all variants of this encoding

```
constant boolean wback = TRUE; constant boolean postindex = FALSE;
```

## Signed offset

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (opc == 00) STP
```

```
<Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]
```

## Encoding for the 64-bit variant

```
Applies when (opc == 10) STP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for all variants of this encoding

```
constant boolean wback = FALSE; constant boolean postindex = FALSE;
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly STP.

## Assembler Symbols

## &lt;Wt1&gt;

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Wt2&gt;

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the 'Post-index 32-bit' and 'Pre-index 32-bit' variants: is the signed immediate byte offset, a multiple of 4 in the range -256 to 252, encoded in the 'imm7' field as &lt;imm&gt;/4.

For the 'Post-index 64-bit' and 'Pre-index 64-bit' variants: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the 'imm7' field as &lt;imm&gt;/8.

For the 'Signed offset 32-bit' variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/4.

For the 'Signed offset 64-bit' variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/8.

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = FALSE; constant integer{} scale = 2 + UInt(opc<1>); constant integer{} datasize = 8 << scale; constant bits(64) offset = LSL(SignExtend(imm7, 64), scale); constant boolean tagchecked = wback || n != 31; boolean rt_unknown = FALSE; if wback && (t == n || t2 == n) && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST); assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_NONE rt_unknown = FALSE; // Value stored is pre-writeback when Constraint_UNKNOWN rt_unknown = TRUE; // Value stored is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

```
Operation privileged,
```

```
bits(64) address; bits(datasize) data1; bits(datasize) data2; constant integer dbytes = datasize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, tagchecked, ispair, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); if rt_unknown && t == n then data1 = bits(datasize) UNKNOWN; else data1 = X[t, datasize]; if rt_unknown && t2 == n then data2 = bits(datasize) UNKNOWN; else data2 = X[t2, datasize]; constant bits(2*datasize) data = (if BigEndian(accdesc.acctype) then data1:data2 else data2:data1); Mem[address, 2 * dbytes, accdesc] = data; if wback then if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.414 STR (immediate)

Store register (immediate)

This instruction stores a word or a doubleword from a register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about addressing modes, see Load/Store addressing modes.

It has encodings from 3 classes: Post-index, Pre-index, and Unsigned offset

## Post-index

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) STR <Wt>, [<Xn|SP>], #<simm>
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) STR <Xt>, [<Xn|SP>], #<simm>
```

## Decode for all variants of this encoding

```
constant boolean wback = TRUE; constant boolean postindex = TRUE; constant integer scale = UInt(size); constant bits(64) offset
```

## Pre-index

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) STR <Wt>, [<Xn|SP>, #<simm>]!
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) STR <Xt>, [<Xn|SP>, #<simm>]!
```

```
= SignExtend(imm9, 64);
```

## Decode for all variants of this encoding

```
constant boolean wback = TRUE; constant boolean postindex = FALSE; constant integer scale = UInt(size); constant bits(64) offset
```

## Unsigned offset

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) STR <Wt>, [<Xn|SP>{, #<pimm>}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) STR <Xt>, [<Xn|SP>{, #<pimm>}]
```

## Decode for all variants of this encoding

```
constant boolean wback = FALSE; constant boolean postindex = FALSE; constant integer scale = UInt(size); constant bits(64) offset = LSL(ZeroExtend(imm12, 64),
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the signed immediate byte offset, in the range -256 to 255, encoded in the 'imm9' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;pimm&gt;

For the '32-bit' variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/4.

For the '64-bit' variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/8.

```
= SignExtend(imm9, 64);
```

```
scale);
```

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8 << scale; constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31; Constraint c; boolean rt_unknown = FALSE; if wback && n == t && n != 31 then c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST); assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_NONE rt_unknown = FALSE; // Value stored is original value when Constraint_UNKNOWN rt_unknown = TRUE; // Value stored is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); bits(datasize) data; if rt_unknown then data = bits(datasize) UNKNOWN; else data = X[t, datasize]; Mem[address, datasize DIV 8, accdesc] = data; if wback then if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.415 STR (register)

Store register (register)

This instruction calculates an address from a base register value and an offset register value, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about addressing modes, see Load/Store addressing modes.

The instruction uses an offset addressing mode, that calculates the address used for the memory access from a base register value and an offset register value. The offset can be optionally shifted and extended.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (size ==

```
STR <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>
```

```
10) {<amount>}}]
```

## Encoding for the 64-bit variant

Applies when (size ==

```
STR <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>
```

```
11) {<amount>}}]
```

## Decode for all variants of this encoding

```
if option<1> == '0' then EndOfDecode(Decode_UNDEF); // sub-word index constant ExtendType extend_type = DecodeRegExtend(option); constant integer scale = UInt(size); constant integer shift = if S == '1' then scale else 0;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

When option&lt;0&gt; is set to 0, is the 32-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;Xm&gt;

When option&lt;0&gt; is set to 1, is the 64-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;extend&gt;

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option when &lt;amount&gt; is omitted, encoded in 'option':

## &lt;amount&gt;

For the '32-bit' variant: is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #2         |

For the '64-bit' variant: is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #3         |

<!-- image -->

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer{} datasize = 8 << scale; constant boolean nontemporal = FALSE; constant boolean tagchecked = TRUE;
```

## Operation

```
constant bits(64) offset = ExtendReg(m, extend_type, shift, 64); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc);
```

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |
|      011 | LSL        |
|      110 | SXTW       |
|      111 | SXTX       |

Mem[address, datasize DIV 8, accdesc] = X[t, datasize];

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.416 STRB (immediate)

Store register byte (immediate)

This instruction stores the least significant byte of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about addressing modes, see Load/Store addressing modes.

It has encodings from 3 classes: Post-index, Pre-index, and Unsigned offset

## Post-index

<!-- image -->

## Encoding

STRB

&lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;

## Decode for this encoding

```
constant boolean wback = TRUE; constant boolean postindex = TRUE; constant bits(64) offset
```

## Pre-index

<!-- image -->

## Encoding

STRB

&lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!

## Decode for this encoding

```
constant boolean wback = TRUE; constant boolean postindex = FALSE; constant bits(64) offset = SignExtend(imm9, 64);
```

## Unsigned offset

<!-- image -->

## Encoding

<!-- image -->

```
= SignExtend(imm9, 64);
```

## Decode for this encoding

```
constant boolean wback = FALSE; constant boolean postindex = FALSE; constant bits(64) offset
```

```
= LSL(ZeroExtend(imm12, 64), 0);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly STRB (immediate).

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the signed immediate byte offset, in the range -256 to 255, encoded in the 'imm9' field.

## &lt;pimm&gt;

Is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the 'imm12' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean nontemporal = FALSE; constant boolean tagchecked = wback || n != 31; Constraint c; boolean rt_unknown = FALSE; if wback && n == t && n != 31 then c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST); assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_NONE rt_unknown = FALSE; // Value stored is original value when Constraint_UNKNOWN rt_unknown = TRUE; // Value stored is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end end
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); bits(8) data;
```

```
if rt_unknown then data = bits(8) UNKNOWN; else data = X[t, 8]; Mem[address, 1, accdesc] = data; if wback then if postindex then address = AddressAdd(address, offset, if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
accdesc);
```

## C6.2.417 STRB (register)

Store register byte (register)

This instruction calculates an address from a base register value and an offset register value, and stores a byte from a 32-bit register to the calculated address. For information about addressing modes, see Load/Store addressing modes.

The instruction uses an offset addressing mode, that calculates the address used for the memory access from a base register value and an offset register value. The offset can be optionally shifted and extended.

<!-- image -->

## Encoding for the Extended register variant

Applies when (option !=

```
011) STRB <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend>
```

## Encoding for the Shifted register variant

```
Applies when (option == 011) STRB <Wt>, [<Xn|SP>, <Xm>{, LSL
```

```
<amount>}]
```

## Decode for all variants of this encoding

```
// sub-word index = DecodeRegExtend(option);
```

```
if option<1> == '0' then EndOfDecode(Decode_UNDEF); constant ExtendType extend_type constant integer shift = 0;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

When option&lt;0&gt; is set to 0, is the 32-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;Xm&gt;

When option&lt;0&gt; is set to 1, is the 64-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;extend&gt;

Is the index extend specifier, encoded in 'option':

```
{<amount>}]
```

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |

## &lt;amount&gt;

Is the index shift amount, it must be #0 , encoded in 'S' as 0 if omitted, or as 1 if present.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean nontemporal constant boolean tagchecked = TRUE;
```

## Operation

```
constant bits(64) offset = ExtendReg(m, extend_type, shift, 64); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Mem[address, 1, accdesc] = X[t, 8];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
= FALSE;
```

|   option | <extend>   |
|----------|------------|
|      110 | SXTW       |
|      111 | SXTX       |

## C6.2.418 STRH (immediate)

Store register halfword (immediate)

This instruction stores the least significant halfword of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about addressing modes, see Load/Store addressing modes.

It has encodings from 3 classes: Post-index, Pre-index, and Unsigned offset

## Post-index

<!-- image -->

## Encoding

STRH

&lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;

## Decode for this encoding

```
constant boolean wback = TRUE; constant boolean postindex = TRUE; constant bits(64) offset
```

## Pre-index

<!-- image -->

## Encoding

STRH

&lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!

## Decode for this encoding

```
constant boolean wback = TRUE; constant boolean postindex = FALSE; constant bits(64) offset = SignExtend(imm9, 64);
```

## Unsigned offset

<!-- image -->

## Encoding

<!-- image -->

```
= SignExtend(imm9, 64);
```

## Decode for this encoding

```
constant boolean wback = FALSE; constant boolean postindex = FALSE; constant bits(64) offset
```

```
= LSL(ZeroExtend(imm12, 64), 1);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly STRH (immediate).

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the signed immediate byte offset, in the range -256 to 255, encoded in the 'imm9' field.

## &lt;pimm&gt;

Is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the 'imm12' field as &lt;pimm&gt;/2.

## Shared Decode

```
integer t = UInt(Rt); integer n = UInt(Rn); boolean nontemporal = FALSE; boolean tagchecked = wback || n != 31; c; = FALSE; && n == t && n != 31 then c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST); assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_NONE rt_unknown = FALSE; // Value stored is original value when Constraint_UNKNOWN rt_unknown = TRUE; // Value stored is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); end
```

```
constant constant constant constant Constraint boolean rt_unknown if wback end
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); bits(16) data;
```

```
if rt_unknown then data = bits(16) UNKNOWN; else data = X[t, 16]; Mem[address, 2, accdesc] = data; if wback then if postindex then address = AddressAdd(address, offset, if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
accdesc);
```

## C6.2.419 STRH (register)

Store register halfword (register)

This instruction calculates an address from a base register value and an offset register value, and stores a halfword from a 32-bit register to the calculated address. For information about addressing modes, see Load/Store addressing modes.

The instruction uses an offset addressing mode, that calculates the address used for the memory access from a base register value and an offset register value. The offset can be optionally shifted and extended.

<!-- image -->

## Encoding

```
STRH <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>
```

```
{<amount>}}]
```

## Decode for this encoding

```
// sub-word index = DecodeRegExtend(option);
```

```
if option<1> == '0' then EndOfDecode(Decode_UNDEF); constant ExtendType extend_type constant integer shift = if S == '1' then 1 else 0;
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

When option&lt;0&gt; is set to 0, is the 32-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;Xm&gt;

When option&lt;0&gt; is set to 1, is the 64-bit name of the general-purpose index register, encoded in the 'Rm' field.

## &lt;extend&gt;

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option when &lt;amount&gt; is omitted, encoded in 'option':

|   option | <extend>   |
|----------|------------|
|      010 | UXTW       |
|      011 | LSL        |
|      110 | SXTW       |
|      111 | SXTX       |

## &lt;amount&gt;

Is the index shift amount, optional only when &lt;extend&gt; is not LSL. Where it is permitted to be optional, it defaults to #0. It is encoded in 'S':

|   S | <amount>   |
|-----|------------|
|   0 | #0         |
|   1 | #1         |

## Shared Decode

```
= FALSE;
```

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant boolean nontemporal constant boolean tagchecked = TRUE;
```

## Operation

```
constant bits(64) offset = ExtendReg(m, extend_type, shift, 64); bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Mem[address, 2, accdesc] = X[t, 16];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.420 STSET, STSETL

Atomic bit set on word or doubleword, without return

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory.

- STSET does not have release semantics.
- STSETL stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDSET, LDSETA, LDSETAL, LDSETL. This means:

- The encodings in this description are named to match the encodings of LDSET, LDSETA, LDSETAL, LDSETL.
- The description of LDSET, LDSETA, LDSETAL, LDSETL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

(size ==

STSET

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

## is equivalent to

```
LDSET <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 32-bit release variant

```
Applies when (size == 10 && R == 1) STSETL <Ws>, [<Xn|SP>]
```

## is equivalent to

```
LDSETL <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 64-bit no memory ordering variant

Applies when

(size ==

```
STSET <Xs>, [<Xn|SP>]
```

is equivalent to

```
LDSET <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

11

&amp;&amp;

R

==

0)

10

&amp;&amp;

R

==

0)

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && R == 1) STSETL <Xs>, [<Xn|SP>] is equivalent to LDSETL <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

The description of LDSET, LDSETA, LDSETAL, LDSETL gives the operational pseudocode for this instruction.

## Operational Information

The description of LDSET, LDSETA, LDSETAL, LDSETL gives the operational information for this instruction.

## C6.2.421 STSETB, STSETLB

Atomic bit set on byte, without return

This instruction atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory.

- STSETB does not have release semantics.
- STSETLB stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDSETB, LDSETAB, LDSETALB, LDSETLB. This means:

- The encodings in this description are named to match the encodings of LDSETB, LDSETAB, LDSETALB, LDSETLB.
- The description of LDSETB, LDSETAB, LDSETALB, LDSETLB gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STSETB <Ws>, [<Xn|SP>] is equivalent to LDSETB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STSETLB <Ws>, [<Xn|SP>] is equivalent to LDSETLB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDSETB, LDSETAB, LDSETALB, LDSETLB gives the operational pseudocode for this instruction.

## Operational Information

The description of LDSETB, LDSETAB, LDSETALB, LDSETLB gives the operational information for this instruction.

## C6.2.422 STSETH, STSETLH

Atomic bit set on halfword, without return

This instruction atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory.

- STSETH does not have release semantics.
- STSETLH stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDSETH, LDSETAH, LDSETALH, LDSETLH. This means:

- The encodings in this description are named to match the encodings of LDSETH, LDSETAH, LDSETALH, LDSETLH.
- The description of LDSETH, LDSETAH, LDSETALH, LDSETLH gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STSETH <Ws>, [<Xn|SP>] is equivalent to LDSETH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STSETLH <Ws>, [<Xn|SP>] is equivalent to LDSETLH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDSETH, LDSETAH, LDSETALH, LDSETLH gives the operational pseudocode for this instruction.

## Operational Information

The description of LDSETH, LDSETAH, LDSETALH, LDSETLH gives the operational information for this instruction.

## C6.2.423 STSHH

Store shared hint

This instruction signals to the memory system that if the next instruction in program order generates an explicit write effect, then it is to a location that one or more other threads of execution will observe, and there is a performance benefit to ensuring that the updated value from the write to that location propagates to those other observers with minimal latency.

The thread of execution on the other observers might be polling the location using load or load-exclusive instructions, or may have executed a PRFM IR instruction targeting the location.

## System

(FEAT\_PCDPHINT)

<!-- image -->

## Encoding

```
STSHH <policy>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_PCDPHINT) then EndOfDecode(Decode_NOP); constant boolean stream = op2<0> == '1';
```

## Assembler Symbols

## &lt;policy&gt;

&lt;policy&gt; is one of:

KEEP Signals to the memory system that there may be a performance benefit to retaining the updated location in the local cache of the updating PE.

STRM Signals to the memory system that there may be a performance benefit to ensuring the updated location is not retained in the local cache of the updating PE.

|   op2<0> | <policy>   |
|----------|------------|
|        0 | KEEP       |
|        1 | STRM       |

## Operation

Hint\_StoreShared(stream);

## C6.2.424 STSMAX, STSMAXL

Atomic signed maximum on word or doubleword, without return

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers.

- STSMAX does not have release semantics.
- STSMAXL stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL. This means:

- The encodings in this description are named to match the encodings of LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL.
- The description of LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

(size ==

STSMAX

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

## is equivalent to

```
LDSMAX <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 32-bit release variant

Applies when

(size ==

STSMAXL

10

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

is equivalent to

```
LDSMAXL <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 64-bit no memory ordering variant

Applies when

(size ==

```
STSMAX <Xs>, [<Xn|SP>]
```

is equivalent to

```
LDSMAX <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

11

&amp;&amp;

R

==

0)

&amp;&amp;

R

==

1)

10

&amp;&amp;

R

==

0)

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && R == 1) STSMAXL <Xs>, [<Xn|SP>] is equivalent to LDSMAXL <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

The description of LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL gives the operational pseudocode for this instruction.

## Operational Information

The description of LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL gives the operational information for this instruction.

## C6.2.425 STSMAXB, STSMAXLB

Atomic signed maximum on byte, without return

This instruction atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers.

- STSMAXB does not have release semantics.
- STSMAXLB stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB. This means:

- The encodings in this description are named to match the encodings of LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB.
- The description of LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STSMAXB <Ws>, [<Xn|SP>] is equivalent to LDSMAXB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STSMAXLB <Ws>, [<Xn|SP>] is equivalent to LDSMAXLB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB gives the operational pseudocode for this instruction.

## Operational Information

The description of LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB gives the operational information for this instruction.

## C6.2.426 STSMAXH, STSMAXLH

Atomic signed maximum on halfword, without return

This instruction atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers.

- STSMAXH does not have release semantics.
- STSMAXLH stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH. This means:

- The encodings in this description are named to match the encodings of LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH.
- The description of LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STSMAXH <Ws>, [<Xn|SP>] is equivalent to LDSMAXH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STSMAXLH <Ws>, [<Xn|SP>] is equivalent to LDSMAXLH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH gives the operational pseudocode for this instruction.

## Operational Information

The description of LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH gives the operational information for this instruction.

## C6.2.427 STSMIN, STSMINL

Atomic signed minimum on word or doubleword, without return

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers.

- STSMIN does not have release semantics.
- STSMINL stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDSMIN, LDSMINA, LDSMINAL, LDSMINL. This means:

- The encodings in this description are named to match the encodings of LDSMIN, LDSMINA, LDSMINAL, LDSMINL.
- The description of LDSMIN, LDSMINA, LDSMINAL, LDSMINL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

(size ==

STSMIN

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

is equivalent to

```
LDSMIN <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 32-bit release variant

Applies when

(size ==

STSMINL

10

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

is equivalent to

```
LDSMINL <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 64-bit no memory ordering variant

Applies when

(size ==

```
STSMIN <Xs>, [<Xn|SP>]
```

is equivalent to

```
LDSMIN <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

11

&amp;&amp;

R

==

0)

&amp;&amp;

R

==

1)

10

&amp;&amp;

R

==

0)

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && R == 1) STSMINL <Xs>, [<Xn|SP>] is equivalent to LDSMINL <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

The description of LDSMIN, LDSMINA, LDSMINAL, LDSMINL gives the operational pseudocode for this instruction.

## Operational Information

The description of LDSMIN, LDSMINA, LDSMINAL, LDSMINL gives the operational information for this instruction.

## C6.2.428 STSMINB, STSMINLB

Atomic signed minimum on byte, without return

This instruction atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers.

- STSMINB does not have release semantics.
- STSMINLB stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB. This means:

- The encodings in this description are named to match the encodings of LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB.
- The description of LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STSMINB <Ws>, [<Xn|SP>] is equivalent to LDSMINB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STSMINLB <Ws>, [<Xn|SP>] is equivalent to LDSMINLB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB gives the operational pseudocode for this instruction.

## Operational Information

The description of LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB gives the operational information for this instruction.

## C6.2.429 STSMINH, STSMINLH

Atomic signed minimum on halfword, without return

This instruction atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers.

- STSMINH does not have release semantics.
- STSMINLH stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH. This means:

- The encodings in this description are named to match the encodings of LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH.
- The description of LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STSMINH <Ws>, [<Xn|SP>] is equivalent to LDSMINH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STSMINLH <Ws>, [<Xn|SP>] is equivalent to LDSMINLH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH gives the operational pseudocode for this instruction.

## Operational Information

The description of LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH gives the operational information for this instruction.

## C6.2.430 STTADD, STTADDL

Atomic add unprivileged, without return

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory.

- STTADD does not have release semantics.
- STTADDL stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDTADD, LDTADDA, LDTADDAL, LDTADDL. This means:

- The encodings in this description are named to match the encodings of LDTADD, LDTADDA, LDTADDAL, LDTADDL.
- The description of LDTADD, LDTADDA, LDTADDAL, LDTADDL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSUI)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

(sz

STTADD

==

0

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

is equivalent to

```
LDTADD <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 32-bit release variant

```
Applies when (sz == 0 && R == 1) STTADDL <Ws>, [<Xn|SP>]
```

is equivalent to

```
LDTADDL <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 64-bit no memory ordering variant

```
Applies when (sz == 1 && R == 0) STTADD <Xs>, [<Xn|SP>]
```

is equivalent to

```
LDTADD <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

&amp;&amp;

R

==

0)

## Encoding for the 64-bit release variant

```
Applies when (sz == 1 && R == 1) STTADDL <Xs>, [<Xn|SP>] is equivalent to LDTADDL <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

The description of LDTADD, LDTADDA, LDTADDAL, LDTADDL gives the operational pseudocode for this instruction.

## Operational Information

The description of LDTADD, LDTADDA, LDTADDAL, LDTADDL gives the operational information for this instruction.

## C6.2.431 STTCLR, STTCLRL

Atomic bit clear unprivileged, without return

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.

- STTCLR does not have release semantics.
- STTCLRL stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDTCLR, LDTCLRA, LDTCLRAL, LDTCLRL. This means:

- The encodings in this description are named to match the encodings of LDTCLR, LDTCLRA, LDTCLRAL, LDTCLRL.
- The description of LDTCLR, LDTCLRA, LDTCLRAL, LDTCLRL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSUI)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

(sz

STTCLR

==

0

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

is equivalent to

LDTCLR

&lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;]

and is always the preferred disassembly.

## Encoding for the 32-bit release variant

```
Applies when (sz == 0 && R == 1) STTCLRL <Ws>, [<Xn|SP>]
```

is equivalent to

```
LDTCLRL <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 64-bit no memory ordering variant

```
Applies when (sz == 1 && R == 0) STTCLR <Xs>, [<Xn|SP>]
```

is equivalent to

```
LDTCLR <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

&amp;&amp;

R

==

0)

## Encoding for the 64-bit release variant

```
Applies when (sz == 1 && R == 1) STTCLRL <Xs>, [<Xn|SP>] is equivalent to LDTCLRL <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

The description of LDTCLR, LDTCLRA, LDTCLRAL, LDTCLRL gives the operational pseudocode for this instruction.

## Operational Information

The description of LDTCLR, LDTCLRA, LDTCLRAL, LDTCLRL gives the operational information for this instruction.

## C6.2.432 STTNP

Store unprivileged pair of registers, with non-temporal hint

This instruction calculates an address from a base register value and an immediate offset, and stores two 64-bit doublewords to the calculated address, from two registers. For information about addressing modes, see Load/Store addressing modes. For information about non-temporal pair instructions, see Load/Store non-temporal pair.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Signed offset

(FEAT\_LSUI)

<!-- image -->

## Encoding

```
STTNP
```

```
<Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = TRUE; constant integer datasize = 64; constant bits(64) offset = LSL(SignExtend(imm7, 64), 3); constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/8.

## Operation

```
bits(64) address; constant integer dbytes = datasize DIV 8; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, ispair, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); constant bits(2*datasize) data = (if BigEndian(accdesc.acctype) then X[t, datasize]:X[t2, datasize] else X[t2, datasize]:X[t, datasize]); Mem[address, 2 * dbytes, accdesc] = data;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.433 STTP

Store unprivileged pair of registers

This instruction calculates an address from a base register value and an immediate offset, and stores two 64-bit doublewords to the calculated address, from two registers.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

For information about addressing modes, see Load/Store addressing modes.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

(FEAT\_LSUI)

<!-- image -->

## Encoding

```
STTP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then constant boolean wback = TRUE; constant boolean postindex = TRUE;
```

## Pre-index

(FEAT\_LSUI)

<!-- image -->

## Encoding

```
STTP <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then constant boolean wback = TRUE; constant boolean postindex = FALSE;
```

```
EndOfDecode(Decode_UNDEF);
```

```
EndOfDecode(Decode_UNDEF);
```

## Signed offset

(FEAT\_LSUI)

<!-- image -->

## Encoding

```
STTP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then constant boolean wback = FALSE; constant boolean postindex = FALSE;
```

```
EndOfDecode(Decode_UNDEF);
```

STTP has the same CONSTRAINED UNPREDICTABLE behavior as STP . See Architectural Constraints on UNPREDICTABLE behaviors, and particularly STP.

## Assembler Symbols

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the 'Load/store register pair (post-indexed)' and 'Load/store register pair (pre-indexed)' variants: is the signed immediate byte offset, a multiple of 8 in the range -512 to 504, encoded in the 'imm7' field as &lt;imm&gt;/8.

For the 'Load/store register pair (offset)' variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the 'imm7' field as &lt;imm&gt;/8.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean nontemporal = FALSE; constant integer{} scale = 2 + UInt(opc<1>); constant integer{} datasize = 64; constant bits(64) offset = LSL(SignExtend(imm7, 64), scale); constant boolean tagchecked = wback || n != 31; boolean rt_unknown = FALSE; if wback && (t == n || t2 == n) && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST); assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_NONE rt_unknown = FALSE; // Value stored is pre-writeback when Constraint_UNKNOWN rt_unknown = TRUE; // Value stored is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF);
```

```
when end end
```

## Operation

```
bits(64) address; bits(datasize) data1; bits(datasize) data2; constant integer dbytes = datasize DIV 8; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, ispair, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; if !postindex then address = AddressAdd(address, offset, accdesc); if rt_unknown && t == n then data1 = bits(datasize) UNKNOWN; else data1 = X[t, datasize]; if rt_unknown && t2 == n then data2 = bits(datasize) UNKNOWN; else data2 = X[t2, datasize]; constant bits(2*datasize) data = (if BigEndian(accdesc.acctype) then data1:data2 else data2:data1); Mem[address, 2 * dbytes, accdesc] = data; if wback then if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
Constraint_NOP EndOfDecode(Decode_NOP);
```

## C6.2.434 STTR

Store register (unprivileged)

This instruction stores a word or doubleword from a register to memory. The address that is used for the store is calculated from a base register and an immediate offset.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (size ==

```
10) STTR <Wt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

Applies when (size ==

```
11) STTR <Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
constant integer scale = UInt(size); constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8 << constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Mem[address, datasize DIV 8, accdesc] = X[t, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
scale;
```

## C6.2.435 STTRB

Store register byte (unprivileged)

This instruction stores a byte from a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
STTRB <Wt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 8; constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Mem[address, datasize DIV 8, accdesc] = X[t, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.436 STTRH

Store register halfword (unprivileged)

This instruction stores a halfword from a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
STTRH <Wt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Shared Decode

```
constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer{} datasize = 16; constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Mem[address, datasize DIV 8, accdesc] = X[t, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.437 STTSET, STTSETL

Atomic bit set unprivileged, without return

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory.

- STTSET does not have release semantics.
- STTSETL stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDTSET, LDTSETA, LDTSETAL, LDTSETL. This means:

- The encodings in this description are named to match the encodings of LDTSET, LDTSETA, LDTSETAL, LDTSETL.
- The description of LDTSET, LDTSETA, LDTSETAL, LDTSETL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSUI)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

(sz

STTSET

==

0

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

is equivalent to

LDTSET

&lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;]

and is always the preferred disassembly.

## Encoding for the 32-bit release variant

```
Applies when (sz == 0 && R == 1) STTSETL <Ws>, [<Xn|SP>]
```

is equivalent to

LDTSETL

&lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;]

and is always the preferred disassembly.

## Encoding for the 64-bit no memory ordering variant

```
Applies when (sz == 1 && R == 0) STTSET <Xs>, [<Xn|SP>]
```

is equivalent to

```
LDTSET <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

&amp;&amp;

R

==

0)

## Encoding for the 64-bit release variant

```
Applies when (sz == 1 && R == 1) STTSETL <Xs>, [<Xn|SP>] is equivalent to LDTSETL <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

The description of LDTSET, LDTSETA, LDTSETAL, LDTSETL gives the operational pseudocode for this instruction.

## Operational Information

The description of LDTSET, LDTSETA, LDTSETAL, LDTSETL gives the operational information for this instruction.

## C6.2.438 STTXR

Store unprivileged exclusive register

This instruction stores a 32-bit word or a 64-bit doubleword from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

Note

For the purposes of the Exclusives monitors, and the forward progress guarantees for Load-Exclusive and Store-Exclusive loops, STTXR is equivalent to STXR .

For information about addressing modes, see Load/Store addressing modes.

## No offset

(FEAT\_LSUI)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sz == 0) STTXR <Ws>,
```

```
<Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (sz == 1) STTXR <Ws>,
```

```
<Xt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer elsize = 32 << UInt(sz); constant boolean acqrel = FALSE; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; boolean rn_unknown = FALSE; if s == t then constant Constraint assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
```

```
c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP); case c of
```

```
when Constraint_UNKNOWN rt_unknown = TRUE; // store UNKNOWN value when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); if s == n && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rn_unknown = TRUE; // address is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

STTXR has the same CONSTRAINED UNPREDICTABLE behavior as STXR . See Architectural Constraints on UNPREDICTABLE behaviors, and particularly STXR.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rs' field. The value returned is:

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

Aborts and alignment

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Ws&gt; is not updated.

Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort exception to be generated, subject to the following rules:

- If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.
- Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
bits(64) address; bits(elsize) data; constant integer dbytes = elsize DIV 8; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked, privileged, if n == 31 then CheckSPAlignment(); address = SP[64]; elsif rn_unknown then address = bits(64) UNKNOWN;
```

```
t);
```

```
else address = X[n, 64]; if rt_unknown then data = bits(elsize) UNKNOWN; else data = X[t, elsize]; bit status = '1'; // Check whether the Exclusives monitors are set to include the // physical memory locations corresponding to virtual address // range [address, address+dbytes-1]. // If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, // if accessed, would generate a synchronous Data Abort exception, it is // IMPLEMENTATION DEFINED whether the exception is generated. // It is a limitation of this model that synchronous Data Aborts are never // generated in this case, as Mem[] is not called. // If FEAT_SPE is implemented, it is also IMPLEMENTATION DEFINED whether or not the // physical address packet is output when permitted and when // AArch64.ExclusiveMonitorPass() returns FALSE for a Store Exclusive instruction. // This behavior is not reflected here due to the previously stated limitation. if AArch64.ExclusiveMonitorsPass(address, dbytes, accdesc) then // This atomic write will be rejected if it does not refer // to the same physical locations after address translation. Mem[address, dbytes, accdesc] = data; status = ExclusiveMonitorsStatus(); X[s, 32] = ZeroExtend(status, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.439 STUMAX, STUMAXL

Atomic unsigned maximum on word or doubleword, without return

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers.

- STUMAX does not have release semantics.
- STUMAXL stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL. This means:

- The encodings in this description are named to match the encodings of LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL.
- The description of LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

(size ==

STUMAX

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

is equivalent to

```
LDUMAX <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 32-bit release variant

Applies when

(size ==

10

```
STUMAXL <Ws>, [<Xn|SP>]
```

is equivalent to

```
LDUMAXL <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 64-bit no memory ordering variant

Applies when

(size ==

```
STUMAX <Xs>, [<Xn|SP>]
```

is equivalent to

```
LDUMAX <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

11

&amp;&amp;

R

==

0)

&amp;&amp;

R

==

1)

10

&amp;&amp;

R

==

0)

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && R == 1) STUMAXL <Xs>, [<Xn|SP>] is equivalent to LDUMAXL <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

The description of LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL gives the operational pseudocode for this instruction.

## Operational Information

The description of LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL gives the operational information for this instruction.

## C6.2.440 STUMAXB, STUMAXLB

Atomic unsigned maximum on byte, without return

This instruction atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers.

- STUMAXB does not have release semantics.
- STUMAXLB stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB. This means:

- The encodings in this description are named to match the encodings of LDUMAXB, LDUMAXAB, LDUMAXALB,LDUMAXLB.
- The description of LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STUMAXB <Ws>, [<Xn|SP>] is equivalent to LDUMAXB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STUMAXLB <Ws>, [<Xn|SP>] is equivalent to LDUMAXLB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB gives the operational pseudocode for this instruction.

## Operational Information

The description of LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB gives the operational information for this instruction.

## C6.2.441 STUMAXH, STUMAXLH

Atomic unsigned maximum on halfword, without return

This instruction atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers.

- STUMAXH does not have release semantics.
- STUMAXLH stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH. This means:

- The encodings in this description are named to match the encodings of LDUMAXH, LDUMAXAH, LDUMAXALH,LDUMAXLH.
- The description of LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STUMAXH <Ws>, [<Xn|SP>] is equivalent to LDUMAXH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STUMAXLH <Ws>, [<Xn|SP>] is equivalent to LDUMAXLH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH gives the operational pseudocode for this instruction.

## Operational Information

The description of LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH gives the operational information for this instruction.

## C6.2.442 STUMIN, STUMINL

Atomic unsigned minimum on word or doubleword, without return

This instruction atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers.

- STUMIN does not have release semantics.
- STUMINL stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDUMIN, LDUMINA, LDUMINAL, LDUMINL. This means:

- The encodings in this description are named to match the encodings of LDUMIN, LDUMINA, LDUMINAL, LDUMINL.
- The description of LDUMIN, LDUMINA, LDUMINAL, LDUMINL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit no memory ordering variant

Applies when

(size ==

STUMIN

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

## is equivalent to

```
LDUMIN <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 32-bit release variant

Applies when

(size ==

STUMINL

10

&lt;Ws&gt;, [&lt;Xn|SP&gt;]

is equivalent to

```
LDUMINL <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the 64-bit no memory ordering variant

Applies when

(size ==

```
STUMIN <Xs>, [<Xn|SP>]
```

## is equivalent to

```
LDUMIN <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

11

&amp;&amp;

R

==

0)

&amp;&amp;

R

==

1)

10

&amp;&amp;

R

==

0)

## Encoding for the 64-bit release variant

```
Applies when (size == 11 && R == 1) STUMINL <Xs>, [<Xn|SP>] is equivalent to LDUMINL <Xs>, <Xt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## Operation

The description of LDUMIN, LDUMINA, LDUMINAL, LDUMINL gives the operational pseudocode for this instruction.

## Operational Information

The description of LDUMIN, LDUMINA, LDUMINAL, LDUMINL gives the operational information for this instruction.

## C6.2.443 STUMINB, STUMINLB

Atomic unsigned minimum on byte, without return

This instruction atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers.

- STUMINB does not have release semantics.
- STUMINLB stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB. This means:

- The encodings in this description are named to match the encodings of LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB.
- The description of LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STUMINB <Ws>, [<Xn|SP>] is equivalent to LDUMINB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STUMINLB <Ws>, [<Xn|SP>] is equivalent to LDUMINLB <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB gives the operational pseudocode for this instruction.

## Operational Information

The description of LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB gives the operational information for this instruction.

## C6.2.444 STUMINH, STUMINLH

Atomic unsigned minimum on halfword, without return

This instruction atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers.

- STUMINH does not have release semantics.
- STUMINLH stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

This is an alias of LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH. This means:

- The encodings in this description are named to match the encodings of LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH.
- The description of LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the No memory ordering variant

```
Applies when (R == 0) STUMINH <Ws>, [<Xn|SP>] is equivalent to LDUMINH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Encoding for the Release variant

```
Applies when (R == 1) STUMINLH <Ws>, [<Xn|SP>] is equivalent to LDUMINLH <Ws>, <Wt>, [<Xn|SP>]
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the 'Rs' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

The description of LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH gives the operational pseudocode for this instruction.

## Operational Information

The description of LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH gives the operational information for this instruction.

## C6.2.445 STUR

## Store register (unscaled)

This instruction calculates an address from a base register value and an immediate offset, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (size == 10) STUR <Wt>, [<Xn|SP>{, #<simm>}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) STUR <Xt>, [<Xn|SP>{, #<simm>}]
```

## Decode for all variants of this encoding

```
constant integer scale = UInt(size); constant bits(64) offset
```

```
= SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

<!-- image -->

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## Shared Decode

```
constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant integer{} datasize = 8 << constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

```
scale;
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Mem[address, datasize DIV 8, accdesc] = X[t, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.446 STURB

Store register byte (unscaled)

This instruction calculates an address from a base register value and an immediate offset, and stores a byte to the calculated address, from a 32-bit register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
STURB <Wt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Shared Decode

```
constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant integer{} datasize = 8; constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Mem[address, datasize DIV 8, accdesc] = X[t, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.447 STURH

Store register halfword (unscaled)

This instruction calculates an address from a base register value and an immediate offset, and stores a halfword to the calculated address, from a 32-bit register. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
STURH <Wt>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
constant bits(64) offset = SignExtend(imm9, 64);
```

## Assembler Symbols

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the 'imm9' field.

## Shared Decode

```
constant integer n = UInt(Rn); constant integer t = UInt(Rt); constant integer{} datasize = 16; constant boolean nontemporal = FALSE; constant boolean tagchecked = n != 31;
```

## Operation

```
bits(64) address; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked, t); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; address = AddressAdd(address, offset, accdesc); Mem[address, datasize DIV 8, accdesc] = X[t, datasize];
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.448 STXP

Store exclusive pair of registers

This instruction stores two 32-bit words or two 64-bit doublewords from two registers to a memory location if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. For information on single-copy atomicity and alignment requirements, see Requirements for single-copy atomicity and Alignment of data accesses. If a 64-bit pair Store-Exclusive succeeds, it causes a single-copy atomic update of the 128-bit memory location being updated. For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sz == 0) STXP
```

```
<Ws>, <Wt1>, <Wt2>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (sz == 1) STXP
```

```
<Ws>, <Xt1>, <Xt2>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant integer elsize = 32 << UInt(sz); constant integer datasize = elsize * 2; constant boolean acqrel = FALSE; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; boolean rn_unknown = FALSE; if s == t || (s == t2) then constant Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // store UNKNOWN value when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); if s == n && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rn_unknown = TRUE; // address is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly STXP.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rs' field. The value returned is:

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

## &lt;Wt1&gt;

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Wt2&gt;

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

Aborts and alignment

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Ws&gt; is not updated.

Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort exception to be generated, subject to the following rules:

- If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.
- Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
bits(64) address; bits(datasize) data; constant integer dbytes = datasize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant boolean ispair = FALSE; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked, privileged, ispair, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; elsif rn_unknown then address = bits(64) UNKNOWN; else address = X[n, 64]; if rt_unknown then data = bits(datasize) UNKNOWN; else
```

```
constant bits(datasize DIV 2) el1 = X[t, datasize DIV 2]; constant bits(datasize DIV 2) el2 = X[t2, datasize DIV 2]; data = if BigEndian(accdesc.acctype) then el1:el2 else el2:el1; bit status = '1'; // Check whether the Exclusives monitors are set to include the // physical memory locations corresponding to virtual address // range [address, address+dbytes-1]. // If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, // if accessed, would generate a synchronous Data Abort exception, it is // IMPLEMENTATION DEFINED whether the exception is generated. // It is a limitation of this model that synchronous Data Aborts are never // generated in this case, as Mem[] is not called. // If FEAT_SPE is implemented, it is also IMPLEMENTATION DEFINED whether or not the // physical address packet is output when permitted and when // AArch64.ExclusiveMonitorPass() returns FALSE for a Store Exclusive instruction. // This behavior is not reflected here due to the previously stated limitation. if AArch64.ExclusiveMonitorsPass(address, dbytes, accdesc) then // This atomic write will be rejected if it does not refer // to the same physical locations after address translation. Mem[address, dbytes, accdesc] = data; status = ExclusiveMonitorsStatus(); X[s, 32] = ZeroExtend(status, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.449 STXR

Store exclusive register

This instruction stores a 32-bit word or a 64-bit doubleword from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (size ==

```
10)
```

```
STXR <Ws>, <Wt>, [<Xn|SP>{, #0}]
```

## Encoding for the 64-bit variant

```
Applies when (size == 11) STXR <Ws>, <Xt>, [<Xn|SP>{, #0}]
```

## Decode for all variants of this encoding

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer elsize = 8 << UInt(size); constant boolean acqrel = FALSE; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; boolean rn_unknown = FALSE; if s == t then constant Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // store UNKNOWN value when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); if s == n && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rn_unknown = TRUE; // address is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly STXR.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rs' field. The value returned is:

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

Aborts and alignment

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Ws&gt; is not updated.

Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort exception to be generated, subject to the following rules:

- If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.
- Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
bits(64) address; bits(elsize) data; constant integer dbytes = elsize DIV 8; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; elsif rn_unknown then address = bits(64) UNKNOWN; else address = X[n, 64]; if rt_unknown then data = bits(elsize) UNKNOWN; else data = X[t, elsize]; bit status = '1'; // Check whether the Exclusives monitors are set to include the // physical memory locations corresponding to virtual address // range [address, address+dbytes-1]. // If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, // if accessed, would generate a synchronous Data Abort exception, it is // IMPLEMENTATION DEFINED whether the exception is generated. // It is a limitation of this model that synchronous Data Aborts are never
```

```
// generated in this case, as Mem[] is not called. // If FEAT_SPE is implemented, it is also IMPLEMENTATION DEFINED whether or not the // physical address packet is output when permitted and when // AArch64.ExclusiveMonitorPass() returns FALSE for a Store Exclusive instruction. // This behavior is not reflected here due to the previously stated limitation. if AArch64.ExclusiveMonitorsPass(address, dbytes, accdesc) then // This atomic write will be rejected if it does not refer // to the same physical locations after address translation. Mem[address, dbytes, accdesc] = data; status = ExclusiveMonitorsStatus(); X[s, 32] = ZeroExtend(status, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.450 STXRB

Store exclusive register byte

This instruction stores a byte from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
STXRB <Ws>, <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acqrel = FALSE; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; boolean rn_unknown = FALSE; if s == t then constant Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // store UNKNOWN value when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); if s == n && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rn_unknown = TRUE; // address is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly STXRB.

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rs' field. The value returned is:

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

&lt;Wt&gt;

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

Aborts

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Ws&gt; is not updated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
bits(64) address; bits(8) data; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; elsif rn_unknown then address = bits(64) UNKNOWN; else address = X[n, 64]; if rt_unknown then data = bits(8) UNKNOWN; else data = X[t, 8]; bit status = '1'; // Check whether the Exclusives monitors are set to include the // physical memory locations corresponding to virtual address // range [address, address+dbytes-1]. // If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, // if accessed, would generate a synchronous Data Abort exception, it is // IMPLEMENTATION DEFINED whether the exception is generated. // It is a limitation of this model that synchronous Data Aborts are never // generated in this case, as Mem[] is not called. // If FEAT_SPE is implemented, it is also IMPLEMENTATION DEFINED whether or not the // physical address packet is output when permitted and when // AArch64.ExclusiveMonitorPass() returns FALSE for a Store Exclusive instruction. // This behavior is not reflected here due to the previously stated limitation. if AArch64.ExclusiveMonitorsPass(address, 1, accdesc) then // This atomic write will be rejected if it does not refer // to the same physical locations after address translation. Mem[address, 1, accdesc] = data; status = ExclusiveMonitorsStatus(); X[s, 32] = ZeroExtend(status, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.451 STXRH

Store exclusive register halfword

This instruction stores a halfword from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic.

For information about addressing modes, see Load/Store addressing modes.

<!-- image -->

## Encoding

```
STXRH <Ws>, <Wt>, [<Xn|SP>{, #0}]
```

## Decode for this encoding

```
constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acqrel = FALSE; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; boolean rn_unknown = FALSE; if s == t then constant Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // store UNKNOWN value when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP); if s == n && n != 31 then constant Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rn_unknown = TRUE; // address is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rs' field. The value returned is:

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

Aborts and alignment

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Ws&gt; is not updated.

Anon halfword-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject to the following rules:

- If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.
- Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
bits(64) address; bits(16) data; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked, privileged, t); if n == 31 then CheckSPAlignment(); address = SP[64]; elsif rn_unknown then address = bits(64) UNKNOWN; else address = X[n, 64]; if rt_unknown then data = bits(16) UNKNOWN; else data = X[t, 16]; bit status = '1'; // Check whether the Exclusives monitors are set to include the // physical memory locations corresponding to virtual address // range [address, address+dbytes-1]. // If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, // if accessed, would generate a synchronous Data Abort exception, it is // IMPLEMENTATION DEFINED whether the exception is generated. // It is a limitation of this model that synchronous Data Aborts are never // generated in this case, as Mem[] is not called. // If FEAT_SPE is implemented, it is also IMPLEMENTATION DEFINED whether or not the // physical address packet is output when permitted and when // AArch64.ExclusiveMonitorPass() returns FALSE for a Store Exclusive instruction. // This behavior is not reflected here due to the previously stated limitation. if AArch64.ExclusiveMonitorsPass(address, 2, accdesc) then // This atomic write will be rejected if it does not refer // to the same physical locations after address translation. Mem[address, 2, accdesc] = data; status = ExclusiveMonitorsStatus(); X[s, 32] = ZeroExtend(status, 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.452 STZ2G

Store Allocation Tags, zeroing

This instruction stores an Allocation Tag to two Tag Granules of memory, zeroing the associated data locations. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag Granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.

This instruction generates an Unchecked access.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

(FEAT\_MTE)

<!-- image -->

## Encoding

```
STZ2G <Xt|SP>, [<Xn|SP>], #<simm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE); constant boolean writeback = TRUE; constant boolean postindex = TRUE;
```

## Pre-index

(FEAT\_MTE)

<!-- image -->

## Encoding

```
STZ2G <Xt|SP>, [<Xn|SP>, #<simm>]!
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE); constant boolean writeback = TRUE; constant boolean postindex = FALSE;
```

## Signed offset

(FEAT\_MTE)

<!-- image -->

## Encoding

```
STZ2G <Xt|SP>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE); constant boolean writeback = FALSE; constant boolean postindex = FALSE;
```

## Assembler Symbols

## &lt;Xt|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the 'imm9' field.

## Operation

```
bits(64) address; bits(64) address2; constant bits(64) data = if t == 31 then SP[64] else X[t, 64]; constant bits(4) tag = AArch64.AllocationTagFromAddress(data); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant boolean stzgm = FALSE; constant boolean ispair = TRUE; constant AccessDescriptor accdesc = CreateAccDescLDGSTG(MemOp_STORE, stzgm, ispair, t, t); if !postindex then address = AddressAdd(address, offset, accdesc); address2 = AddressIncrement(address, TAG_GRANULE, accdesc); if !IsAligned(address, TAG_GRANULE) then constant FaultRecord fault = AlignmentFault(accdesc, address); AArch64.Abort(fault);
```

```
Mem[address, 2 * TAG_GRANULE, accdesc] = Zeros(TAG_GRANULE * 16); AArch64.MemTag[address , accdesc] = tag; AArch64.MemTag[address2, accdesc] = tag; if writeback then if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## C6.2.453 STZG

Store Allocation Tag, zeroing

This instruction stores an Allocation Tag to memory, zeroing the associated data location. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag Granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.

This instruction generates an Unchecked access.

It has encodings from 3 classes: Post-index, Pre-index, and Signed offset

## Post-index

(FEAT\_MTE)

<!-- image -->

## Encoding

```
STZG <Xt|SP>, [<Xn|SP>], #<simm>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE); constant boolean writeback = TRUE; constant boolean postindex = TRUE;
```

## Pre-index

(FEAT\_MTE)

<!-- image -->

## Encoding

```
STZG <Xt|SP>, [<Xn|SP>, #<simm>]!
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE); constant boolean writeback = TRUE; constant boolean postindex = FALSE;
```

## Signed offset

(FEAT\_MTE)

<!-- image -->

## Encoding

```
STZG <Xt|SP>, [<Xn|SP>{, #<simm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE); constant boolean writeback = FALSE; constant boolean postindex = FALSE;
```

## Assembler Symbols

## &lt;Xt|SP&gt;

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;simm&gt;

Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the 'imm9' field.

## Operation

```
bits(64) address; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant boolean stzgm = FALSE; constant AccessDescriptor accdesc = CreateAccDescLDGSTG(MemOp_STORE, stzgm, t); if !postindex then address = AddressAdd(address, offset, accdesc); if !IsAligned(address, TAG_GRANULE) then constant FaultRecord fault = AlignmentFault(accdesc, address); AArch64.Abort(fault); Mem[address, TAG_GRANULE, accdesc] = Zeros(TAG_GRANULE * 8); constant bits(64) data = if t == 31 then SP[64] else X[t, 64]; constant bits(4) tag = AArch64.AllocationTagFromAddress(data); AArch64.MemTag[address, accdesc] = tag;
```

```
if writeback then if postindex then address = AddressAdd(address, offset, accdesc); if n == 31 then SP[64] = address; else X[n, 64] = address;
```

## C6.2.454 STZGM

Store Allocation Tag and zero multiple

This instruction writes a naturally aligned block of N Allocation Tags and stores zero to the associated data locations, where the size of N is identified in DCZID\_EL0.BS, and the Allocation Tag is taken from the source register bits&lt;3:0&gt;.

This instruction is UNDEFINED at EL0.

This instruction generates an Unchecked access.

## Integer

(FEAT\_MTE2)

<!-- image -->

## Encoding

```
STZGM <Xt>, [<Xn|SP>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE2) then constant integer t = UInt(Rt); constant integer n = UInt(Rn);
```

## Assembler Symbols

&lt;Xt&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
if PSTATE.EL == EL0 then UNDEFINED; constant bits(64) data = X[t, 64]; constant bits(4) tag = data<3:0>; bits(64) address; if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; constant integer size = 4 * (2 ^ (UInt(DCZID_EL0.BS))); address = Align(address, size); constant integer count = size >> LOG2_TAG_GRANULE; constant boolean stzgm = TRUE; constant AccessDescriptor accdesc = CreateAccDescLDGSTG(MemOp_STORE, stzgm, t); for i = 0 to count-1 AArch64.MemTag[address, accdesc] = tag; Mem[address, TAG_GRANULE, accdesc] = Zeros(8*TAG_GRANULE); address = AddressIncrement(address, TAG_GRANULE, accdesc);
```

```
EndOfDecode(Decode_UNDEF);
```

## C6.2.455 SUB (extended register)

Subtract extended and scaled register

This instruction subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) SUB <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend>
```

```
{#<amount>}}
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) SUB <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}
```

## Decode for all variants of this encoding

```
if imm3 IN {'101', '110', '111'} then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer shift = UInt(imm3); constant integer datasize = 32 << UInt(sf); constant ExtendType extend_type = DecodeRegExtend(option);
```

## Assembler Symbols

## &lt;Wd|WSP&gt;

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Wn|WSP&gt;

Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;extend&gt;

For the '32-bit' variant: is the extension to be applied to the second source operand, encoded in 'option':

|   option | <extend>   |
|----------|------------|
|      000 | UXTB       |
|      001 | UXTH       |

Is a width specifier, encoded in 'option':

|   option | <extend>      |
|----------|---------------|
|      010 | LSL&#124;UXTW |
|      011 | UXTX          |
|      100 | SXTB          |
|      101 | SXTH          |
|      110 | SXTW          |
|      111 | SXTX          |

If 'Rd' or 'Rn' is '11111' (WSP) and 'option' is '010' then LSL is preferred, but may be omitted when 'imm3' is '000'. In all other cases &lt;extend&gt; is required and must be UXTW when 'option' is '010'.

For the '64-bit' variant: is the extension to be applied to the second source operand, encoded in 'option':

|   option | <extend>      |
|----------|---------------|
|      000 | UXTB          |
|      001 | UXTH          |
|      010 | UXTW          |
|      011 | LSL&#124;UXTX |
|      100 | SXTB          |
|      101 | SXTH          |
|      110 | SXTW          |
|      111 | SXTX          |

If 'Rd' or 'Rn' is '11111' (SP) and 'option' is '011' then LSL is preferred, but may be omitted when 'imm3' is '000'. In all other cases &lt;extend&gt; is required and must be UXTX when 'option' is '011'.

## &lt;amount&gt;

Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the 'imm3' field. It must be absent when &lt;extend&gt; is absent, is required when &lt;extend&gt; is LSL, and is optional when &lt;extend&gt; is present but not LSL.

## &lt;Xd|SP&gt;

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

| option   | <R>   |
|----------|-------|
| 00x      | W     |

&lt;m&gt;

Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the 'Rm' field.

## Operation

```
constant bits(datasize) operand1 = if n == 31 then SP[datasize] else X[n, datasize]; constant bits(datasize) operand2 = NOT(ExtendReg(m, extend_type, shift, datasize)); bits(datasize) result; (result, -) = AddWithCarry(operand1, operand2, '1'); if d == 31 then SP[64] = ZeroExtend(result, 64); else X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| option   | <R>   |
|----------|-------|
| 010      | W     |
| x11      | X     |
| 10x      | W     |
| 110      | W     |

## C6.2.456 SUB (immediate)

Subtract immediate value

This instruction subtracts an optionally-shifted immediate value from a register value, and writes the result to the destination register.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) SUB <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) SUB <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant bits(24) imm = if sh == '0' then Zeros(12):imm12
```

## Assembler Symbols

## &lt;Wd|WSP&gt;

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Wn|WSP&gt;

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is an unsigned immediate, in the range 0 to 4095, encoded in the 'imm12' field.

## &lt;shift&gt;

Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in 'sh':

|   sh | <shift>   |
|------|-----------|
|    0 | LSL #0    |
|    1 | LSL #12   |

## &lt;Xd|SP&gt;

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

```
else imm12:Zeros(12);
```

## &lt;Xn|SP&gt;

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand1 = if n == 31 then SP[datasize] else X[n, datasize]; constant bits(datasize) operand2 = ZeroExtend(imm, datasize); bits(datasize) result; (result, -) = AddWithCarry(operand1, NOT(operand2), '1'); if d == 31 then SP[64] = ZeroExtend(result, 64); else X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.457 SUB (shifted register)

Subtract optionally-shifted register

This instruction subtracts an optionally-shifted register value from a register value, and writes the result to the destination register.

This instruction is used by the alias NEG (shifted register).

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) SUB <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
SUB <Xd>, <Xn>, <Xm>{, <shift>
```

```
1) #<amount>}
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if shift == '11' then EndOfDecode(Decode_UNDEF); if sf == '0' && imm6<5> == '1' then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type = DecodeShift(shift); constant integer shift_amount = UInt(imm6);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded in 'shift':

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = NOT(ShiftReg(m, shift_type, shift_amount, datasize)); bits(datasize) result; (result, -) = AddWithCarry(operand1, operand2, '1'); X[d, datasize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |
|      10 | ASR       |
|      11 | RESERVED  |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

| Alias                  | Is preferred when   |
|------------------------|---------------------|
| NEG (shifted register) | Rn == '11111'       |

## C6.2.458 SUBG

Subtract with tag

This instruction subtracts an immediate value scaled by the Tag Granule from the address in the source register, modifies the Logical Address Tag of the address using an immediate value, and writes the result to the destination register. Tags specified in GCR\_EL1.Exclude are excluded from the possible outputs when modifying the Logical Address Tag.

## Integer

(FEAT\_MTE)

<!-- image -->

## Encoding

```
SUBG <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant bits(4) tag_offset = imm4; constant bits(64) offset = LSL(ZeroExtend(imm6, 64),
```

## Assembler Symbols

## &lt;Xd|SP&gt;

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;uimm6&gt;

Is an unsigned immediate, a multiple of 16 in the range 0 to 1008, encoded in the 'imm6' field.

## &lt;uimm4&gt;

Is an unsigned immediate, in the range 0 to 15, encoded in the 'imm4' field.

## Operation

```
constant bits(64) operand1 = if n == 31 then SP[64] else X[n, 64]; constant bits(4) start_tag = AArch64.AllocationTagFromAddress(operand1); constant bits(16) exclude = GCR_EL1.Exclude; constant bits(4) rtag = AArch64.ChooseNonExcludedTagOrZero(start_tag, tag_offset, exclude); bits(64) result; (result, -) = AddWithCarry(operand1, NOT(offset), '1'); result = AArch64.AddressWithAllocationTag(result, rtag); if d == 31 then SP[64] = result; else X[d, 64] = result;
```

```
LOG2_TAG_GRANULE);
```

## C6.2.459 SUBP

Subtract pointer

This instruction subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, sign-extends the result to 64 bits, and writes the result to the destination register.

## Integer

(FEAT\_MTE)

<!-- image -->

## Encoding

```
SUBP <Xd>, <Xn|SP>, <Xm|SP>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm|SP&gt;

Is the 64-bit name of the second general-purpose source register or stack pointer, encoded in the 'Rm' field.

## Operation

```
bits(64) operand1 = if n == 31 then SP[64] else X[n, 64]; bits(64) operand2 = if m == 31 then SP[64] else X[m, 64]; operand1 = SignExtend(operand1<55:0>, 64); operand2 = NOT(SignExtend(operand2<55:0>, 64)); bits(64) result; (result, -) = AddWithCarry(operand1, operand2, '1'); X[d, 64] = result;
```

## C6.2.460 SUBPS

Subtract pointer, setting flags

This instruction subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, sign-extends the result to 64 bits, and writes the result to the destination register. It updates the condition flags based on the result of the subtraction.

This instruction is used by the alias CMPP.

## Integer

(FEAT\_MTE)

<!-- image -->

## Encoding

```
SUBPS <Xd>, <Xn|SP>, <Xm|SP>
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_MTE) then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm);
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm|SP&gt;

Is the 64-bit name of the second general-purpose source register or stack pointer, encoded in the 'Rm' field.

## Alias Conditions

| Alias   | Is preferred when         |
|---------|---------------------------|
| CMPP    | S == '1' && Rd == '11111' |

## Operation

```
bits(64) operand1 = if n == 31 then SP[64] else bits(64) operand2 = if m == 31 then SP[64] else operand1 = SignExtend(operand1<55:0>, 64); operand2 = NOT(SignExtend(operand2<55:0>, 64)); bits(64) result; bits(4) nzcv; (result, nzcv) = AddWithCarry(operand1, operand2, '1'); X[d, 64] = result; PSTATE.<N,Z,C,V> = nzcv;
```

```
X[n, 64]; X[m, 64];
```

## C6.2.461 SUBPT

Subtract checked pointer

This instruction subtracts an optionally-shifted register value from a base address register value, and writes the result to the destination register. The optionally-shifted register value is treated as the offset.

If the operation would have generated a result where the most significant 8 bits of the result register differ from the most significant 8 bits of the base register, then the result is modified such that it is likely to be non-canonical when used as an address.

## Integer

(FEAT\_CPA)

<!-- image -->

## Encoding

```
SUBPT <Xd|SP>, <Xn|SP>, <Xm>{, LSL #<amount>}
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_CPA) then EndOfDecode(Decode_UNDEF);
```

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer shift = UInt(imm3);
```

## Assembler Symbols

## &lt;Xd|SP&gt;

Is the 64-bit name of the general-purpose destination register or stack pointer, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the first general-purpose source register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;amount&gt;

Is the left shift amount, in the range 0 to 7, defaulting to 0, encoded in the 'imm3' field.

## Operation

```
bits(64) result; constant bits(64) base = if n == 31 then SP[64] else X[n, 64]; constant bits(64) offset = LSL(X[m, 64], shift); result = base -offset; result = PointerAddCheck(result, base); if d == 31 then SP[64] = result; else X[d, 64] = result;
```

## C6.2.462 SUBS (extended register)

Subtract extended and scaled register, setting flags

This instruction subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result.

This instruction is used by the alias CMP (extended register).

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
SUBS <Wd>, <Wn|WSP>, <Wm>{, <extend>
```

```
0) {#<amount>}}
```

## Encoding for the 64-bit variant

Applies when

```
(sf == 1) SUBS <Xd>, <Xn|SP>, <R><m>{, <extend>
```

## Decode for all variants of this encoding

```
if imm3 IN {'101', '110', '111'} then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer shift = UInt(imm3); constant integer datasize = 32 << UInt(sf); constant ExtendType extend_type = DecodeRegExtend(option);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn|WSP&gt;

Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;extend&gt;

For the '32-bit' variant: is the extension to be applied to the second source operand, encoded in 'option':

|   option | <extend>   |
|----------|------------|
|      000 | UXTB       |

```
{#<amount>}}
```

Is a width specifier, encoded in 'option':

|   option | <extend>      |
|----------|---------------|
|      001 | UXTH          |
|      010 | LSL&#124;UXTW |
|      011 | UXTX          |
|      100 | SXTB          |
|      101 | SXTH          |
|      110 | SXTW          |
|      111 | SXTX          |

If 'Rn' is '11111' (WSP) and 'option' is '010' then LSL is preferred, but may be omitted when 'imm3' is '000'. In all other cases &lt;extend&gt; is required and must be UXTW when 'option' is '010'.

For the '64-bit' variant: is the extension to be applied to the second source operand, encoded in 'option':

|   option | <extend>      |
|----------|---------------|
|      000 | UXTB          |
|      001 | UXTH          |
|      010 | UXTW          |
|      011 | LSL&#124;UXTX |
|      100 | SXTB          |
|      101 | SXTH          |
|      110 | SXTW          |
|      111 | SXTX          |

If 'Rn' is '11111' (SP) and 'option' is '011' then LSL is preferred, but may be omitted when 'imm3' is '000'. In all other cases &lt;extend&gt; is required and must be UXTX when 'option' is '011'.

## &lt;amount&gt;

Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the 'imm3' field. It must be absent when &lt;extend&gt; is absent, is required when &lt;extend&gt; is LSL, and is optional when &lt;extend&gt; is present but not LSL.

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;R&gt;

&lt;m&gt;

Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the 'Rm' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = if n == 31 then SP[datasize] else X[n, datasize]; constant bits(datasize) operand2 = NOT(ExtendReg(m, extend_type, shift, datasize)); bits(datasize) result; bits(4) nzcv; (result, nzcv) = AddWithCarry(operand1, operand2, '1'); X[d, datasize] = result; PSTATE.<N,Z,C,V> = nzcv;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

| option   | <R>   |
|----------|-------|
| 00x      | W     |
| 010      | W     |
| x11      | X     |
| 10x      | W     |
| 110      | W     |

| Alias                   | Is preferred when   |
|-------------------------|---------------------|
| CMP (extended register) | Rd == '11111'       |

## C6.2.463 SUBS (immediate)

Subtract immediate value, setting flags

This instruction subtracts an optionally-shifted immediate value from a register value, and writes the result to the destination register. It updates the condition flags based on the result.

This instruction is used by the alias CMP (immediate).

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) SUBS
```

```
<Wd>, <Wn|WSP>, #<imm>{, <shift>}
```

## Encoding for the 64-bit variant

```
Applies when (sf == 1) SUBS <Xd>, <Xn|SP>, #<imm>{, <shift>}
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant bits(24) imm = if sh == '0' then Zeros(12):imm12
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn|WSP&gt;

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is an unsigned immediate, in the range 0 to 4095, encoded in the 'imm12' field.

## &lt;shift&gt;

Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in 'sh':

|   sh | <shift>   |
|------|-----------|
|    0 | LSL #0    |
|    1 | LSL #12   |

```
else imm12:Zeros(12);
```

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the 'Rn' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = if n == 31 then SP[datasize] else X[n, datasize]; constant bits(datasize) operand2 = ZeroExtend(imm, datasize); bits(datasize) result; bits(4) nzcv; (result, nzcv) = AddWithCarry(operand1, NOT(operand2), '1'); X[d, datasize] = result; PSTATE.<N,Z,C,V> = nzcv;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## Alias

CMP

(immediate)

## Is preferred when

Rd

==

'11111'

## C6.2.464 SUBS (shifted register)

Subtract optionally-shifted register, setting flags

This instruction subtracts an optionally-shifted register value from a register value, and writes the result to the destination register. It updates the condition flags based on the result.

This instruction is used by the aliases CMP (shifted register) and NEGS.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) SUBS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
```

## Encoding for the 64-bit variant

Applies when (sf ==

```
SUBS <Xd>, <Xn>, <Xm>{, <shift>
```

```
1) #<amount>}
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if shift == '11' then EndOfDecode(Decode_UNDEF); if sf == '0' && imm6<5> == '1' then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf); constant ShiftType shift_type = DecodeShift(shift); constant integer shift_amount = UInt(imm6);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded in 'shift':

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Alias Conditions

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = NOT(ShiftReg(m, shift_type, shift_amount, datasize)); bits(datasize) result; bits(4) nzcv; (result, nzcv) = AddWithCarry(operand1, operand2, '1'); X[d, datasize] = result; PSTATE.<N,Z,C,V> = nzcv;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |
|      10 | ASR       |
|      11 | RESERVED  |

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

| Alias                  | Is preferred when              |
|------------------------|--------------------------------|
| CMP (shifted register) | Rd == '11111'                  |
| NEGS                   | Rn == '11111' && Rd != '11111' |

## C6.2.465 SVC

Supervisor call

This instruction causes an exception to be taken to EL1.

On executing an SVC instruction, the PE records the exception as a Supervisor Call exception in ESR\_ELx, using the EC syndrome value 0x15 , and the value of the immediate argument.

<!-- image -->

<!-- image -->

## Assembler Symbols

&lt;imm&gt;

Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the 'imm16' field.

## Operation

```
AArch64.CheckForSVCTrap(imm); AArch64.CallSupervisor(imm);
```

## C6.2.466 SWP, SWPA, SWPAL, SWPL

Swap word or doubleword in memory

This instruction atomically loads a 32-bit word or 64-bit doubleword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register.

- If the destination register is not one of WZR or XZR , SWPA and SWPAL load from memory with acquire semantics.
- SWPL and SWPAL store to memory with release semantics.
- SWP has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the 32-bit SWP variant

```
Applies when (size == 10 && A == 0 && R == 0)
```

```
SWP <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit SWPA variant

```
Applies when (size == 10 && A == 1 && R == 0) SWPA <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit SWPAL variant

```
Applies when (size == 10 && A == 1 && R == 1) SWPAL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit SWPL variant

Applies when (size == 10 &amp;&amp; A == 0 &amp;&amp; R == 1)

```
SWPL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 64-bit SWP variant

```
Applies when (size == 11 && A == 0 && R == 0)
```

```
SWP <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit SWPA variant

```
Applies when (size == 11 && A == 1 && R == 0) SWPA <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit SWPAL variant

Applies when (size == 11 &amp;&amp; A == 1 &amp;&amp; R ==

```
SWPAL <Xs>,
```

```
1) <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit SWPL variant

Applies when (size == 11 &amp;&amp; A == 0 &amp;&amp; R ==

```
SWPL
```

```
1) <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 8 << UInt(size); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register to be stored, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xs&gt;

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Operation

```
bits(64) address; bits(datasize) data; bits(datasize) store_value; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_SWP, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; store_value = X[s, datasize];
```

Is the 64-bit name of the general-purpose register to be stored, encoded in the 'Rs' field.

```
constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, store_value, accdesc); X[t, regsize] = ZeroExtend(data, regsize);
```

## C6.2.467 SWPB, SWPAB, SWPALB, SWPLB

Swap byte in memory

This instruction atomically loads an 8-bit byte from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , SWPAB and SWPALB load from memory with acquire semantics.
- SWPLB and SWPALB store to memory with release semantics.
- SWPB has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the SWPB variant

```
Applies when (A == 0 && R == 0) SWPB <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the SWPAB variant

```
Applies when (A == 1 && R == SWPAB <Ws>, <Wt>, [<Xn|SP>]
```

```
0)
```

## Encoding for the SWPALB variant

```
Applies when (A == 1 && R == SWPALB <Ws>, <Wt>, [<Xn|SP>]
```

```
1)
```

## Encoding for the SWPLB variant

```
Applies when (A == 0 && R == 1) SWPLB <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register to be stored, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; bits(8) data; bits(8) store_value; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_SWP, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; store_value = X[s, 8]; constant bits(8) comparevalue = bits(8) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, store_value, accdesc); X[t, 32] = ZeroExtend(data, 32);
```

## C6.2.468 SWPH, SWPAH, SWPALH, SWPLH

Swap halfword in memory

This instruction atomically loads a 16-bit halfword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register.

- If the destination register is not WZR , SWPAH and SWPALH load from memory with acquire semantics.
- SWPLH and SWPALH store to memory with release semantics.
- SWPH has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

## Integer

(FEAT\_LSE)

<!-- image -->

## Encoding for the SWPH variant

```
Applies when (A == 0 && R == 0) SWPH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the SWPAH variant

```
Applies when (A == 1 && R == 0) SWPAH <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the SWPALH variant

```
Applies when (A == 1 && R == SWPALH <Ws>, <Wt>, [<Xn|SP>]
```

```
1)
```

## Encoding for the SWPLH variant

```
Applies when (A == 0 && R == 1) SWPLH <Ws>, <Wt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE) then EndOfDecode(Decode_UNDEF); constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register to be stored, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; bits(16) data; bits(16) store_value; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_SWP, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; store_value = X[s, 16]; constant bits(16) comparevalue = bits(16) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, store_value, accdesc); X[t, 32] = ZeroExtend(data, 32);
```

## C6.2.469 SWPP, SWPPA, SWPPAL, SWPPL

Swap quadword in memory

This instruction atomically loads a 128-bit quadword from a memory location, and stores the value held in a pair of registers back to the same memory location. The value initially loaded from memory is returned in the same pair of registers.

- SWPPA and SWPPAL load from memory with acquire semantics.
- SWPPL and SWPPAL store to memory with release semantics.
- SWPP has neither acquire nor release semantics.

## Integer

(FEAT\_LSE128)

<!-- image -->

## Encoding for the SWPP variant

Applies when

(A == 0

&amp;&amp;

R

==

```
SWPP <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the SWPPA variant

```
Applies when (A == 1 && R == 0) SWPPA <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the SWPPAL variant

```
Applies when (A == 1 && R == 1) SWPPAL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Encoding for the SWPPL variant

```
Applies when (A == 0 && R == 1) SWPPL <Xt1>, <Xt2>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSE128) then EndOfDecode(Decode_UNDEF); if Rt == '11111' then EndOfDecode(Decode_UNDEF); if Rt2 == '11111' then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); constant boolean acquire = A == '1'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31; boolean rt_unknown = FALSE; if t == t2 then
```

0)

```
constant Constraint c = ConstrainUnpredictable(Unpredictable_LSE128OVERLAP); assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP}; case c of when Constraint_UNKNOWN rt_unknown = TRUE; // result is UNKNOWN when Constraint_UNDEF EndOfDecode(Decode_UNDEF); when Constraint_NOP EndOfDecode(Decode_NOP);
```

For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors, and particularly CONSTRAINED UNPREDICTABLE behavior for A64 instructions.

## Assembler Symbols

&lt;Xt1&gt;

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the 'Rt2' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## Operation

```
bits(64) address; constant bits(64) value1 = X[t, 64]; constant bits(64) value2 = X[t2, 64]; bits(128) data; bits(128) store_value; constant boolean privileged = PSTATE.EL != EL0; constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_SWP, acquire, release, tagchecked, privileged, t, t2, t, t2); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; store_value = if BigEndian(accdesc.acctype) then value1:value2 else value2:value1; constant bits(128) comparevalue = bits(128) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, store_value, accdesc); if rt_unknown then data = bits(128) UNKNOWN; if BigEndian(accdesc.acctype) then X[t, 64] = data<127:64>; X[t2, 64] = data<63:0>; else X[t, 64] = data<63:0>; X[t2, 64] = data<127:64>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.470 SWPT, SWPTA, SWPTAL, SWPTL

Swap unprivileged

This instruction atomically loads a 32-bit word or 64-bit doubleword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register.

- If the destination register is not one of WZR or XZR , SWPTA and SWPTAL load from memory with acquire semantics.
- SWPTL and SWPTAL store to memory with release semantics.
- SWPT has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-Release.

For information about addressing modes, see Load/Store addressing modes.

Explicit Memory effects produced by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

- The instruction is executed at EL1.
- The instruction is executed at EL2 when the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the Explicit Memory effects operate with the restrictions determined by the Exception level at which the instruction is executed.

## Integer

(FEAT\_LSUI)

<!-- image -->

## Encoding for the 32-bit SWPT variant

```
Applies when (sz == 0 && A == 0 && R == 0)
```

```
SWPT <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit SWPTA variant

```
Applies when (sz == 0 && A == 1 && R == 0) SWPTA <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit SWPTAL variant

Applies when (sz == 0 &amp;&amp; A == 1 &amp;&amp; R ==

```
SWPTAL
```

```
1) <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 32-bit SWPTL variant

Applies when (sz == 0 &amp;&amp; A == 0 &amp;&amp; R == 1)

```
SWPTL <Ws>, <Wt>, [<Xn|SP>]
```

## Encoding for the 64-bit SWPT variant

Applies when (sz == 1 &amp;&amp; A == 0 &amp;&amp; R ==

```
SWPT
```

```
0) <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit SWPTA variant

```
Applies when (sz == 1 && A == 1 && R ==
```

```
SWPTA <Xs>,
```

```
0) <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit SWPTAL variant

```
Applies when (sz == 1 && A == 1 && R == 1)
```

```
SWPTAL <Xs>, <Xt>, [<Xn|SP>]
```

## Encoding for the 64-bit SWPTL variant

```
Applies when (sz == 1 && A == 0 && R == 1)
```

```
SWPTL <Xs>, <Xt>, [<Xn|SP>]
```

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_LSUI) then constant integer s = UInt(Rs); constant integer t = UInt(Rt); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sz); constant integer regsize = if datasize == 64 then 64 else 32; constant boolean acquire = A == '1' && Rt != '11111'; constant boolean release = R == '1'; constant boolean tagchecked = n != 31;
```

## Assembler Symbols

## &lt;Ws&gt;

Is the 32-bit name of the general-purpose register to be stored, encoded in the 'Rs' field.

## &lt;Wt&gt;

Is the 32-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

&lt;Xs&gt;

- &lt;Xt&gt;

```
EndOfDecode(Decode_UNDEF);
```

Is the 64-bit name of the general-purpose register to be stored, encoded in the 'Rs' field.

Is the 64-bit name of the general-purpose register to be loaded, encoded in the 'Rt' field.

## Operation

```
bits(64) address; bits(datasize) data; bits(datasize) store_value; constant boolean privileged = AArch64.IsUnprivAccessPriv(); constant AccessDescriptor accdesc = CreateAccDescAtomicOp(MemAtomicOp_SWP, acquire, release, tagchecked, privileged, t, s); if n == 31 then CheckSPAlignment(); address = SP[64]; else address = X[n, 64]; store_value = X[s, datasize]; constant bits(datasize) comparevalue = bits(datasize) UNKNOWN; // Irrelevant when not executing CAS data = MemAtomic(address, comparevalue, store_value, accdesc); X[t, regsize] = ZeroExtend(data, regsize);
```

## C6.2.471 SXTB

Signed extend byte

This instruction extracts an 8-bit value from a register, sign-extends it to the size of the register, and writes the result to the destination register.

This is an alias of SBFM. This means:

- The encodings in this description are named to match the encodings of SBFM.
- The description of SBFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0)

SXTB

&lt;Wd&gt;, &lt;Wn&gt;

## is equivalent to

```
SBFM <Wd>, <Wn>, #0, #7
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

Applies when (sf == 1 &amp;&amp; N ==

```
SXTB
```

```
1) <Xd>, <Wn>
```

## is equivalent to

```
SBFM <Xd>, <Xn>, #0, #7
```

and is always the preferred disassembly.

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

&lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

The description of SBFM gives the operational pseudocode for this instruction.

## Operational Information

The description of SBFM gives the operational information for this instruction.

## C6.2.472 SXTH

Sign extend halfword

This instruction extracts a 16-bit value, sign-extends it to the size of the register, and writes the result to the destination register.

This is an alias of SBFM. This means:

- The encodings in this description are named to match the encodings of SBFM.
- The description of SBFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0)

SXTH

&lt;Wd&gt;, &lt;Wn&gt;

## is equivalent to

```
SBFM <Wd>, <Wn>, #0, #15
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

Applies when (sf == 1 &amp;&amp; N ==

```
SXTH
```

```
1) <Xd>, <Wn>
```

## is equivalent to

```
SBFM <Xd>, <Xn>, #0, #15
```

and is always the preferred disassembly.

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

&lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

The description of SBFM gives the operational pseudocode for this instruction.

## Operational Information

The description of SBFM gives the operational information for this instruction.

## C6.2.473 SXTW

Sign extend word

This instruction sign-extends a word to the size of the register, and writes the result to the destination register.

This is an alias of SBFM. This means:

- The encodings in this description are named to match the encodings of SBFM.
- The description of SBFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

SXTW

&lt;Xd&gt;, &lt;Wn&gt;

## is equivalent to

```
SBFM <Xd>, <Xn>, #0, #31
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

The description of SBFM gives the operational pseudocode for this instruction.

## Operational Information

The description of SBFM gives the operational information for this instruction.

## C6.2.474 SYS

System instruction

For more information, see Op0 equals 0b01 , cache maintenance, TLB maintenance, and address translation instructions for the encodings of System instructions.

This instruction is used by the aliases APAS, AT, BRB, CFP, COSP, CPP, DC, DVP, GCSPOPCX, GCSPOPX, GCSPUSHM, GCSPUSHX, GCSSS1, IC, TLBI, and TRCIT.

<!-- image -->

## Encoding

```
SYS #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}
```

## Decode for this encoding

```
= UInt(Rt);
```

```
constant integer t constant bits(1) sys_L = L; constant bits(2) sys_op0 = '01'; constant bits(3) sys_op1 = op1; constant bits(3) sys_op2 = op2; constant bits(4) sys_crn = CRn; constant bits(4) sys_crm = CRm;
```

## Assembler Symbols

## &lt;op1&gt;

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the 'op1' field.

## &lt;Cn&gt;

Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the 'CRn' field.

## &lt;Cm&gt;

Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the 'CRm' field.

## &lt;op2&gt;

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the 'op2' field.

## &lt;Xt&gt;

Is the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in the 'Rt' field.

## Alias Conditions

| Alias   | Is preferred when                                              |
|---------|----------------------------------------------------------------|
| APAS    | op1 == '110' && CRn == '0111' && CRm == '0000' && op2 == '000' |

| Alias    | Is preferred when                                                                              |
|----------|------------------------------------------------------------------------------------------------|
| AT       | CRn == '0111' && CRm IN {'100x'} && SysOp(op1, '0111', CRm, op2) == Sys_AT                     |
| BRB      | op1 == '001' && CRn == '0111' && CRm == '0010' && SysOp('001', '0111', '0010', op2) == Sys_BRB |
| CFP      | op1 == '011' && CRn == '0111' && CRm == '0011' && op2 == '100'                                 |
| COSP     | op1 == '011' && CRn == '0111' && CRm == '0011' && op2 == '110'                                 |
| CPP      | op1 == '011' && CRn == '0111' && CRm == '0011' && op2 == '111'                                 |
| DC       | CRn == '0111' && SysOp(op1, '0111', CRm, op2) == Sys_DC                                        |
| DVP      | op1 == '011' && CRn == '0111' && CRm == '0011' && op2 == '101'                                 |
| GCSPOPCX | op1 == '000' && CRn == '0111' && CRm == '0111' && op2 == '101'                                 |
| GCSPOPX  | op1 == '000' && CRn == '0111' && CRm == '0111' && op2 == '110'                                 |
| GCSPUSHM | op1 == '011' && CRn == '0111' && CRm == '0111' && op2 == '000'                                 |
| GCSPUSHX | op1 == '000' && CRn == '0111' && CRm == '0111' && op2 == '100'                                 |
| GCSSS1   | op1 == '011' && CRn == '0111' && CRm == '0111' && op2 == '010'                                 |
| IC       | CRn == '0111' && SysOp(op1, '0111', CRm, op2) == Sys_IC                                        |
| TLBI     | CRn IN {'100x'} && SysOp(op1, CRn, CRm, op2) == Sys_TLBI                                       |
| TRCIT    | op1 == '011' && CRn == '0111' && CRm == '0010' && op2 == '111'                                 |

## Operation

AArch64.SysInstr(sys\_op0, sys\_op1, sys\_crn, sys\_crm, sys\_op2, t);

## C6.2.475 SYSL

System instruction with result

For more information, see Op0 equals 0b01 , cache maintenance, TLB maintenance, and address translation instructions for the encodings of System instructions.

This instruction is used by the aliases GCSPOPM and GCSSS2.

<!-- image -->

## Encoding

```
SYSL <Xt>, #<op1>, <Cn>, <Cm>, #<op2>
```

## Decode for this encoding

```
= UInt(Rt);
```

```
constant integer t constant bits(1) sys_L = L; constant bits(2) sys_op0 = '01'; constant bits(3) sys_op1 = op1; constant bits(3) sys_op2 = op2; constant bits(4) sys_crn = CRn; constant bits(4) sys_crm = CRm;
```

## Assembler Symbols

## &lt;Xt&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rt' field.

## &lt;op1&gt;

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the 'op1' field.

## &lt;Cn&gt;

Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the 'CRn' field.

## &lt;Cm&gt;

Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the 'CRm' field.

## &lt;op2&gt;

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the 'op2' field.

## Alias Conditions

| Alias   | Is preferred when                                              |
|---------|----------------------------------------------------------------|
| GCSPOPM | op1 == '011' && CRn == '0111' && CRm == '0111' && op2 == '001' |
| GCSSS2  | op1 == '011' && CRn == '0111' && CRm == '0111' && op2 == '011' |

## Operation

AArch64.SysInstrWithResult(sys\_op0, sys\_op1, sys\_crn, sys\_crm, sys\_op2, t);

## C6.2.476 SYSP

128-bit system instruction.

This instruction is used by the alias TLBIP.

## System

(FEAT\_SYSINSTR128)

<!-- image -->

## Encoding

```
SYSP #<op1>, <Cn>, <Cm>, #<op2>{, <Xt1>, <Xt2>}
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SYSINSTR128) then if Rt<0> == '1' && Rt != '11111' then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Rt); constant integer t2 = if t == 31 then 31 else t + 1; constant bits(1) sys_L = L; constant bits(2) sys_op0 = '01'; constant bits(3) sys_op1 = op1; constant bits(3) sys_op2 = op2; constant bits(4) sys_crn = CRn; constant bits(4) sys_crm = CRm;
```

## Assembler Symbols

## &lt;op1&gt;

Is a 3-bit unsigned immediate, in the range 0 to 6, encoded in the 'op1' field.

## &lt;Cn&gt;

Is a name 'Cn', with 'n' in the range 8 to 9, encoded in the 'CRn' field.

## &lt;Cm&gt;

Is a name 'Cm', with 'm' in the range 0 to 7, encoded in the 'CRm' field.

## &lt;op2&gt;

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the 'op2' field.

## &lt;Xt1&gt;

Is the 64-bit name of the first optional general-purpose source register, defaulting to '11111', encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second optional general-purpose source register, defaulting to '11111', encoded as 'Rt' +1. Defaults to '11111' if 'Rt' = '11111'.

```
EndOfDecode(Decode_UNDEF);
```

## Alias Conditions

| Alias   | Is preferred when                                            |
|---------|--------------------------------------------------------------|
| TLBIP   | CRn IN {'100x'} && SysOp128(op1, CRn, CRm, op2) == Sys_TLBIP |

## Operation

AArch64.SysInstr128(sys\_op0, sys\_op1, sys\_crn, sys\_crm, sys\_op2, t, t2);

## C6.2.477 TBNZ

Test bit and branch if nonzero

This instruction compares the value of a bit in a general-purpose register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.

<!-- image -->

## Encoding

```
TBNZ <R><t>, #<imm>, <label>
```

## Decode for this encoding

```
constant integer t = UInt(Rt); constant integer datasize = 32 << UInt(b5); constant integer bit_pos = UInt(b5:b40); constant bits(64) offset
```

## Assembler Symbols

&lt;R&gt;

Is a width specifier, encoded in 'b5':

```
= SignExtend(imm14:'00', 64);
```

<!-- image -->

Is the number [0-30] of the general-purpose register to be tested or the name ZR (31), encoded in the 'Rt' field.

## &lt;imm&gt;

Is the bit number to be tested, in the range 0 to 63, encoded in 'b5:b40'.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-32KB, is encoded as 'imm14' times 4.

|   b5 | <R>   |
|------|-------|
|    0 | W     |
|    1 | X     |

In assembler source code an 'X' specifier is always permitted, but a 'W' specifier is only permitted when the bit number is less than 32.

## Operation

```
constant bits(datasize) operand = X[t, datasize]; constant boolean branch_conditional = TRUE; if operand<bit_pos> != '0' then BranchTo(PC64 + offset, else BranchNotTaken(BranchType_DIR, branch_conditional);
```

```
BranchType_DIR, branch_conditional);
```

## C6.2.478 TBZ

Test bit and branch if zero

This instruction compares the value of a test bit with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. This instruction provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.

<!-- image -->

## Encoding

```
TBZ
```

```
<R><t>, #<imm>, <label>
```

## Decode for this encoding

```
constant integer t = UInt(Rt); constant integer datasize = 32 << UInt(b5); constant integer bit_pos = UInt(b5:b40); constant bits(64) offset
```

## Assembler Symbols

&lt;R&gt;

Is a width specifier, encoded in 'b5':

```
= SignExtend(imm14:'00', 64);
```

<!-- image -->

Is the number [0-30] of the general-purpose register to be tested or the name ZR (31), encoded in the 'Rt' field.

## &lt;imm&gt;

Is the bit number to be tested, in the range 0 to 63, encoded in 'b5:b40'.

## &lt;label&gt;

Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-32KB, is encoded as 'imm14' times 4.

|   b5 | <R>   |
|------|-------|
|    0 | W     |
|    1 | X     |

In assembler source code an 'X' specifier is always permitted, but a 'W' specifier is only permitted when the bit number is less than 32.

## Operation

```
constant bits(datasize) operand = X[t, datasize]; constant boolean branch_conditional = TRUE; if operand<bit_pos> == '0' then BranchTo(PC64 + offset, else BranchNotTaken(BranchType_DIR, branch_conditional);
```

```
BranchType_DIR, branch_conditional);
```

## C6.2.479 TLBI

TLB invalidate operation

For more information, see op0== 0b01 , cache maintenance, TLB maintenance, and address translation instructions.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

```
TLBI <tlbi_op>{, <Xt>}
```

## is equivalent to

```
SYS #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}
```

and is the preferred disassembly when SysOp(op1, CRn, CRm, op2) == Sys\_TLBI .

## Assembler Symbols

## &lt;tlbi\_op&gt;

Is a TLBI operation name, as listed for the TLBI system instruction group, encoded in 'op1:CRn:CRm:op2':

|   op1 |   CRn |   CRm |   op2 | <tlbi_op>   | Architectural Feature   |
|-------|-------|-------|-------|-------------|-------------------------|
|   000 |  1000 |  0001 |   000 | VMALLE1OS   | FEAT_TLBIOS             |
|   000 |  1000 |  0001 |   001 | VAE1OS      | FEAT_TLBIOS             |
|   000 |  1000 |  0001 |   010 | ASIDE1OS    | FEAT_TLBIOS             |
|   000 |  1000 |  0001 |   011 | VAAE1OS     | FEAT_TLBIOS             |
|   000 |  1000 |  0001 |   101 | VALE1OS     | FEAT_TLBIOS             |
|   000 |  1000 |  0001 |   111 | VAALE1OS    | FEAT_TLBIOS             |
|   000 |  1000 |  0010 |   001 | RVAE1IS     | FEAT_TLBIRANGE          |
|   000 |  1000 |  0010 |   011 | RVAAE1IS    | FEAT_TLBIRANGE          |
|   000 |  1000 |  0010 |   101 | RVALE1IS    | FEAT_TLBIRANGE          |
|   000 |  1000 |  0010 |   111 | RVAALE1IS   | FEAT_TLBIRANGE          |
|   000 |  1000 |  0011 |   000 | VMALLE1IS   | -                       |
|   000 |  1000 |  0011 |   001 | VAE1IS      | -                       |
|   000 |  1000 |  0011 |   010 | ASIDE1IS    | -                       |
|   000 |  1000 |  0011 |   011 | VAAE1IS     | -                       |
|   000 |  1000 |  0011 |   101 | VALE1IS     | -                       |

| op1     | CRn       | CRm       |   op2 | <tlbi_op>    | Architectural Feature   |
|---------|-----------|-----------|-------|--------------|-------------------------|
| 000     | 1000      | 0011      |   111 | VAALE1IS     | -                       |
| 000     | 1000      | 0101      |   001 | RVAE1OS      | FEAT_TLBIRANGE          |
| 000     | 1000      | 0101      |   011 | RVAAE1OS     | FEAT_TLBIRANGE          |
| 000     | 1000      | 0101      |   101 | RVALE1OS     | FEAT_TLBIRANGE          |
| 000     | 1000      | 0101      |   111 | RVAALE1OS    | FEAT_TLBIRANGE          |
| 000     | 1000      | 0110      |   001 | RVAE1        | FEAT_TLBIRANGE          |
| 000     | 1000      | 0110      |   011 | RVAAE1       | FEAT_TLBIRANGE          |
| 000     | 1000      | 0110      |   101 | RVALE1       | FEAT_TLBIRANGE          |
| 000     | 1000      | 0110      |   111 | RVAALE1      | FEAT_TLBIRANGE          |
| 000     | 1000      | 0111      |   000 | VMALLE1      | -                       |
| 000     | 1000      | 0111      |   001 | VAE1         | -                       |
| 000     | 1000      | 0111      |   010 | ASIDE1       | -                       |
| 000     | 1000      | 0111      |   011 | VAAE1        | -                       |
| 000     | 1000      | 0111      |   101 | VALE1        | -                       |
| 000     | 1000      | 0111      |   111 | VAALE1       | -                       |
| 000     | 1001      | 0001      |   000 | VMALLE1OSNXS | FEAT_XS                 |
| 000     | 1001      | 0001      |   001 | VAE1OSNXS    | FEAT_XS                 |
| 000     | 1001      | 0001      |   010 | ASIDE1OSNXS  | FEAT_XS                 |
| 000     | 1001      | 0001      |   011 | VAAE1OSNXS   | FEAT_XS                 |
| 000     | 1001      | 0001      |   101 | VALE1OSNXS   | FEAT_XS                 |
| 000     | 1001      | 0001      |   111 | VAALE1OSNXS  | FEAT_XS                 |
| 000     | 1001      | 0010      |   001 | RVAE1ISNXS   | FEAT_XS                 |
| 000     | 1001      | 0010      |   011 | RVAAE1ISNXS  | FEAT_XS                 |
| 000     | 1001      | 0010      |   101 | RVALE1ISNXS  | FEAT_XS                 |
| 000     | 1001      | 0010      |   111 | RVAALE1ISNXS | FEAT_XS                 |
| 000     | 1001      | 0011      |   000 | VMALLE1ISNXS | FEAT_XS                 |
| 000     | 1001      | 0011      |   001 | VAE1ISNXS    | FEAT_XS                 |
| 000     | 1001      | 0011      |   010 | ASIDE1ISNXS  | FEAT_XS                 |
| 000     | 1001      | 0011      |   011 | VAAE1ISNXS   | FEAT_XS                 |
| 000     | 1001      | 0011      |   101 | VALE1ISNXS   | FEAT_XS                 |
| 000 000 | 1001 1001 | 0011 0101 |   111 | VAALE1ISNXS  | FEAT_XS FEAT_XS         |
|         |           |           |   001 | RVAE1OSNXS   |                         |
| 000     | 1001      | 0101      |   011 | RVAAE1OSNXS  | FEAT_XS                 |
| 000     | 1001      | 0101      |   111 | RVAALE1OSNXS | FEAT_XS                 |
| 000     | 1001      | 0110      |   001 | RVAE1NXS     | FEAT_XS                 |
| 000     | 1001      | 0110      |   011 | RVAAE1NXS    | FEAT_XS                 |
| 000     | 1001      | 0110      |   101 | RVALE1NXS    | FEAT_XS                 |
| 000     | 1001      | 0110      |   111 | RVAALE1NXS   | FEAT_XS                 |
| 000     | 1001      | 0111      |   000 | VMALLE1NXS   | FEAT_XS                 |

|   op1 |   CRn |   CRm |   op2 | <tlbi_op>    | Architectural Feature   |
|-------|-------|-------|-------|--------------|-------------------------|
|   000 |  1001 |  0111 |   001 | VAE1NXS      | FEAT_XS                 |
|   000 |  1001 |  0111 |   010 | ASIDE1NXS    | FEAT_XS                 |
|   000 |  1001 |  0111 |   011 | VAAE1NXS     | FEAT_XS                 |
|   000 |  1001 |  0111 |   101 | VALE1NXS     | FEAT_XS                 |
|   000 |  1001 |  0111 |   111 | VAALE1NXS    | FEAT_XS                 |
|   100 |  1000 |  0000 |   001 | IPAS2E1IS    | -                       |
|   100 |  1000 |  0000 |   010 | RIPAS2E1IS   | FEAT_TLBIRANGE          |
|   100 |  1000 |  0000 |   101 | IPAS2LE1IS   | -                       |
|   100 |  1000 |  0000 |   110 | RIPAS2LE1IS  | FEAT_TLBIRANGE          |
|   100 |  1000 |  0001 |   000 | ALLE2OS      | FEAT_TLBIOS             |
|   100 |  1000 |  0001 |   001 | VAE2OS       | FEAT_TLBIOS             |
|   100 |  1000 |  0001 |   100 | ALLE1OS      | FEAT_TLBIOS             |
|   100 |  1000 |  0001 |   101 | VALE2OS      | FEAT_TLBIOS             |
|   100 |  1000 |  0001 |   110 | VMALLS12E1OS | FEAT_TLBIOS             |
|   100 |  1000 |  0010 |   001 | RVAE2IS      | FEAT_TLBIRANGE          |
|   100 |  1000 |  0010 |   010 | VMALLWS2E1IS | FEAT_TLBIW              |
|   100 |  1000 |  0010 |   101 | RVALE2IS     | FEAT_TLBIRANGE          |
|   100 |  1000 |  0011 |   000 | ALLE2IS      | -                       |
|   100 |  1000 |  0011 |   001 | VAE2IS       | -                       |
|   100 |  1000 |  0011 |   100 | ALLE1IS      | -                       |
|   100 |  1000 |  0011 |   101 | VALE2IS      | -                       |
|   100 |  1000 |  0011 |   110 | VMALLS12E1IS | -                       |
|   100 |  1000 |  0100 |   000 | IPAS2E1OS    | FEAT_TLBIOS             |
|   100 |  1000 |  0100 |   001 | IPAS2E1      | -                       |
|   100 |  1000 |  0100 |   010 | RIPAS2E1     | FEAT_TLBIRANGE          |
|   100 |  1000 |  0100 |   011 | RIPAS2E1OS   | FEAT_TLBIRANGE          |
|   100 |  1000 |  0100 |   100 | IPAS2LE1OS   | FEAT_TLBIOS             |
|   100 |  1000 |  0100 |   101 | IPAS2LE1     | -                       |
|   100 |  1000 |  0100 |   110 | RIPAS2LE1    | FEAT_TLBIRANGE          |
|   100 |  1000 |  0100 |   111 | RIPAS2LE1OS  | FEAT_TLBIRANGE          |
|   100 |  1000 |  0101 |   001 | RVAE2OS      | FEAT_TLBIRANGE          |
|   100 |  1000 |  0101 |   010 | VMALLWS2E1OS | FEAT_TLBIW              |
|   100 |  1000 |  0101 |   101 | RVALE2OS     | FEAT_TLBIRANGE          |
|   100 |  1000 |  0110 |   001 | RVAE2        | FEAT_TLBIRANGE          |
|   100 |  1000 |  0110 |   010 | VMALLWS2E1   | FEAT_TLBIW              |
|   100 |  1000 |  0110 |   101 | RVALE2       | FEAT_TLBIRANGE          |
|   100 |  1000 |  0111 |   000 | ALLE2        | -                       |
|   100 |  1000 |  0111 |   001 | VAE2         | -                       |
|   100 |  1000 |  0111 |   100 | ALLE1        | -                       |
|   100 |  1000 |  0111 |   101 | VALE2        | -                       |

| op1   | CRn   | CRm   | op2     | <tlbi_op>                    | Architectural Feature   |
|-------|-------|-------|---------|------------------------------|-------------------------|
| 100   | 1000  | 0111  | 110     | VMALLS12E1                   | -                       |
| 100   | 1001  | 0000  | 001     | IPAS2E1ISNXS                 | FEAT_XS                 |
| 100   | 1001  | 0000  | 010     | RIPAS2E1ISNXS                | FEAT_XS                 |
| 100   | 1001  | 0000  | 101     | IPAS2LE1ISNXS                | FEAT_XS                 |
| 100   | 1001  | 0000  | 110     | RIPAS2LE1ISNXS               | FEAT_XS                 |
| 100   | 1001  | 0001  | 000     | ALLE2OSNXS                   | FEAT_XS                 |
| 100   | 1001  | 0001  | 001     | VAE2OSNXS                    | FEAT_XS                 |
| 100   | 1001  | 0001  | 100     | ALLE1OSNXS                   | FEAT_XS                 |
| 100   | 1001  | 0001  | 101     | VALE2OSNXS                   | FEAT_XS                 |
| 100   | 1001  | 0001  | 110     | VMALLS12E1OSNXS              | FEAT_XS                 |
| 100   | 1001  | 0010  | 001     | RVAE2ISNXS                   | FEAT_XS                 |
| 100   | 1001  | 0010  | 010     | VMALLWS2E1ISNXS              | FEAT_TLBIW              |
| 100   | 1001  | 0010  | 101     | RVALE2ISNXS                  | FEAT_XS                 |
| 100   | 1001  | 0011  | 000     | ALLE2ISNXS                   | FEAT_XS                 |
| 100   | 1001  | 0011  | 001     | VAE2ISNXS                    | FEAT_XS                 |
| 100   | 1001  | 0011  | 100     | ALLE1ISNXS                   | FEAT_XS                 |
| 100   | 1001  | 0011  | 101     | VALE2ISNXS                   | FEAT_XS                 |
| 100   | 1001  | 0011  | 110 000 | VMALLS12E1ISNXS IPAS2E1OSNXS | FEAT_XS FEAT_XS         |
| 100   | 1001  | 0100  | 001     | IPAS2E1NXS                   |                         |
| 100   | 1001  | 0100  |         |                              | FEAT_XS                 |
| 100   | 1001  | 0100  |         | RIPAS2E1OSNXS                | FEAT_XS                 |
|       |       |       | 011 100 | IPAS2LE1OSNXS                |                         |
| 100   | 1001  | 0100  | 101     | IPAS2LE1NXS                  | FEAT_XS                 |
| 100   | 1001  | 0100  |         |                              | FEAT_XS                 |
| 100   | 1001  | 0100  | 110     | RIPAS2LE1NXS                 | FEAT_XS                 |
| 100   | 1001  | 0101  | 001     | RVAE2OSNXS                   | FEAT_XS                 |
| 100   | 1001  | 0101  | 010     | VMALLWS2E1OSNXS              | FEAT_TLBIW              |
| 100   | 1001  | 0101  | 101     | RVALE2OSNXS                  | FEAT_XS                 |
| 100   | 1001  | 0110  | 001     | RVAE2NXS                     | FEAT_XS                 |
| 100   | 1001  | 0110  | 010     | VMALLWS2E1NXS                | FEAT_TLBIW              |
| 100   | 1001  | 0110  | 101     | RVALE2NXS                    | FEAT_XS                 |
| 100   | 1001  | 0111  | 000     | ALLE2NXS                     | FEAT_XS                 |
| 100   | 1001  | 0111  | 001     | VAE2NXS                      | FEAT_XS                 |
| 100   | 1001  | 0111  | 100     | ALLE1NXS                     | FEAT_XS                 |
| 100   | 1001  | 0111  |         |                              | FEAT_XS                 |
| 100   | 1001  | 0111  | 101 110 | VALE2NXS VMALLS12E1NXS       | FEAT_XS                 |
| 110   | 1000  | 0001  | 000     | ALLE3OS                      | FEAT_TLBIOS             |
| 110   | 1000  | 0001  | 001     | VAE3OS                       | FEAT_TLBIOS             |

|   op1 |   CRn |   CRm |   op2 | <tlbi_op>   | Architectural Feature   |
|-------|-------|-------|-------|-------------|-------------------------|
|   110 |  1000 |  0001 |   101 | VALE3OS     | FEAT_TLBIOS             |
|   110 |  1000 |  0010 |   001 | RVAE3IS     | FEAT_TLBIRANGE          |
|   110 |  1000 |  0010 |   101 | RVALE3IS    | FEAT_TLBIRANGE          |
|   110 |  1000 |  0011 |   000 | ALLE3IS     | -                       |
|   110 |  1000 |  0011 |   001 | VAE3IS      | -                       |
|   110 |  1000 |  0011 |   101 | VALE3IS     | -                       |
|   110 |  1000 |  0100 |   011 | RPAOS       | FEAT_RME                |
|   110 |  1000 |  0100 |   111 | RPALOS      | FEAT_RME                |
|   110 |  1000 |  0101 |   001 | RVAE3OS     | FEAT_TLBIRANGE          |
|   110 |  1000 |  0101 |   101 | RVALE3OS    | FEAT_TLBIRANGE          |
|   110 |  1000 |  0110 |   001 | RVAE3       | FEAT_TLBIRANGE          |
|   110 |  1000 |  0110 |   101 | RVALE3      | FEAT_TLBIRANGE          |
|   110 |  1000 |  0111 |   000 | ALLE3       | -                       |
|   110 |  1000 |  0111 |   001 | VAE3        | -                       |
|   110 |  1000 |  0111 |   100 | PAALL       | FEAT_RME                |
|   110 |  1000 |  0111 |   101 | VALE3       | -                       |
|   110 |  1001 |  0001 |   000 | ALLE3OSNXS  | FEAT_XS                 |
|   110 |  1001 |  0001 |   001 | VAE3OSNXS   | FEAT_XS                 |
|   110 |  1001 |  0001 |   101 | VALE3OSNXS  | FEAT_XS                 |
|   110 |  1001 |  0010 |   001 | RVAE3ISNXS  | FEAT_XS                 |
|   110 |  1001 |  0010 |   101 | RVALE3ISNXS | FEAT_XS                 |
|   110 |  1001 |  0011 |   000 | ALLE3ISNXS  | FEAT_XS                 |
|   110 |  1001 |  0011 |   001 | VAE3ISNXS   | FEAT_XS                 |
|   110 |  1001 |  0011 |   101 | VALE3ISNXS  | FEAT_XS                 |
|   110 |  1001 |  0101 |   001 | RVAE3OSNXS  | FEAT_XS                 |
|   110 |  1001 |  0101 |   101 | RVALE3OSNXS | FEAT_XS                 |
|   110 |  1001 |  0110 |   001 | RVAE3NXS    | FEAT_XS                 |
|   110 |  1001 |  0110 |   101 | RVALE3NXS   | FEAT_XS                 |
|   110 |  1001 |  0111 |   000 | ALLE3NXS    | FEAT_XS                 |
|   110 |  1001 |  0111 |   001 | VAE3NXS     | FEAT_XS                 |
|   110 |  1001 |  0111 |   101 | VALE3NXS    | FEAT_XS                 |

## &lt;Xt&gt;

Is the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in the 'Rt' field.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.480 TLBIP

TLB invalidate pair operation.

This is an alias of SYSP. This means:

- The encodings in this description are named to match the encodings of SYSP.
- The description of SYSP gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

## (FEAT\_SYSINSTR128)

<!-- image -->

## Encoding

```
TLBIP <tlbip_op>{, <Xt1>, <Xt2>}
```

## is equivalent to

```
SYSP #<op1>, <Cn>, <Cm>, #<op2>{, <Xt1>, <Xt2>}
```

and is the preferred disassembly when SysOp128(op1, CRn, CRm, op2) == Sys\_TLBIP .

## Assembler Symbols

## &lt;tlbip\_op&gt;

Is a TLBIP operation name, as listed for the TLBIP system pair instruction group, encoded in 'op1:CRn:CRm:op2':

|   op1 |   CRn |   CRm |   op2 | <tlbip_op>   | Architectural Feature   |
|-------|-------|-------|-------|--------------|-------------------------|
|   000 |  1000 |  0001 |   001 | VAE1OS       | FEAT_D128               |
|   000 |  1000 |  0001 |   011 | VAAE1OS      | FEAT_D128               |
|   000 |  1000 |  0001 |   101 | VALE1OS      | FEAT_D128               |
|   000 |  1000 |  0001 |   111 | VAALE1OS     | FEAT_D128               |
|   000 |  1000 |  0010 |   001 | RVAE1IS      | FEAT_D128               |
|   000 |  1000 |  0010 |   011 | RVAAE1IS     | FEAT_D128               |
|   000 |  1000 |  0010 |   101 | RVALE1IS     | FEAT_D128               |
|   000 |  1000 |  0010 |   111 | RVAALE1IS    | FEAT_D128               |
|   000 |  1000 |  0011 |   001 | VAE1IS       | FEAT_D128               |
|   000 |  1000 |  0011 |   011 | VAAE1IS      | FEAT_D128               |
|   000 |  1000 |  0011 |   101 | VALE1IS      | FEAT_D128               |
|   000 |  1000 |  0011 |   111 | VAALE1IS     | FEAT_D128               |
|   000 |  1000 |  0101 |   001 | RVAE1OS      | FEAT_D128               |

|   op1 | CRn       |   CRm |   op2 | <tlbip_op>   | Architectural Feature   |
|-------|-----------|-------|-------|--------------|-------------------------|
|   000 | 1000      |  0101 |   011 | RVAAE1OS     | FEAT_D128               |
|   000 | 1000      |  0101 |   101 | RVALE1OS     | FEAT_D128               |
|   000 | 1000      |  0101 |   111 | RVAALE1OS    | FEAT_D128               |
|   000 | 1000      |  0110 |   001 | RVAE1        | FEAT_D128               |
|   000 | 1000      |  0110 |   011 | RVAAE1       | FEAT_D128               |
|   000 | 1000      |  0110 |   101 | RVALE1       | FEAT_D128               |
|   000 | 1000      |  0110 |   111 | RVAALE1      | FEAT_D128               |
|   000 | 1000      |  0111 |   001 | VAE1         | FEAT_D128               |
|   000 | 1000      |  0111 |   011 | VAAE1        | FEAT_D128               |
|   000 | 1000      |  0111 |   101 | VALE1        | FEAT_D128               |
|   000 | 1000      |  0111 |   111 | VAALE1       | FEAT_D128               |
|   000 | 1001      |  0001 |   001 | VAE1OSNXS    | FEAT_D128               |
|   000 | 1001      |  0001 |   011 | VAAE1OSNXS   | FEAT_D128               |
|   000 | 1001      |  0001 |   101 | VALE1OSNXS   | FEAT_D128               |
|   000 | 1001      |  0001 |   111 | VAALE1OSNXS  | FEAT_D128               |
|   000 | 1001      |  0010 |   011 | RVAAE1ISNXS  | FEAT_D128               |
|   000 | 1001      |  0010 |   101 | RVALE1ISNXS  | FEAT_D128               |
|   000 | 1001      |  0010 |   111 | RVAALE1ISNXS | FEAT_D128               |
|   000 | 1001      |  0011 |   001 | VAE1ISNXS    | FEAT_D128               |
|   000 | 1001      |  0011 |   011 | VAAE1ISNXS   | FEAT_D128               |
|   000 | 1001      |  0011 |   101 | VALE1ISNXS   | FEAT_D128               |
|   000 | 1001      |  0011 |   111 | VAALE1ISNXS  | FEAT_D128               |
|   000 | 1001      |  0101 |   001 | RVAE1OSNXS   | FEAT_D128               |
|   000 | 1001      |  0101 |   011 | RVAAE1OSNXS  | FEAT_D128               |
|   000 | 1001      |  0101 |   101 | RVALE1OSNXS  | FEAT_D128               |
|   000 | 1001      |  0101 |   111 | RVAALE1OSNXS | FEAT_D128               |
|   000 | 1001      |  0110 |   001 | RVAE1NXS     | FEAT_D128               |
|   000 | 1001      |  0110 |   011 | RVAAE1NXS    | FEAT_D128               |
|   000 | 1001      |  0110 |   101 | RVALE1NXS    | FEAT_D128               |
|   000 | 1001      |  0110 |   111 | RVAALE1NXS   | FEAT_D128               |
|   000 | 1001      |  0111 |   001 | VAE1NXS      | FEAT_D128               |
|   000 | 1001      |  0111 |   011 | VAAE1NXS     | FEAT_D128               |
|   000 | 1001 1001 |  0111 |   101 | VALE1NXS     | FEAT_D128               |
|   000 |           |  0111 |   111 | VAALE1NXS    | FEAT_D128               |
|   100 | 1000      |  0000 |   001 | IPAS2E1IS    | FEAT_D128               |
|   100 | 1000      |  0000 |   010 | RIPAS2E1IS   | FEAT_D128               |
|   100 | 1000      |  0000 |   101 | IPAS2LE1IS   | FEAT_D128               |
|   100 | 1000      |  0000 |   110 | RIPAS2LE1IS  | FEAT_D128               |

|   op1 |   CRn |   CRm |   op2 | <tlbip_op>     | Architectural Feature   |
|-------|-------|-------|-------|----------------|-------------------------|
|   100 |  1000 |  0001 |   101 | VALE2OS        | FEAT_D128               |
|   100 |  1000 |  0010 |   001 | RVAE2IS        | FEAT_D128               |
|   100 |  1000 |  0010 |   101 | RVALE2IS       | FEAT_D128               |
|   100 |  1000 |  0011 |   001 | VAE2IS         | FEAT_D128               |
|   100 |  1000 |  0011 |   101 | VALE2IS        | FEAT_D128               |
|   100 |  1000 |  0100 |   000 | IPAS2E1OS      | FEAT_D128               |
|   100 |  1000 |  0100 |   001 | IPAS2E1        | FEAT_D128               |
|   100 |  1000 |  0100 |   010 | RIPAS2E1       | FEAT_D128               |
|   100 |  1000 |  0100 |   011 | RIPAS2E1OS     | FEAT_D128               |
|   100 |  1000 |  0100 |   100 | IPAS2LE1OS     | FEAT_D128               |
|   100 |  1000 |  0100 |   101 | IPAS2LE1       | FEAT_D128               |
|   100 |  1000 |  0100 |   110 | RIPAS2LE1      | FEAT_D128               |
|   100 |  1000 |  0100 |   111 | RIPAS2LE1OS    | FEAT_D128               |
|   100 |  1000 |  0101 |   001 | RVAE2OS        | FEAT_D128               |
|   100 |  1000 |  0101 |   101 | RVALE2OS       | FEAT_D128               |
|   100 |  1000 |  0110 |   001 | RVAE2          | FEAT_D128               |
|   100 |  1000 |  0110 |   101 | RVALE2         | FEAT_D128               |
|   100 |  1000 |  0111 |   001 | VAE2           | FEAT_D128               |
|   100 |  1000 |  0111 |   101 | VALE2          | FEAT_D128               |
|   100 |  1001 |  0000 |   001 | IPAS2E1ISNXS   | FEAT_D128               |
|   100 |  1001 |  0000 |   010 | RIPAS2E1ISNXS  | FEAT_D128               |
|   100 |  1001 |  0000 |   101 | IPAS2LE1ISNXS  | FEAT_D128               |
|   100 |  1001 |  0000 |   110 | RIPAS2LE1ISNXS | FEAT_D128               |
|   100 |  1001 |  0001 |   001 | VAE2OSNXS      | FEAT_D128               |
|   100 |  1001 |  0001 |   101 | VALE2OSNXS     | FEAT_D128               |
|   100 |  1001 |  0010 |   001 | RVAE2ISNXS     | FEAT_D128               |
|   100 |  1001 |  0010 |   101 | RVALE2ISNXS    | FEAT_D128               |
|   100 |  1001 |  0011 |   001 | VAE2ISNXS      | FEAT_D128               |
|   100 |  1001 |  0011 |   101 | VALE2ISNXS     | FEAT_D128               |
|   100 |  1001 |  0100 |   000 | IPAS2E1OSNXS   | FEAT_D128               |
|   100 |  1001 |  0100 |   001 | IPAS2E1NXS     | FEAT_D128               |
|   100 |  1001 |  0100 |   010 | RIPAS2E1NXS    | FEAT_D128               |
|   100 |  1001 |  0100 |   011 | RIPAS2E1OSNXS  | FEAT_D128               |
|   100 |  1001 |  0100 |   100 | IPAS2LE1OSNXS  | FEAT_D128               |
|   100 |  1001 |  0100 |   101 | IPAS2LE1NXS    | FEAT_D128               |
|   100 |  1001 |  0100 |   110 | RIPAS2LE1NXS   | FEAT_D128               |
|   100 |  1001 |  0100 |   111 | RIPAS2LE1OSNXS | FEAT_D128               |
|   100 |  1001 |  0101 |   001 | RVAE2OSNXS     | FEAT_D128               |
|   100 |  1001 |  0101 |   101 | RVALE2OSNXS    | FEAT_D128 FEAT_D128     |
|   100 |  1001 |  0110 |   001 | RVAE2NXS       |                         |

|   op1 |   CRn |   CRm |   op2 | <tlbip_op>   | Architectural Feature   |
|-------|-------|-------|-------|--------------|-------------------------|
|   100 |  1001 |  0110 |   101 | RVALE2NXS    | FEAT_D128               |
|   100 |  1001 |  0111 |   001 | VAE2NXS      | FEAT_D128               |
|   100 |  1001 |  0111 |   101 | VALE2NXS     | FEAT_D128               |
|   110 |  1000 |  0001 |   001 | VAE3OS       | FEAT_D128               |
|   110 |  1000 |  0001 |   101 | VALE3OS      | FEAT_D128               |
|   110 |  1000 |  0010 |   001 | RVAE3IS      | FEAT_D128               |
|   110 |  1000 |  0010 |   101 | RVALE3IS     | FEAT_D128               |
|   110 |  1000 |  0011 |   001 | VAE3IS       | FEAT_D128               |
|   110 |  1000 |  0011 |   101 | VALE3IS      | FEAT_D128               |
|   110 |  1000 |  0101 |   001 | RVAE3OS      | FEAT_D128               |
|   110 |  1000 |  0101 |   101 | RVALE3OS     | FEAT_D128               |
|   110 |  1000 |  0110 |   001 | RVAE3        | FEAT_D128               |
|   110 |  1000 |  0110 |   101 | RVALE3       | FEAT_D128               |
|   110 |  1000 |  0111 |   001 | VAE3         | FEAT_D128               |
|   110 |  1000 |  0111 |   101 | VALE3        | FEAT_D128               |
|   110 |  1001 |  0001 |   001 | VAE3OSNXS    | FEAT_D128               |
|   110 |  1001 |  0001 |   101 | VALE3OSNXS   | FEAT_D128               |
|   110 |  1001 |  0010 |   001 | RVAE3ISNXS   | FEAT_D128               |
|   110 |  1001 |  0010 |   101 | RVALE3ISNXS  | FEAT_D128               |
|   110 |  1001 |  0011 |   001 | VAE3ISNXS    | FEAT_D128               |
|   110 |  1001 |  0011 |   101 | VALE3ISNXS   | FEAT_D128               |
|   110 |  1001 |  0101 |   001 | RVAE3OSNXS   | FEAT_D128               |
|   110 |  1001 |  0101 |   101 | RVALE3OSNXS  | FEAT_D128               |
|   110 |  1001 |  0110 |   001 | RVAE3NXS     | FEAT_D128               |
|   110 |  1001 |  0110 |   101 | RVALE3NXS    | FEAT_D128               |
|   110 |  1001 |  0111 |   001 | VAE3NXS      | FEAT_D128               |
|   110 |  1001 |  0111 |   101 | VALE3NXS     | FEAT_D128               |

## &lt;Xt1&gt;

Is the 64-bit name of the first optional general-purpose source register, defaulting to '11111', encoded in the 'Rt' field.

## &lt;Xt2&gt;

Is the 64-bit name of the second optional general-purpose source register, defaulting to '11111', encoded as 'Rt' +1. Defaults to '11111' if 'Rt' = '11111'.

## Operation

The description of SYSP gives the operational pseudocode for this instruction.

## C6.2.481 TRCIT

Trace instrumentation

This instruction generates an instrumentation trace packet that contains the value of the provided register.

This is an alias of SYS. This means:

- The encodings in this description are named to match the encodings of SYS.
- The description of SYS gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

## System

(FEAT\_ITE)

<!-- image -->

## Encoding

TRCIT

&lt;Xt&gt;

## is equivalent to

<!-- formula-not-decoded -->

and is always the preferred disassembly.

## Assembler Symbols

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rt' field.

## Operation

The description of SYS gives the operational pseudocode for this instruction.

## C6.2.482 TSB

Trace synchronization barrier

This instruction is a barrier that synchronizes the trace operations of instructions, see Trace Synchronization Barrier (TSB).

If FEAT\_TRF is not implemented, this instruction executes as a NOP .

## System

(FEAT\_TRF)

<!-- image -->

## Encoding

TSB CSYNC

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_TRF) then EndOfDecode(Decode_NOP);
```

## Operation

```
if IsFeatureImplemented(FEAT_FGT2) && IsFeatureImplemented(FEAT_TRBEv1p1) then constant boolean trap_to_el2 = (PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() && (!HaveEL(EL3) || SCR_EL3.FGTEn2 == '1') && HFGITR2_EL2.TSBCSYNC == '1'); if trap_to_el2 then ExceptionRecord except = ExceptionSyndrome(Exception_LDST64BTrap); // to except.syndrome.iss = \texttt{0x4}<24:0>; constant bits(64) preferred_exception_return = ThisInstrAddr(64); constant integer vect_offset = \texttt{0x0}; AArch64.TakeException(EL2, except, preferred_exception_return, vect_offset);
```

```
be renamed TraceSynchronizationBarrier();
```

## C6.2.483 TST (immediate)

Test bits (immediate)

This instruction performs a bitwise AND of a register value and an immediate value, and discards the results. It updates the condition flags based on the result.

This is an alias of ANDS (immediate). This means:

- The encodings in this description are named to match the encodings of ANDS (immediate).
- The description of ANDS (immediate) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

<!-- image -->

and is always the preferred disassembly.

## Encoding for the 64-bit variant

```
Applies when (sf == 1) TST <Xn>, #<imm> is equivalent to ANDS XZR, <Xn>, #<imm>
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;imm&gt;

For the '32-bit' variant: is the bitmask immediate, encoded in 'imms:immr'.

For the '64-bit' variant: is the bitmask immediate, encoded in 'N:imms:immr'.

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

The description of ANDS (immediate) gives the operational pseudocode for this instruction.

## Operational Information

The description of ANDS (immediate) gives the operational information for this instruction.

## C6.2.484 TST (shifted register)

Test (shifted register)

This instruction performs a bitwise AND operation on a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result.

This is an alias of ANDS (shifted register). This means:

- The encodings in this description are named to match the encodings of ANDS (shifted register).
- The description of ANDS (shifted register) gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf ==

```
0)
```

```
TST <Wn>, <Wm>{, <shift> #<amount>} is equivalent to ANDS WZR, <Wn>, <Wm>{, <shift> #<amount>}
```

and is always the preferred disassembly.

## Encoding for the 64-bit variant

Applies when (sf ==

```
1)
```

```
TST <Xn>, <Xm>{, <shift> #<amount>} is equivalent to ANDS XZR, <Xn>, <Xm>{, <shift> #<amount>}
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;shift&gt;

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in 'shift':

## &lt;amount&gt;

For the '32-bit' variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the 'imm6' field. For the '64-bit' variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the 'imm6' field.

## &lt;Xn&gt;

|   shift | <shift>   |
|---------|-----------|
|      00 | LSL       |
|      01 | LSR       |
|      10 | ASR       |
|      11 | ROR       |

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## Operation

The description of ANDS (shifted register) gives the operational pseudocode for this instruction.

## Operational Information

The description of ANDS (shifted register) gives the operational information for this instruction.

## C6.2.485 UBFIZ

Unsigned bitfield insert in zeros

This instruction copies a bitfield of &lt;width&gt; bits from the least significant bits of the source register to bit position &lt;lsb&gt; of the destination register, setting the destination bits above and below the bitfield to zero.

This is an alias of UBFM. This means:

- The encodings in this description are named to match the encodings of UBFM.
- The description of UBFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N ==

```
0) UBFIZ <Wd>, <Wn>, #<lsb>, #<width>
```

## is equivalent to

```
UBFM <Wd>, <Wn>, #(-<lsb> MOD 32), #(<width>-1)
```

and is the preferred disassembly when UInt(imms) &lt; UInt(immr) .

## Encoding for the 64-bit variant

```
Applies when (sf == 1 && N == 1) UBFIZ <Xd>, <Xn>, #<lsb>, #<width>
```

## is equivalent to

```
UBFM <Xd>, <Xn>, #(-<lsb> MOD 64), #(<width>-1)
```

and is the preferred disassembly when UInt(imms) &lt; UInt(immr) .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;lsb&gt;

For the '32-bit' variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.

For the '64-bit' variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.

## &lt;width&gt;

For the '32-bit' variant: is the width of the bitfield, in the range 1 to 32-&lt;lsb&gt;.

For the '64-bit' variant: is the width of the bitfield, in the range 1 to 64-&lt;lsb&gt;.

<!-- image -->

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

The description of UBFM gives the operational pseudocode for this instruction.

## Operational Information

The description of UBFM gives the operational information for this instruction.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.486 UBFM

## Unsigned bitfield move

This instruction is usually accessed via one of its aliases, which are always preferred for disassembly.

If &lt;imms&gt; is greater than or equal to &lt;immr&gt; , this copies a bitfield of ( &lt;imms&gt; -&lt;immr&gt; +1) bits starting from bit position &lt;immr&gt; in the source register to the least significant bits of the destination register.

If &lt;imms&gt; is less than &lt;immr&gt; , this copies a bitfield of ( &lt;imms&gt; +1) bits from the least significant bits of the source register to bit position (regsize&lt;immr&gt; ) of the destination register, where regsize is the destination register size of 32 or 64 bits.

In both cases, the destination bits below and above the bitfield are set to zero.

This instruction is used by the aliases LSL (immediate), LSR (immediate), UBFIZ, UBFX, UXTB, and UXTH.

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0 && N == UBFM <Wd>, <Wn>, #<immr>, #<imms>
```

```
0)
```

## Encoding for the 64-bit variant

```
1)
```

```
Applies when (sf == 1 && N == UBFM <Xd>, <Xn>, #<immr>, #<imms>
```

## Decode for all variants of this encoding

```
if sf == '1' && N != '1' then EndOfDecode(Decode_UNDEF); if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then EndOfDecode(Decode_UNDEF); constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant integer s = UInt(imms); constant integer r = UInt(immr); bits(datasize) wmask; bits(datasize) tmask; (wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE, datasize);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;immr&gt;

For the '32-bit' variant: is the right rotate amount, in the range 0 to 31, encoded in the 'immr' field.

For the '64-bit' variant: is the right rotate amount, in the range 0 to 63, encoded in the 'immr' field.

## &lt;imms&gt;

For the '32-bit' variant: is the leftmost bit number to be moved from the source, in the range 0 to 31, encoded in the 'imms' field.

For the '64-bit' variant: is the leftmost bit number to be moved from the source, in the range 0 to 63, encoded in the 'imms' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Alias Conditions

| Alias           | Of variant   | Is preferred when                                |
|-----------------|--------------|--------------------------------------------------|
| LSL (immediate) | 32-bit       | imms != '011111' && UInt(imms) + 1 == UInt(immr) |
| LSL (immediate) | 64-bit       | imms != '111111' && UInt(imms) + 1 == UInt(immr) |
| LSR (immediate) | 32-bit       | imms == '011111'                                 |
| LSR (immediate) | 64-bit       | imms == '111111'                                 |
| UBFIZ           |              | UInt(imms) < UInt(immr)                          |
| UBFX            |              | BFXPreferred(sf, opc<1>, imms, immr)             |
| UXTB            |              | immr == '000000' && imms == '000111'             |
| UXTH            |              | immr == '000000' && imms == '001111'             |

## Operation

```
constant bits(datasize) src = X[n, datasize]; // Perform bitfield move on low bits constant bits(datasize) bot = ROR(src, // Combine extension bits and result bits X[d, datasize] = bot AND tmask;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
r) AND wmask;
```

## C6.2.487 UBFX

## Unsigned bitfield extract

This instruction copies a bitfield of &lt;width&gt; bits starting from bit position &lt;lsb&gt; in the source register to the least significant bits of the destination register, and sets destination bits above the bitfield to zero.

This is an alias of UBFM. This means:

- The encodings in this description are named to match the encodings of UBFM.
- The description of UBFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0 &amp;&amp; N == 0)

```
UBFX <Wd>, <Wn>, #<lsb>, #<width>
```

## is equivalent to

```
UBFM <Wd>, <Wn>, #<lsb>, #(<lsb>+<width>-1)
```

and is the preferred disassembly when BFXPreferred(sf, opc[1], imms, immr) .

## Encoding for the 64-bit variant

```
Applies when (sf == 1 && N == 1) UBFX <Xd>, <Xn>, #<lsb>, #<width>
```

## is equivalent to

```
UBFM <Xd>, <Xn>, #<lsb>, #(<lsb>+<width>-1)
```

and is the preferred disassembly when BFXPreferred(sf, opc[1], imms, immr) .

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;lsb&gt;

For the '32-bit' variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.

For the '64-bit' variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.

## &lt;width&gt;

For the '32-bit' variant: is the width of the bitfield, in the range 1 to 32-&lt;lsb&gt;.

For the '64-bit' variant: is the width of the bitfield, in the range 1 to 64-&lt;lsb&gt;.

<!-- image -->

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

The description of UBFM gives the operational pseudocode for this instruction.

## Operational Information

The description of UBFM gives the operational information for this instruction.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## C6.2.488 UDF

## Permanently undefined

This instruction generates an Undefined Instruction exception (ESR\_ELx.EC = 0b000000 ). The encodings for UDF used in this section are defined as permanently UNDEFINED.

<!-- image -->

## Encoding

UDF

#&lt;imm&gt;

## Decode for this encoding

```
// The imm16 field is ignored by hardware. EndOfDecode(Decode_UNDEF);
```

## Assembler Symbols

## &lt;imm&gt;

is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the 'imm16' field. The PE ignores the value of this constant.

## Operation

// No operation.

## C6.2.489 UDIV

## Unsigned divide

This instruction divides the first unsigned source register value by the second unsigned source register value, and writes the result to the destination register. Dividing by zero writes the value zero to the destination register. The condition flags are not affected.

<!-- image -->

## Encoding for the 32-bit variant

0)

```
Applies when (sf == UDIV <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

```
1)
```

```
Applies when (sf == UDIV <Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 <<
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

```
UInt(sf);
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

```
constant bits(datasize) operand1 = constant bits(datasize) operand2 = constant integer dividend = UInt(operand1); constant integer divisor = UInt(operand2); integer result; if divisor == 0 then result = 0; else result = dividend DIV divisor; X[d, datasize] = result<datasize-1:0>;
```

```
X[n, datasize]; X[m, datasize];
```

## C6.2.490 UMADDL

Unsigned multiply-add long

This instruction multiplies two 32-bit register values, adds a 64-bit register value, and writes the result to the 64-bit destination register.

This instruction is used by the alias UMULL.

<!-- image -->

## Encoding

UMADDL

&lt;Xd&gt;,

&lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;

## Decode for this encoding

```
constant integer d = constant integer n = constant integer m = constant integer a =
```

```
UInt(Rd); UInt(Rn); UInt(Rm); UInt(Ra);
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## &lt;Xa&gt;

Is the 64-bit name of the third general-purpose source register holding the addend, encoded in the 'Ra' field.

## Alias Conditions

## Operation

```
constant bits(32) operand1 = X[n, 32]; constant bits(32) operand2 = X[m, 32]; constant bits(64) operand3 = X[a, 64]; constant integer result = UInt(operand3) + (UInt(operand1) * UInt(operand2)); X[d, 64] = result<63:0>;
```

<!-- image -->

| Alias   | Is preferred when   |
|---------|---------------------|
| UMULL   | Ra == '11111'       |

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.491 UMAX (immediate)

Unsigned maximum (immediate)

This instruction determines the unsigned maximum of the source register value and immediate, and writes the result to the destination register.

## Integer

(FEAT\_CSSC)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) UMAX <Wd>, <Wn>, #<uimm>
```

## Encoding for the 64-bit variant

Applies when

```
(sf == 1) UMAX <Xd>, <Xn>, #<uimm>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CSSC) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant integer imm = UInt(imm8);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;uimm&gt;

Is an unsigned immediate, in the range 0 to 255, encoded in the 'imm8' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant integer result = Max(UInt(operand1), imm); X[d, datasize] = result<datasize-1:0>;
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.492 UMAX (register)

Unsigned maximum (register)

This instruction determines the unsigned maximum of the two source register values and writes the result to the destination register.

## Integer

(FEAT\_CSSC)

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
UMAX <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

Applies when (sf == 1)

```
UMAX
```

```
<Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CSSC) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = X[m, datasize]; constant integer result = X[d, datasize] = result<datasize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
Max(UInt(operand1), UInt(operand2));
```

## C6.2.493 UMIN (immediate)

Unsigned minimum (immediate)

This instruction determines the unsigned minimum of the source register value and immediate, and writes the result to the destination register.

## Integer

(FEAT\_CSSC)

<!-- image -->

## Encoding for the 32-bit variant

```
Applies when (sf == 0) UMIN <Wd>, <Wn>, #<uimm>
```

## Encoding for the 64-bit variant

Applies when

```
(sf == 1) UMIN <Xd>, <Xn>, #<uimm>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CSSC) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer datasize = 32 << UInt(sf); constant integer imm = UInt(imm8);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## &lt;uimm&gt;

Is an unsigned immediate, in the range 0 to 255, encoded in the 'imm8' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant integer result = Min(UInt(operand1), imm); X[d, datasize] = result<datasize-1:0>;
```

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.494 UMIN (register)

Unsigned minimum (register)

This instruction determines the unsigned minimum of the two source register values and writes the result to the destination register.

## Integer

(FEAT\_CSSC)

<!-- image -->

## Encoding for the 32-bit variant

Applies when (sf == 0)

```
UMIN <Wd>, <Wn>, <Wm>
```

## Encoding for the 64-bit variant

Applies when (sf == 1)

```
UMIN
```

```
<Xd>, <Xn>, <Xm>
```

## Decode for all variants of this encoding

```
EndOfDecode(Decode_UNDEF);
```

```
if !IsFeatureImplemented(FEAT_CSSC) then constant integer d = UInt(Rd); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer datasize = 32 << UInt(sf);
```

## Assembler Symbols

## &lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register, encoded in the 'Rm' field.

## &lt;Xd&gt;

## &lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register, encoded in the 'Rm' field.

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

```
constant bits(datasize) operand1 = X[n, datasize]; constant bits(datasize) operand2 = X[m, datasize]; constant integer result = X[d, datasize] = result<datasize-1:0>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
Min(UInt(operand1), UInt(operand2));
```

## C6.2.495 UMNEGL

Unsigned multiply-negate long

This instruction multiplies two 32-bit register values, negates the product, and writes the result to the 64-bit destination register.

This is an alias of UMSUBL. This means:

- The encodings in this description are named to match the encodings of UMSUBL.
- The description of UMSUBL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

```
UMNEGL <Xd>, <Wn>, <Wm>
```

## is equivalent to

```
UMSUBL <Xd>, <Wn>, <Wm>, XZR
```

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## Operation

The description of UMSUBL gives the operational pseudocode for this instruction.

## Operational Information

The description of UMSUBL gives the operational information for this instruction.

## C6.2.496 UMSUBL

Unsigned multiply-subtract long

This instruction multiplies two 32-bit register values, subtracts the product from a 64-bit register value, and writes the result to the 64-bit destination register.

This instruction is used by the alias UMNEGL.

<!-- image -->

## Encoding

UMSUBL

&lt;Xd&gt;,

&lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;

## Decode for this encoding

```
constant integer d = constant integer n = constant integer m = constant integer a =
```

```
UInt(Rd); UInt(Rn); UInt(Rm); UInt(Ra);
```

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

<!-- image -->

Is the 64-bit name of the third general-purpose source register holding the minuend, encoded in the 'Ra' field.

## Alias Conditions

## Operation

```
constant bits(32) operand1 = X[n, 32]; constant bits(32) operand2 = X[m, 32]; constant bits(64) operand3 = X[a, 64]; constant integer result = UInt(operand3) - (UInt(operand1) * UInt(operand2)); X[d, 64] = result<63:0>;
```

| Alias   | Is preferred when   |
|---------|---------------------|
| UMNEGL  | Ra == '11111'       |

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

## C6.2.497 UMULH

Unsigned multiply high

This instruction multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the 64-bit destination register.

<!-- image -->

## Encoding

```
UMULH <Xd>, <Xn>, <Xm>
```

## Decode for this encoding

```
constant integer d = constant integer n = constant integer m =
```

```
UInt(Rd); UInt(Rn); UInt(Rm);
```

## Assembler Symbols

&lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

&lt;Xn&gt;

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

<!-- image -->

&lt;Xm&gt;

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## Operation

```
constant bits(64) operand1 = X[n, 64]; constant bits(64) operand2 = X[m, 64]; constant integer result = UInt(operand1) * X[d, 64] = result<127:64>;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.

```
UInt(operand2);
```

## C6.2.498 UMULL

Unsigned multiply long

This instruction multiplies two 32-bit register values, and writes the result to the 64-bit destination register.

This is an alias of UMADDL. This means:

- The encodings in this description are named to match the encodings of UMADDL.
- The description of UMADDL gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

<!-- image -->

and is always the preferred disassembly.

## Assembler Symbols

## &lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the 'Rn' field.

## &lt;Wm&gt;

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the 'Rm' field.

## Operation

The description of UMADDL gives the operational pseudocode for this instruction.

## Operational Information

The description of UMADDL gives the operational information for this instruction.

## C6.2.499 UXTB

Unsigned extend byte

This instruction extracts an 8-bit value from a register, zero-extends it to the size of the register, and writes the result to the destination register.

This is an alias of UBFM. This means:

- The encodings in this description are named to match the encodings of UBFM.
- The description of UBFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

```
UXTB <Wd>, <Wn>
```

## is equivalent to

```
UBFM <Wd>, <Wn>, #0, #7
```

and is always the preferred disassembly.

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

The description of UBFM gives the operational pseudocode for this instruction.

## Operational Information

The description of UBFM gives the operational information for this instruction.

## C6.2.500 UXTH

Unsigned extend halfword

This instruction extracts a 16-bit value from a register, zero-extends it to the size of the register, and writes the result to the destination register.

This is an alias of UBFM. This means:

- The encodings in this description are named to match the encodings of UBFM.
- The description of UBFM gives the operational pseudocode, any CONSTRAINED UNPREDICTABLE behavior, and any operational information for this instruction.

<!-- image -->

## Encoding

```
UXTH <Wd>, <Wn>
```

## is equivalent to

```
UBFM <Wd>, <Wn>, #0, #15
```

and is always the preferred disassembly.

## Assembler Symbols

&lt;Wd&gt;

Is the 32-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## &lt;Wn&gt;

Is the 32-bit name of the general-purpose source register, encoded in the 'Rn' field.

## Operation

The description of UBFM gives the operational pseudocode for this instruction.

## Operational Information

The description of UBFM gives the operational information for this instruction.

## C6.2.501 WFE

## Wait for event

This instruction is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. Wakeup events include the event signaled as a result of executing the SEV instruction on any PE in the multiprocessor system. For more information, see Wait For Event mechanism and Send event.

As described in Wait For Event mechanism and Send event, the execution of a WFE instruction that would otherwise cause entry to a low-power state can be trapped to a higher Exception level.

<!-- image -->

<!-- image -->

## Encoding

WFE

## Decode for this encoding

// Empty.

## Operation

Hint\_WFE();

## C6.2.502 WFET

Wait for event with timeout

This instruction provides a hint that the PE can enter a low-power state and remain there until either a local timeout event or a wakeup event occurs. Wakeup events include the event signaled as a result of executing the SEV instruction on any PE in the multiprocessor system. For more information, see Wait For Event mechanism and Send event.

As described in Wait For Event mechanism and Send event, the execution of a WFET instruction that would otherwise cause entry to a low-power state can be trapped to a higher Exception level.

## System

(FEAT\_WFxT)

<!-- image -->

## Encoding

WFET

&lt;Xt&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_WFxT) then constant integer d = UInt(Rd);
```

## Assembler Symbols

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rd' field.

## Operation

```
constant integer localtimeout = UInt(X[d, 64]); if Halted() && ConstrainUnpredictableBool(Unpredictable_WFxTDEBUG) then ExecuteAsNOP(); Hint_WFET(localtimeout);
```

```
EndOfDecode(Decode_UNDEF);
```

## C6.2.503 WFI

Wait for interrupt

This instruction is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. For more information, see Wait For Interrupt.

As described in Wait For Interrupt, the execution of a WFI instruction that would otherwise cause entry to a low-power state can be trapped to a higher Exception level.

<!-- image -->

<!-- image -->

<!-- image -->

## Encoding

WFI

## Decode for this encoding

// Empty.

## Operation

Hint\_WFI();

## C6.2.504 WFIT

Wait for interrupt with timeout

This instruction provides a hint that the PE can enter a low-power state and remain there until either a local timeout event or a wakeup event occurs. For more information, see Wait For Interrupt.

As described in Wait For Interrupt, the execution of a WFIT instruction that would otherwise cause entry to a low-power state can be trapped to a higher Exception level.

## System

(FEAT\_WFxT)

<!-- image -->

## Encoding

WFIT

&lt;Xt&gt;

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_WFxT) then constant integer d = UInt(Rd);
```

## Assembler Symbols

<!-- image -->

Is the 64-bit name of the general-purpose source register, encoded in the 'Rd' field.

## Operation

```
constant integer localtimeout = UInt(X[d, 64]); if Halted() && ExecuteAsNOP(); Hint_WFIT(localtimeout);
```

```
EndOfDecode(Decode_UNDEF);
```

```
ConstrainUnpredictableBool(Unpredictable_WFxTDEBUG) then
```

## C6.2.505 XAFLAG

Convert floating-point condition flags from external format to Arm format

This instruction converts the state of the PSTATE.{N,Z,C,V} flags from an alternative representation required by some software to a form representing the result of an Arm floating-point scalar compare instruction.

## System

(FEAT\_FlagM2)

<!-- image -->

## Encoding

XAFLAG

## Decode for this encoding

if !IsFeatureImplemented(FEAT\_FlagM2) then EndOfDecode(Decode\_UNDEF);

## Operation

```
constant bit n = NOT(PSTATE.C) AND constant bit z = PSTATE.Z AND PSTATE.C; constant bit c = PSTATE.C OR PSTATE.Z; constant bit v = NOT(PSTATE.C) AND PSTATE.Z; PSTATE.N = n; PSTATE.Z = z; PSTATE.C = c; PSTATE.V = v;
```

```
NOT(PSTATE.Z);
```

## C6.2.506 XPACD, XPACI, XPACLRI

Strip Pointer Authentication Code

This instruction removes the Pointer Authentication Code from an address. The address is in the specified general-purpose register for XPACI and XPACD , and is in LR for XPACLRI .

The XPACD instruction is used for data addresses, and XPACI and XPACLRI are used for instruction addresses.

It has encodings from 2 classes: Integer and System

## Integer

(FEAT\_PAuth)

<!-- image -->

## Encoding for the XPACD variant

Applies when

(D == 1)

XPACD

&lt;Xd&gt;

## Encoding for the XPACI variant

Applies when

(D == 0)

XPACI

&lt;Xd&gt;

## Decode for all variants of this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then constant integer d = UInt(Rd); constant boolean data = (D == '1');
```

## System

(FEAT\_PAuth)

<!-- image -->

## Encoding

XPACLRI

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_PAuth) then constant integer d = 30; constant boolean data = FALSE;
```

```
EndOfDecode(Decode_UNDEF);
```

```
EndOfDecode(Decode_NOP);
```

## Assembler Symbols

&lt;Xd&gt;

Is the 64-bit name of the general-purpose destination register, encoded in the 'Rd' field.

## Operation

X[d, 64] = Strip(X[d, 64], data);

## C6.2.507 YIELD

## Yield

This instruction is a hint instruction. Software with a multithreading capability can use a YIELD instruction to indicate to the PE that it is performing a task, for example a spin-lock, that could be swapped out to improve overall system performance. The PE can use this hint to suspend and resume multiple software threads if it supports the capability.

For more information about the recommended use of this instruction, see The YIELD instruction.

<!-- image -->

## Encoding

YIELD

## Decode for this encoding

// Empty.

## Operation

Hint\_Yield();

## Chapter C7 A64 Advanced SIMD and Floating-point Descriptions

## Instruction

This chapter describes the A64 Advanced SIMD and floating-point instructions.

It contains the following sections:

- About the A64 Advanced SIMD and floating-point instructions.
- Alphabetical list of A64 Advanced SIMD and floating-point instructions.