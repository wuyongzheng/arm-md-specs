## C5.3 A64 System instructions for cache maintenance

This section lists the A64 System instructions for cache maintenance.

## C5.3.1 DC CGDSW, Clean of Data and Allocation Tags by Set/Way

The DC CGDSW characteristics are:

## Purpose

Clean data and Allocation Tags in data cache by set/way.

## Configuration

This system instruction is present only when FEAT\_MTE2 is implemented. Otherwise, direct accesses to DC CGDSWare UNDEFINED.

## Attributes

DCCGDSWisa64-bit System instruction.

## Field descriptions

<!-- image -->

## Bits [63:32]

Reserved, RES0.

## SetWay, bits [31:4]

Contains two fields:

- Way, bits[31:32-A], the number of the way to operate on.
- Set, bits[B-1:L], the number of the set to operate on.

Bits[L-1:4] are RES0.

A=Log2(ASSOCIATIVITY), L = Log2(LINELEN), B = (L + S), S = Log2(NSETS).

ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS (number of sets) have their usual meanings and are the values for the cache level being operated on. The values of A and S are rounded up to the next integer.

## Level, bits [3:1]

Cache level to operate on, minus 1. For example, this field is 0 for operations on L1 cache, or 1 for operations on L2 cache.

## Bit [0]

Reserved, RES0.

## Executing DC CGDSW

If this instruction is executed with a set, way or level argument that is larger than the value supported by the implementation then the behavior is CONSTRAINED UNPREDICTABLE and one of the following occurs:

- The instruction is UNDEFINED.
- The instruction performs cache maintenance on one of:
- No cache lines.

- Asingle arbitrary cache line.
- Multiple arbitrary cache lines.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CGDSW, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b1010 | 0b110 |

```
if !IsFeatureImplemented(FEAT_MTE2) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TSW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCSW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_SetWay); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_SetWay); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_SetWay);
```

## C5.3.2 DC CGDVAC, Clean of Data and Allocation Tags by VA to PoC

The DC CGDVAC characteristics are:

## Purpose

Clean data and Allocation Tags in data cache by address to Point of Coherency.

## Configuration

This system instruction is present only when FEAT\_MTE is implemented. Otherwise, direct accesses to DC CGDVACare UNDEFINED.

## Attributes

DCCGDVACis a 64-bit System instruction.

## Field descriptions

<!-- image -->

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CGDVAC

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in MMU faults generated by cache maintenance operations.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see The data cache maintenance instruction (DC).

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CGDVAC, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1010 | 0b101 |

```
if !IsFeatureImplemented(FEAT_MTE) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else
```

```
AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC); elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoC);
```

## C5.3.3 DC CGDVADP, Clean of Data and Allocation Tags by VA to PoDP

The DC CGDVADP characteristics are:

## Purpose

Clean Allocation Tags and data in data cache by address to Point of Deep Persistence.

If the memory system does not identify a Point of Deep Persistence, then this instruction behaves as a DC CGDVAP.

## Configuration

This system instruction is present only when FEAT\_DPB2 is implemented and FEAT\_MTE is implemented. Otherwise, direct accesses to DC CGDVADP are UNDEFINED.

## Attributes

DCCGDVADPis a 64-bit System instruction.

## Field descriptions

<!-- image -->

| 63                     | 32                     |
|------------------------|------------------------|
| Virtual address to use |                        |
| 31                     | 0                      |
| Virtual address to use | Virtual address to use |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CGDVADP

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in MMU faults generated by cache maintenance operations.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see The data cache maintenance instruction (DC).

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

```
DC CGDVADP, <Xt>
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1101 | 0b101 |

```
if !(IsFeatureImplemented(FEAT_DPB2) && IsFeatureImplemented(FEAT_MTE)) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then
```

```
if EL2Enabled() && HCR_EL2.TGE == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCVADP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP); elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCVADP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoDP);
```

## C5.3.4 DC CGDVAOC, Clean of Data and Allocation Tags by VA to Outer Cache level

The DC CGDVAOC characteristics are:

## Purpose

Clean data and Allocation Tags in data cache by address to Outer cache level.

## Configuration

This system instruction is present only when FEAT\_OCCMO is implemented, FEAT\_MTE is implemented, and FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CGDVAOC are UNDEFINED.

## Attributes

DCCGDVAOCisa64-bit System instruction.

## Field descriptions

<!-- image -->

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CGDVAOC

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in 'MMU faults generated by cache maintenance operations'.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see 'The data cache maintenance instruction (DC)'.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

```
DC CGDVAOC, <Xt>
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1011 | 0b111 |

```
if !(IsFeatureImplemented(FEAT_OCCMO) && IsFeatureImplemented(FEAT_MTE) && ↪ → IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then if !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then
```

```
AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_OuterCache); elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_OuterCache); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_OuterCache); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_OuterCache);
```

## C5.3.5 DC CGDVAP, Clean of Data and Allocation Tags by VA to PoP

The DC CGDVAP characteristics are:

## Purpose

Clean data and Allocation Tags in data cache by address to Point of Persistence.

If the memory system does not identify a Point of Persistence, then this instruction behaves as a DC CGDV AC.

## Configuration

This system instruction is present only when FEAT\_MTE is implemented. Otherwise, direct accesses to DC CGDVAPare UNDEFINED.

## Attributes

DCCGDVAPis a 64-bit System instruction.

## Field descriptions

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CGDVAP

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in MMU faults generated by cache maintenance operations.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see The data cache maintenance instruction (DC).

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

```
DC CGDVAP, <Xt>
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1100 | 0b101 |

```
if !IsFeatureImplemented(FEAT_MTE) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then
```

```
AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCVAP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP); elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCVAP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Clean, CacheOpScope_PoP);
```

## C5.3.6 DC CGSW, Clean of Allocation Tags by Set/Way

The DC CGSW characteristics are:

## Purpose

Clean Allocation Tags in data cache by set/way.

## Configuration

This system instruction is present only when FEAT\_MTE2 is implemented. Otherwise, direct accesses to DC CGSWare UNDEFINED.

## Attributes

DCCGSWisa64-bit System instruction.

## Field descriptions

<!-- image -->

## Bits [63:32]

Reserved, RES0.

## SetWay, bits [31:4]

Contains two fields:

- Way, bits[31:32-A], the number of the way to operate on.
- Set, bits[B-1:L], the number of the set to operate on.

Bits[L-1:4] are RES0.

A=Log2(ASSOCIATIVITY), L = Log2(LINELEN), B = (L + S), S = Log2(NSETS).

ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS (number of sets) have their usual meanings and are the values for the cache level being operated on. The values of A and S are rounded up to the next integer.

## Level, bits [3:1]

Cache level to operate on, minus 1. For example, this field is 0 for operations on L1 cache, or 1 for operations on L2 cache.

## Bit [0]

Reserved, RES0.

## Executing DC CGSW

If this instruction is executed with a set, way or level argument that is larger than the value supported by the implementation then the behavior is CONSTRAINED UNPREDICTABLE and one of the following occurs:

- The instruction is UNDEFINED.
- The instruction performs cache maintenance on one of:
- No cache lines.

- Asingle arbitrary cache line.
- Multiple arbitrary cache lines.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CGSW, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b1010 | 0b100 |

```
if !IsFeatureImplemented(FEAT_MTE2) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TSW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCSW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_SetWay); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_SetWay); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_SetWay);
```

## C5.3.7 DC CGVAC, Clean of Allocation Tags by VA to PoC

The DC CGVAC characteristics are:

## Purpose

Clean Allocation Tags in data cache by address to Point of Coherency.

## Configuration

This system instruction is present only when FEAT\_MTE is implemented. Otherwise, direct accesses to DC CGVACare UNDEFINED.

## Attributes

DCCGVACis a 64-bit System instruction.

## Field descriptions

<!-- image -->

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CGVAC

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in MMU faults generated by cache maintenance operations.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see The data cache maintenance instruction (DC).

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CGVAC, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1010 | 0b011 |

```
if !IsFeatureImplemented(FEAT_MTE) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else
```

```
AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC); elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_PoC);
```

## C5.3.8 DC CGVADP, Clean of Allocation Tags by VA to PoDP

The DC CGVADP characteristics are:

## Purpose

Clean Allocation tags by address to Point of Deep Persistence.

If the memory system does not identify a Point of Deep Persistence, then this instruction behaves as a DC CGV AP.

## Configuration

This system instruction is present only when FEAT\_DPB2 is implemented and FEAT\_MTE is implemented. Otherwise, direct accesses to DC CGVADP are UNDEFINED.

## Attributes

DCCGVADPis a 64-bit System instruction.

## Field descriptions

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CGVADP

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in MMU faults generated by cache maintenance operations.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see The data cache maintenance instruction (DC).

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

```
DC CGVADP, <Xt>
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1101 | 0b011 |

```
if !(IsFeatureImplemented(FEAT_DPB2) && IsFeatureImplemented(FEAT_MTE)) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then
```

```
AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCVADP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP); elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCVADP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_PoDP);
```

## C5.3.9 DC CGVAP, Clean of Allocation Tags by VA to PoP

The DC CGVAP characteristics are:

## Purpose

Clean Allocation Tags in data cache by address to Point of Persistence.

If the memory system does not identify a Point of Persistence, then this instruction behaves as a DC CGV AC.

## Configuration

This system instruction is present only when FEAT\_MTE is implemented. Otherwise, direct accesses to DC CGVAP are UNDEFINED.

## Attributes

DCCGVAPis a 64-bit System instruction.

## Field descriptions

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CGVAP

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in MMU faults generated by cache maintenance operations.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see The data cache maintenance instruction (DC).

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

```
DC CGVAP, <Xt>
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1100 | 0b011 |

```
if !IsFeatureImplemented(FEAT_MTE) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then
```

```
AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCVAP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP); elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCVAP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Clean, CacheOpScope_PoP);
```

## C5.3.10 DC CIGDPAE, Clean and invalidate of data and allocation tags by PA to PoE

The DC CIGDPAE characteristics are:

## Purpose

Clean and invalidate of data and allocation tags by PA to PoE.

## Configuration

This system instruction is present only when FEAT\_MEC is implemented, FEAT\_MTE2 is implemented, and FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CIGDPAE are UNDEFINED.

## Attributes

DCCIGDPAE is a 64-bit System instruction.

## Field descriptions

<!-- image -->

## NS, bit [63]

## When FEAT\_RME\_GDI is implemented:

Together with the NSE2 and NSE field, this field specifies the target physical address space.

| NSE2   | NSE   | NS   | Meaning       |
|--------|-------|------|---------------|
| 0b0    | 0b0   | 0b0  | Reserved.     |
| 0b0    | 0b0   | 0b1  | Reserved.     |
| 0b0    | 0b1   | 0b0  | Reserved.     |
| 0b0    | 0b1   | 0b1  | Realm.        |
| 0b1    | 0b0   | 0b0  | System Agent. |
| 0b1    | 0b0   | 0b1  | NS Protected. |
| 0b1    | 0b1   | 0b0  | Reserved.     |
| 0b1    | 0b1   | 0b1  | Reserved.     |

If {NSE2, NSE, NS} is reserved, then no cache entries are required to be cleaned or invalidated.

## Otherwise:

Together with the NSE field, this field specifies the target physical address space.

| NSE   | NS   | Meaning   |
|-------|------|-----------|
| 0b0   | 0b0  | Reserved. |
| 0b0   | 0b1  | Reserved. |
| 0b1   | 0b0  | Reserved. |
| 0b1   | 0b1  | Realm.    |

If {NSE, NS} is not {1, 1}, then no cache entries are required to be cleaned or invalidated.

## NSE, bit [62]

If FEAT\_RME\_GDI is implemented, this field together with the NS and NSE2 fields, specifies the target physical address space.

Otherwise, this field and the NS field specify the physical address space

For a description of the values derived by evaluating NS, NSE, and NSE2 together, see DC CIGDPAE.NS.

## NSE2, bit [61]

## When FEAT\_RME\_GDI is implemented:

Together with the NS and NSE field, this field specifies the target physical address space.

For a description of the values derived by evaluating NS and NSE together, see DC CIGDPAE.NS.

## Otherwise:

Reserved, RES0.

## Bits [60:56]

Reserved, RES0.

## PA[55:52], bits [55:52]

## When FEAT\_D128 is implemented:

Extension to PA[51:0] if ID\_AA64MMFR0\_EL1.PARange = 0111. For more information, see PA[51:0].

## Otherwise:

Reserved, RES0.

## PA, bits [51:0]

Physical address to use. No alignment restrictions apply to this PA.

## Executing DC CIGDPAE

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CIGDPAE, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b100 | 0b0111 | 0b1110 | 0b111 |

```
if !(IsFeatureImplemented(FEAT_MEC) && IsFeatureImplemented(FEAT_MTE2) && ↪ → IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then UNDEFINED; elsif PSTATE.EL == EL2 then if !IsCurrentSecurityState(SS_Realm) then UNDEFINED; else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoE); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoE);
```

## C5.3.11 DC CIGDPAPA, Clean and Invalidate of Data and Allocation Tags by PA to PoPA

The DC CIGDPAPA characteristics are:

## Purpose

Clean and Invalidate data and Allocation Tags in data cache by physical address to the Point of Physical Aliasing.

Note

This instruction cleans and invalidates all copies of the Location specified in the Xt argument, irrespective of any MECID associated with the Location. Memory accesses resulting from the Clean operation use the MECID associated with the cache entry.

## Configuration

This system instruction is present only when FEAT\_RME is implemented, FEAT\_MTE2 is implemented, and FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CIGDPAPA are UNDEFINED.

## Attributes

DCCIGDPAPA is a 64-bit System instruction.

## Field descriptions

<!-- image -->

## NS, bit [63]

## When FEAT\_RME\_GDI is implemented:

Together with the NSE2 and NSE field, this field specifies the target physical address space.

| NSE2   | NSE   | NS   | Meaning                                                       |
|--------|-------|------|---------------------------------------------------------------|
| 0b0    | 0b0   | 0b0  | When Secure state is implemented, Secure. Otherwise reserved. |
| 0b0    | 0b0   | 0b1  | Non-secure.                                                   |
| 0b0    | 0b1   | 0b0  | Root.                                                         |
| 0b0    | 0b1   | 0b1  | Realm.                                                        |
| 0b1    | 0b0   | 0b0  | System Agent.                                                 |
| 0b1    | 0b0   | 0b1  | NS Protected.                                                 |
| 0b1    | 0b1   | 0b0  | Reserved.                                                     |
| 0b1    | 0b1   | 0b1  | Reserved.                                                     |

If {NSE2, NSE, NS} is reserved, then no cache entries are required to be cleaned or invalidated.

## Otherwise:

Together with the NSE field, this field specifies the target physical address space.

| NSE   | NS   | Meaning                                                       |
|-------|------|---------------------------------------------------------------|
| 0b0   | 0b0  | When Secure state is implemented, Secure. Otherwise reserved. |
| 0b0   | 0b1  | Non-secure.                                                   |
| 0b1   | 0b0  | Root.                                                         |
| 0b1   | 0b1  | Realm.                                                        |

If FEAT\_SEL2 is not implemented, and {NSE, NS} == { 0b0 , 0b0 }, then no cache entries are required to be cleaned or invalidated

## NSE, bit [62]

If FEAT\_RME\_GDI is implemented, this field together with the NS and NSE2 fields, specifies the target physical address space.

Otherwise, this field and the NS field specify the physical address space

For a description of the values derived by evaluating NS, NSE, and NSE2 together, see DC CIGDPAPA.NS.

## NSE2, bit [61]

## When FEAT\_RME\_GDI is implemented:

Together with the NS and NSE field, this field specifies the target physical address space.

For a description of the values derived by evaluating NS and NSE together, see DC CIGDPAPA.NS.

## Otherwise:

Reserved, RES0.

## Bits [60:56]

Reserved, RES0.

## PA[55:52], bits [55:52]

## When FEAT\_D128 is implemented:

Extension to PA[51:0] if ID\_AA64MMFR0\_EL1.PARange = 0111. For more information see PA[51:0].

## Otherwise:

Reserved, RES0.

## PA, bits [51:0]

Physical address to use. No alignment restrictions apply to this PA.

## Executing DC CIGDPAPA

- This instruction is not subject to any translation, permission checks, or granule protection checks.
- This instruction affects all caches in the Outer Shareable shareability domain.
- This instruction has the same ordering, observability, and completion behavior as V A-based cache maintenance instructions issued to the Outer Shareable shareability domain.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CIGDPAPA, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b110 | 0b0111 | 0b1110 | 0b101 |

```
if !(IsFeatureImplemented(FEAT_RME) && IsFeatureImplemented(FEAT_MTE2) && ↪ → IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then UNDEFINED; elsif PSTATE.EL == EL2 then UNDEFINED; elsif PSTATE.EL == EL3 then
```

AArch64.DC(X[t, 64], CacheType\_Data\_Tag,

```
CacheOp_CleanInvalidate, CacheOpScope_PoPA);
```

## C5.3.12 DC CIGDSW, Clean and Invalidate of Data and Allocation Tags by Set/Way

The DC CIGDSW characteristics are:

## Purpose

Clean and Invalidate data and Allocation Tags in data cache by set/way.

## Configuration

This system instruction is present only when FEAT\_MTE2 is implemented. Otherwise, direct accesses to DC CIGDSW are UNDEFINED.

## Attributes

DCCIGDSWis a 64-bit System instruction.

## Field descriptions

<!-- image -->

## Bits [63:32]

Reserved, RES0.

## SetWay, bits [31:4]

Contains two fields:

- Way, bits[31:32-A], the number of the way to operate on.
- Set, bits[B-1:L], the number of the set to operate on.

Bits[L-1:4] are RES0.

A=Log2(ASSOCIATIVITY), L = Log2(LINELEN), B = (L + S), S = Log2(NSETS).

ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS (number of sets) have their usual meanings and are the values for the cache level being operated on. The values of A and S are rounded up to the next integer.

## Level, bits [3:1]

Cache level to operate on, minus 1. For example, this field is 0 for operations on L1 cache, or 1 for operations on L2 cache.

## Bit [0]

Reserved, RES0.

## Executing DC CIGDSW

If this instruction is executed with a set, way or level argument that is larger than the value supported by the implementation then the behavior is CONSTRAINED UNPREDICTABLE and one of the following occurs:

- The instruction is UNDEFINED.
- The instruction performs cache maintenance on one of:
- No cache lines.

- Asingle arbitrary cache line.
- Multiple arbitrary cache lines.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CIGDSW, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b1110 | 0b110 |

```
if !IsFeatureImplemented(FEAT_MTE2) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TSW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCISW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_SetWay); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_SetWay); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_SetWay);
```

## C5.3.13 DC CIGDVAC, Clean and Invalidate of Data and Allocation Tags by VA to PoC

The DC CIGDVAC characteristics are:

## Purpose

Clean and Invalidate data and Allocation Tags in data cache by address to Point of Coherency.

## Configuration

This system instruction is present only when FEAT\_MTE is implemented. Otherwise, direct accesses to DC CIGDVAC are UNDEFINED.

## Attributes

DCCIGDVACis a 64-bit System instruction.

## Field descriptions

<!-- image -->

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CIGDVAC

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in MMU faults generated by cache maintenance operations.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see The data cache maintenance instruction (DC).

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CIGDVAC, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1110 | 0b101 |

```
if !IsFeatureImplemented(FEAT_MTE) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else
```

```
AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCIVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCIVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC);
```

## C5.3.14 DC CIGDVAOC, Clean and Invalidate of Data and Allocation Tags by VA to Outer Cache level

The DC CIGDVAOC characteristics are:

## Purpose

Clean and invalidate of data and Allocation Tags in data cache by address to Outer cache level.

## Configuration

This system instruction is present only when FEAT\_OCCMO is implemented, FEAT\_MTE is implemented, and FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CIGDVAOC are UNDEFINED.

## Attributes

DCCIGDVAOCis a 64-bit System instruction.

## Field descriptions

<!-- image -->

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CIGDVAOC

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in 'MMU faults generated by cache maintenance operations'.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see 'The data cache maintenance instruction (DC)'.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CIGDVAOC, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1111 | 0b111 |

```
if !(IsFeatureImplemented(FEAT_OCCMO) && IsFeatureImplemented(FEAT_MTE) && ↪ → IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then if !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then
```

```
AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCIVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_OuterCache); elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCIVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_OuterCache); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_OuterCache); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_OuterCache);
```

## C5.3.15 DC CIGDVAPS, Clean and Invalidate of Data and Allocation Tags by VA to PoPS

The DC CIGDVAPS characteristics are:

## Purpose

Clean and Invalidate data and Allocation Tags in data cache by virtual address to the Point of Physical Storage.

Note

This instruction cleans and invalidates all copies of the Location specified in the Xt argument, irrespective of any MECID associated with the Location. Memory accesses resulting from the Clean operation use the MECID associated with the cache entry.

## Configuration

This system instruction is present only when FEAT\_PoPS is implemented, FEAT\_MTE2 is implemented, and FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CIGDVAPS are UNDEFINED.

## Attributes

DCCIGDVAPS is a 64-bit System instruction.

## Field descriptions

<!-- image -->

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CIGDVAPS

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see 'The data cache maintenance instruction (DC)'.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

```
DC CIGDVAPS, <Xt>
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b1111 | 0b101 |

```
if !(IsFeatureImplemented(FEAT_PoPS) && IsFeatureImplemented(FEAT_MTE2) && ↪ → IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TPCP == '1' then
```

```
AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT2) && ((HaveEL(EL3) && SCR_EL3.FGTEn2 == '0') || ↪ → HFGITR2_EL2.nDCCIVAPS == '0') then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoPS); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoPS); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoPS);
```

## C5.3.16 DC CIGSW, Clean and Invalidate of Allocation Tags by Set/Way

The DC CIGSW characteristics are:

## Purpose

Clean and Invalidate Allocation Tags in data cache by set/way.

## Configuration

This system instruction is present only when FEAT\_MTE2 is implemented. Otherwise, direct accesses to DC CIGSW are UNDEFINED.

## Attributes

DCCIGSWis a 64-bit System instruction.

## Field descriptions

<!-- image -->

## Bits [63:32]

Reserved, RES0.

## SetWay, bits [31:4]

Contains two fields:

- Way, bits[31:32-A], the number of the way to operate on.
- Set, bits[B-1:L], the number of the set to operate on.

Bits[L-1:4] are RES0.

A=Log2(ASSOCIATIVITY), L = Log2(LINELEN), B = (L + S), S = Log2(NSETS).

ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS (number of sets) have their usual meanings and are the values for the cache level being operated on. The values of A and S are rounded up to the next integer.

## Level, bits [3:1]

Cache level to operate on, minus 1. For example, this field is 0 for operations on L1 cache, or 1 for operations on L2 cache.

## Bit [0]

Reserved, RES0.

## Executing DC CIGSW

If this instruction is executed with a set, way or level argument that is larger than the value supported by the implementation then the behavior is CONSTRAINED UNPREDICTABLE and one of the following occurs:

- The instruction is UNDEFINED.
- The instruction performs cache maintenance on one of:
- No cache lines.

- Asingle arbitrary cache line.
- Multiple arbitrary cache lines.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CIGSW, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b1110 | 0b100 |

```
if !IsFeatureImplemented(FEAT_MTE2) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TSW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCISW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_SetWay); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_SetWay); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_SetWay);
```

## C5.3.17 DC CIGVAC, Clean and Invalidate of Allocation Tags by VA to PoC

The DC CIGVAC characteristics are:

## Purpose

Clean and Invalidate Allocation Tags in data cache by address to Point of Coherency.

## Configuration

This system instruction is present only when FEAT\_MTE is implemented. Otherwise, direct accesses to DC CIGVAC are UNDEFINED.

## Attributes

DCCIGVACis a 64-bit System instruction.

## Field descriptions

<!-- image -->

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CIGVAC

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in MMU faults generated by cache maintenance operations.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see The data cache maintenance instruction (DC).

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CIGVAC, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1110 | 0b011 |

```
if !IsFeatureImplemented(FEAT_MTE) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else
```

```
AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCIVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCIVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_CleanInvalidate, CacheOpScope_PoC);
```

## C5.3.18 DC CIPAE, Data or unified Cache line Clean and Invalidate by PA to PoE

The DC CIPAE characteristics are:

## Purpose

Data or unified Cache line Clean and Invalidate by PA to PoE.

## Configuration

This system instruction is present only when FEAT\_MEC is implemented and FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CIPAE are UNDEFINED.

## Attributes

DCCIPAE is a 64-bit System instruction.

## Field descriptions

<!-- image -->

## NS, bit [63]

## When FEAT\_RME\_GDI is implemented:

Together with the NSE2 and NSE field, this field specifies the target physical address space.

| NSE2   | NSE   | NS   | Meaning       |
|--------|-------|------|---------------|
| 0b0    | 0b0   | 0b0  | Reserved.     |
| 0b0    | 0b0   | 0b1  | Reserved.     |
| 0b0    | 0b1   | 0b0  | Reserved.     |
| 0b0    | 0b1   | 0b1  | Realm.        |
| 0b1    | 0b0   | 0b0  | System Agent. |
| 0b1    | 0b0   | 0b1  | NS Protected. |
| 0b1    | 0b1   | 0b0  | Reserved.     |
| 0b1    | 0b1   | 0b1  | Reserved.     |

If {NSE2, NSE, NS} is reserved, then no cache entries are required to be cleaned or invalidated.

## Otherwise:

Together with the NSE field, this field specifies the target physical address space.

| NSE   | NS   | Meaning   |
|-------|------|-----------|
| 0b0   | 0b0  | Reserved. |
| 0b0   | 0b1  | Reserved. |
| 0b1   | 0b0  | Reserved. |
| 0b1   | 0b1  | Realm.    |

If {NSE, NS} is not {1, 1}, then no cache entries are required to be cleaned or invalidated.

## NSE, bit [62]

If FEAT\_RME\_GDI is implemented, this field together with the NS and NSE2 fields, specifies the target physical address space.

Otherwise, this field and the NS field specify the physical address space

For a description of the values derived by evaluating NS, NSE, and NSE2 together, see DC CIPAE.NS.

## NSE2, bit [61]

## When FEAT\_RME\_GDI is implemented:

Together with the NS and NSE field, this field specifies the target physical address space.

For a description of the values derived by evaluating NS and NSE together, see DC CIPAE.NS.

## Otherwise:

Reserved, RES0.

## Bits [60:56]

Reserved, RES0.

## PA[55:52], bits [55:52]

## When FEAT\_D128 is implemented:

Extension to PA[51:0] if ID\_AA64MMFR0\_EL1.PARange = 0111. For more information see PA[51:0].

## Otherwise:

Reserved, RES0.

## PA, bits [51:0]

Physical address to use. No alignment restrictions apply to this PA.

## Executing DC CIPAE

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CIPAE, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b100 | 0b0111 | 0b1110 | 0b000 |

```
if !(IsFeatureImplemented(FEAT_MEC) && IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then UNDEFINED; elsif PSTATE.EL == EL2 then if !IsCurrentSecurityState(SS_Realm) then UNDEFINED; else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoE); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoE);
```

## C5.3.19 DC CIPAPA, Data or unified Cache line Clean and Invalidate by PA to PoPA

The DC CIPAPA characteristics are:

## Purpose

Clean and Invalidate data cache by physical address to the Point of Physical Aliasing.

Note

This instruction cleans and invalidates all copies of the Location specified in the Xt argument, irrespective of any MECID associated with the Location. Memory accesses resulting from the Clean operation use the MECID associated with the cache entry.

## Configuration

This system instruction is present only when FEAT\_RME is implemented and FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CIPAPA are UNDEFINED.

## Attributes

DCCIPAPA is a 64-bit System instruction.

## Field descriptions

<!-- image -->

## NS, bit [63]

## When FEAT\_RME\_GDI is implemented:

Together with the NSE2 and NSE field, this field specifies the target physical address space.

| NSE2   | NSE   | NS   | Meaning                                                       |
|--------|-------|------|---------------------------------------------------------------|
| 0b0    | 0b0   | 0b0  | When Secure state is implemented, Secure. Otherwise reserved. |
| 0b0    | 0b0   | 0b1  | Non-secure.                                                   |
| 0b0    | 0b1   | 0b0  | Root.                                                         |
| 0b0    | 0b1   | 0b1  | Realm.                                                        |
| 0b1    | 0b0   | 0b0  | System Agent.                                                 |
| 0b1    | 0b0   | 0b1  | NS Protected.                                                 |
| 0b1    | 0b1   | 0b0  | Reserved.                                                     |
| 0b1    | 0b1   | 0b1  | Reserved.                                                     |

If {NSE2, NSE, NS} is reserved, then no cache entries are required to be cleaned or invalidated.

## Otherwise:

Together with the NSE field, this field specifies the target physical address space.

| NSE   | NS   | Meaning                                                       |
|-------|------|---------------------------------------------------------------|
| 0b0   | 0b0  | When Secure state is implemented, Secure. Otherwise reserved. |
| 0b0   | 0b1  | Non-secure.                                                   |
| 0b1   | 0b0  | Root.                                                         |
| 0b1   | 0b1  | Realm.                                                        |

If FEAT\_SEL2 is not implemented, and {NSE, NS} == { 0b0 , 0b0 }, then no cache entries are required to be cleaned or invalidated

## NSE, bit [62]

If FEAT\_RME\_GDI is implemented, this field together with the NS and NSE2 fields, specifies the target physical address space.

Otherwise, this field and the NS field specify the physical address space

For a description of the values derived by evaluating NS, NSE, and NSE2 together, see DC CIPAPA.NS.

## NSE2, bit [61]

## When FEAT\_RME\_GDI is implemented:

Together with the NS and NSE field, this field specifies the target physical address space.

For a description of the values derived by evaluating NS and NSE together, see DC CIPAPA.NS.

## Otherwise:

Reserved, RES0.

## Bits [60:56]

Reserved, RES0.

## PA[55:52], bits [55:52]

## When FEAT\_D128 is implemented:

Extension to PA[51:0] if ID\_AA64MMFR0\_EL1.PARange = 0111. For more information see PA[51:0].

## Otherwise:

Reserved, RES0.

## PA, bits [51:0]

Physical address to use. No alignment restrictions apply to this PA.

## Executing DC CIPAPA

- This instruction is not subject to any translation, permission checks, or granule protection checks.
- This instruction affects all caches in the Outer Shareable shareability domain.
- This instruction has the same ordering, observability, and completion behavior as V A-based cache maintenance instructions issued to the Outer Shareable shareability domain.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CIPAPA, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b110 | 0b0111 | 0b1110 | 0b001 |

if !(IsFeatureImplemented(FEAT\_RME) &amp;&amp; IsFeatureImplemented(FEAT\_AA64)) then

UNDEFINED;

elsif PSTATE.EL == EL0 then

UNDEFINED;

elsif PSTATE.EL == EL1 then

UNDEFINED;

elsif PSTATE.EL == EL2 then

UNDEFINED;

elsif PSTATE.EL == EL3 then

AArch64.DC(X[t, 64], CacheType\_Data, CacheOp\_CleanInvalidate, CacheOpScope\_PoPA);

## C5.3.20 DC CISW, Data or unified Cache line Clean and Invalidate by Set/Way

The DC CISW characteristics are:

## Purpose

Clean and Invalidate data cache by set/way.

## Configuration

AArch64 System instruction DC CISW bits [31:0] performs the same function as bits [31:0].

This system instruction is present only when FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CISW are UNDEFINED.

## Attributes

DCCISWis a 64-bit System instruction.

## Field descriptions

<!-- image -->

## Bits [63:32]

Reserved, RES0.

## SetWay, bits [31:4]

Contains two fields:

- Way, bits[31:32-A], the number of the way to operate on.
- Set, bits[B-1:L], the number of the set to operate on.

Bits[L-1:4] are RES0.

A=Log2(ASSOCIATIVITY), L = Log2(LINELEN), B = (L + S), S = Log2(NSETS).

ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS (number of sets) have their usual meanings and are the values for the cache level being operated on. The values of A and S are rounded up to the next integer.

## Level, bits [3:1]

Cache level to operate on, minus 1. For example, this field is 0 for operations on L1 cache, or 1 for operations on L2 cache.

## Bit [0]

Reserved, RES0.

## Executing DC CISW

If this instruction is executed with a set, way or level argument that is larger than the value supported by the implementation then the behavior is CONSTRAINED UNPREDICTABLE and one of the following occurs:

- The instruction is UNDEFINED.

- The instruction performs cache maintenance on one of:
- No cache lines.
- Asingle arbitrary cache line.
- Multiple arbitrary cache lines.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CISW, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b1110 | 0b010 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TSW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCISW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_SetWay); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_SetWay); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_SetWay);
```

## C5.3.21 DC CIVAC, Data or unified Cache line Clean and Invalidate by VA to PoC

The DC CIVAC characteristics are:

## Purpose

Clean and Invalidate data cache by address to Point of Coherency.

## Configuration

AArch64 System instruction DC CIVAC bits [31:0] performs the same function as bits [31:0].

This system instruction is present only when FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CIVAC are UNDEFINED.

## Attributes

DCCIVAC is a 64-bit System instruction.

## Field descriptions

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CIVAC

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in 'MMU faults generated by cache maintenance operations'.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see 'The data cache maintenance instruction (DC)'.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

```
DC CIVAC, <Xt>
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1110 | 0b001 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then
```

```
AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCIVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCIVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoC);
```

## C5.3.22 DC CIVAOC, Data or unified Cache line Clean and Invalidate by VA to Outer Cache level

The DC CIVAOC characteristics are:

## Purpose

Clean and Invalidate data cache by address to Outer cache level.

## Configuration

This system instruction is present only when FEAT\_OCCMO is implemented and FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CIV AOC are UNDEFINED.

## Attributes

DCCIVAOCis a 64-bit System instruction.

## Field descriptions

<!-- image -->

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CIVAOC

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in 'MMU faults generated by cache maintenance operations'.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see 'The data cache maintenance instruction (DC)'.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CIVAOC, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1111 | 0b000 |

```
if !(IsFeatureImplemented(FEAT_OCCMO) && IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then if !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18);
```

```
elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCIVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_OuterCache); elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCIVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_OuterCache); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_OuterCache); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_OuterCache);
```

## C5.3.23 DC CIVAPS, Clean and Invalidate of Data by VA to PoPS

The DC CIVAPS characteristics are:

## Purpose

Clean and Invalidate data in data cache by virtual address to the Point of Physical Storage.

Note

This instruction cleans and invalidates all copies of the Location specified in the Xt argument, irrespective of any MECID associated with the Location. Memory accesses resulting from the Clean operation use the MECID associated with the cache entry.

## Configuration

This system instruction is present only when FEAT\_PoPS is implemented and FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CIV APS are UNDEFINED.

## Attributes

DCCIVAPS is a 64-bit System instruction.

## Field descriptions

<!-- image -->

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CIVAPS

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see 'The data cache maintenance instruction (DC)'.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CIVAPS, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b1111 | 0b001 |

```
if !(IsFeatureImplemented(FEAT_PoPS) && IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18);
```

```
elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT2) && ((HaveEL(EL3) && SCR_EL3.FGTEn2 == '0') || ↪ → HFGITR2_EL2.nDCCIVAPS == '0') then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoPS); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoPS); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data, CacheOp_CleanInvalidate, CacheOpScope_PoPS);
```

## C5.3.24 DC CSW, Data or unified Cache line Clean by Set/Way

The DC CSW characteristics are:

## Purpose

Clean data cache by set/way.

## Configuration

AArch64 System instruction DC CSW bits [31:0] performs the same function as bits [31:0].

This system instruction is present only when FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CSW are UNDEFINED.

## Attributes

DCCSWisa64-bit System instruction.

## Field descriptions

<!-- image -->

## Bits [63:32]

Reserved, RES0.

## SetWay, bits [31:4]

Contains two fields:

- Way, bits[31:32-A], the number of the way to operate on.
- Set, bits[B-1:L], the number of the set to operate on.

Bits[L-1:4] are RES0.

A=Log2(ASSOCIATIVITY), L = Log2(LINELEN), B = (L + S), S = Log2(NSETS).

ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS (number of sets) have their usual meanings and are the values for the cache level being operated on. The values of A and S are rounded up to the next integer.

## Level, bits [3:1]

Cache level to operate on, minus 1. For example, this field is 0 for operations on L1 cache, or 1 for operations on L2 cache.

## Bit [0]

Reserved, RES0.

## Executing DC CSW

If this instruction is executed with a set, way or level argument that is larger than the value supported by the implementation then the behavior is CONSTRAINED UNPREDICTABLE and one of the following occurs:

- The instruction is UNDEFINED.

- The instruction performs cache maintenance on one of:
- No cache lines.
- Asingle arbitrary cache line.
- Multiple arbitrary cache lines.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CSW, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b1010 | 0b010 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TSW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCSW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_SetWay); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_SetWay); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_SetWay);
```

## C5.3.25 DC CVAC, Data or unified Cache line Clean by VA to PoC

The DC CVAC characteristics are:

## Purpose

Clean data cache by address to Point of Coherency.

## Configuration

AArch64 System instruction DC CVAC bits [31:0] performs the same function as bits [31:0].

This system instruction is present only when FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CVACare UNDEFINED.

## Attributes

DCCVACis a 64-bit System instruction.

## Field descriptions

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CVAC

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in 'MMU faults generated by cache maintenance operations'.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see 'The data cache maintenance instruction (DC)'.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CVAC, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1010 | 0b001 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then
```

```
AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoC); elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoC); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoC); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoC);
```

## C5.3.26 DC CVADP, Data or unified Cache line Clean by VA to PoDP

The DC CVADP characteristics are:

## Purpose

Clean data cache by address to Point of Deep Persistence.

If the memory system does not identify a Point of Deep Persistence, then this instruction behaves as a DC CV AP.

## Configuration

This system instruction is present only when FEAT\_DPB2 is implemented and FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CV ADP are UNDEFINED.

## Attributes

DCCVADPis a 64-bit System instruction.

## Field descriptions

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CVADP

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in 'MMU faults generated by cache maintenance operations'.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see 'The data cache maintenance instruction (DC)'.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

```
DC CVADP, <Xt>
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1101 | 0b001 |

```
if !(IsFeatureImplemented(FEAT_DPB2) && IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then
```

```
AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCVADP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP); elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCVADP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoDP);
```

## C5.3.27 DC CVAOC, Data or unified Cache line Clean by VA to Outer Cache level

The DC CVAOC characteristics are:

## Purpose

Clean data cache by address to Outer cache level.

## Configuration

This system instruction is present only when FEAT\_OCCMO is implemented and FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CV AOC are UNDEFINED.

## Attributes

DCCVAOCis a 64-bit System instruction.

## Field descriptions

<!-- image -->

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CVAOC

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in 'MMU faults generated by cache maintenance operations'.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see 'The data cache maintenance instruction (DC)'.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CVAOC, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1011 | 0b000 |

```
if !(IsFeatureImplemented(FEAT_OCCMO) && IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then if !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18);
```

```
elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_OuterCache); elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_OuterCache); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_OuterCache); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_OuterCache);
```

## C5.3.28 DC CVAP, Data or unified Cache line Clean by VA to PoP

The DC CVAP characteristics are:

## Purpose

Clean data cache by address to Point of Persistence.

If the memory system does not identify a Point of Persistence, then this instruction behaves as a DC CV AC.

## Configuration

This system instruction is present only when FEAT\_DPB is implemented and FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CV AP are UNDEFINED.

## Attributes

DCCVAPis a 64-bit System instruction.

## Field descriptions

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CVAP

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in 'MMU faults generated by cache maintenance operations'.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see 'The data cache maintenance instruction (DC)'.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CVAP, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1100 | 0b001 |

```
if !(IsFeatureImplemented(FEAT_DPB) && IsFeatureImplemented(FEAT_AA64)) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoP) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then
```

```
AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCVAP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoP); elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoP) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCVAP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoP); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoP) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoP); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoP) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoP);
```

## C5.3.29 DC CVAU, Data or unified Cache line Clean by VA to PoU

The DC CVAU characteristics are:

## Purpose

Clean data cache by address to Point of Unification.

## Configuration

AArch64 System instruction DC CVAU bits [31:0] performs the same function as bits [31:0].

This system instruction is present only when FEAT\_AA64 is implemented. Otherwise, direct accesses to DC CVAUare UNDEFINED.

## Attributes

DCCVAUis a 64-bit System instruction.

## Field descriptions

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC CVAU

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in 'MMU faults generated by cache maintenance operations'.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see 'The data cache maintenance instruction (DC)'.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC CVAU, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b1011 | 0b001 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoU) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Clean, CacheOpScope_PoU) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then
```

```
AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TOCU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCCVAU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoU); elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoU) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Clean, CacheOpScope_PoU) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && HCR_EL2.TOCU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCCVAU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoU); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoU) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Clean, CacheOpScope_PoU) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoU); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Clean, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Clean, CacheOpScope_PoU);
```

## C5.3.30 DC GVA, Data Cache set Allocation Tag by VA

The DC GVA characteristics are:

## Purpose

Write a value to the Allocation Tags of a naturally aligned block of N bytes, where the size of N is identified in DCZID\_EL0. The Allocation Tag used is determined by the input address.

## Configuration

This system instruction is present only when FEAT\_MTE is implemented. Otherwise, direct accesses to DC GV A are UNDEFINED.

## Attributes

DCGVAis a 64-bit System instruction.

## Field descriptions

<!-- image -->

## VA, bits [63:0]

Virtual address to use. There is no alignment restriction on the address within the block of N bytes that is used.

## Executing DC GVA

When this instruction is executed, it can generate memory faults or watchpoints which are prioritized in the same way as other memory-related faults or watchpoints. If a synchronous Data Abort fault or a watchpoint is generated, the CM bit in the ESR\_ELx.ISS field is not set.

ADCGVAinstruction to any type of Device memory is CONSTRAINED UNPREDICTABLE between:

- Not modifying Allocation tags at the specified addresses.
- Generating an Alignment Fault determined by the memory type.

This instruction applies to Normal memory regardless of cacheability attributes.

This instruction behaves as a set of stores to each Allocation Tag within the block being accessed, and so it:

- Generates a Permission fault if the translation system does not permit writes to the locations.
- Requires the same considerations for ordering and the management of coherency as any other store instructions.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC GVA, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b0100 | 0b011 |

```
if !IsFeatureImplemented(FEAT_MTE) then UNDEFINED; elsif PSTATE.EL == EL0 then if !ELIsInHost(EL0) && SCTLR_EL1.DZE == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TDZ == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCZVA == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.DZE == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.MemZero(X[t, 64], CacheType_Tag); elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TDZ == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCZVA == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.MemZero(X[t, 64], CacheType_Tag); elsif PSTATE.EL == EL2 then AArch64.MemZero(X[t, 64], CacheType_Tag); elsif PSTATE.EL == EL3 then AArch64.MemZero(X[t, 64], CacheType_Tag);
```

## C5.3.31 DC GZVA, Data Cache set Allocation Tags and Zero by VA

The DC GZVA characteristics are:

## Purpose

Zero data and write a value to the Allocation Tags of a naturally aligned block of N bytes, where the size of N is identified in DCZID\_EL0. The Allocation Tag used is determined by the input address.

This instruction might have the poison-atomic property for IMPLEMENTATION DEFINED regions of physical memory.

## Configuration

This system instruction is present only when FEAT\_MTE is implemented. Otherwise, direct accesses to DC GZVAare UNDEFINED.

## Attributes

DCGZVAis a 64-bit System instruction.

## Field descriptions

<!-- image -->

## VA, bits [63:0]

Virtual address to use. There is no alignment restriction on the address within the block of N bytes that is used.

## Executing DC GZVA

When this instruction is executed, it can generate memory faults or watchpoints which are prioritized in the same way as other memory-related faults or watchpoints. If a synchronous Data Abort fault or a watchpoint is generated, the CM bit in the ESR\_ELx.ISS field is not set.

If the memory region being zeroed is any type of Device memory, this instruction generates an alignment fault which is prioritized in the same way as other alignment faults that are determined by the memory type.

This instruction applies to Normal memory regardless of cacheability attributes.

This instruction behaves as a set of Stores to each byte and Allocation tag within the block being accessed, and so it:

- Generates a Permission fault if the translation system does not permit writes to the locations.
- Requires the same considerations for ordering and the management of coherency as any other store instructions.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC GZVA, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b0100 | 0b100 |

```
if !IsFeatureImplemented(FEAT_MTE) then UNDEFINED; elsif PSTATE.EL == EL0 then if !ELIsInHost(EL0) && SCTLR_EL1.DZE == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TDZ == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCZVA == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.DZE == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.MemZero(X[t, 64], CacheType_Data_Tag); elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TDZ == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCZVA == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.MemZero(X[t, 64], CacheType_Data_Tag); elsif PSTATE.EL == EL2 then AArch64.MemZero(X[t, 64], CacheType_Data_Tag); elsif PSTATE.EL == EL3 then AArch64.MemZero(X[t, 64], CacheType_Data_Tag);
```

## C5.3.32 DC IGDSW, Invalidate of Data and Allocation Tags by Set/Way

The DC IGDSW characteristics are:

## Purpose

Invalidate data and Allocation Tags in data cache by set/way.

## Configuration

This system instruction is present only when FEAT\_MTE2 is implemented. Otherwise, direct accesses to DC IGDSW are UNDEFINED.

## Attributes

DCIGDSWis a 64-bit System instruction.

## Field descriptions

<!-- image -->

## Bits [63:32]

Reserved, RES0.

## SetWay, bits [31:4]

Contains two fields:

- Way, bits[31:32-A], the number of the way to operate on.
- Set, bits[B-1:L], the number of the set to operate on.

Bits[L-1:4] are RES0.

A=Log2(ASSOCIATIVITY), L = Log2(LINELEN), B = (L + S), S = Log2(NSETS).

ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS (number of sets) have their usual meanings and are the values for the cache level being operated on. The values of A and S are rounded up to the next integer.

## Level, bits [3:1]

Cache level to operate on, minus 1. For example, this field is 0 for operations on L1 cache, or 1 for operations on L2 cache.

## Bit [0]

Reserved, RES0.

## Executing DC IGDSW

If this instruction is executed with a set, way or level argument that is larger than the value supported by the implementation then the behavior is CONSTRAINED UNPREDICTABLE and one of the following occurs:

- The instruction is UNDEFINED.
- The instruction performs cache maintenance on one of:

- No cache lines.
- Asingle arbitrary cache line.
- Multiple arbitrary cache lines.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC IGDSW, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b0110 | 0b110 |

```
if !IsFeatureImplemented(FEAT_MTE2) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TSW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCISW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Invalidate, CacheOpScope_SetWay); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Invalidate, CacheOpScope_SetWay); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Invalidate, CacheOpScope_SetWay);
```

## C5.3.33 DC IGDVAC, Invalidate of Data and Allocation Tags by VA to PoC

The DC IGDVAC characteristics are:

## Purpose

Invalidate data and Allocation Tags in data cache by address to Point of Coherency.

## Configuration

This system instruction is present only when FEAT\_MTE2 is implemented. Otherwise, direct accesses to DC IGDVAC are UNDEFINED.

## Attributes

DCIGDVACis a 64-bit System instruction.

## Field descriptions

<!-- image -->

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC IGDVAC

When the instruction is executed, it can generate a watchpoint, which is prioritized in the same way as other watchpoints. If a watchpoint is generated, the CM bit in the ESR\_ELx.ISS field is set to 1.

This instruction requires write access permission to the V A, otherwise it generates a Permission fault, subject to the constraints described in MMU faults generated by cache maintenance operations.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see The data cache maintenance instruction (DC).

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC IGDVAC, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b0110 | 0b101 |

```
if !IsFeatureImplemented(FEAT_MTE2) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Invalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_Invalidate, CacheOpScope_PoC) then
```

```
ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCIVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Invalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Invalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Invalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data_Tag, CacheOp_Invalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Invalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Invalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Data_Tag, CacheOp_Invalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data_Tag, CacheOp_Invalidate, CacheOpScope_PoC);
```

## C5.3.34 DC IGSW, Invalidate of Allocation Tags by Set/Way

The DC IGSW characteristics are:

## Purpose

Invalidate Allocation Tags in data cache by set/way.

## Configuration

This system instruction is present only when FEAT\_MTE2 is implemented. Otherwise, direct accesses to DC IGSW are UNDEFINED.

## Attributes

DCIGSWis a 64-bit System instruction.

## Field descriptions

<!-- image -->

## Bits [63:32]

Reserved, RES0.

## SetWay, bits [31:4]

Contains two fields:

- Way, bits[31:32-A], the number of the way to operate on.
- Set, bits[B-1:L], the number of the set to operate on.

Bits[L-1:4] are RES0.

A=Log2(ASSOCIATIVITY), L = Log2(LINELEN), B = (L + S), S = Log2(NSETS).

ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS (number of sets) have their usual meanings and are the values for the cache level being operated on. The values of A and S are rounded up to the next integer.

## Level, bits [3:1]

Cache level to operate on, minus 1. For example, this field is 0 for operations on L1 cache, or 1 for operations on L2 cache.

## Bit [0]

Reserved, RES0.

## Executing DC IGSW

If this instruction is executed with a set, way or level argument that is larger than the value supported by the implementation then the behavior is CONSTRAINED UNPREDICTABLE and one of the following occurs:

- The instruction is UNDEFINED.
- The instruction performs cache maintenance on one of:

- No cache lines.
- Asingle arbitrary cache line.
- Multiple arbitrary cache lines.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC IGSW, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b0110 | 0b100 |

```
if !IsFeatureImplemented(FEAT_MTE2) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TSW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCISW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Invalidate, CacheOpScope_SetWay); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Invalidate, CacheOpScope_SetWay); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Invalidate, CacheOpScope_SetWay);
```

## C5.3.35 DC IGVAC, Invalidate of Allocation Tags by VA to PoC

The DC IGVAC characteristics are:

## Purpose

Invalidate Allocation Tags in data cache by address to Point of Coherency.

## Configuration

This system instruction is present only when FEAT\_MTE2 is implemented. Otherwise, direct accesses to DC IGVAC are UNDEFINED.

## Attributes

DCIGVACis a 64-bit System instruction.

## Field descriptions

<!-- image -->

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC IGVAC

When the instruction is executed, it can generate a watchpoint, which is prioritized in the same way as other watchpoints. If a watchpoint is generated, the CM bit in the ESR\_ELx.ISS field is set to 1.

This instruction requires write access permission to the V A, otherwise it generates a Permission fault, subject to the constraints described in MMU faults generated by cache maintenance operations.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see The data cache maintenance instruction (DC).

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC IGVAC, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b0110 | 0b011 |

```
if !IsFeatureImplemented(FEAT_MTE2) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Invalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_Invalidate, CacheOpScope_PoC) then
```

```
ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCIVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Invalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Invalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Invalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Tag, CacheOp_Invalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Invalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Invalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Tag, CacheOp_Invalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Tag, CacheOp_Invalidate, CacheOpScope_PoC);
```

## C5.3.36 DC ISW, Data or unified Cache line Invalidate by Set/Way

The DC ISW characteristics are:

## Purpose

Invalidate data cache by set/way.

When FEAT\_MTE2 is implemented, this instruction might invalidate Allocation Tags from caches. When it invalidates Allocation Tags from caches, it also cleans them.

## Configuration

AArch64 System instruction DC ISW bits [31:0] performs the same function as bits [31:0].

This system instruction is present only when FEAT\_AA64 is implemented. Otherwise, direct accesses to DC ISW are UNDEFINED.

## Attributes

DCISWis a 64-bit System instruction.

## Field descriptions

<!-- image -->

## Bits [63:32]

Reserved, RES0.

## SetWay, bits [31:4]

Contains two fields:

- Way, bits[31:32-A], the number of the way to operate on.
- Set, bits[B-1:L], the number of the set to operate on.

Bits[L-1:4] are RES0.

A=Log2(ASSOCIATIVITY), L = Log2(LINELEN), B = (L + S), S = Log2(NSETS).

ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS (number of sets) have their usual meanings and are the values for the cache level being operated on. The values of A and S are rounded up to the next integer.

## Level, bits [3:1]

Cache level to operate on, minus 1. For example, this field is 0 for operations on L1 cache, or 1 for operations on L2 cache.

## Bit [0]

Reserved, RES0.

## Executing DC ISW

If this instruction is executed with a set, way or level argument that is larger than the value supported by the implementation then the behavior is CONSTRAINED UNPREDICTABLE and one of the following occurs:

- The instruction is UNDEFINED.
- The instruction performs cache maintenance on one of:
- No cache lines.
- Asingle arbitrary cache line.
- Multiple arbitrary cache lines.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC ISW, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b0110 | 0b010 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TSW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCISW == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Invalidate, CacheOpScope_SetWay); elsif PSTATE.EL == EL2 then AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Invalidate, CacheOpScope_SetWay); elsif PSTATE.EL == EL3 then AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Invalidate, CacheOpScope_SetWay);
```

## C5.3.37 DC IVAC, Data or unified Cache line Invalidate by VA to PoC

The DC IVAC characteristics are:

## Purpose

Invalidate data cache by address to Point of Coherency.

When FEAT\_MTE2 is implemented, this instruction might invalidate Allocation Tags from caches. When it invalidates Allocation Tags from caches, it also cleans them.

## Configuration

AArch64 System instruction DC IVAC bits [31:0] performs the same function as bits [31:0].

This system instruction is present only when FEAT\_AA64 is implemented. Otherwise, direct accesses to DC IVAC are UNDEFINED.

## Attributes

DCIVAC is a 64-bit System instruction.

## Field descriptions

<!-- image -->

|   63 |   32 |
|------|------|
|   31 |    0 |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing DC IVAC

When the instruction is executed, it can generate a watchpoint, which is prioritized in the same way as other watchpoints. If a watchpoint is generated, the CM bit in the ESR\_ELx.ISS field is set to 1.

This instruction requires write access permission to the V A, otherwise it generates a Permission fault, subject to the constraints described in 'MMU faults generated by cache maintenance operations'.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see 'The data cache maintenance instruction (DC)'.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC IVAC, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b0110 | 0b001 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Invalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Invalidate, CacheOpScope_PoC) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPCP == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCIVAC == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Invalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Invalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL2 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Invalidate, CacheOpScope_PoC) && ↪ → !AArch64.CanTrapDC(CacheType_Data, CacheOp_Invalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Invalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Invalidate, CacheOpScope_PoC); elsif PSTATE.EL == EL3 then if AArch64.TreatDCAsNOP(CacheType_Data, CacheOp_Invalidate, CacheOpScope_PoC) then ExecuteAsNOP(); else AArch64.DC(X[t, 64], CacheType_Data, CacheOp_Invalidate, CacheOpScope_PoC);
```

## C5.3.38 DC ZVA, Data Cache Zero by VA

The DC ZVA characteristics are:

## Purpose

Zero data cache by address. Zeroes a naturally aligned block of N bytes, where the size of N is identified in DCZID\_EL0.

This instruction might have the poison-atomic property for IMPLEMENTATION DEFINED regions of physical memory.

## Configuration

This system instruction is present only when FEAT\_AA64 is implemented. Otherwise, direct accesses to DC ZV A are UNDEFINED.

## Attributes

DCZVAis a 64-bit System instruction.

## Field descriptions

<!-- image -->

## VA, bits [63:0]

Virtual address to use. There is no alignment restriction on the address within the block of N bytes that is used.

## Executing DC ZVA

When this instruction is executed, it can generate memory faults or watchpoints which are prioritized in the same way as other memory-related faults or watchpoints. If a synchronous Data Abort fault or a watchpoint is generated, the CM bit in the ESR\_ELx.ISS field is set to 0.

If the memory region being zeroed is any type of Device memory, this instruction generates an Alignment fault which is prioritized in the same way as other Alignment faults that are determined by the memory type.

This instruction applies to Normal memory regardless of cacheability attributes.

This instruction behaves as a set of Stores to each byte within the block being accessed, and so it:

- Generates a Permission fault if the translation system does not permit writes to the locations.
- Requires the same considerations for ordering and the management of coherency as any other store instructions.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

DC ZVA, &lt;Xt&gt;

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b0100 | 0b001 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then if !ELIsInHost(EL0) && SCTLR_EL1.DZE == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TDZ == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.DCZVA == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.DZE == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.MemZero(X[t, 64], CacheType_Data); elsif PSTATE.EL == EL1 then if EL2Enabled() && HCR_EL2.TDZ == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.DCZVA == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.MemZero(X[t, 64], CacheType_Data); elsif PSTATE.EL == EL2 then AArch64.MemZero(X[t, 64], CacheType_Data); elsif PSTATE.EL == EL3 then AArch64.MemZero(X[t, 64], CacheType_Data);
```

## C5.3.39 IC IALLU, Instruction Cache Invalidate All to PoU

The IC IALLU characteristics are:

## Purpose

Invalidate all instruction caches of the PE executing the instruction to the Point of Unification.

## Configuration

AArch64 System instruction IC IALLU bits [31:0] performs the same function as bits [31:0].

This system instruction is present only when FEAT\_AA64 is implemented. Otherwise, direct accesses to IC IALLU are UNDEFINED.

## Attributes

IC IALLU is a 64-bit System instruction.

## Field descriptions

This instruction has no applicable fields.

The value in the register specified by &lt;Xt&gt; is ignored.

## Executing IC IALLU

The Rt field should be set to 0b11111 . If the Rt field is not set to 0b11111 , it is CONSTRAINED UNPREDICTABLE whether:

- The instruction is UNDEFINED.
- The instruction behaves as if the Rt field is set to 0b11111 .

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

```
IC IALLU{, <Xt>}
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b0101 | 0b000 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) && ↪ → !AArch64.CanTrapIC(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && HCR_EL2.TOCU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.ICIALLU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && HCR_EL2.FB == '1' then if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.IC(CacheOpScope_ALLUIS);
```

```
else if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.IC(CacheOpScope_ALLU); elsif PSTATE.EL == EL2 then if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) && ↪ → !AArch64.CanTrapIC(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.IC(CacheOpScope_ALLU); elsif PSTATE.EL == EL3 then if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.IC(CacheOpScope_ALLU);
```

## C5.3.40 IC IALLUIS, Instruction Cache Invalidate All to PoU, Inner Shareable

The IC IALLUIS characteristics are:

## Purpose

Invalidate all instruction caches in the Inner Shareable domain of the PE executing the instruction to the Point of Unification.

## Configuration

AArch64 System instruction IC IALLUIS bits [31:0] performs the same function as bits [31:0].

This system instruction is present only when FEAT\_AA64 is implemented. Otherwise, direct accesses to IC IALLUIS are UNDEFINED.

## Attributes

IC IALLUIS is a 64-bit System instruction.

## Field descriptions

This instruction has no applicable fields.

The value in the register specified by &lt;Xt&gt; is ignored.

## Executing IC IALLUIS

The Rt field should be set to 0b11111 . If the Rt field is not set to 0b11111 , it is CONSTRAINED UNPREDICTABLE whether:

- The instruction is UNDEFINED.
- The instruction behaves as if the Rt field is set to 0b11111 .

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

```
IC IALLUIS{, <Xt>}
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b000 | 0b0111 | 0b0001 | 0b000 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) && ↪ → !AArch64.CanTrapIC(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && HCR_EL2.TICAB == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.ICIALLUIS == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else
```

```
AArch64.IC(CacheOpScope_ALLUIS); elsif PSTATE.EL == EL2 then if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) && ↪ → !AArch64.CanTrapIC(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.IC(CacheOpScope_ALLUIS); elsif PSTATE.EL == EL3 then if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.IC(CacheOpScope_ALLUIS);
```

## C5.3.41 IC IVAU, Instruction Cache line Invalidate by VA to PoU

The IC IVAU characteristics are:

## Purpose

Invalidate instruction cache by address to Point of Unification.

## Configuration

AArch64 System instruction IC IVAU bits [31:0] performs the same function as bits [31:0].

This system instruction is present only when FEAT\_AA64 is implemented. Otherwise, direct accesses to IC IV AU are UNDEFINED.

## Attributes

IC IVAU is a 64-bit System instruction.

## Field descriptions

| 63                     | 32   |
|------------------------|------|
| Virtual address to use |      |
| 31                     | 0    |
| Virtual address to use |      |

## VA, bits [63:0]

Virtual address to use. No alignment restrictions apply to this V A.

## Executing IC IVAU

If EL0 access is enabled, when executed at EL0, the instruction may generate a Permission fault, subject to the constraints described in 'MMU faults generated by cache maintenance operations'.

Execution of this instruction might require an address translation from V A to PA, and that translation might fault. For more information, see 'The instruction cache maintenance instruction (IC)'.

This system instruction is an alias of the SYS instruction.

Accesses to this instruction use the following encodings in the System instruction encoding space:

```
IC IVAU{, <Xt>}
```

| op0   | op1   | CRn    | CRm    | op2   |
|-------|-------|--------|--------|-------|
| 0b01  | 0b011 | 0b0111 | 0b0101 | 0b001 |

```
if !IsFeatureImplemented(FEAT_AA64) then UNDEFINED; elsif PSTATE.EL == EL0 then if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) && ↪ → !AArch64.CanTrapIC(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); elsif !ELIsInHost(EL0) && SCTLR_EL1.UCI == '0' then if EL2Enabled() && HCR_EL2.TGE == '1' then
```

```
AArch64.SystemAccessTrap(EL2, 0x18); else AArch64.SystemAccessTrap(EL1, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TPU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && HCR_EL2.TOCU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && !ELIsInHost(EL0) && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || ↪ → SCR_EL3.FGTEn == '1') && HFGITR_EL2.ICIVAU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif ELIsInHost(EL0) && SCTLR_EL2.UCI == '0' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.IC(X[t, 64], CacheOpScope_PoU); elsif PSTATE.EL == EL1 then if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) && ↪ → !AArch64.CanTrapIC(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); elsif EL2Enabled() && HCR_EL2.TPU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && HCR_EL2.TOCU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && ↪ → HFGITR_EL2.ICIVAU == '1' then AArch64.SystemAccessTrap(EL2, 0x18); else if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.IC(X[t, 64], CacheOpScope_PoU); elsif PSTATE.EL == EL2 then if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) && ↪ → !AArch64.CanTrapIC(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.IC(X[t, 64], CacheOpScope_PoU); elsif PSTATE.EL == EL3 then if AArch64.TreatICAsNOP(CacheType_Instruction, CacheOp_Invalidate, CacheOpScope_PoU) then ExecuteAsNOP(); else AArch64.IC(X[t, 64], CacheOpScope_PoU);
```