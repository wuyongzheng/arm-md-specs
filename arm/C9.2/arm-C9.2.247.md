## C9.2.247 ST1D (scalar plus immediate, strided registers)

Contiguous store of doublewords from multiple strided vectors (immediate index)

This instruction performs a contiguous store of doublewords from elements of two or four strided vector registers to the memory address generated by a 64-bit scalar base and immediate index that is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address.

Inactive elements are not written to memory.

It has encodings from 2 classes: Two registers and Four registers

## Two registers

(FEAT\_SME2)

<!-- image -->

## Encoding

```
ST1D { <Zt1>.D, <Zt2>.D }, <PNg>, [<Xn|SP>{, #<imm>, MUL VL}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME2) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer g = UInt('1':PNg); constant integer nreg = 2; constant integer tstride = 8; constant integer t = UInt(T:'0':Zt); constant integer esize = 64; constant integer offset = SInt(imm4);
```

## Four registers

(FEAT\_SME2)

<!-- image -->

## Encoding

```
ST1D { <Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <PNg>, [<Xn|SP>{, #<imm>, MUL VL}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME2) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer g = UInt('1':PNg); constant integer nreg = 4; constant integer tstride = 4; constant integer t = UInt(T:'00':Zt); constant integer esize = 64; constant integer offset = SInt(imm4);
```

## Assembler Symbols

## &lt;Zt1&gt;

For the 'Two registers' variant: is the name of the first scalable vector register Z0-Z7 or Z16-Z23 to be transferred, encoded as 'T:'0':Zt'.

For the 'Four registers' variant: is the name of the first scalable vector register Z0-Z3 or Z16-Z19 to be transferred, encoded as 'T:'00':Zt'.

## &lt;Zt2&gt;

For the 'Two registers' variant: is the name of the second scalable vector register Z8-Z15 or Z24-Z31 to be transferred, encoded as 'T:'1':Zt'.

For the 'Four registers' variant: is the name of the second scalable vector register Z4-Z7 or Z20-Z23 to be transferred, encoded as 'T:'01':Zt'.

## &lt;PNg&gt;

Is the name of the governing scalable predicate register PN8-PN15, with predicate-as-counter encoding, encoded in the 'PNg' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the 'Two registers' variant: is the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the 'imm4' field.

For the 'Four registers' variant: is the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the 'imm4' field.

## &lt;Zt3&gt;

Is the name of the third scalable vector register Z8-Z11 or Z24-Z27 to be transferred, encoded as 'T:'10':Zt'.

## &lt;Zt4&gt;

Is the name of the fourth scalable vector register Z12-Z15 or Z28-Z31 to be transferred, encoded as 'T:'11':Zt'.

## Operation

```
CheckStreamingSVEEnabled(); constant integer VL = CurrentVL; constant integer PL = VL DIV 8; constant integer elements = VL DIV esize; constant integer mbytes = esize DIV 8; bits(64) base; bits(64) addr; bits(VL) src; constant bits(PL) pred = P[g, PL]; constant bits(PL * nreg) mask = CounterToPredicate(pred<15:0>, PL * nreg); constant boolean contiguous = TRUE; constant boolean nontemporal = FALSE; integer transfer = t; constant boolean tagchecked = n != 31; constant AccessDescriptor accdesc = CreateAccDescSVE(MemOp_STORE, nontemporal, contiguous, tagchecked); if !AnyActiveElement(mask, esize) then if n == 31 && ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then CheckSPAlignment(); else if n == 31 then CheckSPAlignment();
```

```
then
```

```
base = if n == 31 then SP[64] else X[n, 64]; addr = AddressAdd(base, offset * nreg * elements * mbytes, accdesc); for r = 0 to nreg-1 src = Z[transfer, VL]; for e = 0 to elements-1 if ActivePredicateElement(mask, r * elements + e, esize) Mem[addr, mbytes, accdesc] = Elem[src, e, esize]; addr = AddressIncrement(addr, mbytes, accdesc); transfer = transfer + tstride;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.