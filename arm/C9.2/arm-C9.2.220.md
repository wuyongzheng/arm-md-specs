## C9.2.220 SMOP4A (2-way)

Signed 16-bit integer quarter-tile sum of outer products to 32-bit integer, accumulating

This instruction generates four independent quarter-tile signed integer sums of outer products from the sub-matrices in the half-vectors of the one or two first and second source vectors and accumulates the results to the corresponding elements of a 32-bit element ZA tile.

Each of the quarter-tile sums of outer products is generated by multiplying the SVLS÷2 × 2 sub-matrix of 16-bit signed values held in the half-vectors of the first source vectors by the 2 × SVLS÷2 sub-matrix of 16-bit signed values held in the half-vectors of the second source vectors. Each 32-bit container of the half-vectors in the first source vectors holds 2 elements of each row of a SVLS÷2 × 2 sub-matrix. Similarly, each 32-bit container of the half-vectors in the second source vector holds 2 elements of each column of a 2 × SVLS÷2 sub-matrix. The resulting quarter-tile SVLS÷2 × SVLS÷2 widened 32-bit integer sums of outer products are then destructively added to the 32-bit integer destination tile.

This is equivalent to performing a 2-way dot product and accumulate to each of the destination tile elements.

This instruction is unpredicated.

It has encodings from 4 classes: Single and multiple vectors, Single vectors, Multiple and single vectors, and Multiple vectors

## Single and multiple vectors

(FEAT\_SME\_MOP4)

<!-- image -->

## Encoding

```
SMOP4A <ZAda>.S, <Zn>.H, { <Zm1>.H-<Zm2>.H }
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) then EndOfDecode(Decode_UNDEF); constant integer esize = 32; constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 1; constant integer mreg = 2; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE; constant boolean op1_unsigned = FALSE; constant boolean op2_unsigned = FALSE;
```

## Single vectors

(FEAT\_SME\_MOP4)

<!-- image -->

## Encoding

```
SMOP4A <ZAda>.S, <Zn>.H, <Zm>.H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) then EndOfDecode(Decode_UNDEF); constant integer esize = 32; constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 1; constant integer mreg = 1; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE; constant boolean op1_unsigned = FALSE; constant boolean op2_unsigned = FALSE;
```

## Multiple and single vectors

(FEAT\_SME\_MOP4)

<!-- image -->

## Encoding

```
SMOP4A <ZAda>.S, { <Zn1>.H-<Zn2>.H }, <Zm>.H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) then EndOfDecode(Decode_UNDEF); constant integer esize = 32; constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 2; constant integer mreg = 1; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE; constant boolean op1_unsigned = FALSE; constant boolean op2_unsigned = FALSE;
```

## Multiple vectors

(FEAT\_SME\_MOP4)

<!-- image -->

## Encoding

```
SMOP4A <ZAda>.S, { <Zn1>.H-<Zn2>.H }, { <Zm1>.H-<Zm2>.H }
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) then EndOfDecode(Decode_UNDEF); constant integer esize = 32; constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 2; constant integer mreg = 2; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE; constant boolean op1_unsigned = FALSE; constant boolean op2_unsigned = FALSE;
```

## Assembler Symbols

## &lt;ZAda&gt;

Is the name of the ZA tile ZA0-ZA3, encoded in the 'ZAda' field.

## &lt;Zn&gt;

Is the name of the first source scalable vector register, registers in the range Z0-Z15, encoded as 'Zn' times 2.

## &lt;Zm1&gt;

Is the name of the first scalable vector register of the second source multi-vector group, in the range Z16-Z31, encoded as 'Zm' times 2 plus 16.

## &lt;Zm2&gt;

Is the name of the second scalable vector register of the second source multi-vector group, in the range Z16-Z31, encoded as 'Zm' times 2 plus 17.

## &lt;Zm&gt;

Is the name of the second source scalable vector register, registers in the range Z16-Z31, encoded as 'Zm' times 2 plus 16.

## &lt;Zn1&gt;

Is the name of the first scalable vector register of the first source multi-vector group, in the range Z0-Z15, encoded as 'Zn' times 2.

## &lt;Zn2&gt;

Is the name of the second scalable vector register of the first source multi-vector group, in the range Z0-Z15, encoded as 'Zn' times 2 plus 1.

## Operation

```
CheckStreamingSVEAndZAEnabled(); constant integer VL = CurrentVL; constant integer hvsize = VL DIV 2; constant integer dim = hvsize DIV esize; constant integer tilesize = 4*dim*dim*esize; constant bits(tilesize) op3 = ZAtile[da, esize, bits(tilesize) result; integer prod; for outprod = 0 to 3 constant integer row_hv = outprod DIV 2; constant integer col_hv = outprod MOD 2; constant integer row_base = row_hv * dim; constant integer col_base = col_hv * dim; constant bits(VL) op1 = Z[n + (nreg-1)*col_hv, VL];
```

```
tilesize];
```

```
constant bits(VL) op2 = Z[m + (mreg-1)*row_hv, VL]; for row = 0 to dim-1 for col = 0 to dim-1 constant integer row_idx = row_base + row; constant integer col_idx = col_base + col; constant integer tile_idx = row_idx * dim * 2 + col_idx; bits(esize) sum = Elem[op3, tile_idx, esize]; for k = 0 to 1 constant bits(esize DIV 2) op1elt = Elem[op1, 2*row_idx + k, esize DIV 2]; constant bits(esize DIV 2) op2elt = Elem[op2, 2*col_idx + k, esize DIV 2]; constant integer element1 = (if op1_unsigned then UInt(op1elt) else SInt(op1elt)); constant integer element2 = (if op2_unsigned then UInt(op2elt) else SInt(op2elt)); prod = element1 * element2; if sub_op then prod = -prod; sum = sum + prod; Elem[result, tile_idx, esize] = sum; ZAtile[da, esize, tilesize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.