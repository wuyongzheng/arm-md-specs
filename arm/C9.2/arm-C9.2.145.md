## C9.2.145 LD1Q

Contiguous load of quadwords to 128-bit element ZA tile slice

This instruction performs a contiguous load of quadwords to a 128-bit element ZA tile slice. The slice number in the tile is selected by the slice index register, modulo the number of 128-bit elements in a Streaming SVE vector. The memory address is generated by scalar base and optional scalar offset that is multiplied by 16 and added to the base address. Inactive elements will not cause a read from Device memory or signal a fault, and are set to zero in the destination vector.

## SME

(FEAT\_SME)

<!-- image -->

## Encoding

```
LD1Q { <ZAt><HV>.Q[<Ws>, <offs>] }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #4}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer g = UInt('0':Pg); constant integer s = UInt('011':Rs); constant integer t = UInt(ZAt); constant integer offset = 0; constant integer esize = 128; constant boolean vertical = V == '1';
```

## Assembler Symbols

&lt;ZAt&gt;

Is the name of the ZA tile ZA0-ZA15 to be accessed, encoded in the 'ZAt' field.

## &lt;HV&gt;

Is the horizontal or vertical slice indicator, encoded in 'V':

|   V | <HV>   |
|-----|--------|
|   0 | H      |
|   1 | V      |

## &lt;Ws&gt;

Is the 32-bit name of the slice index register W12-W15, encoded in the 'Rs' field.

## &lt;offs&gt;

Is the slice index offset, with implicit value 0.

Is the name of the governing scalable predicate register P0-P7, encoded in the 'Pg' field.

<!-- image -->

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

<!-- image -->

Is the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the 'Rm' field.

## Operation

```
CheckStreamingSVEAndZAEnabled(); constant integer VL = CurrentVL; constant integer PL = VL DIV 8; constant integer dim = VL DIV esize; bits(64) base; bits(64) addr; constant bits(PL) mask = P[g, PL]; bits(64) moffs = X[m, 64]; constant bits(32) index = X[s, 32]; constant integer slice = (UInt(index) + offset) MOD dim; bits(VL) result; constant integer mbytes = esize DIV 8; constant boolean contiguous = TRUE; constant boolean nontemporal = FALSE; constant boolean tagchecked = TRUE; constant AccessDescriptor accdesc = CreateAccDescSME(MemOp_LOAD, nontemporal, contiguous, tagchecked); if n == 31 then if (AnyActiveElement(mask, esize) || ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE)) then CheckSPAlignment(); base = SP[64]; else base = X[n, 64]; for e = 0 to dim - 1 addr = AddressAdd(base, UInt(moffs) * mbytes, accdesc); if ActivePredicateElement(mask, e, esize) then Elem[result, e, esize] = Mem[addr, mbytes, accdesc]; else Elem[result, e, esize] = Zeros(esize); moffs = moffs + 1; ZAslice[t, esize, vertical, slice, VL] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.