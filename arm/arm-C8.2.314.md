## C8.2.314 LD1RB

Load and broadcast unsigned byte to vector

This instruction loads a single unsigned byte from a memory address generated by a 64-bit scalar base address plus an immediate offset that is in the range 0 to 63.

The loaded data is broadcast into all Active elements of the destination vector, setting the Inactive elements to zero. If all elements are inactive, then the instruction will not perform a read from Device memory or cause a data abort.

It has encodings from 4 classes: 8-bit element, 16-bit element, 32-bit element, and 64-bit element

## 8-bit element

(FEAT\_SVE || FEAT\_SME)

<!-- image -->

## Encoding

```
LD1RB { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) && !IsFeatureImplemented(FEAT_SME) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Zt); constant integer n = UInt(Rn); constant integer g = UInt(Pg); constant integer esize = 8; constant integer msize = 8; constant boolean unsigned = TRUE; constant integer offset = UInt(imm6);
```

## 16-bit element

(FEAT\_SVE || FEAT\_SME)

<!-- image -->

## Encoding

```
LD1RB { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) && !IsFeatureImplemented(FEAT_SME) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Zt); constant integer n = UInt(Rn); constant integer g = UInt(Pg); constant integer esize = 16; constant integer msize = 8; constant boolean unsigned = TRUE; constant integer offset = UInt(imm6);
```

## 32-bit element

(FEAT\_SVE || FEAT\_SME)

<!-- image -->

## Encoding

```
LD1RB { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) && !IsFeatureImplemented(FEAT_SME) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Zt); constant integer n = UInt(Rn); constant integer g = UInt(Pg); constant integer esize = 32; constant integer msize = 8; constant boolean unsigned = TRUE; constant integer offset = UInt(imm6);
```

## 64-bit element

(FEAT\_SVE || FEAT\_SME)

<!-- image -->

## Encoding

```
LD1RB { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) && !IsFeatureImplemented(FEAT_SME) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Zt); constant integer n = UInt(Rn); constant integer g = UInt(Pg); constant integer esize = 64; constant integer msize = 8; constant boolean unsigned = TRUE; constant integer offset = UInt(imm6);
```

## Assembler Symbols

## &lt;Zt&gt;

Is the name of the scalable vector register to be transferred, encoded in the 'Zt' field.

&lt;Pg&gt;

Is the name of the governing scalable predicate register P0-P7, encoded in the 'Pg' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the optional unsigned immediate byte offset, in the range 0 to 63, defaulting to 0, encoded in the 'imm6' field.

## Operation

```
CheckSVEEnabled(); constant integer VL = CurrentVL; constant integer PL = VL DIV 8; constant integer elements = VL DIV esize; bits(64) base; constant bits(PL) mask = P[g, PL]; bits(VL) result; bits(msize) data; constant integer mbytes = msize DIV 8; constant boolean contiguous = TRUE; constant boolean nontemporal = FALSE; constant boolean predicated = TRUE; constant boolean tagchecked = n != 31; constant AccessDescriptor accdesc = CreateAccDescSVE(MemOp_LOAD, nontemporal, contiguous, predicated, tagchecked); if !AnyActiveElement(mask, esize) then if n == 31 && ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then CheckSPAlignment(); else if n == 31 then CheckSPAlignment(); base = if n == 31 then SP[64] else X[n, 64]; constant bits(64) addr = AddressAdd(base, offset * mbytes, accdesc); data = Mem[addr, mbytes, accdesc]; for e = 0 to elements-1 if ActivePredicateElement(mask, e, esize) then Elem[result, e, esize] = Extend(data, esize, unsigned); else Elem[result, e, esize] = Zeros(esize); Z[t, VL] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.