## F5.1.239 STREXD

Store Register Exclusive Doubleword derives an address from a base register value, stores a 64-bit doubleword from two registers to the derived address if the executing PE has exclusive access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.

For more information about support for shared memory see Synchronization and semaphores. For information about memory accesses see Memory accesses.

It has encodings from the following instruction sets: A32 (A1) and T32 (T1).

A1

<!-- image -->

## Encoding

```
STREXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]
```

## Decode for this encoding

```
constant integer t = UInt(Rt); constant integer t2 = t + 1; constant integer d = UInt(Rd); constant integer n = UInt(Rn); if d == 15 || Rt<0> == '1' || t2 == 15 || n == 15 then if d == n || d == t || d == t2 then UNPREDICTABLE;
```

## CONSTRAINED UNPREDICTABLE behavior

If d == t , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The store instruction executes but the value stored is UNKNOWN.

If d == n , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The instruction performs the store to an UNKNOWN address.

If Rt&lt;0&gt; == '1' , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The instruction executes with the additional decode: Rt&lt;0&gt; = '0'.
- The instruction executes with the additional decode: t2 = t.
- The instruction executes as described, with no change to its behavior and no additional side effects.

If Rt == '1110' , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The instruction is handled as described in Using R15.

```
UNPREDICTABLE;
```

T1

<!-- image -->

## Encoding

```
STREXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]
```

## Decode for this encoding

```
constant integer d = UInt(Rd); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); if d == 15 || t == 15 || t2 == 15 || n == 15 then // Armv8-A removes UNPREDICTABLE for R13 if d == n || d == t || d == t2 then UNPREDICTABLE;
```

```
UNPREDICTABLE;
```

## CONSTRAINED UNPREDICTABLE behavior

If d == t , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The store instruction executes but the value stored is UNKNOWN.

If d == n , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The instruction performs the store to an UNKNOWN address.

For more information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors.

## Assembler Symbols

&lt;c&gt;

See Standard assembler syntax fields.

See Standard assembler syntax fields.

Is the destination general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rd' field. The value returned is:

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

&lt;Rd&gt; must not be the same as &lt;Rn&gt; , &lt;Rt&gt; , or &lt;Rt2&gt; .

<!-- image -->

## &lt;Rd&gt;

## &lt;Rt&gt;

## &lt;Rn&gt;

For the 'A1' variant: is the first general-purpose register to be transferred, encoded in the 'Rt' field. &lt;Rt&gt; must be even-numbered and not R14.

For the 'T1' variant: is the first general-purpose register to be transferred, encoded in the 'Rt' field.

## &lt;Rt2&gt;

For the 'A1' variant: is the second general-purpose register to be transferred. &lt;Rt2&gt; must be &lt;R(t+1)&gt; .

For the 'T1' variant: is the second general-purpose register to be transferred, encoded in the 'Rt2' field.

Is the general-purpose base register, encoded in the 'Rn' field.

Aborts and alignment

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Rd&gt; is not updated.

Anon doubleword-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject to the following rules:

- If AArch32.ExclusiveMonitorsPass() returns TRUE , the exception is generated.
- Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch32.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
if ConditionPassed() then EncodingSpecificOperations(); constant bits(32) address = R[n]; // Create doubleword to store such that R[t] will be stored at address and R[t2] at address+4. constant bits(64) value = if BigEndian(AccessType_GPR) then R[t]:R[t2] else R[t2]:R[t]; if AArch32.ExclusiveMonitorsPass(address,8) then MemA[address,8] = value; R[d] = ZeroExtend('0', 32); else R[d] = ZeroExtend('1', 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About the DIT bit.