## C8.2.354 LD1W (scalar plus vector)

Gather load unsigned words to vector (vector index)

This instruction performs a gather load of unsigned words to Active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign-extended or zero-extended from 32 to 64 bits and then optionally multiplied by 4. Inactive elements will not cause a read from Device memory or signal faults, and are set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless FEAT\_SME\_FA64 is implemented and enabled.

It has encodings from 6 classes: 32-bit scaled offset, 32-bit unpacked scaled offset, 32-bit unpacked unscaled offset, 32-bit unscaled offset, 64-bit scaled offset, and 64-bit unscaled offset

```
32-bit scaled offset (FEAT_SVE)
```

<!-- image -->

## Encoding

```
LD1W { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer t = UInt(Zt); constant integer n = UInt(Rn); constant integer m = UInt(Zm); constant integer g = UInt(Pg); constant integer esize = 32; constant integer msize = 32; constant integer offs_size = 32; constant boolean unsigned = TRUE; constant boolean offs_unsigned = xs == '0'; constant integer scale = 2;
```

## 32-bit unpacked scaled offset

(FEAT\_SVE)

<!-- image -->

## Encoding

```
LD1W { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Zt); constant integer n = UInt(Rn); constant integer m = UInt(Zm); constant integer g = UInt(Pg); constant integer esize = 64; constant integer msize = 32; constant integer offs_size = 32; constant boolean unsigned = TRUE; constant boolean offs_unsigned = xs == '0'; constant integer scale = 2;
```

## 32-bit unpacked unscaled offset

(FEAT\_SVE)

<!-- image -->

## Encoding

```
LD1W { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer t = UInt(Zt); constant integer n = UInt(Rn); constant integer m = UInt(Zm); constant integer g = UInt(Pg); constant integer esize = 64; constant integer msize = 32; constant integer offs_size = 32; constant boolean unsigned = TRUE; constant boolean offs_unsigned = xs == '0'; constant integer scale = 0;
```

## 32-bit unscaled offset

(FEAT\_SVE)

<!-- image -->

## Encoding

```
LD1W { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) then EndOfDecode(Decode_UNDEF);
```

```
constant integer t = UInt(Zt); constant integer n = UInt(Rn); constant integer m = UInt(Zm); constant integer g = UInt(Pg); constant integer esize = 32; constant integer msize = 32; constant integer offs_size = 32; constant boolean unsigned = TRUE; constant boolean offs_unsigned = xs == '0'; constant integer scale = 0;
```

## 64-bit scaled offset

(FEAT\_SVE)

<!-- image -->

## Encoding

```
LD1W { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Zt); constant integer n = UInt(Rn); constant integer m = UInt(Zm); constant integer g = UInt(Pg); constant integer esize = 64; constant integer msize = 32; constant integer offs_size = 64; constant boolean unsigned = TRUE; constant boolean offs_unsigned = TRUE; constant integer scale = 2;
```

## 64-bit unscaled offset

(FEAT\_SVE)

<!-- image -->

## Encoding

```
LD1W { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Zt); constant integer n = UInt(Rn); constant integer m = UInt(Zm); constant integer g = UInt(Pg); constant integer esize = 64; constant integer msize = 32; constant integer offs_size = 64; constant boolean unsigned = TRUE; constant boolean offs_unsigned = TRUE; constant integer scale = 0;
```

## Assembler Symbols

## &lt;Zt&gt;

Is the name of the scalable vector register to be transferred, encoded in the 'Zt' field.

## &lt;Pg&gt;

Is the name of the governing scalable predicate register P0-P7, encoded in the 'Pg' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Zm&gt;

Is the name of the offset scalable vector register, encoded in the 'Zm' field.

## &lt;mod&gt;

Is the index extend and shift specifier, encoded in 'xs':

|   xs | <mod>   |
|------|---------|
|    0 | UXTW    |
|    1 | SXTW    |

## Operation

```
CheckNonStreamingSVEEnabled(); constant integer VL = CurrentVL; constant integer PL = VL DIV 8; constant integer elements = VL DIV esize; bits(64) base; constant bits(PL) mask = P[g, PL]; bits(VL) offset; bits(VL) result; bits(msize) data; constant integer mbytes = msize DIV 8; constant boolean contiguous = FALSE; constant boolean nontemporal = FALSE; constant boolean predicated = TRUE; constant boolean tagchecked = TRUE; constant AccessDescriptor accdesc = CreateAccDescSVE(MemOp_LOAD, nontemporal, contiguous, predicated, tagchecked); if !AnyActiveElement(mask, esize) then if n == 31 && ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then
```

```
CheckSPAlignment(); else if n == 31 then CheckSPAlignment(); base = if n == 31 then SP[64] else X[n, 64]; offset = Z[m, VL]; for e = 0 to elements-1 if ActivePredicateElement(mask, e, esize) then constant bits(offs_size) offselt = Elem[offset, e, esize]<offs_size-1:0>; constant integer off = if offs_unsigned then UInt(offselt) else SInt(offselt); constant bits(64) addr = AddressAdd(base, off << scale, accdesc); data = Mem[addr, mbytes, accdesc]; Elem[result, e, esize] = Extend(data, esize, unsigned); else Elem[result, e, esize] = Zeros(esize); Z[t, VL] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.