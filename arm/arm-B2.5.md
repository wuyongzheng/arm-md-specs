## B2.5 Restrictions on the effects of speculation

A permitted-speculative-nPC is one of:

- For any instruction that is neither an Unconditional branch (immediate) nor an exception generating instruction, the PC plus four.
- For any instruction, an exception vector.
- For a direct branch, the PC plus the offset contained in the immediate field of the opcode.
- For an indirect branch, any address.

A permitted-speculatively-executed-instruction is the speculative execution of an instruction at a permitted-speculative-nPC where that PC was generated from one of the following:

- An architecturally executed instruction.
- Apermitted-speculatively-executed-instruction.

The Arm architecture places certain restrictions on the effects of speculation. These are:

- Each load from a location using a particular V A after an exception return that is a Context Synchronization event will not speculatively read an entry from earlier in the coherence order for the location being loaded from than the entry generated by the latest store to that location using the same V A before the exception exit.
- Each load from a location using a particular V A after an exception entry that is a Context Synchronization event will not speculatively read an entry from earlier in the coherence order for the location being loaded from than the entry generated by the latest store to that location using the same V A before the exception entry.
- Any load from a location using a particular V A before an exception entry that is a Context Synchronization event will not speculatively read data from a store to the same location using the same V A after the exception entry.
- Any load from a location using a particular V A before an exception return that is a Context Synchronization event will not speculatively read data from a store to the same location using the same V A after the exception exit.
- When data is loaded under speculation with a Translation fault, it cannot be used to form an address, generate condition codes, or generate SVE predicate values to be used by other instructions in the speculative sequence.
- Aspeculative Explicit Memory Read Effect generated by an instruction (I2) running in a hardware-defined context (context2) will not speculatively read data from a speculative Explicit Memory Write Effect generated by an instruction (I1) running in a different hardware-defined context (context1) if I1 generates an MMU fault Effect instead of the Explicit Memory Write Effect.
- When data is loaded under speculation with a GPC fault, it cannot be used to form an address, generate condition codes, or generate SVE predicate values to be used by other instructions in the speculative sequence, and the execution timing of any other instructions in the speculative sequence is not a function of the data loaded under speculation.
- When stage 2 translation is enabled and a stage 1 translation table entry is loaded under speculation with a GPC fault, the output address or Next-level table address from the entry cannot be used to form an address to be used by other fetches in the translation table walk.
- Granule protection checks apply to speculative instruction fetch and speculative execution. Any instruction fetched under speculation with a GPC fault:
- -Cannot cause an update to any architectural or micro-architectural state as a result of speculative execution of the instruction, where the update of the state is dependent on the content of the instruction.
- -Cannot be stored in a cache that is not affected by DC PAPA operations.
- If GPCCR\_EL3.GPCP == 0, data from a translation table walk for which the granule protection check for the address being accessed has not been architecturally resolved can not be used to form an address for a subsequent read access or for generating syndrome information, until the granule protection check has passed.

Note

Permitting read accesses to locations for which the granule protection check has not been architecturally resolved means the GPT does not protect non-idempotent locations from these speculative read operations.

- When data is loaded under speculation from a location that does not have a valid translation for the translation regime being speculated in, the data cannot be used to form an address, generate condition codes, or generate SVE predicate values to be used by other instructions in the speculative sequence.

- When data is loaded as a result of speculative accesses made after TLBI + DSB + ERET using a translation that was invalidated by the TLBI, the data cannot be used to form an address, generate condition codes, or generate SVE predicate values to be used by other instructions in the speculative sequence. The execution timing of any other instructions in the speculative sequence is not a function of the data loaded.
- Changes to System registers must not occur speculatively in a way that can affect a speculative memory access that can cause a change to the microarchitectural state.
- Changes to Special-purpose registers can occur speculatively.
- Accesses to Device memory are subject to many restrictions on the effects of Speculation. See Device memory.
- Execute-never controls apply to speculative instruction fetching. See Effects on instruction execution permissions and restrictions on instruction fetch.
- When writing new instructions to memory, there is no requirement for an SB instruction to prevent speculative execution of the old code. See Instruction cache maintenance instructions.
- Write speculation that is visible to other observers is prohibited for all memory types.
- Aload will not speculatively read data from any store that appears in program order after the load itself.
- From Armv9.4, an instruction (I1) that is not a permitted-speculatively-executed-instruction must not speculatively perform any function, other than being fetched, decoded or performing any side effects resulting from being fetched or decoded, that alters the microarchitectural state of the system in such a way that some other architecturally executed code (code2) can determine any architectural state, except for any architectural state accessed by I1 as part of I1 being fetched and decoded, that could not be determined had I1 not speculatively executed.

When an architectural or speculative Explicit Memory Write Effect (E1) to a Location (A1) is properly synchronized such that a subsequent architectural or speculative instruction fetch (I1) from A1 is required to observe E1, the permitted-speculative-nPC generated from I1 is permitted to be generated from the opcode before or after the modification of A1 by E1.

Note

The prohibition of using data loaded under speculation with faults to form addresses, condition codes or SVE predicate values does not prohibit the use of value predicted data from such locations for such purposes, so long as the training of the data value prediction was from the hardware defined context that is using the prediction. A consequence of this is that training of value prediction cannot be based on data loaded under speculation with a translation or Permission fault.

## B2.5.1 AArch64 Speculative Store Bypass Safe

When FEAT\_SSBS is implemented, PSTATE.SSBS is a control that can be set by software to indicate whether hardware is permitted to use, in a manner that is potentially speculatively exploitable, a speculative value in a register that has been loaded from memory using a load instruction that speculatively read the location being loaded from, where the entry that is speculatively read is from earlier in the coherence order than the entry generated by the latest store to that location using the same virtual address as the load instruction.

Aspeculative value in a register is used in a potentially speculatively exploitable manner if it is used to form an address, generate condition codes, generate condition codes, or generate SVE predicate values to be used by other instructions in the speculative sequence or if the execution timing of any other instructions in the speculative sequence is a function of the data loaded under speculation.

When the value of PSTATE.SSBS is 0, hardware is not permitted to use speculative register values in a potentially speculatively exploitable manner if the speculative read that loads the register is from earlier in the coherence order than the entry generated by the latest store to that location using the same virtual address as the load instruction.

Setting PSTATE.SSBS to 0 is deprecated for performance reasons.

When the value of PSTATE.SSBS is 1, hardware is permitted to use speculative register values in a potentially speculatively exploitable manner if the speculative read that loads the register is from earlier in the coherence order than the entry generated by the latest store to that location using the same virtual address as the load instruction.

Note

- If speculation is permitted, then cache timing side channels can lead to addresses being derived using reads of address values that have been speculatively loaded from memory to a register.
- Before the introduction of FEAT\_SSBS, the control bit SPSR\_ELx.SSBS was RES0, and therefore software written without awareness of FEAT\_SSBS is expected to program it to 0. This means that PSTATE.SSBS will not be set, so the PE will not be permitted to use speculative loads with outstanding memory disambiguation issues for any subsequent speculative memory accesses if there is any possibility of those subsequent memory accesses creating a cache timing side channel.

## B2.5.2 Definition of exploitative control of speculative execution

The execution of some code (code1) can exploitatively control speculative execution of some other code (code2) if all of the following apply:

- The actions of code1 can influence, in a manner that is not hard-to-determine, the prediction of multi-bit values that determine speculative execution of code2 to cause an irreversible change to the microarchitectural state of the PE that is indicative of some architectural state accessible to the execution context of code2.
- code1 has control in determining the choice of the architectural state that the irreversible change to the microarchitectural state is indicative of.
- The irreversible changes to the microarchitectural state of the PE can be measured by code executing in an execution context other than that of code2 to allow the retrieval of the architectural state in a manner that is not hard-to-determine.

Note

Eviction of entries from one context by another context is not considered exploitative control as long as eviction does not result in other forms of prediction that could be exploitatively controlled.

## B2.5.3 Definition of predictive leakage to speculative execution

The execution of some code (code1) can predictively leak to some other code (code2) if all of the following apply:

- The execution of code1 influences, in a manner that is not hard-to-determine, the predictive microarchitectural structures of the implementation that predict multi-bit values, not binary choices, to behave in a way that is indicative of some architectural state accessible to the execution context of code1.
- The predictive microarchitectural structures of the implementation impact the timing of the speculative execution of code2 in a way that enables code2 to recover the architectural state in a manner that is not hard-to-determine.
- Code1 and code2 are not collaborating to communicate using the mechanisms in the previous two bullets.

Note

Mechanisms to prevent the influence and the state recovery being 'not hard-to-determine' are left open to implementations. Examples could include the complete separation of prediction resources, or the isolation of the predictions using a cryptographic or pseudo-random mechanism to separate each context.

## B2.5.4 Restrictions on the effects of speculation from Armv8.5

Note

If SCR\_EL3.EEL2 is changed, in order to remove all VMID tagging from Secure EL1 and Secure EL0 entries, each prediction resource should be invalidated by software for:

- Secure EL0 for all ASID and VMID values.
- Secure EL1 for all VMID values.

Further restrictions on speculation are introduced by some additional architectural features as described here.

FEAT\_CSV3 introduces these restrictions:

- An attempt to access data under speculation, where the data is inaccessible given the current state of the PE cannot be used to alter the architectural or microarchitectural state in a manner that allows the value of the inaccessible data to be recovered by code architecturally executed through means such as measuring the timing of code. This restriction applies to any of the following cases which make the data inaccessible:

- reading from a Location with a Permission or Domain fault.

- directly reading from a system register that is not architecturally readable.

- reading from a SIMD&amp;FP register, SVE register, or SME register that is not accessible due to traps configured by a more privileged Exception level.

- indirectly reading from a system register containing a Pointer Authentication Key for which the corresponding Pointer Authentication instructions are disabled.

Note

The current state of the PE is defined as the EL, values of all special-purpose registers, and values of all system registers under which the hardware attempts to access the data, which may be on the speculative execution path. If on the speculative execution path, the hardware must respect any changes to the PE state that occur on the speculative path, respecting the same rules that would be required if executing on the non-speculative path. Note that the sequence of instructions on the speculative path may not be the same sequence of instructions that would occur on the non-speculative path as the hardware control flow predictions could cause the two sequences to differ.

Note

The following is a list of examples in which use of the inaccessible data could lead to recovery of the value of the inaccessible data:

- to form an address, generate condition codes, or generate SVE predicate values to be used in the speculative sequence.

- to form the register value used for the comparison of a compare-and-branch, test-and-branch, or compare- and-swap instruction in the speculative sequence. Note that this is to cover conditional instructions that do not use condition codes to determine their outcomes.

- by prediction mechanisms such as Cache Prefetch or Data Value predictions.

- as an input to an instruction in the speculative sequence where the execution timing of the instruction is dependent on the data value.

Note

It is permissible for a value of zero to be produced by the load or register read and consumed by an instruction newer than the load in the speculative sequence even if the value of zero results in different execution timing compared to non-zero values.

Note

As the effects of speculation are not architecturally visible, this restriction requires that the effect of any speculation cannot give rise to side channels that will leak the values of memory locations, System registers, or Special-purpose registers to a level of privilege that would otherwise not be able to determine those values.

- The value of Allocation tags loaded under speculation as the result of a Tag checked access with a NoTagAccess fault or to Untagged memory cannot influence the execution of the instruction causing the Tag checked access or other instructions in the speculative sequence.

- Changes to System registers must not occur speculatively in a way that can affect a speculative memory access that can cause a change to the microarchitectural state.

Note

Changes to Special-purpose registers can occur speculatively.

FEAT\_CSV2, FEAT\_CSV2\_1p1, FEAT\_CSV2\_1p2, FEAT\_CSV2\_2 and FEAT\_CSV2\_3 introduce a range of additional restrictions.

If FEAT\_CSV2 is implemented:

- Code running in one hardware-defined context (context1) cannot either exploitatively control, or predictively leak to, the speculative execution of code in a different hardware-defined context (context2), as a result of the behavior of any of the following resources:

- Branch target prediction based on the branch targets used in context1.

- This applies to both direct and indirect branches, including return instructions, but excludes the prediction of the direction of a conditional branch.

- Branch type prediction based on the branch types used in context1, when the hardware predicts a branch of a given type to be a different type of branch, and the type of the branch is used to exploitatively control target prediction of indirect branches within context2. Branch type is used to distinguish between:

- Not a branch, direct branch, indirect branch, and branch and link (or call).

- Data Value predictions based on data value from execution in context1.

Note

PSTATE.{N,Z,C,V} values from context1 are not considered a data value for this purpose.

- Virtual address-based cache prefetch predictions generated as a result of execution in context1, based on, or causing dereference of, data values from memory.

- Address predictions based on addresses used in context1.

- This includes any form of memory disambiguation prediction or data forwarding based on partial address match.

- Any other prediction mechanisms, other than Branch, Data Value, Cache Prefetch predictions, or Address predictions.

In this definition, the hardware-defined context is determined by:

- The Exception level.

- The Security state.

- When executing at EL1, if EL2 is implemented and enabled in the current Security state, the VMID.

- When executing at EL0, whether the EL1&amp;0 or the EL2&amp;0 translation regime is in use.

- When executing at EL0 and using the EL1&amp;0 translation regime, the address space identifier (ASID) and, if EL2 is implemented and enabled in the current Security state, the VMID.

- When executing at EL0 and using the EL2&amp;0 translation regime, the ASID.

If FEAT\_CSV2\_2 is implemented, then SCXTNUM\_ELx is also part of the hardware-defined context. For unprivileged accesses generated by unprivileged memory access instructions, the hardware-defined context associated with the data addresses and data values of the unprivileged accesses is determined as if the access was generated by an instruction executed at EL0.

If either FEAT\_CSV2\_1p1 or FEAT\_CSV2\_3 is implemented, code running in one hardware-defined context (context1) cannot either exploitatively control, or predictively leak to, the speculative execution of code in a different hardware-defined context (context2) as a result of the behavior of any prediction mechanism based on the branch history used in context1.

If FEAT\_CSV2\_1p1 is implemented, branch or data values trained from one instruction address cannot exploitatively control, or predictively leak to, the speculative execution of code from a different address.

If FEAT\_CSV2\_1p2 is implemented, the SCXTNUM\_ELx register is implemented, but is not part of the hardware-defined context.

## B2.5.5 Restrictions on the effects of speculation from Armv9.5

If FEAT\_BTI is implemented:

- Branches predicted or executed under speculation into a Guarded Page that land on instructions other than the intended BTI instructions are also guarded against speculative execution of those instructions.

## B2.5.6 Branch history

If FEAT\_CLRBHB is not implemented, then the architecture does not define any branch history maintenance instructions for AArch64 state.

When FEAT\_CLRBHB is implemented, the CLRBHB instruction is available. When the CLRBHB instruction is executed, the branch history is cleared for the current context to the extent that branch history information created before the CLRBHB instruction cannot be used by code before the CLRBHB instruction to exploitatively control the execution of any code in the current context appearing in program order after the instruction.

When FEAT\_ECBHB is implemented, the branch history information created in a context before an exception entry to a higher Exception level using AArch64 cannot be used by code before that exception entry to exploitatively control the execution of any code in a different context after the exception entry.

Note

FEAT\_CLRBHB and FEAT\_ECBHB restrict the use of the branch history to prevent exploitative control. These restrictions apply only to prediction resources that are protected by FEAT\_CSV2.

## B2.5.7 Execution, data prediction and prefetching restriction System instructions

When FEAT\_SPECRES is implemented alone or alongside FEAT\_SPECRES2, the System instructions listed in A64 System instructions for prediction restriction prevent predictions based on information gathered from earlier execution within a particular execution context (CTX), from affecting the later speculative execution within that CTX, to the extent that the speculative execution is observable through side-channels.

The prediction restriction System instructions being used by a particular CTX apply to:

- All control flow prediction resources that predict execution addresses.
- Data value prediction.
- Cache allocation prediction.

For these System instructions, the CTX is defined by:

- The Security state.
- The Exception level.
- When executing at EL1, if EL2 is implemented and enabled in the current Security state, the VMID.
- When executing at EL0, whether the EL1&amp;0 or the EL2&amp;0 translation regime is in use.
- When executing at EL0 when using the EL1&amp;0 translation regime, the ASID and, if EL2 is implemented and enabled in the current Security state, the VMID.
- When executing at EL0 when using the EL2&amp;0 translation regime, the ASID.

## Note

- The data value prediction applies to all prediction resources that use some form of training to speculate data values as part of an execution.
- The cache allocation applies to all instruction and data caches, and TLB prefetching hardware used by the executing PE that applies to the supplied context.

The context information is passed as a register argument, and is restricted so that:

- Execution of the System instruction at EL0 only applies to the current hardware defined context.
- Execution of the System instruction at EL1only applies to the current VMID and Security state, and does not apply to EL2 or EL3.
- Execution of the System instruction at EL2 can only apply to the current Security state, and does not apply to EL3.

If the System instruction is specified to apply to a combination of Security state and Exception level that is not implemented, or an Exception level which is higher than the Exception level that the System instruction is executed at, then the System instruction is treated as a NOP .

When the System instruction is complete and synchronized, no predictions of the restricted type for the affected context are influenced by the execution of the program before the System instruction in a manner that can be observed by the use of any side channels.

Note

- Prediction restriction System instructions do not require the invalidation of prediction structures so long as the behavior described for completion is met by an implementation.
- Prediction restriction System instructions are permitted to invalidate more prediction information than is defined by the supplied execution context.

These System instructions are guaranteed to be complete following a DSB that covers both read and write behavior on the same PE that executed the original instruction. A subsequent Context synchronization event is required to ensure that the effect of the completion of the instructions is synchronized to the current execution.

In AArch64 state, EL0 access to the System instructions is controlled by:

- When the Effective value of HCR\_EL2.{E2H, TGE} is not {1, 1}, SCTLR\_EL1.EnRCTX.
- When the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}, SCTLR\_EL2.EnRCTX.

## Note

If SCR\_EL3.EEL2 is changed, in order to remove all VMID tagging from Secure EL1 and Secure EL0 entries, each prediction resource should be invalidated for:

- Secure EL0 for all ASID and VMID values.
- Secure EL1 for all VMID values.