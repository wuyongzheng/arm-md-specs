## F5.1.240 STREXH

Store Register Exclusive Halfword derives an address from a base register value, stores a halfword from a register to the derived address if the executing PE has exclusive access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.

For more information about support for shared memory see Synchronization and semaphores. For information about memory accesses see Memory accesses.

It has encodings from the following instruction sets: A32 (A1) and T32 (T1).

A1

<!-- image -->

## Encoding

```
STREXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]
```

## Decode for this encoding

```
constant integer d = UInt(Rd); constant integer t = UInt(Rt); constant integer n = UInt(Rn); if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; if d == n || d == t then UNPREDICTABLE;
```

## CONSTRAINED UNPREDICTABLE behavior

If d == t , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The store instruction executes but the value stored is UNKNOWN.

If d == n , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The instruction performs the store to an UNKNOWN address.

T1

<!-- image -->

## Encoding

```
STREXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]
```

## Decode for this encoding

```
UNPREDICTABLE;
```

```
constant integer d = UInt(Rd); constant integer t = UInt(Rt); constant integer n = UInt(Rn); // Armv8-A removes UNPREDICTABLE for R13 if d == 15 || t == 15 || n == 15 then if d == n || d == t then UNPREDICTABLE;
```

## CONSTRAINED UNPREDICTABLE behavior

If d == t , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The store instruction executes but the value stored is UNKNOWN.

If d == n , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The instruction performs the store to an UNKNOWN address.

For more information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors.

## Assembler Symbols

```
<c> See Standard assembler syntax fields. <q> See Standard assembler syntax fields.
```

## &lt;Rd&gt;

## &lt;Rt&gt;

## &lt;Rn&gt;

Is the destination general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rd' field. The value returned is:

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

Is the general-purpose register to be transferred, encoded in the 'Rt' field.

Is the general-purpose base register, encoded in the 'Rn' field.

Aborts and alignment

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Rd&gt; is not updated.

Anon halfword-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject to the following rules:

- If AArch32.ExclusiveMonitorsPass() returns TRUE , the exception is generated.
- Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch32.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
if ConditionPassed() then EncodingSpecificOperations(); constant bits(32) address = R[n]; if AArch32.ExclusiveMonitorsPass(address,2) then MemA[address,2] = R[t]<15:0>; R[d] = ZeroExtend('0', 32); else R[d] = ZeroExtend('1', 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About the DIT bit.