## G2.1 About self-hosted debug

Self-hosted debug supports debugging through the generation and handling of debug exceptions , that are taken using the Exception model described in:

- The AArch64 System Level Programmers' Model, if the exception is taken to AArch64 state.
- The AArch32 System Level Programmers' Model, if the exception is taken to AArch32 state.

This section introduces some terms used in describing self-hosted debug, and then introduces the debug exceptions. See:

- Definition of a debugger in the context of self-hosted debug.
- Context ID and Process ID.

## G2.1.1 Definition of a debugger in the context of self-hosted debug

Within this chapter, debugger means that part of an operating system, or higher level of system software, that handles debug exceptions and programs the debug System registers. An operating system with rich application environments might provide debug services that support a debugger user interface executing at EL0. From the architectural perspective, the debug services are the debugger.

## G2.1.2 Context ID and Process ID

In AArch32 state, the CONTEXTIDR identifies the current Context ID , that is used by:

- The debug logic, for breakpoint and watchpoint matching.
- Implemented trace logic, to identify the current process.

When using the Long-descriptor translation table format, the CONTEXTIDR has a single field, PROCID, that is defined as the Process Identifier (Process ID). Therefore, in AArch64 state, the Context ID and Process ID are identical when using this translation table format.

When using the Short-descriptor translation table format:

- CONTEXTIDR[31:0] defines the Context ID, that is used for breakpoint and watchpoint matching.
- CONTEXTIDR[31:8] defines the Process ID.
- CONTEXTIDR[7:0] define the ASID. See Global and process-specific translation table entries. This means that, when using the Short-descriptor translation table format, the ASID is always bits[7:0] of the Context ID.

## G2.1.3 About debug exceptions

Debug exceptions occur during normal program flow if a debugger has programmed the PE to generate them. For example, a software developer might use a debugger contained in an operating system to debug an application. To do this, the debugger might enable one or more debug exceptions. The debug exceptions that can be generated in an AArch32 stage 1 translation regime are:

- Breakpoint Instruction exceptions.
- Breakpoint exceptions, generated by hardware breakpoints.
- Watchpoint exceptions, generated by hardware watchpoints.
- Vector Catch exceptions.

Note

In addition, Software Step exceptions can be generated in stage 1 of an AArch32 translation regime. However, these are always taken to AArch64 state. Software Step exceptions describes this.

Other than Breakpoint Instruction exceptions, the PE can generate a particular debug exception only if all of the following are true:

- The OS Lock is unlocked.

- DoubleLockStatus() == FALSE.

- Debug exceptions are not disabled from the current Exception level and Security state. See Enabling debug exceptions. Breakpoint Instruction exceptions are always enabled from the current Exception level and Security state.

- Adebugger has not disabled that particular debug exception. All of the debug exceptions except for Breakpoint Instruction exceptions have an enable control contained in the DBGDSCRext. See The debug exception enable controls.

Breakpoint Instruction exceptions are always enabled.

Note

If halting is allowed and EDSCR.HDE is 1, hardware breakpoints and watchpoints cause entry to Debug state instead of causing debug exceptions. In Debug state, the PE is halted.

For the definition of halting is allowed, see Halting allowed and halting prohibited.

When a debug exception is taken to an Exception level that is using AArch32:

- If the debug exception is a Watchpoint exception, it is taken as a Data Abort exception.

- Otherwise, it is taken as a Prefetch Abort exception.

The following list summarizes each of the debug exceptions:

## Breakpoint Instruction exceptions

Breakpoint instructions generate these. Breakpoint instructions are instructions that software developers can use to cause exceptions at particular points in the program flow.

The breakpoint instruction in the T32 and A32 instruction sets is BKPT #&lt;immediate&gt; . Whenever one of these is committed for execution, the PE takes a Breakpoint Instruction exception.

## PE behavior

Breakpoint Instruction exceptions cannot be masked. The PE takes Breakpoint Instruction exceptions regardless of both of the following:

- The current Privilege level and AArch32 mode.

- The current Security state.

For more information, see Breakpoint Instruction exceptions.

## Breakpoint exceptions

The architecture provides 2-16 hardware breakpoints. These can be programmed to generate Breakpoint exceptions based on one or more of instruction addresses, accesses to any address in an instruction address range, or particular PE contexts.

For example, a software developer might program a hardware breakpoint to generate a Breakpoint exception whenever the instruction with address 0x1000 is committed for execution.

The architecture supports the following types of hardware breakpoint for use in stage 1 of an AArch32 translation regime:

- Address:

- [ ] - Address Match.

- [ ] - Address Mismatch.

Comparisons are made with the virtual address of each instruction in the program flow.

- Context:

- [ ] - Context ID Match. Matches with the Context ID value held in the CONTEXTIDR.

- VMIDMatch. Matches with the VMID value held in the VTTBR.

- Context ID and VMID Match. Matches with both the Context ID and the VMID value.

An Address breakpoint can link to a Context breakpoint, so that the Address breakpoint only generates a Breakpoint exception if the PE is in a particular context when the address match or mismatch occurs.

Abreakpoint generates a Breakpoint exception whenever an instruction that causes a match is committed for execution.

## PE behavior

If halting is allowed and EDSCR.HDE is 1, hardware breakpoints cause entry to Debug state. That is, they halt the PE. See Debug State.

## Otherwise:

- If debug exceptions are enabled, hardware breakpoints cause Breakpoint exceptions.
- If debug exceptions are disabled, hardware breakpoints are ignored.

For more information, see Breakpoint exceptions.

## Watchpoint exceptions

The architecture provides 2-16 hardware watchpoints. These can be programmed to generate Watchpoint exceptions based on accesses to particular data addresses, or based on accesses to any address in a data address range.

For example, a software developer might program a hardware watchpoint to generate a Watchpoint exception on an access to any address in the data address range 0x1000 -0x101F .

Ahardware watchpoint can link to a hardware breakpoint if the hardware breakpoint is a Context matching breakpoint with linking enabled, or it can link to an address breakpoint. In this case, the watchpoint only generates a Watchpoint exception if the PE is in a particular context when the data address match occurs.

The smallest data address size that a watchpoint can be programmed to match on is a byte. A single watchpoint can be programmed to match on one or more bytes.

Awatchpoint generates a Watchpoint exception whenever an instruction that initiates an access that causes a match is committed for execution.

## PE behavior

If halting is allowed and EDSCR.HDE is 1, hardware watchpoints cause entry to Debug state. That is, they halt the PE. See Debug State.

Otherwise:

- If debug exceptions are enabled, hardware watchpoints cause Watchpoint exceptions.
- If debug exceptions are disabled, hardware watchpoints are ignored.

For more information, see Watchpoint exceptions.

## Vector Catch exceptions

These are used to trap exceptions. The architecture provides two forms of vector catch, address-matching and exception-trapping . Only one form can be implemented.

Whichever form is implemented, a debugger must enable Vector Catch exceptions for one or more exception vectors by programming the DBGVCR. Generation of Vector Catch exceptions is then as follows:

- For the address-matching form, a Vector Catch exception is generated whenever the virtual address of an instruction matches a vector that Vector Catch exceptions are enabled for.
- For the Exception-trapping form, a Vector Catch exception is generated as part of exception entry for exception types that correspond to vectors that Vector Catch exceptions are enabled for.

## PE behavior

If debug exceptions are:

- Enabled, Vector Catch exceptions can be generated.
- Disabled, vector catch is ignored.

For more information, see Vector Catch exceptions.

Table G2-1 summarizes PE behavior and shows the location of the pseudocode for each of the debug exceptions.

Table G2-1 PE behavior and pseudocode for each of the debug exceptions

| Debug exception                  | PE behavior if debug exceptions are:   | PE behavior if debug exceptions are:   | Pseudocode, see                                                          |
|----------------------------------|----------------------------------------|----------------------------------------|--------------------------------------------------------------------------|
|                                  | Enabled                                | Disabled                               |                                                                          |
| Breakpoint Instruction exception | Takes Prefetch Abort exception         | Takes Prefetch Abort exception         | AArch32.SoftwareBreakpoint()                                             |
| Breakpoint exception             | Takes Prefetch Abort exception a       | Ignored                                | Pseudocode description of Breakpoint exceptions taken from AArch32 state |
| Watchpoint exception             | Takes Data Abort exception a           | Ignored                                | Pseudocode description of Watchpoint exceptions taken from AArch32 state |
| Vector Catch exception           | Takes Prefetch Abort exception         | Ignored                                | Pseudocode description of Vector Catch exceptions                        |