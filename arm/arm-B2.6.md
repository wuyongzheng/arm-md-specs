## B2.6 Memory barriers

Memory barrier is the general term applied to an instruction, or sequence of instructions, that forces synchronization events by a PE with respect to retiring load/store instructions. The memory barriers defined by the Arm architecture provide a range of functionality, including:

- Ordering of load/store instructions.
- Completion of load/store instructions.
- Context synchronization.

The following subsections describe the Arm memory barrier instructions:

- Instruction Synchronization Barrier.
- Data Memory Barrier.
- Speculation Barrier.
- Consumption of Speculative Data Barrier.
- Speculative Store Bypass Barrier.
- Profiling Synchronization Barrier.
- Physical Speculative Store Bypass Barrier.
- Trace Synchronization Barrier.
- Data Synchronization Barrier.
- Shareability and access limitations on the data barrier operations.
- Load-Acquire, Load-AcquirePC, and Store-Release.
- LoadLOAcquire, StoreLORelease.
- Guarded Control Stack Barrier (GCSB).

Note

Depending on the required synchronization, a program might use memory barriers on their own, or it might use them in conjunction with cache maintenance and memory management instructions that in general are available only when software execution is at EL1 or higher.

DMB and DSB instructions affect reads and writes to the memory system generated by load/store instructions and data or unified cache maintenance instructions being executed by the PE.

## B2.6.1 Instruction Synchronization Barrier

An ISB instruction ensures that all instructions that come after the ISB instruction in program order are fetched from the cache or memory after the ISB instruction has completed. Using an ISB ensures that the effects of context-changing operations executed before the ISB are visible to the instructions fetched after the ISB instruction. Examples of context-changing operations that require the insertion of an ISB instruction to ensure the effects of the operation are visible to instructions fetched after the ISB instruction are:

- Completed cache and TLB maintenance instructions.
- Changes to System registers.

Any context-changing operations appearing in program order after the ISB instruction take effect only after the ISB has been executed.

The pseudocode function for the operation of an ISB is InstructionSynchronizationBarrier() .

See also Memory barriers.

## B2.6.2 Data Memory Barrier

The DMB instruction is a memory barrier instruction that ensures the relative order of memory accesses before the barrier with memory accesses after the barrier. The DMB instruction does not ensure the completion of any of the memory accesses for which it ensures relative order.

The full definition of the DMB instruction is covered formally in the Ordering requirements defined by the formal concurrency model and this introduction to the DMB instruction is not intended to contradict that section.

The basic principle of a DMB instruction is to introduce order between memory accesses that are specified to be affected by the DMB options supplied as arguments to the DMB instruction. The DMB instruction ensures that all affected memory accesses by the PE executing the DMB instruction that appear in program order before the DMB instruction and those which originate from a different PE, to the extent required by the DMB options, which have been observed by the PE before the DMB instruction is executed, are observed by each PE, to the extent required by the DMB options, before any affected memory accesses that appear in program order after the DMB instruction are observed by that PE.

The use of a DMB instruction creates order between the Memory effects of instructions as described in the definition of Barrier-ordered-before.

The DMB instruction affects only memory accesses and the operation of data cache and unified cache maintenance instructions, see A64 Cache maintenance instructions. It has no effect on the ordering of any other instructions executing on the PE.

The pseudocode function for the operation of a DMB instruction is DataMemoryBarrier() .

## B2.6.3 Speculation Barrier

An SB instruction is a memory barrier that prevents speculative execution of instructions until after the barrier has completed when those instructions could be observed through side-channels.

Until the barrier completes, the speculative execution of any instruction appearing later in the program order than the barrier cannot be performed to the extent that such speculation can be observed through side-channels as a result of control flow speculation or data value speculation. An example is speculative allocation into any caching structure where the allocation of that entry could indicate any data value present in memory or in the registers.

- Cannot be performed to the extent that such speculation can be observed through side-channels as a result of control flow speculation or data value speculation.
- Can be performed when predicting that a instruction that could generate an exception does not generate an exception.

The speculative execution of an SB instruction cannot be as a result of any of the following:

- Control flow speculation.
- Data value speculation.
- Can be as a result of predicting that an instruction that could generate an exception does not generate an exception.

An SB instruction can complete when all of the following apply:

- It is known that it is not speculative, or it is speculative only as a result of either:
- -Speculating that an instruction that could generate an exception does not generate an exception.
- -Speculating past the point in the Execution stream where a precise asynchronous exception is taken.
- All the data values generated by instructions appearing in program order before the SB instruction are architecturally resolved, and so are not speculative.

Note

The SB instruction has no effect on the use of prediction resources to predict the instruction stream that is being fetched, so long as the prediction of the instruction stream is not informed by data taken from the register outputs of the speculative execution of instructions appearing in program order after the SB instruction.

## B2.6.4 Consumption of Speculative Data Barrier

The CSDB instruction is a memory barrier instruction that controls speculative execution arising from data value prediction.

Any instruction, other than a branch instruction, that appears in program order after the CSDB cannot be speculatively executed using the results of any of the following predictions if those predictions come from instructions that appear in program order before the CSDB and have not been architecturally resolved:

- Data value predictions of any instructions.
- PSTATE.{N,Z,C,V} predictions of any instructions other than conditional branch instructions appearing in program order before the CSDB that have not been architecturally resolved.
- Predictions of SVE predication state for any SVE instructions.

Note

For purposes of the definition of CSDB, PSTATE.{N,Z,C,V} and SVE predication state are not considered data values. This definition permits:

- Control flow speculation before and after the CSDB instruction.
- Speculative execution of conditional data processing instructions after the CSDB instruction, unless they use the results of data value, SVE predication state, or PSTATE.{N,Z,C,V} predictions of instructions appearing in program order before the CSDB instruction that have not been architecturally resolved.

## B2.6.5 Speculative Store Bypass Barrier

The SSBB instruction is a memory barrier that prevents speculative loads from bypassing earlier stores to the same virtual address under certain conditions.

The semantics of the Speculative Store Bypass Barrier are:

- When a load to a location appears in program order after the SSBB instruction, then the load does not speculatively read an entry earlier in the coherence order for that location than the entry generated by the latest store satisfying all of the following conditions:
- -The store is to the same location as the load.
- -The store uses the same virtual address as the load.
- -The store appears in program order before the SSBB instruction.

## B2.6.6 Profiling Synchronization Barrier

The PSB instruction is a barrier that ensures that all existing profiling data for the current PE has been formatted, and profiling buffer addresses have been translated such that all writes to the profiling buffer have been initiated. A following DSB instruction completes when the writes to the profiling buffer have completed.

If the Statistical Profiling Extension is not implemented, this instruction executes as a NOP .

## B2.6.7 Physical Speculative Store Bypass Barrier

The PSSBB instruction is a memory barrier that prevents speculative loads from bypassing earlier stores to the same physical address under certain conditions.

The semantics of the Physical Speculative Store Bypass Barrier are:

- When a load to a location appears in program order after the PSSBB instruction, then the load does not speculatively read an entry earlier in the coherence order for that location than the entry generated by the latest store satisfying all of the following conditions:
- -The store is to the same location as the load.
- -The store appears in program order before the PSSBB instruction.

Note

The effect of this barrier applies to accesses to the same location even if they are accessed with different virtual addresses and from different Exception levels.

## B2.6.8 Trace Synchronization Barrier

The TSB instruction is a barrier instruction that preserves the relative order of accesses to System registers due to trace operations and other accesses to the same registers.

Atrace operation is an operation of the trace unit generating trace for an instruction when FEAT\_TRF is implemented and enabled.

A TSB instruction is not required to execute in program order with respect to other instructions. This includes being reordered with respect to other trace instructions. One or more Context synchronization events are required to ensure that TSB instruction is executed in the necessary order.

If trace is generated between a Context synchronization event and a TSB operation, these trace operations may be reordered with respect to the TSB operation, and therefore may not be synchronized.

The following situations are synchronized using a TSB operation:

- Adirect write B to a System register is ordered after an indirect read or indirect write of the same register by a trace operation of a traced instruction A, if all of the following are true:
- -Ais executed in program order before a Context synchronization event C.
- -Cappears in program order before a TSB operation T.
- -Bis executed in program order after T.
- Adirect read B of a System register is ordered after an indirect write to the same register by a trace operation of a traced instruction A if all the following are true:
- -Ais executed in program order before a Context synchronization event C1.
- -C1 appears in program order before TSB operation T.
- -T is executed in program order before a second Context synchronization event C2.
- -Bis executed in program order after C2.

A TSB operation is not needed to ensure a direct write B to a System register is ordered before an indirect read or indirect write of the same register by a trace operation of a traced instruction A, if all the following are true:

- Ais executed in program order after a Context synchronization event C.
- Bis executed in program order before C.

If FEAT\_TRBE is implemented, the requirements in this section are extended.

See Synchronization and the Trace Buffer Unit.

The pseudocode function for the operation of a TSB instruction is TraceSynchronizationBarrier() .

## B2.6.9 Data Synchronization Barrier

A DSB instruction is a memory barrier that ensures that memory accesses that occur before the DSB instruction have completed before the completion of the DSB instruction. In doing this, it acts as a stronger barrier than a DMB and all ordering that is created by a DMB with specific options is also generated by a DSB with the same options.

Execution of a DSB instruction:

- At EL2 ensures that any memory accesses caused by Speculative translation table walks from the EL1&amp;0 translation regime have been observed.
- At EL3 ensures that any memory accesses caused by speculative translation table walks from the EL2, EL1&amp;0 or EL2&amp;0 translation regimes have been observed.

For more information, see Out-of-context translation regimes.

A DSB instruction executed by a PE completes when all of the following are complete for the set of observers in the required shareability domain:

- If the required access types of the DSB is reads, all of the following:
- -All Explicit Memory Read Effects generated by instructions in program order before the DSB .
- -If FEAT\_GCS is implemented, all GCS Memory Read Effects that appear in program order before a GCSB instruction that appears in program order before the DSB .
- -If FEAT\_MTE2 is implemented, all Implicit Tag Memory Read Effects generated by instructions in program order before the DSB .
- If the required access types of the DSB is writes, all of the following:
- -All Explicit Memory Write Effects generated by instructions in program order before the DSB .
- -If FEAT\_GCS is implemented, all GCS Memory Write Effects that appear in program order before a GCSB instruction that appears in program order before the DSB .
- If the required access types of the DSB is reads and writes, all of the following:
- -All Explicit Memory Effects generated by instructions in program order before the DSB .
- -All Implicit TTD Memory Effects generated by instructions in program order before the DSB .
- -All Implicit Instruction Memory Read Effects generated by instructions in program order before the DSB .
- -All cache maintenance instructions in program order before the DSB .
- -If FEAT\_MTE2 is implemented, all Implicit Tag Memory Read Effects generated by instructions in program order before the DSB .
- -If FEAT\_SPMU is implemented, all Direct System Register Write Effects to a System PMU register generated by instructions in program order before the DSB .
- -If FEAT\_SPE is implemented, all PSB CSYNC instructions in program order before the DSB .
- -If FEAT\_XS is implemented and the DSB has the nXS qualifier, all of the following:
- -All TLBInXS maintenance operations generated by AArch64 TLB maintenance instructions with the nXS qualifier in program order before the DSB .
- -If HCRX\_EL2.FnXS is 1, all TLBInXS maintenance operations generated by AArch32 or AArch64 TLB maintenance instructions executed at EL1 in program order before the DSB .
- -If FEAT\_XS is not implemented or the DSB does not have the nXS qualifier, all of the following:
- -All TLBI maintenance operations generated by TLB maintenance instructions in program order before the DSB .
- -If FEAT\_HDBSS is implemented and the DSB is executed at EL2 or EL3, all HDBSS Memory Write Effects generated by instructions in program order before the DSB .
- -If FEAT\_TRBE is implemented, all TSB CSYNC instructions in program order before the DSB .
- -All CFP RCTX, COSP RCTX, CPP RCTX, DVP RCTX instructions in program order before the DSB .
- -If FEAT\_MTE\_ASYNC is implemented, all Indirect System Register Write Effects to the Tag Fault Status Register accessible at ELx generated by instructions in program order before the DSB .
- -If FEAT\_GCS is implemented, all GCS Memory Effects that appear in program order before a GCSB instruction that appears in program order before the DSB .

In addition, no instruction that appears in program order after the DSB instruction can alter any state of the system or perform any part of its functionality until the DSB completes other than:

- Being fetched from memory and decoded, or any change to architectural or microarchitectural state resulting from being fetched or decoded.
- Indirectly or directly reading any of the following, so long as the reading of these resources does not cause a change in architectural state:
- -General-purpose registers
- -SIMD&amp;FP registers
- -The Stack Pointer register
- -The Program Counter
- -If FEAT\_SVE or FEAT\_SME is implemented, SVE scalable vector registers or SVE predicate registers
- -If FEAT\_SVE is implemented, the First Fault Register
- -If FEAT\_SME is implemented, the ZA storage

- -If FEAT\_SME2 is implemented, the ZT0 register
- -Special-purpose registers
- -System registers other than CNTPCTSS\_EL0 and CNTVCTSS\_EL0
- If FEAT\_ETS2 is not implemented, translating any virtual addresses of instructions that generate Explicit Memory Effects.

If FEAT\_MTE\_ASYNC is implemented, on completion of a DSB instruction with the LD qualifier, or neither the LD nor ST qualifier, all updates to TFSR\_ELx.TFy or TFSRE0\_EL1.TFy due to Tag Check Faults caused by accesses generated by instructions occuring in program order before the DSB will be complete. For more information on FEAT\_MTE\_ASYNC, see The Memory Tagging Extension.

When FEAT\_XS is implemented and HCRX\_EL2.FnXS is 1, an AArch64 DSB instruction executed at EL1 or EL0 behaves in the same way as the corresponding DSB instruction with the nXS qualifier executed at EL1 or EL0.

A DSB instruction ordered after a direct write to a System PMU register does not complete until all observers observe the direct write. A Context synchronization event is required to create the order between the direct write and the DSB instruction.

If FEAT\_TRBE is implemented, the requirements in this section are extended. See Trace synchronization and memory barriers.

The pseudocode function for the operation of a DSB is DataSynchronizationBarrier() .

See also:

- Memory barriers.
- Ordering and completion of TLB maintenance instructions.

## B2.6.10 Shareability and access limitations on the data barrier operations

The DMB and DSB instructions take an argument that specifies:

- The shareability domain over which the instruction must operate. This is one of:

- Full system.

- Outer Shareable.

- Inner Shareable.

- Non-shareable.

Full system applies to all the observers in the system and, as such, encompasses the Inner and Outer Shareable domains of the processor.

Note

The distinction between Full system and Outer Shareable is applicable only for Normal Non-cacheable memory accesses and Device memory accesses.

- The accesses for which the instruction operates. This is one of:

- Read and write accesses, both before and after the barrier instruction.

- Write accesses only, before and after the barrier instruction.

- Read accesses before the barrier instruction, and read and write accesses after the barrier instruction.

Note

This form of a DMB or DSB instruction can be described as a load-load/store barrier.

For more information on whether an access is before or after a barrier instruction, see Data Memory Barrier or Data Synchronization Barrier.

Table B2-1 shows how these options are encoded in the &lt;option&gt; field of the instruction:

Table B2-1 Encoding of the DMB and DSB &lt;option&gt; parameter

| Accesses           |                   | Shareability domain   | Shareability domain   |                 |               |
|--------------------|-------------------|-----------------------|-----------------------|-----------------|---------------|
| Before the barrier | After the barrier | Full system           | Outer Shareable       | Inner Shareable | Non-shareable |
| Reads and writes   | Reads and writes  | SY                    | OSH                   | ISH             | NSH           |
| Writes             | Writes            | ST                    | OSHST                 | ISHST           | NSHST         |
| Reads              | Reads and writes  | LD                    | OSHLD                 | ISHLD           | NSHLD         |

Note

Table B2-1 specifies the memory ordering requirements of DMB and DSB based on the &lt;option&gt; parameter. DSB has additional requirements with respect to execution of instructions appearing in program order after the DSB as described in the section Data Synchronization Barrier. These additional requirements create the effect of additional memory ordering beyond what is specified in the table.

See the instruction descriptions for more information:

- DMB.
- DSB.

Note

ISB also supports an optional limitation argument that can contain only one value that corresponds to full system operation, see ISB.

## B2.6.11 Load-Acquire, Load-AcquirePC, and Store-Release

Arm provides a set of instructions with Acquire semantics for loads, and Release semantics for stores. These instructions support the Release Consistency sequentially consistent (RCsc) model. In addition, FEAT\_LRCPC provides Load-AcquirePC instructions. The combination of Load-AcquirePC and Store-Release can be use to support the weaker Release Consistency processor consistent (RCpc) model.

The full definitions of the Load-Acquire and Load-AcquirePC instructions are covered formally in the Ordering requirements defined by the formal concurrency model. This introduction to the Load-Acquire and Load-AcquirePC instructions is not intended to contradict that section.

The basic principle of both Load-Acquire and Load-AcquirePC instructions is to introduce order between:

- The memory access generated by the Load-Acquire or Load-AcquirePC instruction.
- The memory accesses appearing in program order after the Load-Acquire or Load-AcquirePC instruction, such that the memory access generated by the Load-Acquire or Load-AcquirePC instruction is observed by each PE to the extent that the PE is required to observe the access coherently, before any of the memory accesses appearing in program order after the Load-Acquire or Load-AcquirePC instruction are observed by that PE to the extent that the PE is required to observe the accesses coherently.

The use of a Load-Acquire or Load-AcquirePC instruction creates order between the Memory effects of instructions as described in the definition of Barrier-ordered-before.

The full definition of the Store-Release instruction is covered formally in the Ordering requirements defined by the formal concurrency model and this introduction to the Store-Release instruction is not intended to contradict that section.

The basic principle of a Store-Release instruction is to introduce order between the following:

- Aset of memory accesses, RWx, that are generated by the PE executing the Store-Release instruction and that appear in program order before the Store-Release instruction, together with those that originate from a different PE to the extent that the PE is required to observe them coherently, observed by the PE before executing the Store-release.

- The memory access generated by the Store-Release (Wrel), such that all of the memory accesses, RWx, are observed by each PE to the extent that the PE is required to observe those accesses coherently, before Wrel is observed by that PE to the extent that the PE is required to observe that access coherently.

The use of a Store-Release instruction creates order between the Memory effects of instructions as described in the definition of Barrier-ordered-before.

Where a Load-Acquire appears in program order after a Store-Release, the memory access generated by the Store-Release instruction is observed by each PE to the extent that PE is required to observe the access coherently, before the memory access generated by the Load-Acquire instruction is observed by that PE, to the extent that the PE is required to observe the access coherently. In addition, the use of a Load-Acquire, Load-AcquirePC or a Store-Release instruction on accesses to a Memory-mapped peripheral introduces order between the Memory effects of the instructions that access that peripheral, as described in the definition of Peripheral arrival order.

Load-Acquire, Load-AcquirePC and Store-Release, other than Load-Acquire Exclusive Pair and Store-Release-Exclusive Pair, access only a single data element.

Load-Acquire Exclusive Pair and Store-Release Exclusive Pair access two data elements.

AStore-Release Exclusive instruction has the release semantics only if the store is successful.

Note

- Each Load-Acquire Exclusive and Store-Release Exclusive instruction is essentially a variant of the equivalent Load-Exclusive or Store-Exclusive instruction. All usage restrictions and single-copy atomicity properties:
- -That apply to the Load-Exclusive instructions also apply to the Load-Acquire Exclusive instructions.
- -That apply to the Store-Exclusive instructions also apply to the Store-Release Exclusive instructions.
- The Load-Acquire, Load-AcquirePC, and Store-Release instructions can remove the requirement to use the explicit DMB instruction.

## B2.6.12 LoadLOAcquire, StoreLORelease

For each PE, the Non-secure physical memory map is divided into a set of LORegions using a table that is held within the PE. Any PA in the Non-secure memory map can be a member of one LORegion. If a PA is assigned to more than one LORegion, then an implementation might treat it as if it has been assigned to fewer LORegions than that have been specified. If a PA is not in the Non-secure physical memory map, then that PA cannot be a member of any LORegion. For more information, see Limited ordering regions.

FEAT\_LOR provides a set of instructions with Acquire semantics for loads, and Release semantics for stores that apply in relation to the defined LORegions. The new variants of the Load-Acquire and Store-Release instructions are LoadLOAcquire and StoreLORelease. See LoadLOAcquire/StoreLORelease.

For all memory types, these instructions have the following ordering requirements:

- LoadLOAcquire has the same semantics as Load-Acquire except that the memory accesses affected lie within the same LORegion as the address of the memory access generated by the LoadLOAcquire instruction. See Load-Acquire, Load-AcquirePC, and Store-Release.
- StoreLORelease has the same semantics as Store-Release except that the memory accesses affected lie within the same LORegion as the address of the memory access generated by the StoreLORelease instruction. See Load-Acquire, Load-AcquirePC, and Store-Release.

In addition, for accesses to Memory-mapped peripherals:

- LoadLOAcquire has the same semantics as Load-Acquire except that the affected Memory effects of instructions that access the peripheral lie within the same LORegion as the address of the memory access generated by the LoadLOAcquire instruction. See Load-Acquire, Load-AcquirePC, and Store-Release.
- StoreLORelease has the same semantics as Store-Release except that the affected Memory effects of instructions that access the peripheral lie within the same LORegion as the address of the memory access generated by the StoreLORelease instruction. See Load-Acquire, Load-AcquirePC, and Store-Release.

Note

The LoadLOAcquire/StoreLORelease instructions can remove the requirement to use the explicit DMB instruction.

## B2.6.13 Guarded Control Stack Barrier (GCSB)

The GCSB instruction is a barrier instruction that generates a GCSB event. The GCSB event applies ordering requirements between general load/store accesses and Guarded Control Stack data accesses. For more information, see Guarded Control Stack data access behaviors.

If FEAT\_GCS is not implemented, this instruction executes as a NOP.