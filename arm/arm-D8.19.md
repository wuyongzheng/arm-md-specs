## D8.19 Pseudocode description of VMSA address translation

| I ZMHCV   | The Arm architecture defines pseudocode that describes the translation table walk.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| I STKYL   | Full Physical Address Acomplete PA necessary to identify a location in physical memory is captured by the type FullAddress . This is composed of: • Abitstring address , which identifies the PA. • An enumeration paspace which identifies the PA space.                                                                                                                                                                                                                                                                                                                                                                                |
| I MXLCQ   | Address translation AArch64.TranslateAddress() acts as the entry point to VMSAand performs the required address translation based on the provided parameters and System register configurations. The function returns an AddressDescriptor structure holding valid data for either of the following: • Target memory address and attributes for a non-faulting translation. • Fault details holding data to be populated in syndrome registers.                                                                                                                                                                                          |
| I LTNYC   | AArch64.FullTranslate() selects the translation regime and performs first and potentially second stage of translation returning the PA and attributes of target memory. AArch64.S1Translate() carries out the first stage of translation when stage 1 is not disabled, mapping the VA to the IPA and carrying out permission checks. Otherwise, AArch64.S1DisabledOutput() assigns the appropriate memory attributes and flat maps the input address to the output address. AArch64.S2Translate() carries out stage 2 translation for the EL1&0 translation regime when enabled mapping the IPA to the PA. Otherwise, the IPA is the PA. |
| I KKVJD   | Translation table walk Each stage of translation has a separate walk function, AArch64.S1Walk() and AArch64.S2Walk() , corresponding to the first and second stage of translation respectively. Each use walk parameters extracted from related System registers. Parameters are collected based on the active translation regime. For instance, stage 1 EL2 translation regime parameters are obtained and returned by the function AArch64.S1TTWParamsEL2() . Given these parameters, a walk initializes a walk state of the type TTWState , holding the base address of the first translation table.                                  |
| I XWTPZ   | The walk progressively fetches and decodes translation Table descriptors, updating the walk state to the next base address as it descends through the levels of tables until a Block or Page descriptor is discovered or an invalid descriptor is fetched. Decoding the descriptor for both stage 1 and stage 2 walks is carried out by the function AArch64.DecodeDescriptorType() .                                                                                                                                                                                                                                                    |
| I YMSFF   | For a non-faulting walk, three items are returned by a translation table walk: • The final walk state.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| I KGLCH   | The final descriptor and its address are used to update the descriptor as specified by Hardware management of the Access flag and Hardware management of the dirty state.                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| I RQKNH   | Afaulting walk could report one of the following at a specified level: • Translation Fault. • Address size Fault. • Access flag Fault.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| I DNSWC   | Hardware update of Translation Table descriptors The walk parameters collected from System registers indicate the ability to update the access flag or set write permissions within descriptors. This is controlled by the Dirty Bit Modifier, and the conditions specified in Hardware management of the Access flag and Hardware management of the dirty state. The translation functions AArch64.S1Translate() or AArch64.S2Translate() set the appropriate descriptor bits returned by the walk functions and call AArch64.MemSwapTableDesc() to swap the old descriptor for the updated one in an atomic fashion.                   |

## IDKMRY Address decoding and calculation

The walk state is initialized to hold the base address of the first translation table. For stage 1, the base address is acquired using AArch64.S1TTBaseAddress() , which decodes TTBR0\_ELx and TTBR1\_ELx registers depending on the regime and the range the V A corresponds to. For stage 2, the base address is acquired using AArch64.S2TTBaseAddress() , which decodes VTTBR\_EL2 or VSTTBR\_EL2 registers depending on the Security state of the executing PE. The walk progressively fetches and decodes translation Table descriptors, updating the walk state to the next base address utilizing AArch64.NextTableBase() as it descends through the levels of tables. Prior to every descriptor fetch, apart from the fetch at the start level, the base address is indexed by the function AArch64.S1TTEntryAddress() for stage 1 or AArch64.S2TTEntryAddress() for stage 2 to point to the specific table entry. Indexing at the start level is shown in AArch64.S1SLTTEntryAddress() for stage 1 and in AArch64.S2SLTTEntryAddress() for stage 2. The final walk state would hold the base address for the output block or page; this is extracted from the Leaf descriptor in AArch64.S1LeafBase() for stage 1 and in AArch64.S2LeafBase() for stage 2.

- IGDTNP Memory attribute decoding

If a stage of translation is enabled, fetched descriptors that are blocks or pages encode memory attributes assigned to the output of translation. Stage 1 memory attributes are decoded by the function S1DecodeMemAttrs() . Likewise, the stage 2 memory attributes are decoded by the function S2DecodeMemAttrs() followed by combining stage 1 and stage 2 attributes by the function S2CombineS1MemAttrs() . However, if FEAT\_S2FWB is enabled, this behavior is overridden and memory attributes are decoded as specified in Stage 2 memory type and Cacheability attributes when FWBis enabled. This is captured by the function AArch64.S2ApplyFWBMemAttrs() .

## IHGFRX

IPJBNQ

## Fault detection

As soon as translation is invoked a reserve FaultRecord accompanies the process capturing the stage and level of translation as it proceeds. When a fault is detected, it is reflected in the FaultRecord and reported back as the result of translation with the most recent state to be reported already captured within. The following functions detect a certain type of fault:

- The AArch64.S1CheckPermissions() and AArch64.S2CheckPermissions() functions check permissions for stage 1 and stage 2 respectively.
- The AArch64.S1HasAlignmentFaultDueToMemType() and AArch64.S2HasAlignmentFaultDueToMemType() functions detect an alignment fault for stage 1 and stage 2 respectively.
- The AArch64.S1TxSZFaults() and AArch64.S2TxSZFaults() functions detect a Translation fault caused by erroneous configuration of TCR\_ELx.T n SZ field. Also, the AArch64.S2InconsistentSL() and AArch64.S2InvalidSL() functions detect a stage 2 Translation fault caused by erroneous configuration of the VTCR\_EL2.{SL2, SL0} and VSTCR\_EL2.{SL2, SL0} fields.
- AArch64.VAIsOutOfRange() detects a stage 1 Translation fault caused by V As larger than the address input size configured. Similarly, AArch64.IPAIsOutOfRange() detects a stage 2 Translation fault caused by the output of stage 1 being larger than the configured input size for stage 2.
- AArch64.ContiguousBitFaults() detects a stage 1 or 2 Translation fault caused by a mis-programmed contiguous bit within a fetched descriptor.

For more information, see function descriptions in aarch64/translation.

## Chapter D9 The Granule Protection Check Mechanism

Any access, after all enabled translation stages, targets a physical address (PA) in one of the four physical address spaces. This chapter describes the Granule Protection Check (GPC) mechanism by which accesses to those PA spaces are checked. The GPC mechanism is added by the Realm Management Extension (RME) and includes the following:

- Mechanism to determine the protection information for a particular PA and PA space.
- Allocation and invalidation behavior for TLBs, data caches, and instruction caches.
- Configuration registers and descriptor formats for PA space protection information.

This chapter contains the following sections:

- GPC behavior overview.
- GPC faults.
- GPT caching and invalidation.
- GPT formats.
- GPT lookup process.