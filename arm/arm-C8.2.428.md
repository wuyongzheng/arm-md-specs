## C8.2.428 LDNT1SB

Gather load non-temporal signed bytes

This instruction performs a non-temporal gather load of signed bytes to Active elements of a vector register from memory addresses generated by a vector base plus a 64-bit unscaled scalar register offset. Inactive elements will not cause a read from Device memory or signal faults, and are set to zero in the destination vector.

Anon-temporal load is a hint to the system that this data is unlikely to be referenced again soon.

This instruction is illegal when executed in Streaming SVE mode, unless FEAT\_SME\_FA64 is implemented and enabled.

It has encodings from 2 classes: 32-bit unscaled offset and 64-bit unscaled offset

## 32-bit unscaled offset

(FEAT\_SVE2)

<!-- image -->

## Encoding

```
LDNT1SB { <Zt>.S }, <Pg>/Z, [<Zn>.S{, <Xm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE2) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Zt); constant integer n = UInt(Zn); constant integer m = UInt(Rm); constant integer g = UInt(Pg); constant integer esize = 32; constant integer msize = 8; constant boolean unsigned = FALSE;
```

## 64-bit unscaled offset

(FEAT\_SVE2)

<!-- image -->

## Encoding

```
LDNT1SB { <Zt>.D }, <Pg>/Z, [<Zn>.D{, <Xm>}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE2) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Zt); constant integer n = UInt(Zn); constant integer m = UInt(Rm); constant integer g = UInt(Pg); constant integer esize = 64; constant integer msize = 8; constant boolean unsigned = FALSE;
```

## Assembler Symbols

## &lt;Zt&gt;

Is the name of the scalable vector register to be transferred, encoded in the 'Zt' field.

Is the name of the governing scalable predicate register P0-P7, encoded in the 'Pg' field.

## &lt;Pg&gt;

## &lt;Zn&gt;

Is the name of the base scalable vector register, encoded in the 'Zn' field.

## &lt;Xm&gt;

Is the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the 'Rm' field.

## Operation

```
CheckNonStreamingSVEEnabled(); constant integer VL = CurrentVL; constant integer PL = VL DIV 8; constant integer elements = VL DIV esize; constant bits(PL) mask = P[g, PL]; bits(VL) base; bits(64) offset; bits(VL) result; bits(msize) data; constant integer mbytes = msize DIV 8; constant boolean contiguous = FALSE; constant boolean nontemporal = TRUE; constant boolean predicated = TRUE; constant boolean tagchecked = TRUE; constant AccessDescriptor accdesc = CreateAccDescSVE(MemOp_LOAD, nontemporal, contiguous, predicated, tagchecked); if AnyActiveElement(mask, esize) then base = Z[n, VL]; offset = X[m, 64]; for e = 0 to elements-1 if ActivePredicateElement(mask, e, esize) then constant bits(64) baddr = ZeroExtend(Elem[base, e, esize], 64); constant bits(64) addr = AddressAdd(baddr, offset, accdesc); data = Mem[addr, mbytes, accdesc]; Elem[result, e, esize] = Extend(data, esize, unsigned); else Elem[result, e, esize] = Zeros(esize); Z[t, VL] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.