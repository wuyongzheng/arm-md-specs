## C9.2.310 UMOP4A (4-way)

Unsigned integer quarter-tile sum of outer products, accumulating

This instruction generates four independent quarter-tile unsigned integer sums of outer products from the sub-matrices in the half-vectors of the one or two first and second source vectors and accumulates the results to the corresponding elements of a 32-bit or 64-bit element ZA tile.

In case of the 8-bit integer variant, each of the quarter-tile sums of outer products is generated by multiplying the SVLS÷2 × 4 sub-matrix of 8-bit unsigned values held in the half-vectors of the first source vectors by the 4 × SVLS÷2 sub-matrix of 8-bit unsigned values held in the half-vectors of the second source vectors. Each 32-bit container of the half-vectors in the first source vectors holds 4 elements of each row of a SVLS÷2 × 4 sub-matrix. Similarly, each 32-bit container of the half-vectors in the second source vector holds 4 elements of each column of a 4 × SVLS÷2 sub-matrix.

In case of the 16-bit integer variant, each of the quarter-tile sums of outer products is generated by multiplying the SVLD÷2 × 4 sub-matrix of 16-bit unsigned values held in the half-vectors of the first source vectors by the 4 × SVLD÷2 sub-matrix of 16-bit unsigned values held in the half-vectors of the second source vectors. Each 64-bit container of the half-vectors in the first source vectors holds 4 elements of each row of a SVLD÷2 × 4 sub-matrix. Similarly, each 64-bit container of the half-vectors in the second source vector holds 4 elements of each column of a 4 × SVLD÷2 sub-matrix.

The resulting quarter-tile SVLS÷2 × SVLS÷2 widened 32-bit integer sums of outer products in case of the 8-bit integer variant or SVLD÷2 × SVLD÷2 widened 64-bit integer sums of outer products in case of the 16-bit integer variant are then destructively added to the 32-bit or 64-bit integer destination tile respectively.

This is equivalent to performing a 4-way dot product and accumulate to each of the destination tile elements.

This instruction is unpredicated.

It has encodings from 8 classes: 32-bit, single and multiple vectors, 32-bit, single vectors, 32-bit, multiple and single vectors, 32-bit, multiple vectors, 64-bit, single and multiple vectors, 64-bit, single vectors, 64-bit, multiple and single vectors, and 64-bit, multiple vectors

## 32-bit, single and multiple vectors

```
(FEAT_SME_MOP4)
```

<!-- image -->

## Encoding

```
UMOP4A <ZAda>.S, <Zn>.B, { <Zm1>.B-<Zm2>.B }
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) then EndOfDecode(Decode_UNDEF); constant integer esize = 32; constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 1; constant integer mreg = 2; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE; constant boolean op1_unsigned = TRUE; constant boolean op2_unsigned = TRUE;
```

## 32-bit, single vectors

(FEAT\_SME\_MOP4)

<!-- image -->

## Encoding

```
UMOP4A <ZAda>.S, <Zn>.B, <Zm>.B
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) then EndOfDecode(Decode_UNDEF);
```

```
constant integer esize = 32; constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 1; constant integer mreg = 1; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE; constant boolean op1_unsigned = TRUE; constant boolean op2_unsigned = TRUE;
```

## 32-bit, multiple and single vectors

(FEAT\_SME\_MOP4)

<!-- image -->

## Encoding

```
UMOP4A <ZAda>.S, { <Zn1>.B-<Zn2>.B }, <Zm>.B
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) then EndOfDecode(Decode_UNDEF);
```

```
constant integer esize = 32; constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 2; constant integer mreg = 1; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE; constant boolean op1_unsigned = TRUE; constant boolean op2_unsigned = TRUE;
```

## 32-bit, multiple vectors

(FEAT\_SME\_MOP4)

<!-- image -->

## Encoding

```
UMOP4A <ZAda>.S, { <Zn1>.B-<Zn2>.B }, { <Zm1>.B-<Zm2>.B }
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) then EndOfDecode(Decode_UNDEF);
```

```
constant integer esize = 32; constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 2; constant integer mreg = 2; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE; constant boolean op1_unsigned = TRUE; constant boolean op2_unsigned = TRUE;
```

## 64-bit, single and multiple vectors

(FEAT\_SME\_MOP4 &amp;&amp; FEAT\_SME\_I16I64)

<!-- image -->

## Encoding

```
UMOP4A <ZAda>.D, <Zn>.H, { <Zm1>.H-<Zm2>.H }
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) || !IsFeatureImplemented(FEAT_SME_I16I64) then EndOfDecode(Decode_UNDEF); constant integer esize = 64; constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 1; constant integer mreg = 2; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE; constant boolean op1_unsigned = TRUE; constant boolean op2_unsigned = TRUE;
```

## 64-bit, single vectors

(FEAT\_SME\_MOP4 &amp;&amp; FEAT\_SME\_I16I64)

<!-- image -->

## Encoding

```
UMOP4A <ZAda>.D, <Zn>.H, <Zm>.H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) || !IsFeatureImplemented(FEAT_SME_I16I64) then EndOfDecode(Decode_UNDEF); constant integer esize = 64; constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 1; constant integer mreg = 1; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE; constant boolean op1_unsigned = TRUE; constant boolean op2_unsigned = TRUE;
```

## 64-bit, multiple and single vectors

(FEAT\_SME\_MOP4 &amp;&amp; FEAT\_SME\_I16I64)

<!-- image -->

## Encoding

```
UMOP4A <ZAda>.D, { <Zn1>.H-<Zn2>.H }, <Zm>.H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) || !IsFeatureImplemented(FEAT_SME_I16I64) then EndOfDecode(Decode_UNDEF); constant integer esize = 64; constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 2; constant integer mreg = 1; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE; constant boolean op1_unsigned = TRUE; constant boolean op2_unsigned = TRUE;
```

## 64-bit, multiple vectors

## (FEAT\_SME\_MOP4 &amp;&amp; FEAT\_SME\_I16I64)

<!-- image -->

## Encoding

```
UMOP4A <ZAda>.D, { <Zn1>.H-<Zn2>.H }, { <Zm1>.H-<Zm2>.H }
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) || !IsFeatureImplemented(FEAT_SME_I16I64) then EndOfDecode(Decode_UNDEF); constant integer esize = 64; constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 2; constant integer mreg = 2; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE; constant boolean op1_unsigned = TRUE; constant boolean op2_unsigned = TRUE;
```

## Assembler Symbols

## &lt;ZAda&gt;

For the '32-bit, multiple and single vectors', '32-bit, multiple vectors', '32-bit, single and multiple vectors', and '32-bit, single vectors' variants: is the name of the ZA tile ZA0-ZA3, encoded in the 'ZAda' field.

For the '64-bit, multiple and single vectors', '64-bit, multiple vectors', '64-bit, single and multiple vectors', and '64-bit, single vectors' variants: is the name of the ZA tile ZA0-ZA7, encoded in the 'ZAda' field.

## &lt;Zn&gt;

Is the name of the first source scalable vector register, registers in the range Z0-Z15, encoded as 'Zn' times 2.

## &lt;Zm1&gt;

Is the name of the first scalable vector register of the second source multi-vector group, in the range Z16-Z31, encoded as 'Zm' times 2 plus 16.

## &lt;Zm2&gt;

Is the name of the second scalable vector register of the second source multi-vector group, in the range Z16-Z31, encoded as 'Zm' times 2 plus 17.

## &lt;Zm&gt;

Is the name of the second source scalable vector register, registers in the range Z16-Z31, encoded as 'Zm' times 2 plus 16.

## &lt;Zn1&gt;

Is the name of the first scalable vector register of the first source multi-vector group, in the range Z0-Z15, encoded as 'Zn' times 2.

## &lt;Zn2&gt;

Is the name of the second scalable vector register of the first source multi-vector group, in the range Z0-Z15, encoded as 'Zn' times 2 plus 1.

## Operation

```
CheckStreamingSVEAndZAEnabled(); constant integer VL = CurrentVL; constant integer hvsize = VL DIV 2; constant integer dim = hvsize DIV esize; constant integer tilesize = 4*dim*dim*esize; constant bits(tilesize) op3 = ZAtile[da, esize, tilesize]; bits(tilesize) result; integer prod; for outprod = 0 to 3 constant integer row_hv = outprod DIV 2; constant integer col_hv = outprod MOD 2; constant integer row_base = row_hv * dim; constant integer col_base = col_hv * dim; constant bits(VL) op1 = Z[n + (nreg-1)*col_hv, VL]; constant bits(VL) op2 = Z[m + (mreg-1)*row_hv, VL]; for row = 0 to dim-1 for col = 0 to dim-1 constant integer row_idx = row_base + row; constant integer col_idx = col_base + col; constant integer tile_idx = row_idx * dim * 2 + col_idx; bits(esize) sum = Elem[op3, tile_idx, esize]; for k = 0 to 3 constant bits(esize DIV 4) op1elt = Elem[op1, 4*row_idx + k, esize DIV 4]; constant bits(esize DIV 4) op2elt = Elem[op2, 4*col_idx + k, esize DIV 4]; constant integer element1 = (if op1_unsigned then UInt(op1elt) else SInt(op1elt)); constant integer element2 = (if op2_unsigned then UInt(op2elt) else SInt(op2elt)); prod = element1 * element2; if sub_op then prod = -prod; sum = sum + prod; Elem[result, tile_idx, esize] = sum; ZAtile[da, esize, tilesize] = result;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.