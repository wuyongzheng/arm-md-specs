## G1.13 Handling exceptions that are taken to an Exception level using AArch32

An exception causes the PE to suspend program execution to handle an event, such as an externally generated interrupt or an attempt to execute an undefined instruction. Exceptions can be generated by internal and external sources.

Normally, when an exception is taken the PE state is preserved immediately, before handling the exception. This means that, when the event has been handled, the original state can be restored and program execution resumed from the point where the exception was taken.

More than one exception might be generated at the same time, and a new exception can be generated while the PE is handling an exception.

The following sections describe exception handling:

- Exception vectors and the exception base address.
- Exception prioritization for exceptions taken to AArch32 state.
- Overview of exception entry.
- PE mode for taking exceptions.
- PE state on exception entry.
- Routing exceptions from Non-secure EL0 to EL2.
- Routing debug exceptions to EL2 using AArch32.

## See also:

- Routing of aborts taken to AArch32 state.
- Exception return to an Exception level using AArch32.
- Asynchronous exception behavior for exceptions taken from AArch32 state.
- AArch32 state exception descriptions.

## G1.13.1 Exception vectors and the exception base address

When an exception is taken, PE execution is forced to an address that corresponds to the type of exception. This address is called the exception vector for that exception. The vectors for the different types of exception form a vector table .

Note

There are significant differences in the sets of exception vectors for exceptions taken to an Exception level that is using AArch32 and for exceptions taken to an Exception level that is using AArch64. This part of this manual describes only how exceptions are taken to an Exception level that is using AArch32.

When an exception is taken to an Exception level that is using AArch64, then the exception is taken as described in The AArch64 System Level Programmers' Model using the exception vectors described in Exception vectors.

AArch32 state defines exception vector tables for exceptions taken to EL2 and EL3 when those Exception levels are using AArch32. Those vector tables are not used when the corresponding Exception levels are using AArch64.

Aset of exception vectors for an Exception level that is using AArch32 comprises eight consecutive word-aligned memory addresses, starting at an exception base address . These eight vectors form an AArch32 vector table .

The number of possible exception base addresses, and therefore the number of vector tables, depends on the implemented Exception levels, as follows:

## Implementation that does not include EL3

Any implementation that does not include EL3 must include the following AArch32 vector table if EL1 can use AArch32:

- An exception table for exceptions taken to EL1 modes other than System mode. This is the EL1 vector table, and is in the address space of the PL1&amp;0 translation regime.

Note

Exceptions cannot be taken to System mode.

For this vector table:

- [ ] - When SCTLR.V == 0, the VBAR holds the exception base address.

- When SCTLR.V == 1, the exception base address is 0xFFFF\_0000 .

## Implementation that includes EL2

Any implementation that includes EL2 must include the following additional AArch32 vector table if EL2 can use AArch32:

- An exception table for exceptions taken to Hyp mode. This is the Hyp vector table, and is in the address space of the Non-secure PL2 translation regime. For this vector table, HVBAR holds the exception base address.

## Implementation that includes EL3

Any implementation that includes EL3 must include the following AArch32 vector tables:

- If EL3 can use AArch32, a vector table for exceptions taken to Secure Monitor mode. This is the Monitor vector table, and is in the address space of the Secure PL1&amp;0 translation regime. For this vector table, MVBAR holds the exception base address.
- If Secure EL1 can use AArch32, a vector table for exceptions taken to Secure privileged modes other than Monitor mode and System mode. This is the Secure vector table, and is in the address space of the Secure PL1&amp;0 translation regime.
- -When the Secure instance of SCTLR.V == 0, the Secure instance of VBAR holds the exception base address.
- -When the Secure instance of SCTLR.V == 1, the exception base address is 0xFFFF\_0000 .
- If Non-secure EL1 can use AArch32, a vector table for exceptions taken to Non-secure PL1 modes. This is the Non-secure vector table, and is in the address space of the Non-secure PL1&amp;0 translation regime.
- -When the Non-secure instance of SCTLR.V == 0, the Non-secure instance of VBAR holds the exception base address.
- -When the Non-secure instance of SCTLR.V == 1, the exception base address is 0xFFFF\_0000 .

The following subsections give more information:

- The vector tables and exception offsets.
- Pseudocode determination of the exception base address.

## G1.13.1.1 The vector tables and exception offsets

Table G1-6 defines the AArch32 vector table entries. In this table:

- The Hyp column defines the vector table entries for exceptions taken to Hyp mode.

- The Monitor column defines the vector table entries for exceptions taken to Monitor mode.

- The Secure and Non-secure columns define the Secure and Non-secure vector table entries, that are used for exceptions taken to modes other than Monitor mode, Hyp mode, System mode, and User mode. Table G1-7 shows the mode to which each of these exceptions is taken. Each of these modes is described as the default mode for taking the corresponding exception.

Note

Exceptions cannot be taken to System mode or User mode.

For more information about determining the mode to which an exception is taken, see PE mode for taking exceptions.

When EL2 is using AArch32, it provides a number of additional exceptions, some of which are not shown explicitly in the vector tables. For more information, see Offsets of AArch32 exceptions provided by EL2.

Table G1-6 The AArch32 vector tables

| Offset   | Vector tables Hyp a                  | Monitor b           | Secure c              | Non-secure c          |
|----------|--------------------------------------|---------------------|-----------------------|-----------------------|
| 0x00     | Not used                             | Not used            | Not used d            | Not used              |
| 0x04     | Undefined Instruction, from Hyp mode | Monitor Trap        | Undefined Instruction | Undefined Instruction |
| 0x08     | Hypervisor Call, from Hyp mode       | Secure Monitor Call | Supervisor Call       | Supervisor Call       |
| 0x0C     | Prefetch Abort, from Hyp mode        | Prefetch Abort      | Prefetch Abort        | Prefetch Abort        |
| 0x10     | Data Abort, from Hyp mode            | Data Abort          | Data Abort            | Data Abort            |
| 0x14     | Hyp Trap, or Hyp mode entry e        | Not used            | Not used              | Not used              |
| 0x18     | IRQ interrupt                        | IRQ interrupt       | IRQ interrupt         | IRQ interrupt         |
| 0x1C     | FIQ interrupt                        | FIQ interrupt       | FIQ interrupt         | FIQ interrupt         |

Table G1-7 Modes for taking the exceptions shown in the Secure or Non-secure vector table

| Exception             | Mode taken to   |
|-----------------------|-----------------|
| Undefined Instruction | Undefined       |
| Supervisor Call       | Supervisor      |
| Prefetch Abort        | Abort           |
| Data Abort            | Abort           |
| IRQ interrupt         | IRQ             |
| FIQ interrupt         | FIQ             |

For more information about use of the vector tables, see Overview of exception entry.

## G1.13.1.1.1 Offsets of AArch32 exceptions provided by EL2

EL2 provides the following exceptions. When EL2 is using AArch32, these exceptions are taken to Hyp mode, and the PE enters the handlers for these exceptions using the following vector table entries shown in Table G1-6:

## Hypervisor Call

If taken from Hyp mode, shown explicitly in the Hyp mode vector table. Otherwise, see Use of offset 0x14 in the Hyp vector table.

| Hyp Trap      | Shown explicitly in the Hyp mode vector table.                        |
|---------------|-----------------------------------------------------------------------|
| Virtual Abort | Entered through the Data Abort vector in the Non-secure vector table. |
| Virtual IRQ   | Entered through the IRQ vector in the Non-secure vector table.        |
| Virtual FIQ   | Entered through the FIQ vector in the Non-secure vector table.        |

Note

Virtual exceptions when an implementation includes EL2 gives more information about the virtual exceptions.

## G1.13.1.1.2 Use of offset 0x14 in the Hyp vector table

The vector at offset 0x14 in the Hyp vector table is used for all exceptions that cause entry to Hyp mode from Non-secure EL0 and EL1, except for IRQ and FIQ exceptions.

Note

Virtual exceptions are never taken to Hyp mode.

## G1.13.1.1.3 Pseudocode determination of the exception base address

For an exception taken to a PL1 mode, the ExcVectorBase() function determines the exception base address.

The ExcVectorBase() function is defined in A-profile Architecture Pseudocode.

Note

The PL1 modes to which exceptions can be taken are Supervisor mode, Undefined mode, Abort mode, IRQ mode, and FIQ mode. In Non-secure state, and in Secure state when EL3 is using AArch64, these are EL1 modes. However, in Secure state when EL3 is using AArch32, these are EL3 modes. For more information, see Security state, Exception levels, and AArch32 execution privilege.

## G1.13.2 Exception prioritization for exceptions taken to AArch32 state

The following sections describe the requirements for the prioritization of synchronous exceptions, and the limits on when asynchronous exceptions can be taken:

- Synchronous exception prioritization for exceptions taken to AArch32 state.
- Architectural requirements for taking asynchronous exceptions.

See also:

- AArch32 state prioritization of synchronous aborts from a single stage of address translation, for information about:
- -The prioritization of aborts on a single memory access in a VMSA implementation.
- -The prioritization of exceptions generated during address translation.
- Debug state entry and debug event prioritization for information about the relative prioritization of exceptions and the debug events that cause entry to Debug state.

## G1.13.2.1 Synchronous exception prioritization for exceptions taken to AArch32 state

In principle, any single instruction can generate a number of different synchronous exceptions, between the fetching of the instruction, its decode, and eventual execution. This section describes the prioritization of such exceptions when they are taken to an Exception level that is using AArch32.

Note

- An exception that is taken to an Exception level that is using AArch32 must have been taken from an Exception level that is using AArch32.
- The priority numbering in this list correlates with the equivalent AArch64 list in Prioritization of Synchronous exceptions taken to AArch64 state.

For an exception that is taken to an Exception level that is using AArch32, exceptions are prioritized as follows, where 1 is the highest priority.

- 1-6

These priority numbers are used by AArch64 exceptions or debug events.

- 7 PC alignment fault exceptions. A PC alignment fault exception can only be taken to an Exception level that is using AArch32 as a result of:
- The CONSTRAINED UNPREDICTABLE handling of a branch to an unaligned address, see Branching to an unaligned PC.
- Exiting from Debug state to AArch32 specifying an unaligned PC value, see Exiting Debug state.

APCalignment fault exception that is taken to an Exception level that is using AArch32 is reported as a Prefetch Abort exception, see Prefetch Abort exception reporting a PC alignment fault exception.

- 8 Illegal Execution state exceptions. It is IMPLEMENTATION DEFINED whether this is prioritized here or at 11. See The Illegal Execution state exception.
- 9 Prefetch Abort exceptions. See Prefetch Abort exception and AArch32 state prioritization of synchronous aborts from a single stage of address translation.
- 10 Breakpoint exceptions or Address Matching Vector Catch exceptions. See:
- Breakpoint exceptions.
- Vector Catch exceptions.

Note

AnException Trapping Vector Catch exception is generated on exception entry for an exception that has been prioritized as described in this section. This means that it does not have its own entry in this list.

- 11 Illegal Execution state exceptions. It is IMPLEMENTATION DEFINED whether this is prioritized here or at 8. See The Illegal Execution state exception.
- 12 This priority number is used by an AArch64 exception.
- 13 Software Breakpoint Exceptions caused by the execution of a BKPT Exception generating instruction.
- 14-17 These priority numbers are used by AArch64 exceptions.
- 18 Exceptions taken from EL1 to EL2 because of one of the following configuration settings:
- HSTR.T n .
- HCR.TIDCP.
- 19 UNDEFINED Instruction exceptions that occur as a result of one or more of the following:
- An attempt to execute an unallocated instruction encoding, including an encoding for an instruction that is not implemented in the PE implementation.
- An attempt to execute an instruction that is defined never to be accessible at the current Exception level regardless of any enables or traps.
- Debug state execution of an instruction encoding that is not accessible in Debug state.
- Non-debug state execution of an instruction encoding that is not accessible in Non-debug state.
- Execution of an HVC instruction when HVC instructions are disabled by SCR.HCE or HCR.HCD.
- Execution of an HLT instruction when HLT instructions are disabled by EDSCR.HDE or when halting is prohibited.
- When FEAT\_FGT and FEAT\_PMUv3 are implemented, executing an MSR or MRS instruction in AArch64 state, or an MCR or MRC instruction in AArch32 state, that accesses a register associated with an unimplemented event counter.
- In Debug state:
- -Execution of a DCPS1 instruction in Non-secure EL0 when HCR.TGE is 1.
- -Execution of a DCPS2 instruction in EL1 or EL0 when SCR.NS is 0 or when EL2 is disabled or not implemented in the current Security state.
- -Execution of a DCPS3 instruction when EDSCR.SDD is 1 or when EL3 is not implemented.
- -When the value of EDSCR.SDD is 1, execution in EL2, EL1, or EL0 of an instruction that is trapped to EL3.

- Execution of an instruction that is UNDEFINED as a result of any of:
- -Being in an IT block when SCTLR.ITD is 1, or when HSCTLR.ITD is 1.
- -Executing a SETEND instruction when SCTLR.SED is 1, or when HSCTLR.SED is 1.
- -Executing a CP15DMB, CP15DSB, or CP15ISB barrier instruction when SCTLR.CP15BEN is 0, or when HSCTLR.CP15BEN is 0.
- Execution of an instruction that is UNDEFINED because at least one of FPSCR.{Stride, Len} is nonzero, when programming these bits to nonzero values is supported. See Floating-point exceptions and exception traps.

| 20    | This priority number is used by AArch64 exceptions.                                                                                                                                                                                                             |
|-------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 21    | Exceptions taken to EL1, or taken to EL2 because the value of HCR.TGE is 1, that are generated because of configurable access to instructions, and that are not covered by any of priorities 7-19.                                                              |
| 22    | Exceptions taken from EL0 to EL2 because of one of the following configuration settings: • HSTR.T n . • HCR.TIDCP.                                                                                                                                              |
| 23    | This priority number is used by AArch64 exceptions.                                                                                                                                                                                                             |
| 24    | Exceptions taken to EL2 because of configuration settings in the HCPTR.                                                                                                                                                                                         |
| 25    | Exceptions taken to EL2 because of one of the following configuration settings: • Any setting in HCR, other than the TIDCP bit. • Any setting in CNTHCTL. • Any setting in HDCR. • If EL1 is using AArch64 state, any of the fine-grained traps in HAFGRTR_EL2, |
| 26    | Exceptions taken to EL2 because of configurable access to instructions, and that are not covered by any of priorities 7-25.                                                                                                                                     |
| 27    | Exceptions caused by the SMC instruction being UNDEFINED because the value of SCR.SCD is 1.                                                                                                                                                                     |
| 28    | Exceptions caused by the execution of an Exception generating instruction, SVC , HVC , or SMC .                                                                                                                                                                 |
| 29-31 | These priority numbers are used by AArch64 exceptions.                                                                                                                                                                                                          |
| 32    | Exceptions taken to EL3 from EL0, EL1, or EL2 because of configuration settings in SDCR.                                                                                                                                                                        |
| 33    | Exceptions taken to EL3 because of configurable access to instructions, and that are not covered by any of priorities 7-32.                                                                                                                                     |
| 34-38 | These priority numbers are used by AArch64 exceptions.                                                                                                                                                                                                          |
| 39    | Trapped floating-point exceptions, if supported. See Floating-point exceptions and exception traps.                                                                                                                                                             |
| 40-43 | These priority numbers are used by AArch64 exceptions and debug events.                                                                                                                                                                                         |
| 44    | In descending priority order:                                                                                                                                                                                                                                   |
|       | a) Data Abort exceptions on translation table walks and translation table entry updates. b) Data Abort exceptions due to synchronous External aborts on translation table walks and translation                                                                 |
|       | c) Data Abort exceptions arising from an MMUfault not on a translation table walk, that are not covered by priorities 45 or 47.                                                                                                                                 |
|       | See Data Abort exception and AArch32 state prioritization of synchronous aborts from a single stage of address translation.                                                                                                                                     |
| 45    | Data Abort exceptions due to synchronous External aborts on the final physical address of the address translation process.                                                                                                                                      |

See External aborts.

- 46

Watchpoint exceptions. See Watchpoint exceptions.

- 47 The exceptions listed for priority 45 if they are prioritized as 47

- 48 This priority number is used by AArch64 exceptions.

For priorities 44-47, if an instruction results in more than one single-copy atomic memory access, the prioritization between synchronous exceptions generated on each of those different memory accesses is not defined by the architecture.

Note

Exceptions generated by a translation table walk are reported and prioritized as either a Prefetch Abort exception, priority 9 in this list, or a Data Abort exception, priority 44 in this list. See also AArch32 state prioritization of synchronous aborts from a single stage of address translation.

## G1.13.2.2 Architectural requirements for taking asynchronous exceptions

The Arm architecture does not define when asynchronous exceptions are taken. The prioritization of asynchronous exceptions, including virtual asynchronous exceptions, is IMPLEMENTATION DEFINED.

An asynchronous exception that is pending before a Context Synchronization event in the following list, is taken before the first instruction after the context synchronization event, provided that the pending asynchronous event is not masked:

- Execution of an ISB instruction that does not fail its Condition code check.

- Exception entry.

- Exception return.

- Exit from Debug state.

Note

- If the first instruction after the context synchronization event generates a synchronous exception, then the architecture does not define the order in which that synchronous exception and the asynchronous exception are taken.

- The ISR identifies any pending asynchronous exceptions.

- Interrupts are masked when the PE is in Debug state, and therefore this list of context synchronization events does not include the DCPS and DRPS instructions.

In the absence of a specific requirement to take an asynchronous exception, the only requirement of the architecture is that an unmasked asynchronous exception is taken in finite time.

Note

The taking of an unmasked asynchronous exception in finite time must occur with all code sequences, including with a sequence that consists of unconditional loops.

If an unmasked interrupt was pending but is changed to not pending before it is taken, then the architecture permits the interrupt to be taken, but does not require this to happen. If the interrupt is taken, then it must be taken before the first Context Synchronization event after the interrupt was changed to not pending.

PSTATE includes a mask bit for each type of asynchronous exception. Setting one of these bits to 1 can prevent the corresponding asynchronous exception from being taken, although when the PE is in Non-secure state other controls can modify the effect of these bits. For more information, see Asynchronous exception behavior for exceptions taken from AArch32 state.

Taking an exception sets an exception-dependent subset of these mask bits.

Note

In some contexts, the PSTATE.{A, I, F} bits mask the taking of asynchronous exceptions. The way these are set on exception entry, described in PSTATE.{A, I, F, M} values on exception entry, can prevent an exception handler being interrupted by an asynchronous exception.

## G1.13.3 Overview of exception entry

There are some significant differences between the handling of exceptions taken to Hyp mode and exceptions taken to other modes. Because Hyp mode is the EL2 mode, this means that the following descriptions sometimes distinguish between the EL2 mode and the non-EL2 modes .

On taking an exception to an Exception level that is using AArch32:

1. The hardware determines the mode to which the exception must be taken, see PE mode for taking exceptions.
2. Alink value, indicating the preferred return address for the exception, is saved. This is a possible return address for the exception handler, and depends on:
- The exception type.
- Whether the exception is taken to the EL2 mode or to a non-EL2 mode.
- For some exceptions taken to non-EL2 modes, the instruction set state when the exception was taken.

Where the link value is saved depends on whether the exception is taken to the EL2 mode. For more information, see Link values saved on exception entry.

3. The value of PSTATE is saved in the SPSR for the mode to which the exception must be taken. The value saved in SPSR.IT[7:0] is always correct for the preferred return address.
4. In an implementation that includes EL3, when EL3 is using AArch32:
- If the exception is taken from Monitor mode, SCR.NS is cleared to 0.
- Otherwise, taking the exception leaves SCR.NS unchanged.

When EL3 is using AArch64, Monitor mode is not available.

5. PSTATE is updated with new context information for the exception handler. This includes:
- Setting PSTATE.M to the PE mode to which the exception is taken.
- Setting the appropriate PSTATE mask bits. This can disable the corresponding exceptions, preventing uncontrolled nesting of exception handlers.
- Setting the instruction set state to the state required for exception entry.
- Setting the endianness to the required value for exception entry.
- Clearing the PSTATE.IT[7:0] bits to 0.

For more information, see PE state on exception entry.

6. The appropriate exception vector is loaded into the PC, see Exception vectors and the exception base address.
7. Execution continues from the address held in the PC.

For an exception taken to a non-EL2 mode, on exception entry, the exception handler can use the SRS instruction to store the return state onto the stack of any mode at the same Exception level and in the same Security state, and can use the CPS instruction to change mode. For more information about the instructions, see SRS, SRSDA, SRSDB, SRSIA, SRSIB and CPS, CPSID, CPSIE.

Later sections of this chapter describe each of the possible exceptions, and each of these descriptions includes a pseudocode description of the PE state changes on taking that exception. Table G1-8 gives an index to these descriptions:

Table G1-8 Pseudocode descriptions of exception entry for exceptions taken to AArch32 state

| Exception             | Description of exception entry                                       |
|-----------------------|----------------------------------------------------------------------|
| Reset                 | Pseudocode descriptions of reset                                     |
| Undefined Instruction | Pseudocode description of taking the Undefined Instruction exception |
| Hyp Trap              | Pseudocode description of taking the Hyp Trap exception              |
| Monitor Trap          | Pseudocode description of taking the Monitor Trap exception          |
| Supervisor Call       | Pseudocode description of taking the Supervisor Call exception       |
| Secure Monitor Call   | Pseudocode description of taking the Secure Monitor Call exception   |

| Exception       | Description of exception entry                                          |
|-----------------|-------------------------------------------------------------------------|
| Hypervisor Call | Pseudocode description of taking the Hypervisor Call exception          |
| Prefetch Abort  | Pseudocode description of taking the Prefetch Abort exception           |
| Data Abort      | Pseudocode description of taking the Data Abort exception               |
| Virtual Abort   | Pseudocode description of taking the Virtual SError interrupt exception |
| IRQ             | Pseudocode description of taking the physical IRQ exception             |
| Virtual IRQ     | Pseudocode description of taking the Virtual IRQ exception              |
| FIQ             | Pseudocode description of taking the FIQ exception                      |
| Virtual FIQ     | Pseudocode description of taking the Virtual FIQ exception              |

The following sections give more information about the PE state changes, for different architecture implementations. However, you must refer to the pseudocode for a full description of the state changes:

- PE mode for taking exceptions.
- PE state on exception entry.

## G1.13.3.1 Link values saved on exception entry

On exception entry, a link value for use on return from the exception, is saved. This link value is based on the preferred return address for the exception , as shown in Table G1-9:

Table G1-9 Exception return addresses for exceptions taken to AArch32 state

| Exception                  | Preferred return address                             | Taken to a mode at                |
|----------------------------|------------------------------------------------------|-----------------------------------|
| Undefined Instruction      | Address of the UNDEFINED instruction                 | Non-EL2 a , or EL2 c              |
| Hyp Trap                   | Address of the trapped instruction                   | EL2 only c                        |
| Monitor Trap               | Address of the trapped instruction                   | EL3 only                          |
| Supervisor Call            | Address of the instruction after the SVC instruction | Non-EL2 a or EL2 c                |
| Secure Monitor Call        | Address of the instruction after the SMC instruction | EL3 b , and only in Secure state  |
| Hypervisor Call            | Address of the instruction after the HVC instruction | EL2 only c                        |
| Prefetch Abort             | Address of aborted instruction fetch                 | Non-EL2 a or EL2 c                |
| Data Abort                 | Address of instruction that generated the abort      | Non-EL2 a or EL2 c                |
| Virtual Abort              | Address of next instruction to execute               | EL1, and only in Non-secure state |
| IRQ or FIQ                 | Address of next instruction to execute               | Non-EL2 a or EL2 c                |
| Virtual IRQ or Virtual FIQ | Address of next instruction to execute               | EL1, and only in Non-secure state |

## Note

- Although Reset is described as an exception, it differs significantly from other exceptions. The architecture has no concept of a return from a Reset and therefore it is not listed in this section.
- For each exception, the preferred return address is not affected by the Exception level from which the exception was taken.

The link value saved, and where it is saved, depend on whether the exception is taken to a non-EL2 mode, or to an EL2 mode, as follows:

## Exception taken to a non-EL2 mode

The link value is saved in the LR for the mode to which the exception is taken.

The saved link value is the preferred return address for the exception, plus an offset that depends on the instruction set state when the exception was taken, as Table G1-10 shows:

Table G1-10 Offsets applied to Link value for exceptions taken to non-EL2 modes

| Exception                  | Offset, for PE state of:   | Offset, for PE state of:   |
|----------------------------|----------------------------|----------------------------|
|                            | A32                        | T32                        |
| Undefined Instruction      | +4                         | +2                         |
| Monitor Trap               | +4                         | +2                         |
| Supervisor Call            | None                       | None                       |
| Secure Monitor Call        | None                       | None                       |
| Prefetch Abort             | +4                         | +4                         |
| Data Abort                 | +8                         | +8                         |
| Virtual Abort              | +8                         | +8                         |
| IRQ or FIQ                 | +4                         | +4                         |
| Virtual IRQ or Virtual FIQ | +4                         | +4                         |

## Exception taken to an EL2 mode

The link value is saved in the ELR\_hyp Special-purpose register.

The saved link value is the preferred return address for the exception, as shown in Table G1-9, with no offset.

## G1.13.4 PE mode for taking exceptions

The following principles determine the Exception level to which an exception is taken, and if that Exception level is using AArch32, the PE mode to which the exception is taken:

- An exception cannot be taken to the EL0 mode.
- An exception is taken either:
- -To the Exception level at which the PE was executing when it took the exception.
- -To a higher Exception level.

This means that, in Secure state:

- -When EL3 is using AArch32, an exception is always taken to an EL3 mode.
- -When EL3 is using AArch64, an exception that is taken to AArch32 state is taken to an EL1 mode.

- Configuration options and other features provided by EL2 and EL3 can determine the mode to which some exceptions are taken, as follows:

## In an implementation that does not include EL2 or EL3

An exception is always taken to the default mode for that exception.

## In an implementation that includes EL3

ASecure Monitor Call exception is always taken to EL3. This means:

- -If EL3 is using AArch32 the exception is taken to Secure Monitor mode.
- -If EL3 is using AArch64, then executing the instruction generates an exception that is taken to EL3, see Execution of an SMC instruction from a privileged Exception level that is using AArch32.

IRQ, FIQ, and External abort exceptions can be configured to be taken to EL3. Therefore, if EL3 is using AArch32 the exceptions are taken to Secure Monitor mode.

When EL3 is using AArch32, a Monitor Trap exception is taken to Secure Monitor mode.

Any exception taken from Secure state that is not taken to Secure Monitor mode is taken to Secure state in the default mode for that exception. As described in Security state, Exception levels, and AArch32 execution privilege, this means it is taken to:

- -An EL3 mode other than Monitor mode if EL3 is using AArch32.
- -An EL1 mode if EL3 is using AArch64.

If the implementation does not include EL2, any exception taken from Non-secure state that is not taken to Secure Monitor mode is taken to Non-secure state to the default mode for that exception. The default mode will be an EL1 mode.

## In an implementation that includes EL2

An exception taken from Non-secure state that is not taken to Secure Monitor mode is taken to Non-secure state and:

- If the exception is taken from Hyp mode, then it is taken to Hyp mode.

- Otherwise, the exception is either taken to Hyp mode, as described in Exceptions taken to Hyp mode, or taken to the default mode for the exception.

Note

- Hyp mode is the EL2 mode. The other modes to which an exception can be taken in Non-secure state are EL1 modes.

- Hyp mode has no effect on the handling of exceptions taken from Secure state.

Table G1-7 shows the default mode to which each exception is taken.

Asynchronous exception routing controls describes the exception routing controls provided by EL2 and EL3.

Routing of aborts taken to AArch32 state gives more information about the modes to which memory aborts are taken.

The possible modes for taking each exception shows all modes to which each exception might be taken, in any implementation. That is, it applies to implementations:

- That include neither EL2 nor EL3.
- That include EL2 but not EL3.
- That do not include EL2 but include EL3.
- That include both EL2 and EL3.

## G1.13.4.1 Exceptions taken to Hyp mode

In an implementation that includes EL2 and EL3, when EL2 is using AArch32:

- Any exception taken from Hyp mode that is not routed to EL3 by the controls described in Asynchronous exception routing controls is taken to Hyp mode.
- The following exceptions, if taken from Non-secure state, are taken to Hyp mode:
- -An abort that Routing of aborts taken to AArch32 state identifies as taken to Hyp mode.
- -AHypTrap exception, see EL2 configurable controls.

- AHypervisor Call exception. This is generated by executing an HVC instruction in a Non-secure mode.

- An SError exception, IRQ exception or FIQ exception that is not routed to EL3 but is explicitly routed to Hyp mode, as described in Asynchronous exception routing controls.

- [ ] - Asynchronous External abort, Alignment fault, Undefined Instruction exception, or Supervisor Call exception taken from the Non-secure EL0 mode and explicitly routed to Hyp mode, as described in Routing exceptions from Non-secure EL0 to EL2.

Note

Asynchronous External abort can be routed to Hyp mode only if it is not routed to EL3.

- Adebug exception that is explicitly routed to Hyp mode, as described in Routing debug exceptions to EL2 using AArch32.

Note

The virtual exceptions cannot be taken to Hyp mode. They are always taken to a Non-secure EL1 mode.

## G1.13.4.2 Security behavior in Exception levels using AArch32 when EL2 or EL3 are using AArch64

As described in The Armv8-A security model, when EL3 is using AArch64, lower Exception levels, in either Security state, can be using AArch32. This means software executing in those Exception levels might try to access AArch32 security features that are not available. The following subsections describe the associated behaviors:

- Execution of an SMC instruction from a privileged Exception level that is using AArch32.
- Non-secure reads of the NSACR.
- Secure EL1 operations when Secure EL1 is using AArch32 state.

## G1.13.4.2.1 Execution of an SMC instruction from a privileged Exception level that is using AArch32

When EL3 is using AArch64, an SMC instruction executed from Secure or Non-secure EL1 using AArch32, or from Non-secure EL2 using AArch32 when the value of HCR.TSC is 0, generates an exception that is taken to EL3. The exception syndrome is reported with an EC value of 0x13 , SMC instruction executed in AArch32 state.

## G1.13.4.2.2 Non-secure reads of the NSACR

The NSACR is defined as being RO from Non-secure PE modes other than User mode. When EL3 is using AArch64, a read of the NSACR returns a fixed value of 0x0000\_0C00 in the following cases:

- If the read is from a Non-secure EL1 mode when EL1 is using AArch32.
- If the read is from Hyp mode when EL2 is using AArch32.

## G1.13.4.2.3 Secure EL1 operations when Secure EL1 is using AArch32 state

When Secure EL1 is using AArch32 and if FEAT\_SEL2 is implemented and enabled or EL3 is using AArch64:

- Any of the following operations performed in a Secure EL1 mode is trapped to Secure EL3:
- -Aread or write of any of the SCR, NSACR, MVBAR, and SDCR.
- -Executing any of the ATS12NSO** instructions.
- -Executing an SRS instruction that would use SP\_mon, see SRS, SRSDA, SRSDB, SRSIA, SRSIB.
- -Executing an MRS (banked register) or MSR (banked register) instruction that would access SPSR\_mon, SP\_mon, or LR\_mon, see MRS (Banked register) and MSR (Banked register).
- Any attempt to move into Hypervisor mode, either by an exception return or by executing a CPS or MSR instruction, is treated as an illegal operation and is handled as described in Illegal return events from AArch32 state.
- Any attempt to move into Monitor mode, either by an exception return or by executing a CPS or MSR instruction, is treated as an illegal operation and is handled as described in Illegal return events from AArch32 state.

Note

This functionality supports a usage model where:

- EL3 uses AArch64.
- Secure software executed in Secure EL1 using AArch32 and Secure EL0 using AArch32.
- The Non-secure state uses AArch64.

## G1.13.4.3 The possible modes for taking each exception

Each of the exception descriptions in AArch32 state exception descriptions includes a subsection that describes the modes to which each exception can be taken. Those subsections are:

- The PE mode to which the Undefined Instruction exception is taken.
- The PE mode to which the Hyp Trap exception is taken.
- The PE mode to which the Monitor Trap exception is taken.
- The PE mode to which the Supervisor Call exception is taken.
- The PE mode to which the Secure Monitor Call exception is taken.
- The PE mode to which the Hypervisor Call exception is taken.
- The PE mode to which the Prefetch Abort exception is taken.
- The PE mode to which the Data Abort exception is taken.
- The PE mode to which the Virtual SError interrupt exception is taken.
- The PE mode to which the physical IRQ exception is taken.
- The PE mode to which the Virtual IRQ exception is taken.
- The PE mode to which the physical FIQ exception is taken.
- The PE mode to which the Virtual FIQ exception is taken.

These descriptions also show the vector offset for the exception entry for each mode. These descriptions assume that all Exception levels are using AArch32, meaning:

- HCR, rather than HCR\_EL2, controls the routing of exceptions to EL2.
- SCR, rather than SCR\_EL3, controls the routing of exceptions to EL3.

For more information about:

- Vector offsets, see Exception vectors and the exception base address.
- The routing of synchronous External aborts or SError, IRQ, and FIQ interrupt exceptions, and the virtual exceptions, see Asynchronous exception routing controls.

## G1.13.4.3.1 UNPREDICTABLE cases when the value of HCR.TGE is 1

When the value of HCR.TGE is 1, exceptions that would otherwise be taken to EL1 are, instead, routed to EL2, see Routing exceptions from Non-secure EL0 to EL2. Related to this, when the value of HCR.TGE is 1, execution in a Non-secure EL1 mode is UNPREDICTABLE. The architecture does not constrain this UNPREDICTABLE behavior, but software that follows the Arm recommendations cannot get to this state. When following the Arm recommendations, any attempt to move to a Non-secure EL1 mode when the value of HCR.TGE is 1 is either:

- An illegal exception return, see Illegal return events from AArch32 state.
- An illegal PE mode change, see Illegal changes to PSTATE.M.

## G1.13.5 PE state on exception entry

The description of each exception includes a pseudocode description of entry to that exception, as Table G1-8 shows. The following sections describe the PE state changes on entering an exception, for different implementations and operating states. However, you must always see the exception entry pseudocode for a full description of the state changes on exception entry:

- Instruction set state on exception entry.
- PSTATE.E value on exception entry.
- PSTATE.{A, I, F, M} values on exception entry.

Note

The descriptions in these sections assume that EL2 and EL3, which control some aspects of the routing of exceptions taken from EL1 or EL0, are both using AArch32. If this is not the case:

- If EL2 is using AArch64:
- -Controls shown as provided by the HSCTLR are provided by the SCTLR\_EL2.
- -Controls shown as provided by the HCR are provided by the HCR\_EL2.
- If EL3 is using AArch64, controls shown as provided by the SCR are provided by the SCR\_EL3.

## G1.13.5.1 Instruction set state on exception entry

Exception handlers can execute in either T32 state or A32 state. On exception entry, PSTATE.T is set to the required value, as determined by SCTLR.TE or HSCTLR.TE, depending on the mode the exception is taken to. Table G1-11 shows this:

Table G1-11 PSTATE.T bit value on exception entry

| Mode to which exception is taken   | HSCTLR.TE   | SCTLR.TE   |   PSTATE.T | Exception handler state   |
|------------------------------------|-------------|------------|------------|---------------------------|
| Not Hyp mode                       | x           | 0          |          0 | A32                       |
|                                    |             | 1          |          1 | T32                       |
| Hyp mode                           | 0           | x          |          0 | A32                       |
|                                    | 1           | x          |          1 | T32                       |

When an implementation includes EL3 and EL3 is using AArch32, SCTLR is banked for Secure and Non-secure states, and therefore the TE bit value might be different for Secure and Non-secure states. For an exception taken to a PE mode other than Hyp mode, the SCTLR.TE bit for the Security state to which the exception is taken determines the instruction set state for the exception handler. This means the instruction set state in which an exception handler might execute depends on the Security state to which the exception is taken.

## G1.13.5.2 PSTATE.E value on exception entry

PSTATE.E controls the load and store endianness for data handling. Table G1-12 show the value to which this bit is set on exception entry:

Table G1-12 PSTATE.E value on exception entry

| Exception mode           | HSCTLR.EE   |   SCTLR.EE | Endianness for data loads and stores   |   PSTATE.E |
|--------------------------|-------------|------------|----------------------------------------|------------|
| Secure or Non-secure EL1 | x           |          0 | Little-endian                          |          0 |

| Exception mode   | HSCTLR.EE   | SCTLR.EE   | Endianness for data loads and stores   |   PSTATE.E |
|------------------|-------------|------------|----------------------------------------|------------|
|                  |             | 1          | Big-endian                             |          1 |
| Hyp              | 0           | x          | Little-endian                          |          0 |
|                  | 1           | x          | Big-endian                             |          1 |

For more information, see the bit description in Saved Program Status Registers (SPSRs).

## G1.13.5.3 PSTATE.{A, I, F, M} values on exception entry

On exception entry, PSTATE.M is set to the value for the mode to which the exception is taken, as described in PE mode for taking exceptions.

Table G1-13 shows the cases where PSTATE.{A, I, F} bits are set to 1 on an exception entry, and how this depends on the mode and Security state to which an exception is taken. If the table entry for a particular mode and Security state does not define a value for a PSTATE.{A, I, F} bit then that bit is unchanged by the exception entry. In this table:

- The PE mode exception is taken to column is the mode to which the exception is taken.
- The Non-secure column applies to exceptions taken to Non-secure state in an implementation that includes EL3 but does not include EL2.
- The Secure column applies to:
- -Exceptions taken to Secure state.
- -Implementations that do not include the EL3.
- -Exceptions taken to Non-secure state in an implementation that includes EL2.

Table G1-13 PSTATE.{A, I, F} values on exception entry

| PE mode exception is taken to   | Security state Non-secure                                                                                              | Secure                                                         |
|---------------------------------|------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------|
| Hyp                             | If SCR.EA==0 then PSTATE.A is set to 1 If SCR.IRQ==0 then PSTATE.I is set to 1 If SCR.FIQ==0 then PSTATE.F is set to 1 | -                                                              |
| Monitor                         | -                                                                                                                      | PSTATE.A is set to 1 PSTATE.I is set to 1 PSTATE.F is set to 1 |
| FIQ                             | PSTATE.A is set to 1 PSTATE.I is set to 1 PSTATE.F is set to 1                                                         | PSTATE.A is set to 1 PSTATE.I is set to 1 PSTATE.F is set to 1 |
| IRQ, Abort                      | PSTATE.A is set to 1 PSTATE.I is set to 1                                                                              | PSTATE.A is set to 1 PSTATE.I is set to 1                      |
| Undefined, Supervisor           | PSTATE.I is set to 1                                                                                                   | PSTATE.I is set to 1                                           |

Asynchronous exception behavior for exceptions taken from AArch32 state describes how, in some situations, the PSTATE.{A, I, F} bits mask the taking of SError exceptions, IRQ interrupts, and FIQ interrupts.

## G1.13.6 Routing exceptions from Non-secure EL0 to EL2

Note

The routing control described in this section permits a Non-secure state usage model where applications execute in User mode under a hypervisor, which executes in Hyp mode, without a Guest OS running at Non-secure EL1. This control applies when the PE is executing in Non-secure EL0 using AArch32 and EL2 is using AArch32 and the value of HCR.TGE is 1.

If the PE is in Non-secure User mode, any exception that would otherwise be taken to Non-secure EL1 is taken to EL2 if either:

- EL2 is using AArch32 and the value of HCR.TGE is 1. In this case the exception is taken to Hyp mode, instead of to the default Non-secure mode for handling the exception. For more information, see Exception reporting when HCR.TGE routes an exception to EL2 using AArch32.
- EL2 is using AArch64 and the value of HCR\_EL2.TGE is 1. In this case the exception is taken to EL2 using AArch64, see Exception entry.

Any exception that is routed to Secure Monitor mode or to EL3 using AArch64 is unaffected by the value of HCR.TGE or HCR\_EL2.TGE.

When the value of HCR.TGE is 1, meaning TGE routing from Non-secure EL0 using AArch32 to EL2 using AArch32 applies:

- The SCTLR.M bit is treated as 0 for all purposes other than a direct read of the SCTLR register.
- Each of the HCR.{FMO, IMO, AMO} bits is treated as 1 for all purposes other than a direct read of the HCR register.
- Each of the HDCR.{TDE, TDA, TDRA, TDOSA} bits is treated as 1 for all purposes other than a direct read of the HDCR register.
- An exception return to Non-secure EL1 is treated as an illegal exception return, see Illegal return events from AArch32 state.
- All virtual interrupts, including any IMPLEMENTATION DEFINED mechanisms for signaling virtual interrupts, are disabled.

## G1.13.6.1 Exception reporting when HCR.TGE routes an exception to EL2 using AArch32

The following sections give more information about the behavior of synchronous exceptions that are routed to Hyp mode because the value of HCR.TGE is 1:

- Undefined Instruction exception, when the value of HCR.TGE is 1.
- Supervisor Call exception, when the value of HCR.TGE is 1.
- Abort exceptions, when the value of HCR.TGE is 1.
- Reporting of exceptions routed to EL2 using AArch32 because the value of HCR.TGE is 1.

## G1.13.6.1.1 Undefined Instruction exception, when the value of HCR.TGE is 1

When HCR.TGE is set to 1, if the PE is executing in Non-secure User mode and attempts to execute an UNDEFINED instruction, it takes the Hyp Trap exception, instead of an Undefined Instruction exception. On taking the Hyp Trap exception, the HSR reports an unknown reason for the exception, using the EC value 0x00 . For more information, see Use of the HSR.

## G1.13.6.1.2 Supervisor Call exception, when the value of HCR.TGE is 1

When HCR.TGE is set to 1, if the PE executes an SVC instruction in Non-secure User mode, the Supervisor Call exception generated by the instruction is taken to Hyp mode.

The HSR reports that entry to Hyp mode was because of a Supervisor Call exception, and:

- If the SVC is unconditional, takes for the imm16 value in the HSR:

- Azero-extended 8-bit immediate value for the T32 SVC instruction.

Note

The only T32 encoding for SVC is a 16-bit instruction encoding.

- The bottom16 bits of the immediate value for the A32 SVC instruction.

- If the SVC is conditional, the imm16 value in the HSR is UNKNOWN.

If the SVC is conditional, the PE takes the exception only if the instruction passes its Condition code check.

The HSR reports the exception as a Supervisor Call exception taken to Hyp mode, using the EC value 0x11 . For more information, see Use of the HSR.

Note

The effect of setting HCR.TGE to 1 is to route the Supervisor Call exception to Hyp mode, not to trap the execution of the SVC instruction. This means that the preferred return address for the exception, when routed to Hyp mode in this way, is the instruction after the SVC instruction.

## G1.13.6.1.3 Abort exceptions, when the value of HCR.TGE is 1

When the value of HCR.TGE is 1, if the PE is executing in Non-secure User mode then any abort exception that is not routed to Secure Monitor mode or to EL3 using AArch64 generates an exception that is taken as a Hyp Trap exception. Where an attempt to execute an instruction causes an abort, on taking the Hyp Trap exception, the HSR indicates whether a Data Abort exception or a Prefetch Abort exception caused the Hyp Trap exception entry, and presents a valid syndrome in the HSR.

When SCR.EA is set to 1, External aborts and SError exceptions are routed to EL3, and this routing takes priority over the HCR.TGE routing. For more information, see Routing of aborts taken to AArch32 state.

An SError exception that is routed to Hyp mode because the value of HCR.TGE is 1 is reported as a Data Abort exception routed to Hyp mode.

The HSR reports the exception either:

- As a Prefetch Abort exception routed to Hyp mode, using the EC value 0x20 .
- As a Data Abort exception routed to Hyp mode, using the EC value 0x24 .

For more information about the exception reporting, see Use of the HSR.

## G1.13.6.1.4 Reporting of exceptions routed to EL2 using AArch32 because the value of HCR.TGE is 1

PL1 configurable controls describes controls that, when the value of HCR.TGE is 0, can generate exceptions that are taken from Non-secure EL0 to EL1. When EL2 is using AArch32 and the value of HCR.TGE is 1, the exceptions generated by these controls are routed to Hyp mode. Table G1-14 shows how these exceptions are then reported in the HSR.

Table G1-14 Syndrome reporting in HSR from HCR.TGE routing of traps, disables, and enables

| Control provided by PL1                        | Control type a   | Syndrome reporting in HSR                                     |
|------------------------------------------------|------------------|---------------------------------------------------------------|
| SCTLR.{nTWE, nTWI}                             | T                | Uses EC syndrome value 0x00 , Exception for an unknown reason |
| SCTLR.{SED, ITD}                               | D                | Uses EC syndrome value 0x00 , Exception for an unknown reason |
| SCTLR.CP15BEN                                  | E                | Uses EC syndrome value 0x00 , Exception for an unknown reason |
| CPACR.TRCDIS                                   | T                | Uses EC syndrome value 0x00 , Exception for an unknown reason |
| CPACR.{cp11, cp10}                             | E                | Uses EC syndrome value 0x00 , Exception for an unknown reason |
| FPEXC.EN                                       | E                | Uses EC syndrome value 0x00 , Exception for an unknown reason |
| CPACR.ASEDIS                                   | D                | Uses EC syndrome value 0x00 , Exception for an unknown reason |
| DBGDSCRext.UDCCdis                             | T                | Uses EC syndrome value 0x00 , Exception for an unknown reason |
| CNTKCTL.{PL0PTEN, PL0VTEN, PL0PCTEN, PL0VCTEN} | T                | Uses EC syndrome value 0x00 , Exception for an unknown reason |
| PMUSERENR.{ER, CR, SW, EN}                     | T                | Uses EC syndrome value 0x00 , Exception for an unknown reason |

## G1.13.7 Routing debug exceptions to EL2 using AArch32

When the value of HDCR.TDE is 1, if the PE is executing in a Non-secure mode other than Hyp mode, any Debug exception is routed to Hyp mode. This means it generates a Hyp Trap exception. This applies to:

- Debug exceptions associated with an instruction fetch, that would otherwise generate a Prefetch Abort exception. These are the Breakpoint, Breakpoint Instruction, and Vector Catch exception, see AArch32 Self-hosted Debug.
- Watchpoint exceptions associated with data accesses, that would otherwise generate a Data Abort exception. See Watchpoint exceptions.

When the value of HDCR.TDE is 1, each of the HDCR.{TDRA, TDOSA, TDA} bits is treated as 1 for all purposes other than reading the HDCR register.

## Note

- ABreakpoint or Watchpoint debug event that generates entry to Debug state cannot be trapped to Hyp mode. See Breakpoint and Watchpoint debug events.
- WhenHDCR.TDEisset to 1, the Hyp Trap exception is generated instead of the Prefetch Abort exception or Data Abort exception that is otherwise generated by the Debug exception.
- Debug exceptions, other than Breakpoint Instruction exceptions, are never generated in Hyp mode.

When a Hyp Trap exception is generated because the value of HDCR.TDE is 1, The HSR reports the exception either:

- As a Prefetch Abort exception routed to Hyp mode, using the EC value 0x20 .
- As a Data Abort exception routed to Hyp mode, using the EC value 0x24 .

For more information, see Use of the HSR.