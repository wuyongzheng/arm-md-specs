## C9.2.40 BFMOP4A (non-widening)

BFloat16 quarter-tile outer product, accumulating

This instruction generates four independent quarter-tile BFloat16 outer products from the sub-matrices in the half-vectors of the one or two first and second source vectors and accumulates the results to the corresponding elements of a 16-bit element ZA tile.

Each of the quarter-tile outer products is generated by multiplying the SVLH÷2 × 1 sub-matrix of BFloat16 values held in the half-vectors of the first source vectors by the 1 × SVLH÷2 sub-matrix of BFloat16 values held in the half-vectors of the second source vectors.

The resulting quarter-tile SVLH÷2 × SVLH÷2 BFloat16 outer products are destructively added to the destination ZA tile. This is equivalent to performing a single multiply-accumulate to each of the destination tile elements.

This instruction follows SME2 ZA-targeting non-widening BFloat16 numerical behaviors.

This instruction is unpredicated.

It has encodings from 4 classes: Single and multiple vectors, Single vectors, Multiple and single vectors, and Multiple vectors

## Single and multiple vectors

(FEAT\_SME\_MOP4 &amp;&amp; FEAT\_SME\_B16B16)

<!-- image -->

## Encoding

```
BFMOP4A <ZAda>.H, <Zn>.H, { <Zm1>.H-<Zm2>.H }
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) || !IsFeatureImplemented(FEAT_SME_B16B16) then EndOfDecode(Decode_UNDEF); constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 1; constant integer mreg = 2; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE;
```

## Single vectors

(FEAT\_SME\_MOP4 &amp;&amp; FEAT\_SME\_B16B16)

<!-- image -->

## Encoding

BFMOP4A

&lt;ZAda&gt;.H,

&lt;Zn&gt;.H,

&lt;Zm&gt;.H

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) || !IsFeatureImplemented(FEAT_SME_B16B16) then EndOfDecode(Decode_UNDEF); constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 1; constant integer mreg = 1; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE;
```

## Multiple and single vectors

(FEAT\_SME\_MOP4 &amp;&amp; FEAT\_SME\_B16B16)

<!-- image -->

## Encoding

```
BFMOP4A <ZAda>.H, { <Zn1>.H-<Zn2>.H }, <Zm>.H
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) || !IsFeatureImplemented(FEAT_SME_B16B16) then EndOfDecode(Decode_UNDEF); constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 2; constant integer mreg = 1; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE;
```

## Multiple vectors

(FEAT\_SME\_MOP4 &amp;&amp; FEAT\_SME\_B16B16)

<!-- image -->

## Encoding

```
BFMOP4A <ZAda>.H, { <Zn1>.H-<Zn2>.H }, { <Zm1>.H-<Zm2>.H }
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME_MOP4) || !IsFeatureImplemented(FEAT_SME_B16B16) then EndOfDecode(Decode_UNDEF); constant integer n = UInt('0':Zn:'0'); constant integer m = UInt('1':Zm:'0'); constant integer nreg = 2; constant integer mreg = 2; constant integer da = UInt(ZAda); constant boolean sub_op = FALSE;
```

## Assembler Symbols

## &lt;ZAda&gt;

Is the name of the ZA tile ZA0-ZA1, encoded in the 'ZAda' field.

## &lt;Zn&gt;

Is the name of the first source scalable vector register, registers in the range Z0-Z15, encoded as 'Zn' times 2.

## &lt;Zm1&gt;

Is the name of the first scalable vector register of the second source multi-vector group, in the range Z16-Z31, encoded as 'Zm' times 2 plus 16.

## &lt;Zm2&gt;

Is the name of the second scalable vector register of the second source multi-vector group, in the range Z16-Z31, encoded as 'Zm' times 2 plus 17.

## &lt;Zm&gt;

Is the name of the second source scalable vector register, registers in the range Z16-Z31, encoded as 'Zm' times 2 plus 16.

## &lt;Zn1&gt;

Is the name of the first scalable vector register of the first source multi-vector group, in the range Z0-Z15, encoded as 'Zn' times 2.

## &lt;Zn2&gt;

Is the name of the second scalable vector register of the first source multi-vector group, in the range Z0-Z15, encoded as 'Zn' times 2 plus 1.

## Operation

```
CheckStreamingSVEAndZAEnabled(); constant integer VL = CurrentVL; constant integer hvsize = VL DIV 2; constant integer dim = hvsize DIV 16; constant integer tilesize = 4*dim*dim*16; constant bits(tilesize) op3 = ZAtile[da, 16, tilesize]; bits(tilesize) result; for outprod = 0 to 3 constant integer row_hv = outprod DIV 2; constant integer col_hv = outprod MOD 2; constant integer row_base = row_hv * dim; constant integer col_base = col_hv * dim; constant bits(VL) op1 = Z[n + (nreg-1)*col_hv, VL]; constant bits(VL) op2 = Z[m + (mreg-1)*row_hv, VL]; for row = 0 to dim-1 for col = 0 to dim-1 constant integer row_idx = row_base + row; constant integer col_idx = col_base + col; constant integer tile_idx = row_idx * dim * 2 + col_idx; bits(16) elem1 = Elem[op1, row_idx, 16]; constant bits(16) elem2 = Elem[op2, col_idx, 16]; constant bits(16) elem3 = Elem[op3, tile_idx, 16]; if sub_op then constant boolean honor_altfp = FALSE; // Alternate handling elem1 = BFNeg(elem1, honor_altfp);
```

ignored

```
Elem[result, tile_idx, 16] = BFMulAdd_ZA(elem3, elem1, elem2, FPCR); ZAtile[da, 16, tilesize] = result;
```