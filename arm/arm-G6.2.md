## G6.2 The AArch32 view of the Generic Timer

The following sections describe the components and features of a PE implementation of the Generic Timer, as seen from AArch32 state:

- The physical counter.
- The virtual counter.
- Event streams.
- Timers.

## G6.2.1 The physical counter

The PE includes a physical counter that contains the count value of the system counter. The CNTPCT register holds the current physical counter value. When FEAT\_ECV is implemented and EL2 is executing in AArch64 state, the CNTPOFF\_EL2 register holds the optional physical offset that can be applied to EL0 and EL1 whether EL0 and EL1 are using AArch64 state or AArch32 state. For more information, see The physical offset register.

Reads of CNTPCT can occur speculatively and out of order relative to other instructions executed on the same PE.

## G6.2.1.1 The self-synchronized view of the physical counter

When FEAT\_ECV is implemented, an alternative way to read the physical counter is supported. The CNTPCTSS register is a non-speculative view of the physical counter, as seen from the Exception level that CNTPCTSS is read from.

Access to the CNTPCTSS are subject to the same traps as accesses to the CNTPCT.

Reads of CNTPCT occur in program order relative to reads of CNTPCT or CNTPCTSS.

Reads of CNTPCTSS occur in program order relative to reads of CNTPCT or CNTPCTSS.

Example G6-1 Ensuring reads of the physical counter occur after signal read from memory

If a read from memory is used to obtain a signal from another agent that indicates that CNTPCT must be read, an ISB is used to ensure that the read of CNTPCT occurs after the signal has been read from memory, as shown in the following code sequence:

```
loop ; polling for some communication to indicate a requirement to ; read the timer LDR R1, [R2] CMP R1, #1 ; has had the value 1 written to it BNE loop ISB ; without this the CNTPCT could be read before the memory location in [R2] MRC R1, CNTPCT
```

When FEAT\_ECV is implemented, an access to CNTPCTSS can be used in place of the CNTPCT which, because it cannot be accessed speculatively, allows the ISB to be removed. This means that the following code sequence can be used:

```
loop ; polling for some communication to indicate a requirement to ; read the timer LDR R1, [R2] CMP R1, #1 ; has had the value 1 written to it BNE loop MRC R1, CNTPCTSS
```

Similarly where a read of the physical counter is required to take place after the completion of all loads and stores appearing in program order before the read of the counter, then the following code sequences can be used:

```
... ; earlier loads and stores DSB ; completes earlier loads and stores ISB ; without this the CNTPCT could be read before the completion ; of the earlier loads and stores MRC R1, CNTPCT
```

## Or, if FEAT\_ECV is implemented:

```
... ; earlier loads and stores DSB ; completes earlier loads and stores MRC R1, CNTPCTSS
```

Neither view of the physical counter ensures that:

- Context changes occurring in program order before the read of the counter have been synchronized.
- Accesses to memory appearing in program order after the read of the counter are executed before the counter has been read.

Where there is a Dependency through registers and memory dependency from the read of the physical counter to a Register effect generated by a read or write, the read or write will be executed after the read of the counter.

Example G6-2 Ensuring reads of the physical counter occur after previous memory accesses

To ensure that all previous memory accesses have completed and all previous context changes have been synchronized before the read of the counter, one of the following sequences should be used:

```
DSB ISB MRC Rn, CNTPCT{SS} ; either view of the physical counter has the same effect in ; this example
```

## or

```
DSB ISB CBZ Ra, next next ISB ; this ISB is not needed if the MRC is accessing CNTPCT{SS} MRC Rn, CNTPCT{SS}
```

To ensure that a memory access occurs only after a read of the counter, then either of the following sequences should be used:

```
MRC Rn, CNTPCT{SS} ; either view of the physical counter has the same effect ; in this example ISB LDR Ra, [Rb] ; this load will be executed after the timer has been read
```

## or

```
MRC Rn, CNTPCT{SS} ; either view of the physical counter has the same effect ; in this example EOR Rm, Rn, Rn LDR Ra, [Rb] ; this load will be executed after the counter has been read
```

## G6.2.2 The virtual counter

An implementation of the Generic Timer always includes a virtual counter, that indicates virtual time.

The virtual counter contains the value of the physical counter minus a 64-bit virtual offset. When executing in a Non-secure EL1 or EL0 mode, the virtual offset value relates to the current virtual machine.

The CNTVOFF register contains the virtual offset, see The virtual offset register.

The CNTVCT register holds the current virtual counter value.

Reads of CNTVCT can occur speculatively and out of order relative to other instructions executed on the same PE.

## G6.2.2.1 The self-synchronized view of the virtual counter

When FEAT\_ECV is implemented, an alternative way to read the virtual counter is supported. The CNTVCTSS register is a non-speculative view of the virtual counter, as seen from the Exception level that CNTVCTSS is read from.

Accesses to the CNTVCTSS are subject to the same traps as accesses to the CNTVCT.

Reads of CNTVCT occur in program order relative to reads of CNTVCT or CNTVCTSS.

Reads of CNTVCTSS occur in program order relative to reads of CNTVCT or CNTVCTSS.

Example G6-3 Ensuring reads of virtual counter occur after signal read from memory

If a read from memory is used to obtain a signal from another agent that indicates that CNTVCT must be read, an ISB is used to ensure that the read of CNTVCT occurs after the signal has been read from memory, as shown in the following code sequence:

```
loop ; polling for some communication to indicate a requirement to ; read the timer LDR R1, [R2] CMP R1, #1 ; has had the value 1 written to it BNE loop ISB ; without this the CNTVCT could be read before the memory ; location in [R2] MRC R1, CNTVCT
```

WhenFEAT\_ECVisimplemented, an access to CNTVCTSS can be used in place of the CNTVCT, which, because it cannot be accessed speculatively, allows the ISB to be removed. This means that the following code sequence can be used:

```
loop ; polling for some communication to indicate a requirement to ; read the timer LDR R1, [R2] CMP R1, #1 ; has had the value 1 written to it BNE loop MRC R1, CNTVCTSS
```

Similarly where a read of the virtual counter is required to take place after the completion of all loads and stores appearing in program order before the read of the counter, then the following two sequences can be used:

```
... ; earlier loads and stores DSB ; completes earlier loads and stores ISB ; without this the CNTVCT could be read before the completion ; of the earlier loads and stores MRC R1, CNTVCT
```

## Or, if FEAT\_ECV is implemented:

```
... ; earlier loads and stores DSB ; completes earlier loads and stores MRC R1, CNTVCTSS
```

Neither view of the virtual counter ensures that:

- Context changes occurring in program order before the read of the counter have been synchronized.
- Accesses to memory appearing in program order after the read of the counter are executed before the counter has been read.

Where there is a Dependency through registers and memory dependency from the read of the virtual counter to a Register effect generated by a read or write, the read or write will be executed after the read of the counter.

Example G6-4 Ensuring reads of virtual counter occur after previous memory accesses

To ensure that all previous memory accesses have completed and all previous context changes have been synchronized before the read of the counter, one of the following sequences should be used:

```
DSB ISB MRC Rn, CNTVCT{SS} ; either view of the virtual counter has the same effect in ; this example
```

## or

```
DSB ISB CBZ Ra, next next ISB ; this ISB is not needed if the MRS is accessing CNTVCT{SS} MRC Rn, CNTVCT{SS}
```

To ensure that a memory access occurs only after a read of the counter, then either of the following sequences should be used:

```
MRC Rn, CNTVCT{SS} ; either view of the virtual counter has the same effect in ; this example ISB LDR Ra, [Rb] ; this load will be executed after the timer has been read
```

```
or MRC Rn, CNTVCT{SS} ; either view of the virtual counter has the same effect in ; this example EOR Rm, Rn, Rn LDR Ra, [Rb] ; this load will be executed after the counter has been read
```

## G6.2.2.2 The virtual offset register

The virtual counter is a counter that has a virtual offset relative to the physical counter as viewed from EL2 and EL3. This virtual offset is held in the register CNTVOFF. The virtual counter value is the count compared by the EL1 virtual timer.

If EL2 is not implemented and enabled, then the virtual counter uses a fixed virtual offset of zero.

## G6.2.3 Event streams

An implementation that includes the Generic Timer can use the system counter to generate one or more event streams , to generate periodic wakeup events as part of the mechanism described in Wait for Event.

Note

An event stream might be used:

- To impose a time-out on a Wait For Event polling loop.
- To safeguard against any programming error that means an expected event is not generated.

The CNTKCTL.{EVNTEN, EVNTDIR, EVNTI, EVNTIS} fields define an event stream that is generated from the virtual counter.

In all implementations the CNTHCTL.{EVNTEN, EVNTDIR, EVNTI, EVNTIS} fields define an event stream that is generated from the physical counter.

The event stream is configured as follows:

- EVNTI selects the counter bit that triggers the event.

## G6.2.4 Timers

- If FEAT\_ECV is not implemented, EVNTI selects between bits[0:15].
- If FEAT\_ECV is implemented, EVNTIS selects whether ENVTI selects between bits[0:15] or bits[8:23].
- EVNTDIR selects whether the event is generated on each 0 to 1 transition, or each 1 to 0 transition, of the selected counter bit.

Note

If the event stream is configured to produce events from the low order bits of the counter when the effective frequency is very high (for example 1GHz), then the practical update rate of the counter might mean that the event stream is not generated as the low order bit might not change. Software can rely on an event stream rate of at least 1MHz in normal operation.

The pseudocode descriptions of the operation of an event stream are SetEventRegister , TestEventCNTV , and TestEventCNTP .

In an implementation of the Generic Timer that includes EL3 the following timers are accessible from AArch32 state, provided the appropriate Exception level can use AArch32:

- ANon-secure EL1 physical timer. A Non-secure EL1 control determines whether this register is accessible from Non-secure EL0.
- ASecure PL1 physical timer. This timer is accessible from EL3 when EL3 is using AArch32.

Note

When EL3 is using AArch64, the AArch32 EL1 timers are not banked between Secure and Non-secure state.

ASecure PL1 control determines whether this register is accessible from Secure EL0.

- ANon-secure EL2 physical timer, accessible from Non-secure EL2, or EL3 when SCR.NS is set to 1.
- An EL1 virtual timer.
- When FEAT\_VHE is implemented, a Non-secure EL2 virtual timer.
- When FEAT\_SEL2 is implemented, a Secure EL2 physical timer.
- When FEAT\_SEL2 is implemented, a Secure EL2 virtual timer.

Note

The Secure EL2 timers are accessible in AArch32 state if using EL0, when EL0 is using AArch32 state, Secure EL2 is using AArch64, and the Effective value of HCR\_EL2.{E2H,TGE} is {1, 1}.

The output of each implemented timer:

- Provides an output signal to the system.
- If the PE interfaces to a Generic Interrupt Controller (GIC), signals a Private Peripheral Interrupt (PPI) to that GIC. In a multiprocessor implementation, each PE must use the same interrupt number for each timer.

## Each timer:

- Is based around a 64-bit CompareValue that provides a 64-bit unsigned upcounter.
- Provides an alternative view of the CompareValue, called the TimerValue, that appears to operate as a 32-bit downcounter.
- Has, in addition, a 32-bit Control register.

In all implementations, the AArch32 System registers for the EL1 (or PL1) physical timer are banked, to provide the Secure and Non-secure implementations of the timer. Table G6-1 shows the physical timer registers and Table G6-2 show the virtual timer registers.

Table G6-1 Physical timer registers summary for the Generic Timer

| Timer register a   | Secure PL1 or Non-secure EL1 physical timer   | Non-secure EL2 physical timer   | Secure EL2 physical timer b   |
|--------------------|-----------------------------------------------|---------------------------------|-------------------------------|
| CV                 | CNTP_CVAL c                                   | CNTHP_CVAL                      | CNTHPS_CVAL                   |
| TV                 | CNTP_TVAL c                                   | CNTHP_TVAL                      | CNTHPS_TVAL                   |
| Control            | CNTP_CTL c                                    | CNTHP_CTL                       | CNTHPS_CTL                    |

- c. In AArch32 state, these registers are banked to provide the Non-secure EL1 physical timer and the Secure PL1 physical timer.

Table G6-2 Virtual timer register summary for the Generic Timer

| Timer register a   | EL1 virtual timer   | Non-secure EL2 virtual timer b   | Secure EL2 virtual timer c   |
|--------------------|---------------------|----------------------------------|------------------------------|
| CV                 | CNTV_CVAL           | CNTHV_CVAL                       | CNTHVS_CVAL                  |
| TV                 | CNTV_TVAL           | CNTHV_TVAL                       | CNTHVS_TVAL                  |
| Control            | CNTV_CTL            | CNTHV_CTL                        | CNTHVS_CTL                   |

## G6.2.4.1 Operation of the CompareValue views of the timers

The CompareValue view of a timer operates as a 64-bit upcounter. The timer condition is met when the appropriate counter reaches the value programmed into its CompareValue register. When the timer condition is met an interrupt is generated if the interrupt is not masked in the corresponding timer control register, CNTP\_CTL, CNTHP\_CTL, CNTHPS\_CTL, CNTV\_CTL, CNTHV\_CTL, or CNTHVS\_CTL. For CNTP\_CTL, the interrupt is the same as the interrupt asserted by the Non-secure instance of the AArch64 register CNTP\_CTL\_EL0.

The operation of this view of a timer is:

```
TimerConditionMet = (((Counter[63:0] Offset[63:0])[63:0] CompareValue[63:0]) >= 0)
```

## Where:

TimerConditionMet Is TRUE if the timer condition for this counter is met, and FALSE otherwise.

Counter

The physical counter value, that can be read from the CNTPCT register.

Offset

For the EL1 physical timer, if ID\_AA64MMFR0\_EL1.ECV is 0b10 , EL2 is using AArch64 and is implemented and enabled in the current Security state, and CNTHCTL\_EL2.ECV is 1, then the offset value is held in the CNTPOFF\_EL2. Otherwise the offset value for the EL1 physical timer is zero.

For the EL1 virtual timer, the offset value is held in the CNTVOFF register.

For the EL2 physical and virtual timers, the offset value is zero.

CompareValue The value of the appropriate CompareValue register, CNTP\_CVAL, CNTHP\_CVAL, CNTHPS\_CVAL, CNTV\_CVAL, CNTHV\_CVAL, or CNTHVS\_CVAL.

In this view of a timer, Counter , Offset , and CompareValue are all 64-bit unsigned values.

Note

This means that a timer with a CompareValue of, or close to, 0xFFFF\_FFFF\_FFFF\_FFFF might never meet its timer condition. However, there is no practical requirement to use values close to the counter wrap value. Software can observe the counter value by the offset in some situations by reading CNTVCT.

## G6.2.4.2 Operation of the TimerValue views of the timers

The TimerValue view of a timer appears to operate as a signed 32-bit downcounter. A TimerValue register is programmed with a count value. This value decrements on each increment of the appropriate counter, and the timer condition is met when the value reaches zero. When the timer condition is met, an interrupt is generated if the interrupt is not masked in the corresponding timer control register, CNTP\_CTL, CNTHP\_CTL, CNTHPS\_CTL, CNTV\_CTL, CNTHV\_CTL, or CNTHVS\_CTL.

This view of a timer depends on the following behavior of accesses to TimerValue registers:

Reads

Writes

CompareValue = ((Counter - Offset)[63:0] + SignExtend(TimerValue))[63:0]

Where the arguments other than TimerValue have the definitions used in Operation of the CompareValue views of the timers, and in addition:

TimerValue

The value of a TimerValue register, CNTP\_TVAL, CNTHP\_TVAL, CNTHPS\_TVAL, CNTV\_TVAL, CNTHV\_TVAL, or CNTHVS\_TVAL.

In this view of a timer, values are signed, in standard two's complement form.

Aread of a TimerValue register after the timer condition has been met indicates the time since the timer condition was met.

## Note

- Operation of the CompareValue views of the timers gives a strict definition of TimerConditionMet . However, provided that the TimerValue is not expected to wrap as a 32-bit signed value when decremented from 0x80000000 , the TimerValue view can be used as giving an effect equivalent to:
- Programming TimerValue to a negative number with magnitude greater than (Counter - Offset) can lead to an arithmetic overflow that causes the CompareValue to be an extremely large positive value. This potentially delays meeting the timer condition for an extremely long period of time.

```
TimerConditionMet = (TimerValue ≤ 0)
```

TimerValue = (CompareValue - (Counter Offset))[31:0]

## Chapter G7 AArch32 System Register Encoding

This chapter describes the AArch32 System register encoding space. It contains the following sections:

- The AArch32 System register encoding space.
- Organization of registers in the ( coproc == 0b1110 ) encoding space.
- Organization of registers in the ( coproc == 0b1111 ) encoding space.