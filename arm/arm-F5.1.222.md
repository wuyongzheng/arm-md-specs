## F5.1.222 STLEXD

Store-Release Exclusive Doubleword stores a doubleword from two registers to memory if the executing PE has exclusive access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.

The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release.

For more information about support for shared memory see Synchronization and semaphores. For information about memory accesses see Memory accesses.

It has encodings from the following instruction sets: A32 (A1) and T32 (T1).

A1

<!-- image -->

## Encoding

```
STLEXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]
```

## Decode for this encoding

```
constant integer t = UInt(Rt); constant integer t2 = t + 1; constant integer d = UInt(Rd); constant integer n = UInt(Rn); if d == 15 || Rt<0> == '1' || t2 == 15 || n == 15 then if d == n || d == t || d == t2 then UNPREDICTABLE;
```

## CONSTRAINED UNPREDICTABLE behavior

If d == t , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The store instruction executes but the value stored is UNKNOWN.

If d == n , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The instruction performs the store to an UNKNOWN address.

If Rt&lt;0&gt; == '1' , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The instruction executes with the additional decode: Rt&lt;0&gt; = '0'.
- The instruction executes with the additional decode: t2 = t.
- The instruction executes as described, with no change to its behavior and no additional side effects.

If Rt == '1110' , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The instruction is handled as described in Using R15.

```
UNPREDICTABLE;
```

T1

<!-- image -->

## Encoding

```
STLEXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]
```

## Decode for this encoding

```
constant integer d = UInt(Rd); constant integer t = UInt(Rt); constant integer t2 = UInt(Rt2); constant integer n = UInt(Rn); if d == 15 || t == 15 || t2 == 15 || n == 15 then if d == n || d == t || d == t2 then UNPREDICTABLE;
```

```
UNPREDICTABLE;
```

## CONSTRAINED UNPREDICTABLE behavior

If d == t , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The store instruction executes but the value stored is UNKNOWN.

If d == n , then one of the following behaviors must occur:

- The instruction is UNDEFINED.
- The instruction executes as NOP .
- The instruction performs the store to an UNKNOWN address.

For more information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Architectural Constraints on UNPREDICTABLE behaviors.

## Assembler Symbols

&lt;c&gt;

See Standard assembler syntax fields.

See Standard assembler syntax fields.

Is the destination general-purpose register into which the status result of the store exclusive is written, encoded in the 'Rd' field. The value returned is:

- 0 If the operation updates memory.
- 1 If the operation fails to update memory.

For the 'A1' variant: is the first general-purpose register to be transferred, encoded in the 'Rt' field. &lt;Rt&gt; must be even-numbered and not R14.

For the 'T1' variant: is the first general-purpose register to be transferred, encoded in the 'Rt' field.

&lt;q&gt;

## &lt;Rd&gt;

&lt;Rt&gt;

## &lt;Rt2&gt;

For the 'A1' variant: is the second general-purpose register to be transferred. &lt;Rt2&gt; must be &lt;R(t+1)&gt; .

For the 'T1' variant: is the second general-purpose register to be transferred, encoded in the 'Rt2' field.

Is the general-purpose base register, encoded in the 'Rn' field.

Aborts and alignment

If a synchronous Data Abort exception is generated by the execution of this instruction:

- Memory is not updated.
- &lt;Rd&gt; is not updated.

Anon word-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject to the following rules:

- If AArch32.ExclusiveMonitorsPass() returns TRUE , the exception is generated.
- Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch32.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

## Operation

```
if ConditionPassed() then EncodingSpecificOperations(); constant bits(32) address = R[n]; // Create doubleword to store such that R[t] will be stored at address and R[t2] at address+4. constant bits(64) value = if BigEndian(AccessType_GPR) then R[t]:R[t2] else R[t2]:R[t]; if AArch32.ExclusiveMonitorsPass(address, 8) then MemO[address, 8] = value; R[d] = ZeroExtend('0', 32); else R[d] = ZeroExtend('1', 32);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About the DIT bit.

## &lt;Rn&gt;