## G8.2.54 FPEXC, Floating-Point Exception Control register

The FPEXC characteristics are:

## Purpose

Provides a global enable for the implemented Advanced SIMD and floating-point functionality, and reports floating-point status information.

## Configuration

Implemented only if the implementation includes the Advanced SIMD and floating-point functionality.

AArch32 System register FPEXC bits [31:0] are architecturally mapped to AArch64 System register FPEXC32\_EL2[31:0].

This register is present only when FEAT\_AA32EL1 is implemented. Otherwise, direct accesses to FPEXC are UNDEFINED.

## Attributes

FPEXC is a 32-bit register.

## Field descriptions

<!-- image -->

## EX, bit [31]

Exception bit.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

Access to this field is RAZ/WI.

## EN, bit [30]

Enables access to the Advanced SIMD and floating-point functionality from all Exception levels, except that setting this field to 0 does not disable the following:

- VMSRaccesses to the FPEXC or FPSID.
- VMRSaccesses from the FPEXC, FPSID, MVFR0, MVFR1, or MVFR2.

| EN   | Meaning                                                                                                                                                                               |
|------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b0  | Accesses to the FPSCR, and any of the SIMD and floating-point registers Q0-Q15, including their views as D0-D31 registers or S0-S31 registers, are UNDEFINED at all Exception levels. |
| 0b1  | This control permits access to the Advanced SIMD and floating-point functionality at all Exception levels.                                                                            |

Execution of Advanced SIMD and floating-point instructions in AArch32 state can be disabled or trapped by the following controls:

- CPACR.cp10, or, if executing at EL0, CPACR\_EL1.FPEN.
- FPEXC.EN.
- If executing in Non-secure state:
- HCPTR.TCP10, or if EL2 is using AArch64, CPTR\_EL2.TFP.
- NSACR.cp10, or if EL3 is using AArch64, CPTR\_EL3.TFP.
- For Advanced SIMD instructions only:
- CPACR.ASEDIS.
- If executing in Non-secure state, HCPTR.TASE and NSACR.NSASEDIS.

See the descriptions of the controls for more information.

Note

When executing at EL0 using AArch32:

- If EL1 is using AArch64, then the Effective value of FPEXC.EN is 1. This includes when EL2 is using AArch64 and is enabled in the current Security state, HCR\_EL2.TGE is 1, and the Effective value of HCR\_EL2.RW is 1.
- If EL2 is using AArch64 and is enabled in the current Security state, HCR\_EL2.TGE is 1, and the Effective value of HCR\_EL2.RW is 0, then it is IMPLEMENTATION DEFINED whether the Effective value of FPEXC.EN is 1 or the value written to FPEXC.EN. However, Arm deprecates using the value of FPEXC.EN to determine behavior.

The reset behavior of this field is:

- On a Warm reset, this field resets to '0' .

## DEX, bit [29]

Defined synchronous exception on floating-point execution.

This field identifies whether a synchronous exception generated by the attempted execution of an instruction was generated by an unallocated encoding. The instruction must be in the encoding space that is identified by the pseudocode function ExecutingCP10or11Instr() returning TRUE. This field also indicates whether the FPEXC.TFV field is valid.

The meaning of this bit is:

| DEX   | Meaning                                                                                                                                                                                                                                                                                                               |
|-------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b0   | The exception was generated by the attempted execution of an unallocated instruction in the encoding space that is identified by the pseudocode function ExecutingCP10or11Instr(). If FPEXC.TFV is RWthen it is invalid and UNKNOWN. If FPEXC.{IDF, IXF, UFF, OFF, DZF, IOF} are RWthen they are invalid and UNKNOWN. |
| 0b1   | The exception was generated during the execution of an allocated encoding. FPEXC.TFV is valid and indicates the cause of the exception.                                                                                                                                                                               |

On an exception that sets this bit to 1 the exception-handling routine must clear this bit to 0.

On an implementation that both does not support trapping of floating-point exceptions and implements the FPSCR.{Stride, Len} fields as RAZ, this bit is RES0.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

## FP2V, bit [28]

FPINST2 instruction Valid bit. From Armv8.0, this bit is RES0.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

Access to this field is RES0.

## VV, bit [27]

VECITR Valid bit. From Armv8.0, this bit is RES0.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

Access to this field is RES0.

## TFV, bit [26]

Trapped Fault Valid bit. Valid only when the value of FPEXC.DEX is 1. When valid, it indicates the cause of the exception and therefore whether FPEXC.{IDF, IXF, UFF, OFF, DZF, IOF} are valid.

| TFV   | Meaning                                                                                                                                                                                                                                                                                                                      |
|-------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b0   | The exception was caused by the execution of a floating-point VABS, VADD, VDIV, VFMA, VFMS, VFNMA, VFNMS, VMLA, VMLS, VMOV, VMUL, VNEG, VNMLA, VNMLS, VNMUL, VSQRT, or VSUBinstruction when one or both of FPSCR.{Stride, Len} was nonzero. If FPEXC.{IDF, IXF, UFF, OFF, DZF, IOF} are RWthen they are invalid and UNKNOWN. |
| 0b1   | FPEXC.{IDF, IXF, UFF, OFF, DZF, IOF} indicate the presence of trapped floating-point exceptions that had occurred at the time of the exception. Bits are set for all trapped exceptions that had occurred at the time of the exception.                                                                                      |

This bit returns a status value and ignores writes.

When the value of FPEXC.DEX is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

Accessing this field has the following behavior:

- When an implementation does not implement trapping of floating-point exceptions, access to this field is RAZ/WI.
- When an implementation implements FPSCR.LEN,STRIDE as RAZ, access to this field is RAO/WI.

## Bits [25:11]

Reserved, RES0.

## VECITR, bits [10:8]

Vector Iteration count. From Armv8.0, this field is RES1.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

Access to this field is RES1.

## IDF, bit [7]

Input Denormal trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Input Denormal exception occurred while FPSCR.IDE was 1:

| IDF   | Meaning                                    |
|-------|--------------------------------------------|
| 0b0   | Input Denormal exception has not occurred. |
| 0b1   | Input Denormal exception has occurred.     |

Input Denormal exceptions can occur only when FPSCR.FZ is 1.

Note

Ahalf-precision floating-point value that is flushed to zero because the value of FPSCR.FZ16 is 1 does not generate an Input Denormal exception.

This bit must be cleared to 0 by the exception-handling routine.

When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

When an implementation does not implement trapping of Input Denormal floating-point exceptions, access to this field is RAZ/WI.

## Bits [6:5]

Reserved, RES0.

## IXF, bit [4]

Inexact trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Inexact exception occurred while FPSCR.IXE was 1:

| IXF   | Meaning                             |
|-------|-------------------------------------|
| 0b0   | Inexact exception has not occurred. |
| 0b1   | Inexact exception has occurred.     |

This bit must be cleared to 0 by the exception-handling routine.

When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

When an implementation does not implement trapping of Inexact floating-point exceptions, access to this field is RAZ/WI.

## UFF, bit [3]

Underflow trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Underflow exception occurred while FPSCR.UFE was 1:

| UFF   | Meaning                               |
|-------|---------------------------------------|
| 0b0   | Underflow exception has not occurred. |

Underflow trapped exceptions can occur:

- On half-precision data-processing instructions only when FPSCR.FZ16 is 0.
- Otherwise only when FPSCR.FZ is 0.

This bit must be cleared to 0 by the exception-handling routine.

When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

When an implementation does not implement trapping of Underflow floating-point exceptions, access to this field is RAZ/WI.

## OFF, bit [2]

Overflow trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Overflow exception occurred while FPSCR.OFE was 1:

| OFF   | Meaning                              |
|-------|--------------------------------------|
| 0b0   | Overflow exception has not occurred. |
| 0b1   | Overflow exception has occurred.     |

This bit must be cleared to 0 by the exception-handling routine.

When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

When an implementation does not implement trapping of Overflow floating-point exceptions, access to this field is RAZ/WI.

## DZF, bit [1]

Divide by Zero trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether a Divide by Zero exception occurred while FPSCR.DZE was 1:

| DZF   | Meaning                                    |
|-------|--------------------------------------------|
| 0b0   | Divide by Zero exception has not occurred. |
| 0b1   | Divide by Zero exception has occurred.     |

This bit must be cleared to 0 by the exception-handling routine.

When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

| UFF   | Meaning                           |
|-------|-----------------------------------|
| 0b1   | Underflow exception has occurred. |

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

When an implementation does not implement trapping of Divide by Zero floating-point exceptions, access to this field is RAZ/WI.

## IOF, bit [0]

Invalid Operation trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Invalid Operation exception occurred while FPSCR.IOE was 1:

| IOF   | Meaning                                       |
|-------|-----------------------------------------------|
| 0b0   | Invalid Operation exception has not occurred. |
| 0b1   | Invalid Operation exception has occurred.     |

This bit must be cleared to 0 by the exception-handling routine.

When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and UNKNOWN.

The reset behavior of this field is:

- On a Warm reset, this field resets to an architecturally UNKNOWN value.

When an implementation does not implement trapping of Invalid Operation floating-point exceptions, access to this field is RAZ/WI.

## Accessing FPEXC

Accesses to this register use the following encodings in the System register encoding space:

```
VMRS{<c>}{<q>} <Rt>, <spec_reg>
```

| reg    |
|--------|
| 0b1000 |

```
if !IsFeatureImplemented(FEAT_AA32EL1) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if HaveEL(EL3) && EL3SDDUndefPriority() && IsFeatureImplemented(FEAT_AA64EL3) && ↪ → !ELUsingAArch32(EL3) && CPTR_EL3.TFP == '1' then UNDEFINED; elsif (IsFeatureImplemented(FEAT_AA32EL3) && ELUsingAArch32(EL3) && SCR.NS == '1' && NSACR.cp10 == ↪ → '0') || CPACR.cp10 == '00' then UNDEFINED; elsif EL2Enabled() && IsFeatureImplemented(FEAT_AA64EL2) && !ELUsingAArch32(EL2) && !ELIsInHost(EL2) ↪ → && CPTR_EL2.TFP == '1' then AArch64.AArch32SystemAccessTrap(EL2, 0x07); elsif ELIsInHost(EL2) && IsFeatureImplemented(FEAT_AA64EL2) && !ELUsingAArch32(EL2) && CPTR_EL2.FPEN ↪ → IN {'x0'} then AArch64.AArch32SystemAccessTrap(EL2, 0x07); elsif EL2Enabled() && IsFeatureImplemented(FEAT_AA32EL2) && ELUsingAArch32(EL2) && ↪ → ((IsFeatureImplemented(FEAT_AA32EL3) && ELUsingAArch32(EL3) && SCR.NS == '1' && NSACR.cp10 == ↪ → '0') || HCPTR.TCP10 == '1') then AArch32.TakeHypTrapException(0x08);
```

```
elsif HaveEL(EL3) && IsFeatureImplemented(FEAT_AA64EL3) && !ELUsingAArch32(EL3) && CPTR_EL3.TFP == ↪ → '1' then if EL3SDDUndef() then UNDEFINED; else AArch64.AArch32SystemAccessTrap(EL3, 0x07); else R[t] = FPEXC; elsif PSTATE.EL == EL2 then if HaveEL(EL3) && EL3SDDUndefPriority() && IsFeatureImplemented(FEAT_AA64EL3) && ↪ → !ELUsingAArch32(EL3) && CPTR_EL3.TFP == '1' then UNDEFINED; elsif EL2Enabled() && ((IsFeatureImplemented(FEAT_AA32EL3) && ELUsingAArch32(EL3) && SCR.NS == '1' ↪ → && NSACR.cp10 == '0') || HCPTR.TCP10 == '1') then AArch32.TakeHypTrapException(0x00); elsif HaveEL(EL3) && IsFeatureImplemented(FEAT_AA64EL3) && !ELUsingAArch32(EL3) && CPTR_EL3.TFP == ↪ → '1' then if EL3SDDUndef() then UNDEFINED; else AArch64.AArch32SystemAccessTrap(EL3, 0x07); else R[t] = FPEXC; elsif PSTATE.EL == EL3 then if CPACR.cp10 == '00' then UNDEFINED; else R[t] = FPEXC;
```

VMSR{&lt;c&gt;}{&lt;q&gt;} &lt;spec\_reg&gt;,

```
<Rt> reg 0b1000
```

```
if !IsFeatureImplemented(FEAT_AA32EL1) then UNDEFINED; elsif PSTATE.EL == EL0 then UNDEFINED; elsif PSTATE.EL == EL1 then if HaveEL(EL3) && EL3SDDUndefPriority() && IsFeatureImplemented(FEAT_AA64EL3) && ↪ → !ELUsingAArch32(EL3) && CPTR_EL3.TFP == '1' then UNDEFINED; elsif (IsFeatureImplemented(FEAT_AA32EL3) && ELUsingAArch32(EL3) && SCR.NS == '1' && NSACR.cp10 == ↪ → '0') || CPACR.cp10 == '00' then UNDEFINED; elsif EL2Enabled() && IsFeatureImplemented(FEAT_AA64EL2) && !ELUsingAArch32(EL2) && !ELIsInHost(EL2) ↪ → && CPTR_EL2.TFP == '1' then AArch64.AArch32SystemAccessTrap(EL2, 0x07); elsif ELIsInHost(EL2) && IsFeatureImplemented(FEAT_AA64EL2) && !ELUsingAArch32(EL2) && CPTR_EL2.FPEN ↪ → IN {'x0'} then AArch64.AArch32SystemAccessTrap(EL2, 0x07); elsif EL2Enabled() && IsFeatureImplemented(FEAT_AA32EL2) && ELUsingAArch32(EL2) && ↪ → ((IsFeatureImplemented(FEAT_AA32EL3) && ELUsingAArch32(EL3) && SCR.NS == '1' && NSACR.cp10 == ↪ → '0') || HCPTR.TCP10 == '1') then AArch32.TakeHypTrapException(0x08); elsif HaveEL(EL3) && IsFeatureImplemented(FEAT_AA64EL3) && !ELUsingAArch32(EL3) && CPTR_EL3.TFP == ↪ → '1' then if EL3SDDUndef() then UNDEFINED; else
```

```
AArch64.AArch32SystemAccessTrap(EL3, 0x07); else FPEXC = R[t]; elsif PSTATE.EL == EL2 then if HaveEL(EL3) && EL3SDDUndefPriority() && IsFeatureImplemented(FEAT_AA64EL3) && ↪ → !ELUsingAArch32(EL3) && CPTR_EL3.TFP == '1' then UNDEFINED; elsif EL2Enabled() && ((IsFeatureImplemented(FEAT_AA32EL3) && ELUsingAArch32(EL3) && SCR.NS == '1' ↪ → && NSACR.cp10 == '0') || HCPTR.TCP10 == '1') then AArch32.TakeHypTrapException(0x00); elsif HaveEL(EL3) && IsFeatureImplemented(FEAT_AA64EL3) && !ELUsingAArch32(EL3) && CPTR_EL3.TFP == ↪ → '1' then if EL3SDDUndef() then UNDEFINED; else AArch64.AArch32SystemAccessTrap(EL3, 0x07); else FPEXC = R[t]; elsif PSTATE.EL == EL3 then if CPACR.cp10 == '00' then UNDEFINED; else FPEXC = R[t];
```