## C8.2.436 LDR (predicate)

Load predicate register

This instruction loads a predicate register from a memory address generated by a 64-bit scalar base, plus an immediate offset in the range -256 to 255 that is multiplied by the current predicate register size in bytes. This instruction is unpredicated.

The load is performed as contiguous byte accesses, each containing 8 consecutive predicate bits in ascending element order, with no endian conversion and no guarantee of single-copy atomicity larger than a byte. However, if alignment is checked, then a general-purpose base register must be aligned to 2 bytes.

For programmer convenience, an assembler must also accept a predicate-as-counter register name for the destination predicate register.

## SVE

(FEAT\_SVE || FEAT\_SME)

<!-- image -->

## Encoding

```
LDR
```

```
<Pt>, [<Xn|SP>{, #<imm>, MUL VL}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) && !IsFeatureImplemented(FEAT_SME) then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Pt); constant integer n = UInt(Rn); constant integer imm = SInt(imm9h:imm9l);
```

## Assembler Symbols

## &lt;Pt&gt;

Is the name of the destination scalable predicate register, encoded in the 'Pt' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

Is the optional signed immediate vector offset, in the range -256 to 255, defaulting to 0, encoded in the 'imm9h:imm9l' fields.

## Operation

```
CheckSVEEnabled(); constant integer VL = CurrentVL; constant integer PL = VL DIV 8; constant integer elements = PL DIV 8; bits(64) base; constant integer offset = imm bits(PL) result; constant boolean contiguous = TRUE; constant boolean nontemporal = FALSE; constant boolean predicated = FALSE; constant boolean tagchecked = n != 31;
```

```
* elements;
```

```
constant AccessDescriptor accdesc = CreateAccDescSVE(MemOp_LOAD, nontemporal, contiguous, predicated, tagchecked); if n == 31 then CheckSPAlignment(); base = SP[64]; else base = X[n, 64]; bits(64) addr = AddressAdd(base, offset, accdesc); constant boolean aligned = IsAligned(addr, 2); if !aligned && AlignmentEnforced() then constant FaultRecord fault = AlignmentFault(accdesc, addr); AArch64.Abort(fault); for e = 0 to elements-1 Elem[result, e, 8] = AArch64.MemSingle[addr, 1, accdesc, aligned]; addr = AddressIncrement(addr, 1, accdesc); P[t, PL] = result;
```