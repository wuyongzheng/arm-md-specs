## C8.2.765 STNT1D (scalar plus scalar, single register)

Contiguous store non-temporal doublewords from vector (scalar index)

This instruction performs a contiguous non-temporal store of doublewords from elements of a vector register to the memory address generated by a 64-bit scalar base and scalar index that is multiplied by 8 and added to the base address. After each element access the index value is incremented, but the index register is not updated. Inactive elements are not written to memory.

Anon-temporal store is a hint to the system that this data is unlikely to be referenced again soon.

## SVE

(FEAT\_SVE || FEAT\_SME)

<!-- image -->

## Encoding

```
STNT1D { <Zt>.D },
```

```
<Pg>, [<Xn|SP>, <Xm>, LSL #3]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SVE) && !IsFeatureImplemented(FEAT_SME) then EndOfDecode(Decode_UNDEF); if Rm == '11111' then EndOfDecode(Decode_UNDEF); constant integer t = UInt(Zt); constant integer n = UInt(Rn); constant integer m = UInt(Rm); constant integer g = UInt(Pg); constant integer esize = 64;
```

## Assembler Symbols

&lt;Zt&gt;

Is the name of the scalable vector register to be transferred, encoded in the 'Zt' field.

&lt;Pg&gt;

Is the name of the governing scalable predicate register P0-P7, encoded in the 'Pg' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;Xm&gt;

Is the 64-bit name of the general-purpose offset register, encoded in the 'Rm' field.

## Operation

```
CheckSVEEnabled(); constant integer VL = CurrentVL; constant integer PL = VL DIV 8; constant integer elements = VL DIV bits(64) base; bits(64) offset; bits(64) addr; bits(VL) src;
```

```
esize;
```

```
constant bits(PL) mask = P[g, PL]; constant integer mbytes = esize DIV 8; constant boolean contiguous = TRUE; constant boolean nontemporal = TRUE; constant boolean predicated = TRUE; constant boolean tagchecked = TRUE; constant AccessDescriptor accdesc = CreateAccDescSVE(MemOp_STORE, nontemporal, contiguous, predicated, tagchecked); if !AnyActiveElement(mask, esize) then if n == 31 && ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then CheckSPAlignment(); else if n == 31 then CheckSPAlignment(); src = Z[t, VL]; base = if n == 31 then SP[64] else X[n, 64]; offset = X[m, 64]; addr = AddressAdd(base, UInt(offset) * mbytes, accdesc); for e = 0 to elements-1 if ActivePredicateElement(mask, e, esize) then Mem[addr, mbytes, accdesc] = Elem[src, e, esize]; addr = AddressIncrement(addr, mbytes, accdesc);
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.