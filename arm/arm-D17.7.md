## D17.7 The Profiling Buffer

ILSYJL

RKLGPG

IJXFJK

RPSLVX

When the SPU is not in Discard mode, profile data is collected in a memory Profiling Buffer . The Profiling Buffer is defined by:

- PMBPTR\_EL1, the current write pointer.
- PMBLIMITR\_EL1, the write limit pointer.

The Profiling Buffer starts at the current write pointer and extends to the current limit pointer minus one. The write limit pointer must be aligned to the smallest implemented translation granule size. The alignment of the current write pointer

is IMPLEMENTATION DEFINED.

If the Effective value of PMBLIMITR\_EL1.nVM is 0, then address translation for the Profiling buffer in the owning translation regime is enabled. See Behavior when address translation is enabled.

If the Effective value of PMBLIMITR\_EL1.nVM is 1, then address translation for the Profiling buffer in the owning translation regime is disabled. See Behavior when address translation is disabled.

If FEAT\_SPE\_nVM is not implemented or all of the following apply, then the Effective value of PMBLIMITR\_EL1.nVM is 0:

- EL2 is implemented and enabled in the owning Security state.
- The owning Exception level is EL1.
- The Effective value of PMSCR\_EL2.EnVM is 0.

## D17.7.1 Behavior when address translation is enabled

RLWHSF

If the Effective value of PMBLIMITR\_EL1.nVM is 0, then PMBLIMITR\_EL1 and PMBPTR\_EL1 are virtual addresses in the stage 1 translation regime of the owning translation regime.

RVGJHQ

If the Effective value of PMBLIMITR\_EL1.nVM is 0, then the stage 1 translation process for translating virtual addresses and checking for MMU faults is identical to that for any other virtual address in the owning translation regime. For example, PMBPTR\_EL1[63:56] are ignored by address translation if the respective TBI bit is set to 1.

## D17.7.2 Behavior when address translation is disabled

RRPSLW

RSDWFC

IFRCPH

IDJRBT

If the Effective value of PMBLIMITR\_EL1.nVM is 1, then the write limit pointer and current write pointer are:

- Physical address in the owning Security state if the owning translation regime has no stage 2 translation.
- Intermediate physical addresses (IPAs) in the owning Security state if the owning translation regime has stage 2 translations.

These addresses are output directly by stage 1 without any address translation. Stage 1 translation is disabled for writes to the Profiling Buffer made by the Statistical Profiling Unit .

The pseudocode function AArch64.S1Enabled() shows this.

If the Effective value of PMBLIMITR\_EL1.nVM is 1, PMBMAR\_EL1 defines:

- The memory type.
- And as applicable, the following attributes:
- -Cacheability.
- -Shareability.
- -
- Device type.

The pseudocode function AArch64.S1DisabledOutput() shows this.

If the Effective value of PMBLIMITR\_EL1.nVM is 1, the values of SCTLR\_ELx.{C, M} for the owning translation regime are ignored for the purposes of determining the Profiling Buffer Cacheability attributes.

If the Effective value of PMBLIMITR\_EL1.nVM is 1, it is possible to generate mismatched attributes for a location from within stage 1 of the owning translation regime using PMBMAR\_EL1.

Software must be aware of the consequences of and permitted behaviors when accessing a memory location with mismatched attributes. For more information, see Mismatched memory attributes.

RQJNFT

RXBFCM

If the Effective value of PMBLIMITR\_EL1.nVM is 1 and PMBPTR\_EL1[ OAMax:AArch64.PAMax() ] is nonzero, a stage 1 Address Size fault is generated when the Statistical Profiling Unit attempts to write to memory, where:

- If FEAT\_D128 is implemented, then OAMax is 55.
- Otherwise, if FEAT\_LPA is implemented or FEAT\_LPA2 is implemented , then OAMax is 51.
- Otherwise, OAMax is 47.

For more information, see Implemented physical address size.

If the Effective value of PMBLIMITR\_EL1.nVM is 1 and PMBPTR\_EL1[ 63:(OAMax+1) ] is nonzero when the Statistical Profiling Unit attempts to write to the Profiling Buffer, then one of the following CONSTRAINED UNPREDICTABLE behaviors apply:

- Astage 1 Address Size fault is generated.
- PMBPTR\_EL1[ 63:(OAMax+1) ] are ignored and treated as zero.

The value of OAMax is as defined by RQJNFT.

## D17.7.3 Effect of stage 2 translation

RDQTTB

If the owning translation regime has stage 2 translations, the stage 2 process of the following is identical to that for any other intermediate physical address generated by the owning translation regime:

- Translating the stage 1 output intermediate physical addresses.
- Translating the stage 1 attributes to a physical address and attributes.
- Checking for MMU faults.

Example D17-7

The intermediate physical addresses are translated to physical addresses by stage 2 translation, and checked for stage 2 MMU faults.

- If the Effective value of PMBLIMITR\_EL1.nVM is 1, meaning stage 1 translation is disabled, and the resulting IPA is translated by a stage 2 Block or Page descriptor with the AssuredOnly attribute set to 1, then the access translated by that descriptor generates a stage 2 Permission fault. See RWWYDL in Assured translation.
- The attributes from stage 1 are combined with the attributes from the stage 2 translation to generate the physical memory attributes.
- If the Effective value of HCR\_EL2.DC in the owning translation regime is 1, then stage 1 translation is disabled and the memory type produced by stage 1 is Normal Non-shareable, Inner Write-Back Cacheable Read-Allocate Write-Allocate, Outer Write-Back Cacheable Read-Allocate Write-Allocate, regardless of the values of SCTLR\_EL1.C and PMBMAR\_EL1.
- If the Effective value of HCR\_EL2.MIOCNCE in the owning translation regime is 0, then for permitted accesses to a memory location that use a common definition of the Shareability and Cacheability of the location, there is no loss of coherency if the Inner Cacheability attribute for those accesses differs from the Outer Cacheability attribute.

## D17.7.4 Restrictions on the current write pointer

This section describes the software rules on setting the current write pointer, PMBPTR\_EL1. The rules in this section do not apply when Discard mode is enabled. See Discard mode.

RPGGHS

If software violates the restrictions in RHXSYK and RHLXGD, then the behavior is CONSTRAINED UNPREDICTABLE, and the PE might do any of the following at any point after profiling is enabled:

- The value of PMBPTR\_EL1 becomes UNKNOWN.
- Write sample records to any address in memory that is writable by a privileged access in the owning translation regime. These addresses are:

- Virtual addresses in the owning translation regime, if the Effective value of PMBLIMITR\_EL1.nVM is 0.

- Intermediate physical addresses in the owning Security state, if the Effective value of PMBLIMITR\_EL1.nVM is 1, and the owning translation regime has stage 2 translations.

- Physical addresses in the owning Security state, if the Effective value of PMBLIMITR\_EL1.nVM is 1, and either the owning translation regime has no stage 2 translation or stage 2 translation is disabled.

- Generate a Profiling Buffer management event, with or without indicating data loss, for one of the following reasons:

- ABuffer full buffer management event. See Buffer full event.

- An Access not allowed buffer management event. See Access not allowed.

- Any MMU Fault. See Faults and watchpoints.

- An IMPLEMENTATION DEFINED buffer management event. See Implementation defined reason.

If FEAT\_SPE\_EXC is implemented, then the management event is recorded as described by RHJXHT.

- Silently discard all profiling data without writing it to memory.

- Behave as if profiling is disabled.

- Generate the SAMPLE\_BUFFER\_FULL PMU event.

RHXSYK

When profiling becomes enabled, all the following must be true:

- The current write pointer must be at least one sample record size below the write limit pointer. That is: UInt (PMBPTR\_EL1.PTR) &lt;= UInt (PMBLIMITR\_EL1.LIMIT: Zeros (12)) - 2 PMSIDR\_EL1.MaxSize .

- PMBPTR\_EL1.PTR[63:56] must equal PMBLIMITR\_EL1.LIMIT[63:56].

If profiling becomes enabled due to a Context synchronization event, then these conditions apply for the values of these System registers after the Context synchronization event.

- RHLXGD When the Profiling Buffer is first configured, PMBPTR\_EL1.PTR must be aligned to PMBIDR\_EL1.Align. That is, if PMBIDR\_EL1.Align is nonzero, PMBPTR\_EL1.PTR [ UInt (PMBIDR\_EL1.Align)-1:0] must be all zeros.

However, the current write pointer and write limit pointer can usually be restored to the saved write pointer and saved write limit pointer values that were in the System registers when profiling was disabled, providing a PSB and a Context synchronization event were executed before reading the System registers.

Following a management event and executing a PSB and a Context synchronization event:

- If PMBSR\_ELx.{EA, DL} are not {0, 0}, indicating an External abort and/or data loss occurred, then profiling cannot be restarted using the saved write pointer and saved write limit pointer.

- Otherwise, if PMBSR\_ELx.S is 0, indicating no Profiling Buffer management event was signaled, then profiling can be restarted from the saved write pointer and saved write limit pointer.

- Otherwise, if software clears PMBSR\_ELx.S to 0 before restarting profiling, then the following apply:

- If the Profiling Buffer management event was caused by an MMU fault, then profiling can be restarted from the saved write pointer.

Note

If the MMU fault has not been corrected, then the SPU will generate a MMU fault Profiling Buffer management event when it next tries to write a sample record.

- If the Profiling Buffer management event was caused by a buffer full event, then profiling cannot be restarted from the saved write pointer and saved limit pointer, as the saved write pointer will not be at least one sample record below the saved limit pointer. However, software can extend the Profiling Buffer by changing PMBLIMITR\_EL1, and then profiling can be restarted from the saved write pointer.

- Otherwise, profiling is restarted with PMBSR\_ELx.S set to 1, meaning profiling is stopped and there are no constraints on the values of the current write pointer and write limit pointer.

If software restarts profiling with a new current write pointer and new write limit pointer, then the restrictions on the current write pointer when first enabling profiling apply.

ELx is defined by RHJXHT.

For more information, see Synchronization and Statistical Profiling and Profiling Buffer management.

## D17.7.5 The owning translation regime

RWWFKZ

The owning translation regime is defined by the owning Security state and the owning Exception level.

RBWRVP

IYCDWQ

IYZHFG

When the Profiling Buffer is enabled, the owning Security state is:

- Non-secure state if and only if one of the following is true:
- -EL3 is not implemented and the PE executes in Non-secure state.
- -FEAT\_RME is not implemented, EL3 is implemented, and MDCR\_EL3.NSPB is either 0b10 or 0b11 .
- -FEAT\_RME is implemented and MDCR\_EL3.{NSPBE, NSPB} is either { 0b0 , 0b10 } or { 0b0 , 0b11 }.
- Secure state if and only if one of the following is true:
- -EL3 is not implemented and the PE executes in Secure state.
- -FEAT\_RME is not implemented, EL3 is implemented, and MDCR\_EL3.NSPB is either 0b00 or 0b01 .
- -FEAT\_RME is implemented, Secure state is implemented, and MDCR\_EL3.{NSPBE, NSPB} is either { 0b0 , 0b00 } or { 0b0 , 0b01 }.
- Realm state if and only if all of the following are true:
- -FEAT\_RME is implemented.
- -MDCR\_EL3.{NSPBE, NSPB} is either { 0b1 , 0b10 } or { 0b1 , 0b11 }.

## RKFMHR When the Profiling Buffer is enabled, the owning Exception level is:

- EL1 if and only if at least one of the following is true:
- -EL2 is not implemented in the owning Security state.
- -EL2 is disabled in the owning Security state.
- -MDCR\_EL2.E2PB is either 0b10 or 0b11 .
- EL2, if and only if all of the following are true:
- -EL2 is implemented and enabled in the owning Security state.
- -MDCR\_EL2.E2PB is 0b00 .

RTDHBH When the Profiling Buffer is enabled and the owning Exception level is EL1, all of the following apply:

- The owning translation regime is EL1&amp;0.
- If the Effective value of PMBLIMITR\_EL1.nVM is 0, the Profiling Buffer addresses are virtual addresses in the EL1&amp;0 translation regime using the current ASID from TTBRx\_EL1.
- If the Effective value of PMBLIMITR\_EL1.nVM is 1, the Profiling Buffer addresses are intermediate physical addresses.
- Intermediate physical addresses (whether from the output of stage 1, or the pointers, as applicable) are subject to stage 2 translation using the current VMID if EL2 is implemented and enabled and HCR\_EL2.VM is 1.
- Profiling is disabled at the following Exception levels:
- -EL3.
- -EL2.
- -EL0, if EL2 is implemented and enabled and HCR\_EL2.TGE is 1.

RKRVDC When the Profiling Buffer is enabled and the owning Exception level is EL2, all of the following apply:

- If the Effective value of HCR\_EL2.E2H is 0, the owning translation regime is EL2.
- If the Effective value of HCR\_EL2.E2H is 1, the owning translation regime is EL2&amp;0.
- If the Effective value of HCR\_EL2.E2H is 0 and the Effective value of PMBLIMITR\_EL1.nVM is 0, the Profiling Buffer addresses are virtual addresses in the EL2 translation regime.
- If the Effective value of HCR\_EL2.E2H is 1 and the Effective value of PMBLIMITR\_EL1.nVM is 0, the Profiling Buffer addresses are virtual addresses in the EL2&amp;0 translation regime using the current ASID from TTBRx\_EL2.
- If the Effective value of PMBLIMITR\_EL1.nVM is 1, the Profiling Buffer addresses are physical addresses.
- Profiling is disabled at EL3.

When the Profiling Buffer is enabled, all of the following apply:

- If the owning Security state is Non-secure state, profiling is disabled in Secure and Realm states.
- If the owning Security state is Secure state, profiling is disabled in Non-secure and Realm states.
- If the owning Security state is Realm state, profiling is disabled in Non-secure and Secure states.

## D17.7.5.1 Summary of the owning translation regime

Table D17-4 summarizes the owning translation regime. In this table:

| E     | is the value of PMBLIMITR_EL1.E.          |
|-------|-------------------------------------------|
| NSE   | is the Effective value of SCR_EL3.NSE.    |
| NS    | is the Effective value of SCR_EL3.NS.     |
| EEL2  | is the Effective value of SCR_EL3.EEL2.   |
| NSPBE | is the Effective value of MDCR_EL3.NSPBE. |
| NSPB  | is the Effective value of MDCR_EL3.NSPB.  |
| E2PB  | is the Effective value of MDCR_EL2.E2PB.  |
| E2H   | is the Effective value of HCR_EL2.E2H.    |

Table D17-4 Summary of owning translation regime (for all Exception levels using AArch64 state)

| Controls   | Controls   |     |      |       |      |      |     | Owning translation regime    |
|------------|------------|-----|------|-------|------|------|-----|------------------------------|
| E          | NSE        | NS  | EEL2 | NSPBE | NSPB | E2PB | E2H | Owning translation regime    |
| 0b0        | x          | x   | x    | x     | x    | x    | x   | Disabled                     |
| 0b1        | 0b0        | 0b0 | 0b0  | 0b0   | 0b0x | x    | x   | Secure EL1&0                 |
|            |            |     | 0b1  | 0b0   | 0b0x | 0b1x | x   | Secure EL1&0                 |
|            |            |     |      |       |      | 0b00 | 0b0 | Secure EL2                   |
|            |            |     |      |       |      |      | 0b1 | Secure EL2&0                 |
|            |            |     | x    | 0b0   | 0b1x | x    | x   | Disabled in Secure state     |
|            |            | 0b1 | x    | 0b0   | 0b1x | 0b1x | x   | Non-secure EL1&0             |
|            |            |     |      |       |      | 0b00 | 0b0 | Non-secure EL2               |
|            |            |     |      |       |      |      | 0b1 | Non-secure EL2&0             |
|            |            |     |      |       | 0b0x | x    | x   | Disabled in Non-secure state |
|            | 0b1        | 0b1 | x    | 0b1   | 0b1x | 0b1x | x   | Realm EL1&0                  |
|            |            |     |      |       |      | 0b00 | 0b0 | Realm EL2                    |
|            |            |     |      |       |      |      | 0b1 | Realm EL2&0                  |
|            |            |     |      |       | 0b0x | x    | x   | Disabled in Non-secure state |
| x          | x          | x   | x    | 0b1   | 0b0x | x    | x   | Reserved                     |

## D17.7.6 Memory access types and coherency

Writes to any Device memory type by the SPU occur once.

The memory type and attributes that are used for a write by the SPU to the Profiling Buffer is taken from the translation table entries for the virtual address being written to. That is:

- The writes are treated as coming from an observer that is coherent with all observers in the Shareability domain that is defined by the translation tables.
- There is no requirement to manage coherency for observers in the same Shareability domain but coherency for other observers in the system might require explicit management.

For more information, see Synchronization and Statistical Profiling.

If FEAT\_MTE2 is implemented, a PE will generate a Tag Unchecked access for each access to the Profiling Buffer as part of writing a sample record.

For more information on FEAT\_MTE2, see The Memory Tagging Extension.

Writes to the Profiling Buffer are made as privileged writes within the owning translation regime. However, the value of PSTATE.PAN is ignored for these writes and treated as zero, see Faults and watchpoints.

This means that if FEAT\_E0PD is implemented, the values of TCR\_ELx.E0PDy, where ELx is the owning Exception level, do not apply to accesses to the Profiling Buffer made by the SPU.

## D17.7.7 Memory access and crossing page boundaries

Amemory access from the SPU that crosses a page boundary to a memory location that has a different memory type or Shareability attribute results in CONSTRAINED UNPREDICTABLE behavior. In this case, the implementation performs one of the following behaviors:

- Each memory access generated by the SPU uses the memory type and Shareability attribute associated with its own address.
- The access generates an Alignment fault caused by the memory type:
- -If only the stage 1 translation generated the mismatch, or there is only one stage of translation in the owning translation regime, the resulting Buffer Management event is a stage 1 Data Abort.
- -If only the stage 2 translation generated the mismatch, the resulting Buffer Management event is a stage 2 Data Abort.
- -If both stages of translation generate the mismatch, the resulting Buffer Management event is either a stage 1 Data Abort or a stage 2 Data Abort.
- Some or all of the data is discarded. The write pointer is either updated by the amount of data written not including the discarded data or the amount of data written including the discarded data.

Amemory access from the SPU to Device memory that crosses a boundary corresponding to the smallest translation granule size of the implementation causes CONSTRAINED UNPREDICTABLE behavior. In this case, the implementation performs one of the following behaviors:

- All memory accesses generated by the SPU are performed as if the boundary has no effect on the memory accesses.
- All memory accesses generated by the SPU are performed as if the boundary has no effect on the memory accesses except that there is no guarantee of ordering between memory accesses.
- The access generates an Alignment fault caused by the memory type:
- -If only the stage 1 translation causes the boundary to be crossed, or there is only one stage of translation in the owning translation regime, the resulting Buffer Management event is a stage 1 Data Abort.
- -If only the stage 2 translation causes the boundary to be crossed, the resulting Buffer Management event is a stage 2 Data Abort.
- -If both stages of translation cause the boundary to be crossed, the resulting Buffer Management event is either a stage 1 Data Abort or a stage 2 Data Abort.
- Some or all of the data is discarded. The write pointer is either updated by the amount of data written not including the discarded data or the amount of data written including the discarded data.

Note

The boundary referred to is between two Device memory regions that are both:

- Of the size of the smallest implemented translation granule.
- Aligned to the size of the smallest implemented translation granule.

If PMSIDR\_EL1.MaxSize indicates the same value as PMBIDR\_EL1.Align, then records are a fixed power-of-two size and never cross a page boundary.

## D17.7.8 Cache and TLB operations

TLB maintenance operations that affect the TLB of the PE also affect any TLB caching translations for the SPU of that PE.

Cache maintenance operations that affect the caches of the PE also affect data caching by the SPU of that PE.

This means that the completion of any cache or TLB maintenance instruction includes its completion on all SPUs for PEs that are affected by both the instruction and the DSB operation that is required to guarantee visibility of the maintenance instruction.

## See also:

- Completion and endpoint ordering.
- Synchronization and Statistical Profiling.

## D17.7.9 Effect on the exclusive monitors

If a Load-exclusive instruction or an operation between Load-exclusive and Store-exclusive instructions is sampled, and the sample record is written to an unrelated address, then to avoid a probe effect, Arm recommends that the Store-exclusive does not systematically fail on account of the sampled operation.

If a Store-exclusive instruction is sampled, and the sample record is written to an unrelated address, then the Store-exclusive must not systematically fail on account of the instruction having been sampled.

## D17.7.10 Statistical Profiling and MEC

RDFFVT

If FEAT\_MEC is implemented, accesses made by the Statistical Profiling Unit to the Profiling Buffer are associated with a MECID that is determined by the owning translation regime, owning Security state, and owning Exception level, as defined in Memory Encryption Contexts extension.