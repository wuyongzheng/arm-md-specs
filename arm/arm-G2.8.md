## G2.8 Breakpoint exceptions

This section describes Breakpoint exceptions in stage 1 of an AArch32 translation regime.

The PE is using an AArch32 translation regime when it is executing either:

- At EL1 or higher in an Exception level that is using AArch32.
- At EL0 using AArch32 when EL1 is using AArch32.

This section contains the following subsections:

- About Breakpoint exceptions.
- Breakpoint types and linking of breakpoints.
- Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Breakpoint instruction address comparisons.
- Breakpoint context comparisons.
- Using breakpoints.
- Exception syndrome information and preferred return address for a Breakpoint exception.
- Pseudocode description of Breakpoint exceptions taken from AArch32 state.

## G2.8.1 About Breakpoint exceptions

A breakpoint is an event that results from the execution of an instruction, based on either:

- The instruction address, the PE context, or both. This type of breakpoint is called a hardware breakpoint.
- The instruction itself. That is, the instruction is a breakpoint instruction . These can be included in the program that the PE executes. This type of breakpoint is called a software breakpoint .

Breakpoint exceptions are generated by Breakpoint debug events . Breakpoint debug events are generated by hardware breakpoints. Software breakpoints are described in Breakpoint Instruction exceptions.

An implementation can include between 2-16 hardware breakpoints. DBGDIDR.BRPs shows how many are implemented.

To use an implemented hardware breakpoint, a debugger programs the following registers for the breakpoint:

- The Breakpoint Control Register , DBGBCR&lt;n&gt;. This contains controls for the breakpoint, for example an enable control.
- The Breakpoint Value Register , DBGBVR&lt;n&gt;. This holds a value used for breakpoint matching, that is one of:
- -An instruction virtual address.
- -AContext ID.
- If EL2 is implemented, the Breakpoint Extended Value Register , DBGBXVR&lt;n&gt;, that holds a VMID value used for breakpoint matching.

These registers are numbered, so that:

- DBGBCR1, DBGBVR1, and DBGBXVR1 are for breakpoint number one.
- DBGBCR2, DBGBVR2, and DBGBXVR2 are for breakpoint number two.
- . . .
- . . .
- DBGBCR&lt;n&gt;, DBGBVR&lt;n&gt;, and DBGBXVR&lt;n&gt; are for breakpoint number &lt;n&gt;.

Adebugger can link a breakpoint that is programmed with an address and a breakpoint that is programmed with anything other than an address together, so that a Breakpoint debug event is only generated if both breakpoints match.

For each instruction in the program flow, all of the breakpoints are tested. When a breakpoint is tested, it generates a Breakpoint debug event if all of the following are true:

- The breakpoint is enabled. That is, the breakpoint enable control for it, DBGBCR&lt;n&gt;.E, is 1.
- The conditions specified in the DBGBCR&lt;n&gt; are met.
- The comparisons with the values held in one or both of the DBGBVR&lt;n&gt; and DBGBXVR&lt;n&gt;, as applicable, are successful.
- If the breakpoint is linked to another breakpoint, the comparisons made by that other breakpoint are also successful.
- The instruction is committed for execution.

If all of these conditions are met, the breakpoint generates the Breakpoint debug event regardless of the following:

- Whether the instruction passes its Condition code check.
- The instruction type.

If halting is allowed and EDSCR.HDE is 1, Breakpoint debug events cause entry to Debug state.

Otherwise, if debug exceptions are

- Enabled, Breakpoint debug events generate Breakpoint exceptions
- Disabled, Breakpoint debug events are ignored.

Note

The remainder of this Breakpoint exceptions section, including all subsections, describes breakpoints as generating Breakpoint exceptions. However, the behavior described also applies if breakpoints are causing entry to Debug state.

The debug exception enable controls describes the enable controls for Breakpoint debug events.

## G2.8.2 Breakpoint types and linking of breakpoints

Each implemented breakpoint is one of the following:

- A context-aware breakpoint. This is a breakpoint that can be programmed to generate a Breakpoint exception on any one of the following:
- -An instruction address match.
- -An instruction address mismatch.
- -AContext ID match, with the value held in the CONTEXTIDR.
- -AVMIDmatch, with the value held in the VTTBR.
- -Both a Context ID match and a VMID match.
- Abreakpoint that is not context-aware. These can only be programmed to generate a Breakpoint exception on an instruction address match or an instruction address mismatch.

DBGDIDR.CTX\_CMPs shows how many of the implemented breakpoints are context-aware breakpoints. At least one implemented breakpoint must be context-aware. The context-aware breakpoints are the highest numbered breakpoints.

Any breakpoint that is programmed to generate a Breakpoint exception on an instruction address match or mismatch is categorized as an Address breakpoint . Breakpoints that are programmed to match on anything else are categorized as Context breakpoints .

When a debugger programs a breakpoint to be an Address or a Context breakpoint, it must also program that breakpoint so that it is either:

- Used in isolation. In this case, the breakpoint is called an Unlinked breakpoint .
- Enabled for linking to another breakpoint. In this case, the breakpoint is called a Linked breakpoint .

By linking an Address breakpoint and a Context breakpoint together, the debugger can create a breakpoint pair that only generates a Breakpoint exception if the PE is in a particular context when an instruction address match or mismatch occurs. For example, a debugger might:

1. Program breakpoint number one to be a Linked Address Match breakpoint .
2. Program breakpoint number five to be a Linked Context ID Match breakpoint .
3. Link these two breakpoints together. A Breakpoint exception is only generated if both the instruction address matches and the Context ID matches.

The Breakpoint Type field for a breakpoint, DBGBCR&lt;n&gt;.BT, controls the breakpoint type and whether the breakpoint is enabled for linking. If BT[0] is 1, the breakpoint is enabled for linking.

Address breakpoints can be programmed to generate Breakpoint exceptions on addresses that are halfword-aligned but not word-aligned. This makes it possible to breakpoint on T32 instructions. See Specifying the halfword-aligned address that an Address breakpoint matches on.

## G2.8.2.1 Rules for linking breakpoints

The rules for breakpoint linking are as follows:

- Only Linked breakpoint types can be linked.
- Any type of Linked Address breakpoint can link to any type of Linked Context breakpoint. The Linked Breakpoint Number field, DBGBCR&lt;n&gt;.LBN, for the Linked Address breakpoint specifies the particular Linked Context breakpoint that the Linked Address breakpoint links to, and:
- -DBGBCR&lt;n&gt;.{SSC, HMC, PMC} for the Linked Address breakpoint define the execution conditions that the breakpoint pair generates Breakpoint exceptions for. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- -DBGBCR&lt;n&gt;.{SSC, HMC, PMC} for the Linked Context breakpoint are ignored.
- Linked Context breakpoint types can only be linked to. The LBN field for Context breakpoints is therefore ignored.
- Linked Address breakpoints cannot link to watchpoints. The LBN field can therefore only specify another breakpoint.
- If a Linked Address breakpoint links to a breakpoint that is not context-aware, the behavior of the Linked Address breakpoint is CONSTRAINED UNPREDICTABLE. See Other usage constraints for Address breakpoints.
- If a Linked Address breakpoint links to an Unlinked Context breakpoint, the Linked Address breakpoint never generates any Breakpoint exceptions.
- Multiple Linked Address breakpoints can link to a single Linked Context breakpoint.

Note

Multiple Linked watchpoints can also link to a single Linked Context breakpoint. Watchpoint exceptions describes watchpoints.

These rules mean that a single Linked Context breakpoint might be linked to by all, or any combination of, the following:

- Multiple Linked Address Match breakpoints.
- Multiple Linked Address Mismatch breakpoints.
- Multiple Linked watchpoints.

It is also possible that a Linked Context breakpoint might have no breakpoints or watchpoints linked to it.

Figure G2-1 shows an example of permitted breakpoint and watchpoint linking.

Figure G2-1 The role of linking in Breakpoint and Watchpoint exception generation

<!-- image -->

In Figure G2-1, each Linked Address breakpoint can only generate a Breakpoint exception if the comparisons made by both it, and the Linked Context breakpoint that it links to, are successful. Similarly, each Linked watchpoint can only generate a Watchpoint exception if the comparisons made by both it, and the Linked Context breakpoint that it links to, are successful.

## G2.8.2.2 Breakpoint types defined by DBGBCRn.BT

The following list provides more detail about each breakpoint type:

## 0b0000 , Unlinked Address Match breakpoint

Generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;.{SSC, HMC, PMC}. These define the execution conditions that the breakpoint generates Breakpoint exceptions for. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Asuccessful address match, as described in Breakpoint instruction address comparisons.

DBGBCR&lt;n&gt;.{LBNX, LBN} for this breakpoint is ignored.

## 0b0001 , Linked Address Match breakpoint

Generation of a Breakpoint exception depends on all of the following:

- DBGBCR&lt;n&gt;.{SSC, HMC, PMC} for this breakpoint. These define the execution conditions that the breakpoint generates Breakpoint exceptions for. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Asuccessful address match defined by this breakpoint, as described in Breakpoint instruction address comparisons.

- Asuccessful context match defined by the Context breakpoint with linking enabled that this breakpoint links to.

DBGBCR&lt;n&gt;.{LBNX, LBN} for this breakpoint selects the Context breakpoint with linking enabled that this breakpoint links to.

## 0b0010 , Context ID Match breakpoint

BT == 0b0010 is a reserved value if the breakpoint is not a context-aware breakpoint.

For context-aware breakpoints, generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;.{SSC, HMC, PMC}. These define the execution conditions that the breakpoint generates Breakpoint exceptions for. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Asuccessful Context ID match, as described in Breakpoint context comparisons.

The value of DBGBVR&lt;n&gt;.ContextID is compared with the current Context ID.

CONTEXTIDR\_EL2 holds the current Context ID when all of:

- The implementation includes FEAT\_VHE.
- EL2 is implemented and enabled in the current Security state.
- EL2 using AArch64 and the Effective value of HCR\_EL2.E2H is 1.
- The PE is executing at EL0 and HCR\_EL2.TGE is 1, or the PE is executing at EL2.

Otherwise, CONTEXTIDR holds the current Context ID.

DBGBCR&lt;n&gt;.{LBNX, LBN, BAS} for this breakpoint are ignored

## 0b0011 , Context ID Match breakpoint with linking enabled

BT == 0b0011 is a reserved value if the breakpoint is not a context-aware breakpoint.

For context-aware breakpoints, either:

- This breakpoint does not generate any debug exceptions, if no Linked breakpoints or Linked watchpoints link to it.
- Generation of a Breakpoint exception depends on both:
- -Asuccessful instruction address match, defined by a Linked Address breakpoint that links to this breakpoint, see Breakpoint instruction address comparisons.
- -Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.
- Generation of a Watchpoint exception depends on both:
- -Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.
- -Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.

The value of DBGBVR&lt;n&gt;.ContextID is compared with the current Context ID.

CONTEXTIDR\_EL2 holds the current Context ID when all of:

- The implementation includes FEAT\_VHE.
- EL2 is implemented and enabled in the current Security state.
- EL2 using AArch64 and the Effective value of HCR\_EL2.E2H is 1.
- The PE is executing at EL0 and HCR\_EL2.TGE is 1, or the PE is executing at EL2.

Otherwise, CONTEXTIDR holds the current Context ID.

DBGBCR&lt;n&gt;.{LBNX, LBN, SSC, HMC, BAS PMC} for this breakpoint are ignored.

## 0b0100 , Unlinked Address Mismatch breakpoint

Generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;.{SSC, HMC, PMC}. These define the execution conditions that the breakpoint generates Breakpoint exceptions for. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Asuccessful address mismatch, as described in Breakpoint instruction address comparisons.

DBGBCR&lt;n&gt;.{LBNX, LBN} for this breakpoint is ignored.

## 0b0101 , Linked Address Mismatch breakpoint

Generation of a Breakpoint exception depends on all of the following:

- DBGBCR&lt;n&gt;.{SSC, HMC, PMC}. These define the execution conditions that the breakpoint generates Breakpoint exceptions for. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Asuccessful address mismatch defined by this breakpoint, as described in Breakpoint instruction address comparisons.
- Asuccessful context match defined by the Linked Context breakpoint that this breakpoint links to.

DBGBCR&lt;n&gt;.{LBNX, LBN} for this breakpoint selects the Linked Context breakpoint that this breakpoint links to.

## 0b0110 , CONTEXTIDR\_EL1 Match breakpoint

BT == 0b0110 is a reserved value if either:

- The breakpoint is not a context-aware breakpoint.
- The implementation does not include FEAT\_VHE.

For context-aware breakpoints, generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;.{SSC, HMC, PMC}. These define the execution conditions for which the breakpoint generates Breakpoint exceptions.
- Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.

The Context ID check is made against the value in CONTEXTIDR, or CONTEXTIDR\_EL1. The value of DBGBVR&lt;n&gt;.ContextID is compared with the Context ID value held in CONTEXTIDR or CONTEXTIDR\_EL1.

DBGBCR&lt;n&gt;.{LBNX, LBN, BAS} for this breakpoint are ignored.

## 0b0111 , CONTEXTIDR\_EL1 Match breakpoint with linking enabled

BT == 0b0111 is a reserved value if either:

- The breakpoint is not a context-aware breakpoint.
- The implementation does not include FEAT\_VHE.

For context-aware breakpoints, one of the following applies:

- If no Linked breakpoints or Linked watchpoints link to this breakpoint, then the breakpoint does not generate any debug exceptions.
- Generation of a Breakpoint exception depends on both:
- -Asuccessful instruction address match, defined by a Linked Address match breakpoint that links to this breakpoint, see Breakpoint instruction address comparisons.
- -Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.
- Generation of a Watchpoint exception depends on both:
- -Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.
- -Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.

The Context ID check is made against the value in CONTEXTIDR, or CONTEXTIDR\_EL1. The value of DBGBVR&lt;n&gt;.ContextID is compared with the Context ID value held in CONTEXTIDR or CONTEXTIDR\_EL1.

DBGBCR&lt;n&gt;.{LBNX, LBN, SSC, HMC, BAS, PMC} for this breakpoint are ignored.

## 0b1000 , VMID Match breakpoint

BT == 0b1000 is a reserved value if either:

- The breakpoint is not a context-aware breakpoint.
- EL2 is not implemented.

For context-aware breakpoints, generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;.{SSC, HMC, PMC}. These define the execution conditions that the breakpoint generates Breakpoint exceptions for. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Asuccessful VMID match, as described in Breakpoint context comparisons.

DBGBCR&lt;n&gt;.{LBNX, LBN, BAS} for this breakpoint are ignored.

## 0b1001 , VMID Match breakpoint with linking enabled

BT == 0b1000 is a reserved value if either:

- The breakpoint is not a context-matching breakpoint.
- EL2 is not implemented.

For context-aware breakpoints, either:

- This breakpoint does not generate any debug exceptions, if no Linked breakpoints or Linked watchpoints link to it.
- Generation of a Breakpoint exception depends on both:
- -Asuccessful instruction address match, defined by a Linked Address Match breakpoint that links to this breakpoint. See Breakpoint instruction address comparisons.
- -Asuccessful VMID match defined by this breakpoint.
- Generation of a Watchpoint exception depends on both:
- -Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.
- -Asuccessful VMID match defined by this breakpoint, as described in Breakpoint context comparisons.

DBGBCR&lt;n&gt;.{LBNX, LBN, SSC, HMC, BAS, PMC} for this breakpoint are ignored.

## 0b1010 , Context ID and VMID Match breakpoint

BT == 0b1010 is a reserved value if either:

- The breakpoint is not a context-matching breakpoint.
- EL2 is not implemented.

For context-matching breakpoints, generation of a Breakpoint exception depends on all of the following:

- DBGBCR&lt;n&gt;.{SSC, HMC, PMC}. These define the execution conditions that the breakpoint generates Breakpoint exceptions for. See Execution conditions for which a breakpoint generates Breakpoint exceptions.
- Asuccessful Context ID match, as described in Breakpoint context comparisons.
- Asuccessful VMID match.

The value of DBGBVR&lt;n&gt;.ContextID is compared with CONTEXTIDR.

Breakpoint context comparisons describes the requirements for a successful Context ID match and a successful VMID match.

DBGBCR&lt;n&gt;.{LBNX, LBN, BAS} for this breakpoint are ignored.

## 0b1011 , Context ID and VMID Match breakpoint with linking enabled

BT == 0b1011 is a reserved value if either:

- The breakpoint is not a context-matching breakpoint.
- EL2 is not implemented.

For context-matching breakpoints, either:

- This breakpoint does not generate any debug exceptions, if no Linked breakpoints or Linked watchpoints link to it.
- Generation of a Breakpoint exception depends on all of the following:
- -Asuccessful instruction address match, defined by a Linked Address breakpoint that links to this breakpoint, see Breakpoint instruction address comparisons.
- -Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.
- -Asuccessful VMID match defined by this breakpoint.
- Generation of a Watchpoint exception depends on all of the following:
- -Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.
- -Asuccessful Context ID match defined by this breakpoint, as described in Breakpoint context comparisons.
- -Asuccessful VMID match defined by this breakpoint.

The value of DBGBVR&lt;n&gt;.ContextID is compared with CONTEXTIDR.

Breakpoint context comparisons describes the requirements for a successful Context ID match and a successful VMID match by this breakpoint.

DBGBCR&lt;n&gt;.{LBNX, LBN, SSC, HMC, BAS, PMC} for this breakpoint are ignored.

## 0b1100 , CONTEXTIDR\_EL2 Match breakpoint

BT == 0b1100 is a reserved value if:

- The breakpoint is not a context-aware breakpoint.
- FEAT\_VHE is not implemented and FEAT\_Debugv8p2 is not implemented, which means the implementation does not include CONTEXTIDR\_EL2.
- EL2 is not implemented.

For context-aware breakpoints, generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;.{SSC, HMC, PMC}. These define the execution conditions for which the breakpoint generates Breakpoint exceptions.
- Asuccessful CONTEXTIDR\_EL2 match. The value of DBGBVR&lt;n&gt;.ContextID2 is compared with the Context ID value held in CONTEXTIDR\_EL2, as described in Breakpoint context comparisons.

The check against CONTEXTIDR\_EL2 means this breakpoint can be generated only if EL2 is implemented and enabled in the current Security state and EL2 is using AArch64.

Note

The operation of this breakpoint does not depend on the Effective value of HCR\_EL2.E2H.

DBGBCR&lt;n&gt;.{LBNX, LBN, BAS} for this breakpoint are ignored.

## 0b1101 , CONTEXTIDR\_EL2 Match with linking enabled

BT == 0b1101 is a reserved value if:

- The breakpoint is not a context-aware breakpoint.
- FEAT\_VHE is not implemented and FEAT\_Debugv8p2 is not implemented, which means the implementation does not include CONTEXTIDR\_EL2.
- EL2 is not implemented.

For context-aware breakpoints, either:

- If no Linked breakpoints or Linked watchpoints link to this breakpoint, then the breakpoint does not generate any debug exceptions.

- Generation of a Breakpoint exception depends on both:
- -Asuccessful instruction address match, defined by a Linked Address match breakpoint that links to this breakpoint, see Breakpoint instruction address comparisons.
- -Asuccessful CONTEXTIDR\_EL2 match, as described in Breakpoint context comparisons.
- Generation of a Watchpoint exception depends on both:
- -Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.
- -Asuccessful CONTEXTIDR\_EL2 match. The value of DBGBVR&lt;n&gt;.ContextID2 is compared with the Context ID value held in CONTEXTIDR\_EL2, as described in Breakpoint context comparisons.

The check against the CONTEXTIDR\_EL2 means the breakpoint or watchpoint can be generated only if EL2 is implemented and enabled in the current Security state and EL2 is using AArch64.

Note

The operation of this breakpoint does not depend on the Effective value of HCR\_EL2.E2H.

DBGBCR&lt;n&gt;.{LBNX, LBN, SSC, HMC, BAS, PMC} for this breakpoint are ignored.

## 0b1110 , Full Context ID Match breakpoint

BT == 0b1110 is a reserved value if:

- The breakpoint is not a context-aware breakpoint.
- FEAT\_VHE is not implemented and FEAT\_Debugv8p2 is not implemented, which means the implementation does not include CONTEXTIDR\_EL2.
- EL2 is not implemented.

For context-aware breakpoints, generation of a Breakpoint exception depends on both:

- DBGBCR&lt;n&gt;.{SSC, HMC, PMC}. These define the execution conditions for which the breakpoint generates Breakpoint exceptions.
- Asuccessful Context ID match, as described in Breakpoint context comparisons.

The Context ID check is made by checking both:

- The value of DBGBVR&lt;n&gt;.ContextID against the value in CONTEXTIDR, or CONTEXTIDR\_EL1.
- The value of DBGBXVR&lt;n&gt;.ContextID2 against the value in CONTEXTIDR\_EL2.

Both comparisons must match for the check to succeed.

The check against the CONTEXTIDR\_EL2 means this breakpoint can be generated only if EL2 is implemented and enabled in the current Security state and EL2 is using AArch64.

Note

The operation of this breakpoint does not depend on the Effective value of HCR\_EL2.E2H.

DBGBCR&lt;n&gt;.{LBNX, LBN, BAS} for this breakpoint are ignored.

## 0b1111 , Full Context ID Match breakpoint with linking enabled

BT == 0b1111 is a reserved value if:

- The breakpoint is not a context-aware breakpoint.
- FEAT\_VHE is not implemented and FEAT\_Debugv8p2 is not implemented, which means the implementation does not include CONTEXTIDR\_EL2.
- EL2 is not implemented.

For context-aware breakpoints, one of the following applies:

- If no Linked breakpoints or Linked watchpoints link to this breakpoint, then the breakpoint does not generate any debug exceptions.

- Generation of a Breakpoint exception depends on both:

- [ ] - Asuccessful instruction address match, defined by a Linked Address match breakpoint that links to this breakpoint, see Breakpoint instruction address comparisons.

- Asuccessful Context ID match, as described in Breakpoint context comparisons.

- Generation of a Watchpoint exception depends on both:

- [ ] - Asuccessful data address match, defined by a Linked watchpoint that links to this breakpoint, see Watchpoint data address comparisons.

- Asuccessful Context ID match, as described in Breakpoint context comparisons.

The Context ID check is made by checking both:

- The value of DBGBVR&lt;n&gt;.ContextID against the value in CONTEXTIDR, or CONTEXTIDR\_EL1.

- The value of DBGBXVR&lt;n&gt;.ContextID2 against the value in CONTEXTIDR\_EL2.

Both comparisons must match for the check to succeed.

The check against the CONTEXTIDR\_EL2 means the breakpoint or watchpoint can be generated only if EL2 is implemented and enabled in the current Security state and EL2 is using AArch64.

Note

The operation of this breakpoint does not depend on the Effective value of HCR\_EL2.E2H.

DBGBCR&lt;n&gt;.{LBNX, LBN, SSC, HMC, BAS, PMC} for this breakpoint are ignored.

Note

See Reserved DBGBCR&lt;n&gt;.BT values for the behavior of breakpoints programmed with reserved BT values.

## G2.8.3 Execution conditions for which a breakpoint generates Breakpoint exceptions

Each breakpoint can be programmed so that it only generates Breakpoint exceptions for certain execution conditions. For example, a breakpoint might be programmed to generate Breakpoint exceptions only when the PE is executing at PL0 in Secure state.

DBGBCR&lt;n&gt;.{SSC, HMC, PMC} define the execution conditions the breakpoint generates Breakpoint exceptions for, as follows:

## Security State Control, SSC

Controls whether the breakpoint generates Breakpoint exceptions only in Secure state, only in Non-secure state, or in both Security states.

Note

This is determined by the Security state of the PE, not from the NS attribute returned by the translation of the virtual address on which the breakpoint is set.

## Higher Mode Control, HMC, and Privileged Mode Control, PMC

HMCand PMC together control which AArch32 modes the breakpoint generates Breakpoint exceptions in.

Table G2-10 shows the valid combinations of the values of HMC, SSC, and PMC, and for each combination shows which Privilege levels breakpoints generate Breakpoint exceptions in.

In the table:

Y

-

Means that a breakpoint programmed with the values of HMC, SSC and PMC shown in that row can generate Breakpoint exceptions in AArch32 modes at that Privilege level.

Means that a breakpoint programmed with the values of HMC, SSC and PMC shown in that row cannot generate Breakpoint exceptions in AArch32 modes at that Privilege level.

Acombination in Table G2-10 might be reserved if an Exception level or Security state is not implemented. For information about which combinations of HMC, SSC and PMC are reserved if an Exception level or Security state are not implemented, see Reserved DBGBCR&lt;n&gt;.{SSC, HMC, PMC} values.

Table G2-10 Summary of breakpoint HMC, SSC, and PMC encodings

|   HMC |   SSC |   PMC | Security state the breakpoint is programmed to match in   | PL2 a   | PL1   | PL0   |
|-------|-------|-------|-----------------------------------------------------------|---------|-------|-------|
|     0 |    00 |    00 | Both                                                      | -       | Y b   | Y     |
|     0 |    00 |    01 | Both                                                      | -       | Y     | -     |
|     0 |    00 |    10 | Both                                                      | -       | -     | Y     |
|     0 |    00 |    11 | Both                                                      | -       | Y     | Y     |
|     0 |    01 |    00 | Non-secure                                                | -       | Y b   | Y     |
|     0 |    01 |    01 | Non-secure                                                | -       | Y     | -     |
|     0 |    01 |    10 | Non-secure                                                | -       | -     | Y     |
|     0 |    01 |    11 | Non-secure                                                | -       | Y     | Y     |
|     0 |    10 |    00 | Secure                                                    | -       | Y b   | Y     |
|     0 |    10 |    01 | Secure                                                    | -       | Y     | -     |
|     0 |    10 |    10 | Secure                                                    | -       | -     | Y     |
|     0 |    10 |    11 | Secure                                                    | -       | Y     | Y     |
|     0 |    11 |    01 | Secure                                                    | Y       | Y     | -     |
|     0 |    11 |    11 | Secure                                                    | Y       | Y     | Y     |
|     1 |    00 |    01 | Both                                                      | Y       | Y     | -     |
|     1 |    00 |    11 | Both                                                      | Y       | Y     | Y     |
|     1 |    01 |    00 | Non-secure                                                | Y       |       | -     |
|     1 |    01 |    01 | Non-secure                                                | Y       | Y     | -     |
|     1 |    01 |    11 | Non-secure                                                | Y       | Y     | Y     |
|     1 |    10 |    01 | Secure                                                    | Y       | Y     | -     |
|     1 |    10 |    11 | Secure                                                    | Y       | Y     | Y     |
|     1 |    11 |    00 | Both                                                      | Y       | -     | -     |
|     1 |    11 |    01 | Both                                                      | Y       | Y     | -     |
|     1 |    11 |    11 | Both                                                      | Y       | Y     | Y     |

All combinations of HMC, SSC, and PMC that this table does not show are reserved. See Table G2-13.

## G2.8.4 Breakpoint instruction address comparisons

Address comparisons are made for each instruction in the program flow. The following subsections describe the criteria for a successful address comparison, for:

- Address Match breakpoints.
- Address Mismatch breakpoints.

## G2.8.4.1 Address Match breakpoints

An address match comparison is successful if both:

- Bits [31:2] of the current instruction virtual address are equal to DBGBVR&lt;n&gt;[31:2].
- The word or halfword selected by DBGBCR&lt;n&gt;.BAS matches. That is, either:
- -DBGBCR&lt;n&gt;.BAS is programmed with 0b0011 or 0b1111 , and the instruction is at a word-aligned address.
- -DBGBCR&lt;n&gt;.BAS is programmed with 0b1100 , and the instruction is not at a word-aligned address.

See Specifying the halfword-aligned address that an Address breakpoint matches on.

Note

DBGBVR&lt;n&gt;[1:0] are RES0 and are ignored.

## G2.8.4.2 Address Mismatch breakpoints

An address mismatch comparison is successful if either:

- Bits [31:2] of the current instruction virtual address are not equal to DBGBVR&lt;n&gt;[31:2].
- The word or halfword selected by DBGBCR&lt;n&gt;.BAS does not match. That is, either:
- -DBGBCR&lt;n&gt;.BAS is programmed with 0b0011 or 0b1111 , and the instruction is not at a word-aligned address.
- -DBGBCR&lt;n&gt;.BAS is programmed with 0b1100 , and the instruction is at a word-aligned address.

See Specifying the halfword-aligned address that an Address breakpoint matches on.

## Note

- DBGBVR&lt;n&gt;[1:0] are RES0 and are ignored.
- Address Mismatch breakpoints can be used to single-step through code. See Using an Address Mismatch breakpoint to single-step an instruction.

## G2.8.4.3 Specifying the halfword-aligned address that an Address breakpoint matches on

For an Address breakpoint, a debugger can use the Byte Address Selection field, DBGBCR&lt;n&gt;.BAS, so that the address comparison is successful on one of:

- The whole word starting at address DBGBVR&lt;n&gt;[31:2]:00.
- The halfword starting at address DBGBVR&lt;n&gt;[31:2]:00.
- The halfword starting at address ((DBGBVR&lt;n&gt;[31:2]:00) + 2).

Note

The address programmed into the DBGBVR&lt;n&gt; must be word-aligned.

DBGBCR&lt;n&gt;.BAS can be used in both Address Match breakpoints and Address Mismatch breakpoints, as follows:

- For an Address Match breakpoint, DBGBCR&lt;n&gt;.BAS selects which halfword-aligned address the breakpoint must generate a Breakpoint exception for. This means that an address comparison is successful only if both of the following match:
- -The instruction address held in bits [31:2] of the DBGBVR&lt;n&gt;.

- -The halfword defined by the BAS field.

That is, a successful address comparison = DBGBVR&lt;n&gt;[31:2] match AND BAS match.

- For an Address Mismatch breakpoint, DBGBCR&lt;n&gt;.BAS selects which halfword-aligned address the breakpoint must not generate a Breakpoint exception for. This means that an address comparison is successful if either or both of the following do not match:
- -The instruction address held in bits [31:2] of the DBGBVR&lt;n&gt;.
- -The halfword defined by the BAS field.

That is, a successful address comparison = NOT (DBGBVR&lt;n&gt;[31:2] match AND BAS match).

The following subsections show the supported BAS values:

- Using the BAS field in Address Match breakpoints.
- Using the BAS field in Address Mismatch breakpoints.

For Context breakpoints, DBGBCR&lt;n&gt;.BAS is RES1 and is ignored.

## G2.8.4.3.1 Using the BAS field in Address Match breakpoints

The supported BAS values are:

0b0000 This value is reserved. Behavior is a CONSTRAINED UNPREDICTABLE choice of:

- The breakpoint is disabled.
- The breakpoint behaves as if BAS is 0b0011 , 0b1100 , or 0b1111 .

0b0011 The breakpoint generates a Breakpoint exception if an instruction with an address described as follows is committed for execution:

- Bits [31:2] of the address equals DBGBVR&lt;n&gt;[31:2].
- Bits [1:0] of the address are 0b00 .

This means that breakpoints programmed with this BAS value generate Breakpoint exceptions for all of the following:

- 32-bit T32 instructions at word-aligned addresses.
- 16-bit T32 instructions at word-aligned addresses.
- A32 instructions. These are always at word-aligned addresses.

However, Arm recommends that a debugger uses this BAS value only for T32 instructions.

It is CONSTRAINED UNPREDICTABLE whether a breakpoint programmed with this BAS value generates a Breakpoint exception on the second halfword of a 32-bit T32 instruction starting at the halfword-aligned address ((DBGBVR&lt;n&gt;[31:2]:00) - 2).

- 0b1100 The breakpoint generates a Breakpoint exception if an instruction with an address described as follows is committed for execution:
- Bits [31:2] of the address equals DBGBVR&lt;n&gt;[31:2].
- Bits [1:0] of the address are 0b10 .

This means that breakpoints programmed with this BAS value generate Breakpoint exceptions for both of the following:

- 32-bit T32 instructions at addresses that are halfword-aligned but not word-aligned.
- 16-bit T32 instructions at addresses that are halfword-aligned but not word-aligned.

It is CONSTRAINED UNPREDICTABLE whether a breakpoint programmed with this BAS value generates a Breakpoint exception on the second halfword of a 32-bit T32 or A32 instruction starting at a word-aligned address.

- 0b1111 The breakpoint generates a Breakpoint exception if an instruction with an address described as follows is committed for execution:

- Bits [31:2] of the address equals DBGBVR&lt;n&gt;[31:2].
- Bits [1:0] of the address are 0b00 .

This means that breakpoints programmed with this BAS value generate Breakpoint exceptions for all of the following:

- 32-bit T32 instructions at word-aligned addresses.
- 16-bit T32 instructions at word-aligned addresses.
- A32 instructions. These are always at word-aligned addresses.

However, Arm recommends that a debugger uses this BAS value only for A32 instructions.

It is CONSTRAINED UNPREDICTABLE whether a breakpoint programmed with this BAS value generates a Breakpoint exception on the second halfword of a 32-bit T32 instruction starting at the halfword-aligned address ((DBGBVR&lt;n&gt;[31:2]:00) - 2).

It is CONSTRAINED UNPREDICTABLE whether a breakpoint programmed with this BAS value generates a Breakpoint exception on a 32-bit T32 instruction or a 16-bit T32 instruction at the halfword-aligned address ((DBGBVR&lt;n&gt;[31:2]:00) + 2).

All other BAS values are reserved. For these reserved other values, DBGBCR&lt;n&gt;.BAS[3,1] ignore writes and read the same values as DBGBCR&lt;n&gt;[2,0] respectively. This means that the smallest instruction size a debugger can program breakpoints to match on is a halfword.

Figure G2-2 shows a summary of when breakpoints programmed with particular BAS values generate Breakpoint exceptions.

The figure contains four parts:

- Acolumn showing the row number, on the left.
- An instruction set and instruction size table.
- Alocation of instruction figure.
- ABASfield values table, on the right.

To use the figure, read across the rows. For example:

- Row 2 shows that a breakpoint with a BAS value of 0b1100 generates Breakpoint exceptions for 16-bit T32 instructions starting at the halfword-aligned address ((DBGBVR&lt;n&gt;[31:2]:00) + 2).
- Row 6 shows that a breakpoint with a BAS value of either 0b0011 or 0b1111 generates Breakpoint exceptions for A32 instructions. A32 instructions are always at word-aligned addresses.

In the figure:

| Yes   | Means that the breakpoint generates a Breakpoint exception.                                                                                              |
|-------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| No    | Means that the breakpoint does not generate a Breakpoint exception.                                                                                      |
| UNP   | Means that it is CONSTRAINED UNPREDICTABLE whether the breakpoint generates a Breakpoint exception. See Other usage constraints for Address breakpoints. |

|       | Instruction set   | Size   |
|-------|-------------------|--------|
| Row 1 | T32               | 16-bit |
| ROW 2 |                   | 16-bit |
| ROW 3 | T32               | 32-bit |
| Row 4 |                   | 32-bit |
| ROW 5 |                   | 32-bit |
| Row 6 | A32               | 32-bit |

<!-- image -->

| 0b0011 BAS[3:0]   | 0b1100   | 0b1111   |
|-------------------|----------|----------|
| Yes               | No       | Yes      |
| No                | Yes      | UNP      |
| UNP               | No       | UNP      |
| Yes               | UNP      | Yes      |
| No                | Yes      | UNP      |
| Yes               | UNP      | Yes      |

- a.  0 means the word-aligned address held in the DBGBVRn. The other locations are as follows:
-    -2 means ((DBGBVRn[31:2]:00) - 2).
-    -1 means ((DBGBVRn[31:2]:00) - 1).
-    ...
-    ...
-    +5 means ((DBGBVRn[31:2]:00) + 5).

The solid areas show the location of the instruction.

## Figure G2-2 Summary of BAS field meanings for Address Match breakpoints

## G2.8.4.3.2 Using the BAS field in Address Mismatch breakpoints

An Address Mismatch breakpoint generates Breakpoint exceptions for all instructions committed for execution, except the instruction whose address the breakpoint is programmed to match.

The supported BAS values are:

- 0b0000 The breakpoint ignores the address held in the DBGBVR&lt;n&gt; and generates Breakpoint exceptions for

all instruction addresses.

- 0b0011 The breakpoint does not generate a Breakpoint exception if an instruction with an address described as follows is committed for execution:
- Bits [31:2] of the address equals DBGBVR&lt;n&gt;[31:2].
- Bits [1:0] of the address are 0b00 .

This means that breakpoints programmed with this BAS value do not generate Breakpoint exceptions for any of the following:

- 32-bit T32 instructions at word-aligned addresses.
- 16-bit T32 instructions at word-aligned addresses.
- A32 instructions. These are always at word-aligned addresses.

However, Arm recommends that a debugger uses this BAS value only for T32 instructions.

It is CONSTRAINED UNPREDICTABLE whether a breakpoint programmed with this BAS value does not generate a Breakpoint exception on the second halfword of a 32-bit T32 instruction starting at the halfword-aligned address ((DBGBVR&lt;n&gt;[31:2]:00) - 2).

0b1100 The breakpoint does not generate a Breakpoint exception if an instruction with an address described as follows is committed for execution:

- Bits [31:2] equals DBGBVR&lt;n&gt;[31:2].
- Bits [1:0] of the address are 0b10 .

This means that breakpoints programmed with this BAS value do not generate Breakpoint exceptions for either of the following:

- 32-bit T32 instructions at addresses that are halfword-aligned but not word-aligned.
- 16-bit T32 instructions at addresses that are halfword-aligned but not word-aligned.

It is CONSTRAINED UNPREDICTABLE whether a breakpoint programmed with this BAS value does not generate a Breakpoint exception on the second halfword of a 32-bit T32 or A32 instruction at a word-aligned address.

0b1111 The breakpoint does not generate a Breakpoint exception if an instruction with an address described as follows is committed for execution:

- Bits [31:2] of the address equals DBGBVR&lt;n&gt;[31:2].
- Bits [1:0] of the address are 0b00 .

This means that breakpoints programmed with this BAS value do not generate Breakpoint exceptions for any of the following:

- 32-bit T32 instructions at word-aligned addresses.
- 16-bit T32 instructions at word-aligned addresses.
- A32 instructions. These are always at word-aligned addresses.

However, Arm recommends that a debugger uses this BAS value only for A32 instructions.

It is CONSTRAINED UNPREDICTABLE whether a breakpoint programmed with this BAS value does not generate a Breakpoint exception on the second halfword of a 32-bit T32 instruction starting at the halfword-aligned address ((DBGBVR&lt;n&gt;[31:2]:00) - 2).

It is CONSTRAINED UNPREDICTABLE whether a breakpoint programmed with this BAS value does not generate a Breakpoint exception on a 32-bit T32 instruction or a 16-bit T32 instruction at the halfword-aligned address ((DBGBVR&lt;n&gt;[31:2]:00) + 2).

All other BAS values are reserved. For these reserved other values, DBGBCR&lt;n&gt;.BAS[3,1] ignore writes and read the same values as DBGBCR&lt;n&gt;[2,0] respectively. This means that the smallest instruction size that a breakpoint can never generate a Breakpoint exception for is a halfword.

Figure G2-3 shows a summary of when breakpoints programmed with particular BAS values generate Breakpoint exceptions.

The figure contains four parts:

- Acolumn showing the row number, on the left.
- An instruction set and instruction size table.
- Alocation of instruction figure.
- ABASfield values table, on the right.

To use the figure, read across the rows. For example:

- Row 1 shows that a breakpoint with a BAS value of 0b1100 generates Breakpoint exceptions for 16-bit T32 instructions starting at the word-aligned address held in the DBGBVR&lt;n&gt;.
- Row 5 shows that a breakpoint with a BAS value of 0b0011 generates Breakpoint exceptions for 32-bit T32 instructions starting at the halfword-aligned address immediately after the word aligned address held in the DBGBVR&lt;n&gt;.

In the figure:

| Yes   | Means that the breakpoint does generate a Breakpoint exception.                                                                                          |
|-------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| No    | Means that the breakpoint does not generate a Breakpoint exception.                                                                                      |
| UNP   | Means that is it CONSTRAINED UNPREDICTABLE whether the breakpoint generates a Breakpoint exception. See Other usage constraints for Address breakpoints. |

|       | Instruction set   | Size   |
|-------|-------------------|--------|
| Row 1 | T32               | 16-bit |
| ROW 2 |                   | 16-bit |
| ROW 3 | T32               | 32-bit |
| Row 4 |                   | 32-bit |
| ROW 5 |                   | 32-bit |
| Row 6 | A32               | 32-bit |

<!-- image -->

| BAS[3:0] 0b0000   | 0b0011   | 0b1100   | 0b1111   |
|-------------------|----------|----------|----------|
| Yes               | No       | Yes      | No       |
| Yes               | Yes      | No       | UNP      |
| Yes               | UNP      | Yes      | UNP      |
| Yes               | No       | UNP      | No       |
| Yes               | Yes      | No       | UNP      |
| Yes               | No       | UNP      | No       |

- a.  0 means the word-aligned address held in the DBGBVRn. The other locations are as follows:
-    -2 means ((DBGBVRn[31:2]:00) - 2).
-    -1 means ((DBGBVRn[31:2]:00) - 1).

•    ...

•    ...

-    +5 means ((DBGBVRn[31:2]:00) + 5).

The solid areas show the location of the instruction.

Figure G2-3 Summary of BAS field meanings for Address Mismatch breakpoints

## G2.8.5 Breakpoint context comparisons

The breakpoint type defined by DBGBCR&lt;n&gt;.BT determines what context comparison is required, if any. Table G2-11 shows the BT values that require a comparison, and the match required for the comparison to be successful.

Table G2-11 Breakpoint Context ID and VMID comparison tests

| DBGBCR<n>.BT   | Test required for successful context comparison                                                                                                                                                                                                                                                                            |
|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b001x         | • When FEAT_VHE is implemented, EL2 is using AArch64, the Effective value of HCR_EL2.E2H is 1, and either the PE is executing at EL0 with HCR_EL2.TGE set to 1, or the PE is executing at EL2, CONTEXTIDR_EL2 must match the DBGBVR<n>. ContextID value. • Otherwise, CONTEXTIDR must match the DBGBVR<n>.ContextID value. |
| 0b011x         | CONTEXTIDR, or CONTEXTIDR_EL1, must match the DBGBVR<n>.ContextID value.                                                                                                                                                                                                                                                   |
| 0b100x         | VTTBR.VMID must match the DBGBXVR<n>.VMID value.                                                                                                                                                                                                                                                                           |
| 0b101x         | CONTEXTIDR, or CONTEXTIDR_EL1, must match the DBGBVR<n>.ContextID value, and VTTBR.VMID must match the DBGBXVR<n>.VMID value.                                                                                                                                                                                              |
| 0b110x         | CONTEXTIDR_EL2 must match the DBGBXVR<n>.ContextID2 value.                                                                                                                                                                                                                                                                 |
| 0b111x         | Both: • CONTEXTIDR, or CONTEXTIDR_EL1, must match the DBGBVR<n>.ContextID value. • CONTEXTIDR_EL2 must match the DBGBXVR<n>.ContextID2 value.                                                                                                                                                                              |

No context comparison is required for other valid DBGBCR&lt;n&gt;.BT values.

Context breakpoints do not generate Breakpoint exceptions when any of:

- The comparison uses the value of CONTEXTIDR, or CONTEXTIDR\_EL1, and any of:
- -The PE is executing at EL3 using AArch64.
- -The PE is executing at EL2.
- -FEAT\_VHE is implemented, EL2 is using AArch64, EL2 is implemented and enabled in the current Security state, and the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.
- The comparison uses the value of CONTEXTIDR\_EL2 and any of:

- -Neither FEAT\_VHE is implemented, nor FEAT\_Debugv8p2 is implemented.
- -EL2 is either not implemented or not enabled in the current Security state.
- -EL2 is using AArch32.
- The comparison uses the current VMID value and any of:
- -EL2 is not implemented.
- -EL2 is either not implemented or not enabled in the current Security state.
- -The PE is executing at EL2.
- -FEAT\_VHE is implemented, EL2 is using AArch64, EL2 is implemented and enabled in the current Security state, and the Effective value of HCR\_EL2.{E2H, TGE} is {1, 1}.

Note

- For all Context breakpoints, DBGBCR&lt;n&gt;.BAS is RES1 and is ignored.
- For Linked Context breakpoints, DBGBCR&lt;n&gt;.{LBN, SSC, HMC, PMC} are RES0 and are ignored.

## G2.8.6 Using breakpoints

This section contains the following:

- Using an Address Mismatch breakpoint to single-step an instruction.
- ITD control effects on address breakpoints on the first instruction in an IT block.
- Breakpoint usage constraints.

## G2.8.6.1 Using an Address Mismatch breakpoint to single-step an instruction

In execution conditions that an Address Mismatch breakpoint matches, defined by DBGBCR&lt;n&gt;.{LBN, SSC, PMC}, the breakpoint generates Breakpoint exceptions for all instructions committed for execution, except the instruction whose address the breakpoint is programmed with. Figure G2-4 shows an example of Address Mismatch breakpoint operation, for an Address Mismatch breakpoint programmed with address 0x1014 .

<!-- image -->

## Figure G2-4 Operation of an Address Mismatch breakpoint

This means that an Address Mismatch breakpoint can be used to single-step an instruction.

In the example shown in Figure G2-4:

- If the target of a branch is an instruction other than the instruction at address 0x1014 , the breakpoint generates a Breakpoint exception when the instruction is committed for execution.

- If the target of a branch is the instruction at address 0x1014 , the PE executes the instruction at 0x1014 and the breakpoint does not generate a Breakpoint exception until the instruction at address 0x1018 is committed for execution. The instruction at address 0x1014 is therefore single-stepped.

However, if the instruction at 0x1014 generates a synchronous exception, or if the PE takes an asynchronous exception while the instruction is being stepped, the breakpoint is evaluated again after taking the exception. This means that behavior is as follows:

- -If the exception handler executes in execution conditions that the breakpoint matches, the breakpoint generates a Breakpoint exception for the exception vector, because the exception vector is not address 0x1014 . This means that software execution steps into the exception.
- -If the exception handler executes in execution conditions that the breakpoint does not match, the breakpoint does not generate any Breakpoint exceptions after the PE has taken the exception, until the exception handler completes and executes an exception return instruction. The effect is to step over the exception. Whether the instruction is stepped again depends on whether the target of the exception return instruction is the instruction at 0x1014 or the instruction at 0x1018 .

If the instruction at 0x1014 is single-stepped and branches to itself, it is CONSTRAINED UNPREDICTABLE whether the breakpoint generates a Breakpoint exception after the PE has executed the branch.

This means that an instruction is only single-stepped if it is the target of a branch instruction and its address matches the address the breakpoint is programmed for. In the example shown in Figure G2-4, this is 0x1014 .

Usually this branch instruction is an exception return instruction that changes PE mode, branching from a PE mode in which the breakpoint does not generate a Breakpoint exception. A branch instruction that does not change PE mode would itself generate a Breakpoint exception. However, it might be a branch-to-self instruction as described above.

Because Address Mismatch breakpoints can single-step instructions, the behavior of an address mismatch Breakpoint exception is similar to the behavior of an AArch64 Software Step exception.

Note

- The example shown in Figure G2-4 assumes an A32 instruction. The same behavior applies for both 32-bit and 16-bit T32 instructions.
- Software Step exceptions are the highest priority synchronous exception. Breakpoint exceptions are lower priority. See Prioritization of Synchronous exceptions taken to AArch64 state.

## G2.8.6.2 ITD control effects on address breakpoints on the first instruction in an IT block

In an implementation that supports the ITD control, if the value of the ITD field that applies to the current Exception level is 1, all of the following are true:

- An IT instruction can only be used to apply to one 16-bit T32 instruction.
- Only certain combinations of an IT instruction and second single 16-bit T32 instruction are permitted.
- For a permitted combination, it is IMPLEMENTATION DEFINED whether the implementation treats the combination as:
- -Apair of 16-bit instructions.
- -One 32-bit instruction.

If the implementation treats the combination as one 32-bit instruction, then as described in Other usage constraints for Address breakpoints, an Address breakpoint might not generate a Breakpoint exception for an address match only on the second halfword of the instruction.

For this reason, if the ITD bit associated with the current Exception level is 1, Arm recommends that a debugger that wants to program a breakpoint to match on the second T32 instruction programs it to match on the IT instruction instead.

However, if returning from an exception whose preferred return address is the address of the second T32 instruction, then because the debugger is aware that the implementation has treated the combination as a pair of 16-bit instructions, the debugger is permitted to program the breakpoint to match on the second T32 instruction.

The ITD control fields are:

HSCTLR.ITD Applies to execution at EL2 when EL2 is using AArch32.

SCTLR.ITD

Applies to execution at EL0 or EL1 when EL1 is using AArch32.

## SCTLR\_EL1.ITD

Applies to execution at EL0 using AArch32 when EL1 is using AArch64.

An implementation that does not support the ITD control behaves as if the value of the ITD field is 0, and therefore the information in this section does not apply to such an implementation.

Note

Programming the breakpoint to match on the second T32 instruction might be necessary when using an Address Mismatch breakpoint for single stepping.

## G2.8.6.3 Breakpoint usage constraints

See the following sections:

- Reserved DBGBCR&lt;n&gt;.BT values.
- Reserved DBGBCR&lt;n&gt;.{SSC, HMC, PMC} values.
- Reserved DBGBCR&lt;n&gt;.BAS values.
- Reserved DBGBCR&lt;n&gt;.LBN values.
- Other usage constraints for Address breakpoints.
- Other usage constraints for Context breakpoints.

## G2.8.6.3.1 Reserved DBGBCR&lt;n&gt;.BT values

Table G2-12 shows when particular DBGBCR&lt;n&gt;.BT values are reserved.

Table G2-12 Reserved BT values

| BT value   | Breakpoint type          | Reserved                                                                                                    |
|------------|--------------------------|-------------------------------------------------------------------------------------------------------------|
| 0b001x     | Context ID Match         | If the breakpoint is not context-aware                                                                      |
| 0b010x     | Address Mismatch         | If EDSCR.HDE is 1 and halting is allowed                                                                    |
| 0b011x     | CONTEXTIDR_EL1 Match     | If FEAT_VHE is not implemented, or the breakpoint is not context-aware                                      |
| 0b100x     | VMIDMatch                | If EL2 is not implemented, or the breakpoint is not context-aware                                           |
| 0b101x     | Context ID and VMIDMatch |                                                                                                             |
| 0b110x     | CONTEXTIDR_EL2 Match     | If FEAT_VHE is not implemented and FEAT_Debugv8p2 is not implemented, or if the                             |
| 0b111x     | Full Context ID Match    | breakpoint is not context-aware For these BT values, breakpoints are not generated if EL2 is using AArch32. |

If a breakpoint is programmed with one of these reserved BT values:

- The breakpoint must behave as if it is either:
- -Disabled.
- -Programmed with a BT value that is not reserved, other than for a direct or external read of DBGBCR&lt;n&gt;.
- For a direct or external read of DBGBCR&lt;n&gt;, if the reserved BT value:
- -Has no function for any execution conditions, the value read back is UNKNOWN.
- -Has a function for execution conditions other than the current execution conditions, the value read back is the value written. This permits software to save and restore the BT value so that the breakpoint functions for the other execution conditions.

The behavior of breakpoints with reserved BT values might change in future revisions of the architecture. For this reason, software must not rely on the behavior described here.

## G2.8.6.3.2 Reserved DBGBCR&lt;n&gt;.{SSC, HMC, PMC} values

Table G2-13 shows when particular combinations of DBGBCR&lt;n&gt;.{SSC, HMC, PMC} are reserved.

## Table G2-13 Reserved HMC, SSC, and PMC combinations

| HMC, SSC, and PMC combination                                                                                                                       | Reserved                                                                     |
|-----------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------|
| All combinations with SSC set to 0b01 or 0b10 .                                                                                                     | When EL3 is not implemented and EL2 is implemented and EL2 is implemented.   |
| Any combination where HMCorSSCis nonzero.                                                                                                           | When both of EL2 and EL3 are not implemented.                                |
| The combinations with SSC set to 0b11 and the combination with HMCset to 1, SSC set to 0b01 and PMCset to 0b00 .                                    | When EL2 is not implemented and EL3 is implemented.                          |
| Any combination where HMCorSSCis nonzero.                                                                                                           | When RMEis not implemented.                                                  |
| The combination with HMCset to 1, SSC set to 0b01 and PMCset to 0b00 , and the combinations with SSC set to 1, SSC set to 0b11 and PMCset to 0b00 . | When both of EL2 and EL3 are implemented, but Secure EL2 is not implemented. |
| Combinations not included in Table G2-10.                                                                                                           | Always.                                                                      |

For all breakpoints except Linked Context breakpoints, if a breakpoint is programmed with one of these reserved combinations:

- If the reserved combination has a function for other execution conditions:
- -The breakpoint must behave as if it is disabled.
- -Adirect or external read of DBGBCR&lt;n&gt;.{SSC, HMC, PMC} returns the values written. This means that software can save and restore the combination so that the breakpoint can function for the other execution conditions.
- If the reserved combination does not have a function for other execution conditions:
- -It must behave either as if it is programmed with a combination that is not reserved or as if it is disabled.
- -Adirect or external read of DBGBCR&lt;n&gt;.{SSC, HMC, PMC} returns UNKNOWN values.

If the breakpoint is a Linked Context breakpoint, then:

- The values of HMC, SSC, and PMC are ignored.
- Adirect or external read of DBGBCR&lt;n&gt;.{SSC, HMC, PMC} returns UNKNOWN values

The behavior of breakpoints with reserved combinations of HMC, SSC, and PMC might change in future revisions of the architecture. For this reason, software must not rely on the behavior described here.

## G2.8.6.3.3 Reserved DBGBCR&lt;n&gt;.BAS values

## For all Context breakpoints

DBGBCR&lt;n&gt;.BAS is RES1 and is ignored.

## For all Address breakpoints

The supported values of the BAS field for the Address Match and Address Mismatch breakpoints are shown in Specifying the halfword-aligned address that an Address breakpoint matches on.

If a breakpoint is programmed with a reserved BAS value:

- The breakpoint must behave as if it is either:
- -Disabled.
- -Programmed with a BAS value that is not reserved, other than for a direct or external read of DBGBCR&lt;n&gt;.

- Adirect or external read of DBGBCR&lt;n&gt;.BAS returns an UNKNOWN value.

Software must not rely on these properties as the behavior of reserved values might change in a future revision of the architecture.

## G2.8.6.3.4 Reserved DBGBCR&lt;n&gt;.LBN values

## For all Context breakpoints

DBGBCR&lt;n&gt;.LBN reads UNKNOWN and its value is ignored.

## For Linked Address breakpoints

ALinked Address breakpoint must link to a context-aware breakpoint. For a Linked Address breakpoint, any DBGBCR&lt;n&gt;.LBN value that is not for a context-aware breakpoint is reserved.

If a Linked Address breakpoint links to a breakpoint that is not implemented, or that is not context-aware, then reads of DBGBCR&lt;n&gt;.LBN return an unknown value and the behavior is CONSTRAINED UNPREDICTABLE. The Linked Address breakpoint behaves as if it is either:

- Disabled.
- Linked to an UNKNOWN context-aware breakpoint.

If a Linked Address breakpoint that links to a breakpoint that is implemented and that is context-aware, but that is either not enabled or not programmed as a Linked Context breakpoint, it behaves as if it is disabled.

## For Unlinked Address breakpoints

DBGBCR&lt;n&gt;.LBN reads UNKNOWN and its value is ignored.

## G2.8.6.3.5 Other usage constraints for Address breakpoints

## For all Address breakpoints

- DBGBVR&lt;n&gt;[1:0] are RES0 and are ignored.
- The DBGBXVR&lt;n&gt; is ignored.

## For Address Match breakpoints

- For 32-bit instructions, if a breakpoint matches on the address of the second halfword but not the address of the first halfword, it is CONSTRAINED UNPREDICTABLE whether the breakpoint generates a Breakpoint exception.
- If DBGBCR&lt;n&gt;.BAS is 0b1111 , it is CONSTRAINED UNPREDICTABLE whether the breakpoint generates a Breakpoint exception for a T32 instruction starting at address ((DBGBVR&lt;n&gt;[31:2]:00) + 2). For T32 instructions, Arm recommends that the debugger programs the BAS field with either 0b0011 or 0b1100 .

## For Address Mismatch breakpoints

The constraints are the same as those described in For Address Match breakpoints, except that if two Address Mismatch breakpoints are programmed to match in the same Exception level and Security state, it is CONSTRAINED UNPREDICTABLE whether or not the instruction is stepped or a Breakpoint debug even is generated.

## G2.8.6.3.6 Other usage constraints for Context breakpoints

## For all Context breakpoints

Any bits of DBGBVR&lt;n&gt; and DBGBXVR&lt;n&gt; that are not used to specify Context ID or VMID are RES0 and are ignored.

Note

This means that for Context ID Match breakpoints, the DBGBXVR&lt;n&gt; is RES0 and is ignored, and for VMIDMatch breakpoints, the DBGBVR&lt;n&gt; is RES0 and is ignored.

## For Linked Context breakpoints

If no Linked Address breakpoints or Linked Watchpoints link to a Linked Context breakpoint, the Linked Context breakpoint does not generate any Breakpoint exceptions.

## G2.8.7 Exception syndrome information and preferred return address for a Breakpoint exception

See the following:

- Exception syndrome information for a Breakpoint exception.
- Preferred return address for a Breakpoint exception.

Note

Usually, the term exception syndrome is used only for exceptions taken to Hyp mode, or to AArch64 state. The referenced section uses the term more generally, to include exception information reported in the IFSR.

## G2.8.7.1 Exception syndrome information for a Breakpoint exception

The PE takes a Breakpoint exception as either:

- APrefetch Abort exception if it is taken to PL1. In this case, it is taken to Abort mode.
- AHyptrap exception, if it is taken to PL2 because HCR.TGE or HDCR.TDE is 1. In this case, it is taken to Hyp mode.

If the exception is taken to:

## Abort mode

The PE sets all of the following:

- DBGDSCRext.MOE to 0b0001 , to indicate a Breakpoint exception.
- IFSR.FS to the code for a debug exception, 0b00010 .
- The IFAR with an UNKNOWN value.

The PE does all of the following:

- Records information about the exception in the Hypervisor Syndrome Register , HSR. See Table G2-14.
- Sets DBGDSCRext.MOE to 0b0001 , to indicate a Breakpoint exception.
- Sets the HIFAR to an unknown value.

## Hyp mode

## Table G2-14 Information recorded in the HSR

| HSR field                           | Information recorded                                                                                                                                                                                  |
|-------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Exception Class , EC                | The PE sets this to the code for a Prefetch Abort exception routed to Hyp mode, 0x20 .                                                                                                                |
| Instruction Length , IL             | The PE sets this to 1.                                                                                                                                                                                |
| Instruction Specific Syndrome , ISS | ISS[24:10] RES0. ISS[9] External Abort type (EA). The PE sets this to 0. ISS[8:6] RES0. ISS[5:0] Instruction Fault Status Code (IFSC). The PE sets this to the code for a debug exception, 0b100010 . |

Note

For information about how debug exceptions can be routed to PL2, see Routing debug exceptions.

## G2.8.7.2 Preferred return address for a Breakpoint exception

The preferred return address of a Breakpoint exception is the address of the instruction that was not executed because the PE took the Breakpoint exception instead.

This means that the preferred return address is the address of the instruction that caused the exception.

## G2.8.8 Pseudocode description of Breakpoint exceptions taken from AArch32 state

AArch32.BreakpointValueMatch() returns a pair of results:

- Aresult for Address Match and Context breakpoints.
- Aresult for Address Mismatch breakpoints.

AArch32.StateMatch() tests the values in DBGBCR&lt;n&gt;.{SSC, HMC, PMC} and, if the breakpoint links to a Linked Context breakpoint, also tests the Linked Context breakpoint.

AArch32.BreakpointMatch() tests a committed instruction against all breakpoints.

AArch32.CheckBreakpoint() generates a FaultRecord . ABreakpoint exception is taken if all of the following are true:

- DBGDSCRext.MDBGen is 1.
- Debug exceptions are enabled from the current Exception level and Security state. See Enabling debug exceptions.
- All of the conditions required for Breakpoint exception generation are met. See About Breakpoint exceptions.

Note

AArch32.CheckBreakpoint() might halt the PE and cause it to enter Debug state. External debug uses Debug state.

The AArch32.Abort() function processes the FaultRecord object returned by AArch32.CheckBreakpoint() , as described in Abort exceptions. When a Breakpoint exception is taken to AArch32 state, the AArch32.Abort() function generates a Prefetch Abort exception.