## C9.2.153 LDNT1H (scalar plus immediate, strided registers)

Contiguous load non-temporal of halfwords to multiple strided vectors (immediate index)

This instruction performs a contiguous non-temporal load of halfwords to elements of two or four strided vector registers from the memory address generated by a 64-bit scalar base and immediate index that is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address.

Inactive elements will not cause a read from Device memory or signal a fault, and are set to zero in the destination vector.

Anon-temporal load is a hint to the system that this data is unlikely to be referenced again soon.

It has encodings from 2 classes: Two registers and Four registers

## Two registers

(FEAT\_SME2)

<!-- image -->

## Encoding

```
LDNT1H { <Zt1>.H, <Zt2>.H }, <PNg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME2) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer g = UInt('1':PNg); constant integer nreg = 2; constant integer tstride = 8; constant integer t = UInt(T:'0':Zt); constant integer esize = 16; constant integer offset = SInt(imm4);
```

## Four registers

```
(FEAT_SME2)
```

<!-- image -->

## Encoding

```
LDNT1H { <Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <PNg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
```

## Decode for this encoding

```
if !IsFeatureImplemented(FEAT_SME2) then EndOfDecode(Decode_UNDEF); constant integer n = UInt(Rn); constant integer g = UInt('1':PNg); constant integer nreg = 4; constant integer tstride = 4; constant integer t = UInt(T:'00':Zt); constant integer esize = 16; constant integer offset = SInt(imm4);
```

## Assembler Symbols

## &lt;Zt1&gt;

For the 'Two registers' variant: is the name of the first scalable vector register Z0-Z7 or Z16-Z23 to be transferred, encoded as 'T:'0':Zt'.

For the 'Four registers' variant: is the name of the first scalable vector register Z0-Z3 or Z16-Z19 to be transferred, encoded as 'T:'00':Zt'.

## &lt;Zt2&gt;

For the 'Two registers' variant: is the name of the second scalable vector register Z8-Z15 or Z24-Z31 to be transferred, encoded as 'T:'1':Zt'.

For the 'Four registers' variant: is the name of the second scalable vector register Z4-Z7 or Z20-Z23 to be transferred, encoded as 'T:'01':Zt'.

## &lt;PNg&gt;

Is the name of the governing scalable predicate register PN8-PN15, with predicate-as-counter encoding, encoded in the 'PNg' field.

## &lt;Xn|SP&gt;

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the 'Rn' field.

## &lt;imm&gt;

For the 'Two registers' variant: is the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the 'imm4' field.

For the 'Four registers' variant: is the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the 'imm4' field.

## &lt;Zt3&gt;

Is the name of the third scalable vector register Z8-Z11 or Z24-Z27 to be transferred, encoded as 'T:'10':Zt'.

## &lt;Zt4&gt;

Is the name of the fourth scalable vector register Z12-Z15 or Z28-Z31 to be transferred, encoded as 'T:'11':Zt'.

## Operation

```
CheckStreamingSVEEnabled(); constant integer VL = CurrentVL; constant integer PL = VL DIV 8; constant integer elements = VL DIV esize; constant integer mbytes = esize DIV 8; bits(64) base; bits(64) addr; constant bits(PL) pred = P[g, PL]; constant bits(PL * nreg) mask = CounterToPredicate(pred<15:0>, PL * nreg); array [0..3] of bits(VL) values; constant boolean contiguous = TRUE;
```

```
constant boolean nontemporal = TRUE; integer transfer = t; constant boolean tagchecked = n != 31; constant AccessDescriptor accdesc = CreateAccDescSVE(MemOp_LOAD, nontemporal, contiguous, tagchecked); if !AnyActiveElement(mask, esize) then if n == 31 && ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then CheckSPAlignment(); else if n == 31 then CheckSPAlignment(); base = if n == 31 then SP[64] else X[n, 64]; addr = AddressAdd(base, offset * nreg * elements * mbytes, accdesc); for r = 0 to nreg-1 for e = 0 to elements-1 if ActivePredicateElement(mask, r * elements + e, esize) then Elem[values[r], e, esize] = Mem[addr, mbytes, accdesc]; else Elem[values[r], e, esize] = Zeros(esize); addr = AddressIncrement(addr, mbytes, accdesc); for r = 0 to nreg-1 Z[transfer, VL] = values[r]; transfer = transfer + tstride;
```

## Operational Information

This instruction is a data-independent-time instruction as described in About PSTATE.DIT.