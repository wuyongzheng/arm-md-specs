## 3.12 Fault models, recording and reporting

An incoming transaction goes through several logical stages before continuing into the system. If the transaction is of a type or has a property that an SMMU cannot support for IMPLEMENTATION DEFINED reasons, an Unsupported Upstream Transaction fault event is recorded and the transaction is terminated with an abort.

Otherwise, configuration is located for the transaction, given its StreamID (and SubstreamID, if supplied). If all of the required STE and CD structures cannot be located or are invalid, a configuration error event is recorded, if there is a free location in the Event queue, and the transaction is terminated with an abort.

If a valid configuration is located so that the translation tables can be accessed, the translation process begins, other faults can occur during this phase. See section 7.2 Event queue recorded faults and events for more information about the individual events that are recorded for configuration errors and faults.

When a transaction progresses as far as translation, or during the process of fetching a CD from IPA space through stage 2 translation, the behavior on encountering a fault becomes configurable, if this is supported by the implementation.

There are four fault types that constitute Translation-related faults when they are generated at either stage 1 or stage 2:

- F\_TRANSLATION
- F\_ADDR\_SIZE
- F\_ACCESS
- F\_PERMISSION

Behavior for these faults can be switched between the Terminate and Stall model as determined by the CD.{A,R,S} flags for stage 1 and the STE.{S2R,S2S} flags for stage 2.

All other faults (including F\_WALK\_EABT and F\_TLB\_CONFLICT) and configuration errors terminate the transaction with an abort.

Note: An F\_ADDR\_SIZE can also arise from a transaction that bypassed stage 1 but that has an out-of-range IPA, see section 3.4 Address sizes . In this case the transaction is always terminated with an abort.

Note: An F\_PERMISSION can also arise as a result of an instruction fetch transaction on a Secure stream that bypasses stage 1, is determined to be Non-secure and that is prevented with SMMU\_S\_CR0.SIF == 1, see section 6.3.57.2 SIF . In this case the transaction is always terminated with an abort.

The fault behavior configuration at stage 1 is at a per-substream granularity when substreams are used, that is where an STE points to multiple CDs. When substreams are not configured, that is where an STE points to one CD, the fault behavior configuration at stage 1 is at a per-stream granularity. Use of the Stall model at stage 1 can be disabled by setting STE.S1STALLD == 1.

The stage 2 fault behavior is configured using STE.{S2R,S2S}; that is, at a per-stream granularity.

When a fault occurs at either stage 1 or stage 2, then when the fault is detected it is known at which stage it occurred, and the SMMU performs the action configured for that stage. For example:

- A two-stage configuration that encounters a translation fault in the stage 1 translation tables is a stage 1 fault.
- A transaction that progresses through stage 1 to an IPA and then faults when it is translated using the stage 2 translation tables is a stage 2 fault.
- A stage 2 translation fault that occurs during a stage 1 translation table walk counts as a stage 2 fault. The event that is recorded differentiates this access from a transaction that access a faulting IPA post-stage 1 translation table walk, so that hypervisor software can inform the VM of the correct event type (a simulated external abort on translation table walk).
- A Stage 2 translation fault that occurs fetching a CD from an IPA address is a stage 2 fault. The event that is recorded shows that a CD was being fetched.

Note: The Hypervisor might fix the cause of the fault and retry the stalled transaction, or if the transaction is terminated, inform the VM of the correct event type (a simulated external abort on CD fetch).

After a transaction progresses through the SMMU into the system, certain system-specific transaction aborts might occur on the path to the memory system. Whether, and how, these are reported to the client device is interconnect-specific. The SMMU does not record any faults for these events. The SMMU only records fault events that are generated by its own accesses or by client device accesses that encounter an internal translation issue.

When an incoming transaction is immediately terminated, for any reason, an order is not enforced between the response to the client device and the event that is recorded into the Event queue. However, if an event is committed to be recorded for the terminated transaction, a CMD\_SYNC ensures that the event record is visible in the Event queue before the CMD\_SYNC is considered complete. See section 4.7.3 CMD\_SYNC(ComplSignal, MSIAddress, MSIData, MSIWriteAttributes) .

The SMMU treats a transaction as being independent of all other transactions (regardless of whether the transaction originates from the same traffic stream or from different streams) and the fault behavior of one transaction has no direct effect on any other transaction. Section 3.12.2 Stall model below describes interconnect ordering issues and recommendations for the presentation of grouped fault information to software. Whether an external agent makes an association between different transactions is outside the scope of the SMMU architecture.

When a transaction causes a Translation related fault at stage 1, the transaction might be:

- Terminated with an abort (CD.S == 0 and CD.A == 1)
- Terminated with RAZ/WI behavior (CD.S == 0 and CD.A == 0)
- Stalled (CD.S == 1 and STE.S1STALLD == 0)

When a transaction Translation related fault at stage 2, the transaction might be:

- Terminated with an abort (STE.S2S == 0)
- Stalled (STE.S2S == 1)

Support for stalling or terminating a transaction is IMPLEMENTATION DEFINED, indicated by SMMU\_(*\_)IDR0 .STALL\_MODEL.

When SMMU\_S\_IDR1.SECURE\_IMPL == 1:

- SMMU\_S\_IDR0.STALL\_MODEL indicates the physical capabilities of the SMMU implementation,
- SMMU\_IDR0.STALL\_MODEL indicates the capabilities that Non-secure software is permitted to use.
- -This field is generated from SMMU\_S\_IDR0.STALL\_MODEL and affected by the SMMU\_S\_CR0.NSSTALLD flag which, when set on an SMMU implementation supporting both the Stall model and the Terminate model, prevents Non-secure use of stalling faults.
- -Note: This can be used to guarantee Non-secure software cannot stall transactions where doing so might cause external problems in certain system topologies.

When SMMU\_S\_IDR1.SECURE\_IMPL == 0, SMMU\_IDR0.STALL\_MODEL reflects the physical capabilities of the SMMU implementation.

| SMMU_S_IDR0 .STALL_MODEL                    | SMMU_S_CR0 .NSSTALLD              | SMMU_IDR0 .STALL_MODEL                            | Notes:                                                                                 |
|---------------------------------------------|-----------------------------------|---------------------------------------------------|----------------------------------------------------------------------------------------|
| 0b00 (Stall and Terminate models supported) | 0 (do not filter NS use of stall) | 0b00 (Stall and Terminate model supported for NS) | NS usage reflects physical reality                                                     |
| 0b00 (Stall and Terminate models supported) | 1 (NS cannot use stall)           | 0b01 (Terminate model supported for NS)           | NS usage limited to terminate-only, even though physically the SMMUsupports stall too. |

| SMMU_S_IDR0 .STALL_MODEL         | SMMU_S_CR0 .NSSTALLD        | SMMU_IDR0 .STALL_MODEL           | Notes:                                                          |
|----------------------------------|-----------------------------|----------------------------------|-----------------------------------------------------------------|
| 0b01 (Terminate model supported) | X (No stall to filter)      | 0b01 (Terminate model supported) | NSSTALLD irrelevant, no stall to prevent.                       |
| 0b10 (Stall model supported)     | X (No alternative to stall) | 0b10 (Stall model supported)     | NSSTALLD irrelevant, no alternative to stall so cannot disable. |

The SMMU\_IDR0.TERM\_MODEL field indicates the termination models provided by an implementation, globally. An implementation might, for a stage 1 fault, offer the choice of terminate with abort or RAZ/WI behavior, or an implementation might only allow termination by abort, in which case the CD.A bit must be set.

Note: A transaction faulting at stage 2 is, when terminated, always aborted.

It is optional whether an SMMU implementation supports the Stall model, the Terminate model, or both. Where system usage cannot be anticipated, Arm recommends that both fault models (SMMU\_IDR0.STALL\_MODEL == 0) and both termination models (SMMU\_IDR0.TERM\_MODEL == 0) are implemented.

If there is a risk that the stability of the system is compromised when the stall configuration is used for a set of client devices you can consider the following countermeasures:

- An implementation that supports both the Stall and Terminate models is permitted, but not required, to treat a stalling configuration for these devices as a terminating configuration.
- -When stalling is configured for these devices, faulting transactions are terminated instead of stalled.
- -The faults are reported with Stall == 0.
- -The transaction is terminated with Abort.
- These devices are not required to be defined by the SMMU implementation, but are an IMPLEMENTATION DEFINED system property.

Note: For faulting transactions that are associated with client devices that have been configured to stall, but where the system has not explicitly advertised the client devices to be usable with the stall model, Arm recommends for software to expect that events might be recorded with Stall == 0.

## 3.12.1 Terminate model

When stage 1 is configured to terminate faults, a transaction that faults at stage 1 is either terminated with an abort reported to the client device that is making the access, or the transaction completing successfully with reads returning 0 and writes being ignored (RAZ/WI), depending on the setting of CD.A and SMMU\_IDR0.TERM\_MODEL. See section 5.5 Fault configuration (A, R, S bits) .

When stage 2 is configured to terminate faults, a transaction that faults at stage 2 is terminated with an abort.

The behavior of the client device after termination is specific to the device.

If a stage that is configured to terminate faults is also configured with CD.R == 1 or STE.S2R == 1, as appropriate to the stage of the fault, the SMMU records the details of the access into one Event record in the Event queue, supplying information including:

- Address
- Syndrome
- Attributes (Read/Write, Inst/Data, Privileged/Unprivileged, NS)
- Type (S1/S2 Translation, Permission, Address Size, Access flag fault)

If the Event queue is full, the event record is lost.

Note: In some interconnects, stalling the transaction until its fault can be recorded might trigger interconnect timeouts or deadlocks from which it might be more difficult to recover than from a lost fault record. Arm expects that such fault records arise from programming errors and that software will not implement any mechanism that depends on the delivery of terminate fault records.

Streams that originate from PCIe subsystems must not stall and must be configured to use the Terminate model at all enabled stages of translation. This is enforced at stage 1 through the STE.S1STALLD flag, see section 16.4 System integration .

## 3.12.2 Stall model

When a stage is configured to stall transactions on a fault, and a transaction experiences a Translation-related fault as described in 3.12 Fault models, recording and reporting , the faulting transaction does not progress and no response is reported to the client device. The transaction is buffered in a stalled state until subsequent resolution. The SMMU always records the details of the access into the Event queue. A stalled transaction is retried or terminated by issuing a CMD\_RESUME or CMD\_STALL\_TERM command.

If retry is chosen, the transaction is handled as though it had just arrived at the SMMU. This means that the transaction will be affected by any configuration or translation changes that occurred since it originally stalled.

Note: This means a transaction can stall and later when it is retried, use a configuration that causes it to immediately terminate, for example, a change to stall configuration in the meantime. This property can safely clean up stalled transactions on a stream by ensuring that a new configuration for transactions that are retried causes them to be terminated.

If a stalled transaction is terminated by a CMD\_RESUME command, a command parameter determines whether an abort is reported, or if SMMU\_IDR0.TERM\_MODEL == 0, whether the transactions completes with RAZ/WI behavior.

To ensure that no transaction is stalled indefinitely, software must ensure that every stall event has a corresponding CMD\_RESUME command, is subject to a CMD\_STALL\_TERM command, or that stalled transactions are terminated because translation is disabled by clearing SMMU\_(*\_)CR0.SMMUEN to 0.

When an event record is generated for a stalled transaction, a Stall Tag (STAG) is supplied by the SMMU as part of the record to uniquely identify the transaction. The SMMU uses the combination of StreamID and STAG parameters to CMD\_RESUME to identify the stalled transaction. A CMD\_RESUME command has no effect on any stalled transaction other than on the transaction that is uniquely identified by the combination of STAG and StreamID.

Note: This identification is required for virtualization correctness, where a CMD\_RESUME from a guest VM is trapped and reinterpreted by a hypervisor and generates a CMD\_RESUME to the SMMU. The hypervisor validates the correctness of the StreamID parameter, but the STAG parameter is passed directly from the guest, and cannot be trusted to be correct and cannot be the sole selector of a stalled transaction.

The format of the STAG field is IMPLEMENTATION SPECIFIC, with the restriction that a value cannot be re-used until the transaction it was last associated with has been acknowledged through a CMD\_RESUME or a CMD\_STALL\_TERM command, or translation is disabled by clearing SMMU\_(*\_)CR0.SMMUEN to 0.

If the Event queue is not writable at the time when the fault record of a stall is to be written, the stalled transaction is retried as though it had just arrived when the queue is next writable and a new fault record is generated. For more information about recording faults and events, see section 7.2 Event queue recorded faults and events .

Note: For software to be notified of stalled transactions, it must enable the Event queue using SMMU\_(*\_)CR0.EVENTQEN.

Software can depend on the delivery of fault records from stalled transactions, see section 3.12.4 Virtual Memory paging with SMMU .

Note: Retrying the stalled transaction when the queue becomes writable might lead to the transaction succeeding

or experiencing a different type of fault, if the configuration or translations were changed before the queue became writable. Therefore, an event can be written that is different to the originally-attempted event.

If the client device and interconnect rules allow it, a later transaction might pass through the SMMU and complete before an earlier stalled transaction that is associated with the same stream. The SMMU does not require any additional ordering between transactions from different streams beyond that required by the interconnect rules.

Note: The following cases are all considered to be from different streams:

- Transactions with different StreamIDs,
- Transactions with the same StreamID but different SubstreamIDs,
- Two transactions with the same StreamID but where only one transaction has a SubstreamID.

## 3.12.2.1 Suppression of duplicate Stall event records

If a transaction faults and then stalls, and a subsequent transaction belonging to the same stream also faults and then stalls, the SMMU is permitted but not required to suppress the generation of a new stall fault record for the new transaction if all of the following apply:

- The transactions require access to the same page.
- The transactions have the same privilege.
- The transactions have the same data/instruction attribute.
- The transactions have the same type, that is they are both reads or both writes.
- The transactions are associated with the same SubstreamID, if present.
- The first stalled transaction is still stalled when a subsequent transaction stalls.

Arm recommends that an implementation suppresses additional fault records where possible.

Note: It is not guaranteed that event records are suppressed in all possible scenarios. Software must ensure correctness where a transaction records a fault that duplicates a previous fault that was recorded for an earlier transaction.

When a stall fault record is acknowledged by a CMD\_RESUME command, any related suppressed stalled transaction are retried by the SMMU as though they had just arrived.

Note: A series of faults for one page might result in a single stall fault record, with a single CMD\_RESUME command enabling all stalled transactions for that page to progress. If the CMD\_RESUME command terminates the stalled transaction that is specified by the stall fault record, the re-trying of the other stalled transactions might cause new fault records to be recorded.

Note: For example, transactions A, B, C, D from the same stream that fault for the same reason might cause a single stall record for A to be recorded, and those for B, C, D to be suppressed. If software decides that the address was an error and terminates A, transactions B, C, D retry and fault again. A stall for B is recorded (and C, D might be suppressed). Software terminates B and the process repeats. Ultimately, A, B, C, D are all visible to software (rather than some being silently terminated), which can aid debug.

Stall fault records are not merged, see section 7.3.1 Event record merging .

Note: The suppression of identical stall fault records as described in this section is not the same as non-stall events being merged. When a stall record is suppressed, a stalled transaction still might exist and can affect future behavior, whereas the act of merging non-stall events completes the delivery of those events.

If a new transaction stalls for a reason that is unrelated to that of an existing stalled transaction, a new fault is recorded, - that is, it is not suppressed by dissimilar prior stalls even for the same StreamID and SubstreamID. Arm recommends that the new fault is recorded without being delayed by prior unrelated faults or CMD\_RESUME activities where possible.

The SMMU does not record more than one fault for each incoming transaction, with the exception of the scenario in which a transaction stalls, and is explicitly retried with CMD\_RESUME(Retry). After this command it is considered to be a new transaction and might again encounter a fault.

## 3.12.2.2 Early retry of Stalled transactions

The SMMU is permitted to speculatively retry a stalled transaction without first receiving a CMD\_RESUME(Retry) command that matches the stalled transaction, this is referred to as early retry . If this occurs:

- An early retry is similar in function to the retry caused by an explicit CMD\_RESUME(Retry). The transaction undergoes the full translation procedure and does not use any stale cached configuration or translation data that was invalidated since the time of the stall.
- A recorded stalled transaction causes a single fault record. An early retry of the stalled transaction does not cause additional faults to be recorded. When a retry is directly caused by a matching CMD\_RESUME that indicates a retry, it is not considered to be an early retry, and this rule does not apply. This rule is in keeping with the behavior that an explicit retry command causes the transaction to be retried as though it had just arrived at the SMMU.

Note: This rule includes the case where configuration has been changed to terminate faults after the transaction stalls then, under the new configuration, the transaction retries successfully by termination. Alternatively, if a retry occurs under stall fault configuration, the transaction remains stalled. Neither of these cases result in the reporting of a new event record.

- The progress of a transaction and the device-specific behavior are the only indications that an early retry has occurred that is visible to software.
- A successful early retry does not remove the requirement for software to acknowledge the stall fault record, see section 3.12.2 Stall model . A successful early retry does not remove the restriction on re-using STAG values, see section 3.12.2 Stall model . If targeted by CMD\_RESUME(Terminate) or CMD\_STALL\_TERM, a stalled transaction is eventually terminated, if the transaction does not early-retry and successfully progress into the system before the termination can take place. If the transaction early-retries and fails to successfully translate, it remains stalled until the termination action takes effect, or a successive early-retry enables the transaction to progress successfully.

A CMD\_RESUME(Retry) guarantees that the stalled transaction will be retried at a future point, unless it is terminated by CMD\_STALL\_TERM command or an SMMUEN transition before the retry. A stalled transaction is only guaranteed to be retried by the use of a CMD\_RESUME(Retry) command.

A CMD\_RESUME(Terminate) does not prevent a stalled transaction from being retried after the CMD\_RESUME is consumed by the SMMU, but guarantees that the transaction will be terminated if the transaction cannot successfully early-retry. Note: For example, if translations have not changed from the time that a fault was generated, a transaction cannot successfully early-retry.

Note: Arm does not expect software to modify a translation table descriptor from a faulting or invalid state into a valid state, and then terminate a transaction that has previously stalled because of the initial state of the descriptor. The transaction could early-retry, observe the valid state and then progress into the system.

If the SMMU is able to successfully early-retry a stalled faulting transaction before the original stall event is committed to be written to the Event queue, the SMMU is permitted to discard the fault event or to continue on and commit to the event write.

Note: To software, this race condition is indistinguishable from a temporally-later transaction that translates successfully the first time so a stall event record is not required. If an implementation records the event, the behavior described in this section applies.

If a stalled faulting transaction is retried before the original stall event is committed to be written to the event queue and experiences a fault that is different to the previous fault, the most recent fault is recorded, provided that it is possible to do so and that the previous fault is invisible.

Note: This scenario is permitted to occur when the Event queue is writable.

See section 7.2.1 Recording of events and conditions for writing to the Event queue for retry behavior requirements when the Event queue is not writable.

## 3.12.2.3 Miscellaneous Stall considerations

The number of transactions that can be stalled before the ingress port cannot accept any more transactions, from the same stream or from other streams, is IMPLEMENTATION SPECIFIC. Stalling traffic can therefore cause backpressure that affects the flow of traffic for other devices behind the SMMU.

If a stall blocks other traffic and resolving the fault condition that caused the stall involves transferring data using another device, the system architecture must ensure that the act of fetching the data will not itself stall behind the original transaction.

Note: STE.S1STALLD == 1 prevents a guest VM from using the Stall model. This guarantees that stalled transactions cannot affect other parts of the system, such as a different guest VM, where stalls could cause deadlocks. Arm expects that hypervisor software uses the virtualization of SMMU\_IDR0.STALL\_MODEL to report to the guest VM that the Stall model was not supported.

If a transaction experiences a fault during an IPA to PA translation of a stage 1 translation table walk or CD fetch, it is not required to be terminated and might stall, depending on the stage 2 fault configuration provided by STE.S2S. Software might address the cause of the stage 2 fault and retry the transaction, which will re-fetch the configuration and translation structures as necessary.

## 3.12.3 Considerations for client devices using the Stall fault model

If a transaction from a client device experiences a fault that stalls and is terminated by software issuing CMD\_RESUME(Terminate), the transaction is marked and guaranteed to terminate at some point in the future if translations do not change so as to allow an early-retry to succeed in the meantime. The SMMU does not guarantee when a stalled transaction is terminated.

Note: A situation might arise in which software is required to reconfigure translations so that a previously-marked stalled transaction might now succeed if it were to retry. For example, a transaction that is made to an unmapped address causes an initial fault, and then a terminate operation is performed. Later software creates a legitimate mapping at that address and, if the original transaction was a write that retries and now succeeds, data corruption might result. Software might need a mechanism to ensure that previous transactions have all completed, both terminated stalls and transactions that are progress that the SMMU is not yet aware of.

The system, or client devices, must provide a mechanism to enable software to wait for these previous transactions to complete before changing configuration to a state that might let them proceed. This might be an explicit indication from the client device that its outstanding transactions have all been terminated or completed, an interconnect ordering guarantee that prior transactions are all visible, or another mechanism.

## 3.12.4 Virtual Memory paging with SMMU

The SMMU architecture supports three models of usage with respect to translation-related faults that occur during translation of client device accesses:

1. A fault that occurs due to a device access might always be considered to be an error by the system and is terminated.

Note: This might be the result of a programming error.

2. A fault that occurs due to a device access might be considered permanent due to a programming error, or temporary due to particular page state resulting from use of virtual memory with the address space, and one of the following is configured to occur:
- a. The device transaction is stalled, the fault is reported to software and then the transaction is resumed after the virtual memory system resolves the cause of the fault. Or, if the virtual memory system determines that the access was invalid, the transaction is terminated. This model can only be used with a device and interconnect that can support stalls.
- b. For PCIe devices, for which transactions cannot safely be stalled, the PCIe specification provides ATS and PRI. ATS enables an endpoint to ascertain whether a page can be accessed without causing a fault in

the SMMU before accessing it. PRI provides a mechanism for a page fault to be resolved if the prior ATS step indicates a fault would otherwise occur.

## 3.12.4.1 Page-in request event

When non-PCIe devices are used with the Stall fault model to access paged virtual memory spaces, the Stall fault record itself is the notification to software that a page miss occurred and that software intervention is required.

Note: Devices used with, or integrating, an SMMU will generally emit transactions when the access is required. Although read speculation is permitted, writes cannot be emitted speculatively to trigger a page fault early, see section 3.14 Speculative accesses . In particular, stall fault records do not arise from accesses marked speculative.

An optional hint event record, E\_PAGE\_REQUEST, can be provided by an implementation to request that software initiates any costly page-in operations early. An implementation might provide an IMPLEMENTATION DEFINED mechanism to convey this message from client devices. This message:

- Is a hint, and can be ignored or dropped by the SMMU or software.
- Can be issued speculatively.
- Requires no response.

Note: A stall fault record is generated in response to a non-speculative transaction. A speculative transaction generates no software-visible record. E\_PAGE\_REQUEST allows a software-visible record to make an early start on fetch of pages from secondary storage and can be used to hide latency.

## 3.12.5 Combinations of fault configuration with two stages

When the Stall model and the Terminate model are used differently at different stages of translation, the resulting behavior depends on the stage at which the transaction faulted and the type of fault. For Translation-related faults that can stall the following scenarios arise:

| Stage 1 config   | Stage 2 config   | Fault at   | Transaction result   | Event parameters   | Hypervisor behavior                                                                                                                                                                        |
|------------------|------------------|------------|----------------------|--------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Terminate        | Terminate        | Stage 1    | Terminated           | VA                 | Event passed to guest as stage 1-only event.                                                                                                                                               |
| Terminate        | Terminate        | Stage 2    | Terminated           | VA, IPA            | Might log IPA of fault for debug purposes. (1)Might pass event to guest if terminated.                                                                                                     |
| Terminate        | Stall            | Stage 1    | Terminated           | VA                 | Event passed to guest as S1-only event.                                                                                                                                                    |
| Terminate        | Stall            | Stage 2    | Stalled              | VA, IPA            | May terminate with CMD_RESUME (Terminate) and log IPA of fault for debug purposes. Or, correct the translation fo IPA then CMD_RESUME(Retry). (1) Might pass event to guest if terminated. |
| Stall            | Terminate        | Stage 1    | Stalled              | VA                 | Event passed to guest as S1-only event with stall. Guest must CMD_RESUME(Retry/Terminate).                                                                                                 |
| Stall            | Terminate        | Stage 2    | Terminated           | VA, IPA            | Might log IPA of fault for debug purposes. (1)Might pass event to guest if terminated.                                                                                                     |

| Stage 1 config   | Stage 2 config   | Fault at   | Transaction result   | Event parameters   | Hypervisor behavior                                                                                                                                                                       |
|------------------|------------------|------------|----------------------|--------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Stall            | Stall            | Stage 1    | Stalled              | VA                 | Event passed to guest as S1-only event with stall. Guest must CMD_RESUME(Retry/Terminate)                                                                                                 |
|                  |                  | Stage 2    | Stalled              | VA, IPA            | Might terminate with CMD_RESUME (Terminate) and log IPA for fault or debug purposes. Or, correct translation for IPA then CMD_RESUME(Retry). (1) Might pass event to guest if terminated. |

1. Might pass event to guest: Anything that is terminated at stage 2 is equivalent to a stage 1 external abort. A successful stage 1 translation that outputs an incorrect IPA that leads to a stage 2 fault would not ordinarily be reported to the guest through its SMMU interface, because its stage 1 translation succeeded and the error arises outside of the (stage 1) domain of the SMMU interface. Arm expects that a stage 1 translation table walk that faults at stage 2 is reported to the guest as F\_WALK\_EABT by the hypervisor.

All other fault types cause the transaction to be aborted. For example, a failure to locate a valid STE (F\_BAD\_STE) or CD (F\_BAD\_CD) terminate the transaction with an abort.

Note: When both stage 1 and stage 2 are enabled, a CD or stage 1 translation table descriptor fetch might cause a stage 2 Translation-related fault, and might therefore stall the transaction. Regardless of the reason for making the IPA access, the fault can be resolved at stage 2 and restarted. This is the same behavior as with a faulting IPA access for the transaction address after stage 1 translation.