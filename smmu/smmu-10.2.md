## 10.2 Overview of counters and groups

The SMMU performance monitoring facility provides:

- A number of specified events can be detected that correspond to behavior of aspects of the SMMU or the implementation.
- A number of counters that increment when their configured event occurs.

An implementation has one or more counter groups, and each group contains 1 - 64 counters. Each group has a discoverable set of supported events which can be counted by the counters within the group. All counters in a group can be configured to count any of the supported events. Different groups are not required to support the same set of events.

For example, a particular distributed SMMU implementation might have two groups:

- A group for a unit performing translation table walks and counting translation-related events
- A group for a separate unit containing TLBs and counting TLB-related events.

Some event types are not attributable to one traffic StreamID and are considered to be common to all. Other events are generated by a specific stream and can be filtered by StreamID so that a counter increment is enabled when the StreamID filter matches the event's originating StreamID.

Counters associated with a group are not required to be able to count events that originate from all possible StreamIDs. A counter group is permitted to be affiliated with a subset of incoming StreamIDs. Arm strongly recommends that the incoming StreamID namespace is covered by the union of all counter groups, so that events from any StreamID can be counted using a counter in a group appropriate to the StreamID value. The discovery of whether a given group counts events from a given StreamID, that is the mapping of a StreamID to supporting group or groups, is IMPLEMENTATION DEFINED.

Multiple counter groups might count events that originate from the same StreamID or StreamIDs, or from overlapping sets of StreamIDs.

Note: Because counter groups are not required to support the same kinds of events, events that originate from a given StreamID might be counted in several groups, if multiple groups are associated with that StreamID.

Note: Taking the previous example of the distributed implementation, activity from a given StreamID might cause TLB miss events that can be counted in the group associated with a TLB unit, whereas the same StreamID might cause translation table fetch events that can only be counted in the other counter group associated with the translation table walk unit.

Figure 10.1: Example counter groups filtered on events from different StreamID spans

<!-- image -->

Figure 10.1 illustrates these rules. In this example system, five counter groups exist and any event A, B, C, D or E can be counted for any StreamID. For events A, B and C, any counter in Group 0 can count events that originate from any input StreamID. However, events D and E are counted by groups 1-4 and the group that is selected depends on which services the relevant StreamIDs. For example, to count event D originating from StreamID N, a counter in Group 4 must be used.

Note: Although a counter can be configured to count an event that is filtered by StreamID N, a counter can also be configured to count an event without the StreamID filter. In the example in Figure 10.1, a counter in Group 4 could count an event that occurs from any of the StreamIDs associated with Group 4.

If a counter group exists that is associated with all StreamIDs, Arm recommends that Group 0 is used.

The association between counter groups and ranges of StreamIDs is fixed at design time and no mechanism is provided to re-configure this mapping.

A counter group is conceptually free-standing and has no interdependency on the behavior of other counter groups or even on the SMMU configuration itself. This means that:

- A counter group can be dissimilar to other groups, for example if implemented in a different IP block to another group.
- The capabilities of a given counter group (events captured, number of counters, MSI support) might be unique in the SMMU.

If the SMMUEN for a Security state is zero, it is IMPLEMENTATION DEFINED whether events that can be filtered by stream are counted for activity on the streams that are associated with that Security state. The Secure Observation rules in 10.6 Support for Secure state also apply if the implementation supports counting the event in this scenario.

For events that cannot be filtered by stream, it is IMPLEMENTATION DEFINED whether they are counted when all traffic through the SMMU is treated as global bypass, as indicated by SMMU\_(*\_)CR0.SMMUEN == 0.

Note: Event 0, 'Clock cycle' is the only architectural event in this category.

Unless otherwise specified, when the configuration is changed, there is an IMPLEMENTATION SPECIFIC delay between the observation of the register write by the PMCG and the configuration change taking effect. The change is not required to affect transactions that have been observed and might be partly processed by the SMMU.

Note: Arm expects that any delay is small. Register accesses and client transactions that occur after the completion of a register access that alters the configuration are expected to observe the new configuration.

## 10.2.1 Overflow, interrupts and capture

An individual counter overflows when an increment causes a carry-out to be generated, that is when the counter wraps beyond its maximum unsigned value to a smaller value. When this happens, a bit is set in the Overflow Status array that corresponds to the counter that overflowed. An overflow condition does not prevent a counter from counting.

Note: Software can read the Overflow Status (OVS) array using the SMMU\_PMCG\_OVS{SET0,CLR0} registers to determine which counters have overflowed.

A counter can be programmed to assert a common per-counter group interrupt, when enabled, on overflow. In addition, the counter group interrupt has a per-group overall enable flag.

Note: Whether an overflow occurs is independent of, and not prevented by, the OVS status. If a counter overflow occurs, any side effects of interrupting and capturing it, if enabled, occur regardless of the value of the corresponding OVS bit.

The counter group interrupt is an edge-triggered wired interrupt output, an MSI interrupt, or both. Because counter groups might represent distinct IP blocks, MSI support can differ between counter groups that are associated with one SMMU. However, Arm strongly recommends that all counter groups support MSIs if the core SMMU supports MSIs.

Note: As with the core SMMU MSI IRQs, an implementation that supports MSIs can still supply a wired IRQ output, giving the system the choice of using the wired IRQ and leaving the MSI disabled, or using the MSI.

Optionally, a PMCG can allow all counter registers in a group to be simultaneously sampled by a capture mechanism that copies the counter values to their respective shadow register. The presence of support for this mechanism

is discovered via SMMU\_PMCG\_CFGR.CAPTURE == 1. The capture mechanism is triggered by one of the following:

- A write of 1 to SMMU\_PMCG\_CAPR.CAPTURE.
- Overflow of a counter configured with SMMU\_PMCG\_EVTYPERn.OVFCAP == 1.
- -Note: The counter that causes the capture due to overflow is captured with a post-overflow value.
- An external IMPLEMENTATION DEFINED mechanism.

When capture is triggered by a write to SMMU\_PMCG\_CAPR.CAPTURE, the captured values are observable to an access that is performed after the write to SMMU\_PMCG\_CAPR completes.

Note: One use model for the PMCG might be to program a counter to overflow within a known number of counts and, on overflow a capture is triggered and an interrupt is sent. The interrupt handler reads out the captured counter values.

Note: In addition, counter values and their overflow events can be exported in an IMPLEMENTATION DEFINED manner to external profiling logic. Export and capture of counter values through a mechanism that is invisible to the SMMU PMCG programming interface are unrelated to the presence of the programmatic capture mechanism indicated by SMMU\_PMCG\_CFGR.CAPTURE.

If an MSI is configured with a cacheable, shareable attribute, whether the PMCG is able to perform a cache-coherent MSI write is IMPLEMENTATION DEFINED. The core SMMU\_IDR0.COHACC field does not apply to PMCG MSI writes.

When a counter that overflows is configured to trigger an interrupt, the interrupt is made observable after all of the following have become observable:

- The update to OVS.
- The new counter value.
- The captured values, if the overflow that caused the interrupt also triggered a capture.
