## 3.4 Address sizes

There are three address size concepts to consider in the SMMU, the input address size from the system, the Intermediate Address Size (IAS), and the Output Address Size (OAS):

- The SMMU input address size is 64 bits.
- -Note: See section 3.4.1 Input address size and Virtual Address size for recommendations on how a smaller interconnect or device address capability is presented to the SMMU.
- IAS reflects the maximum usable IPA of an implementation that is generated by stage 1 and input to stage 2:
- -This term is defined to illustrate the handling of intermediate addresses in this section and is not a configurable parameter.
- -The maximum usable IPA size of an SMMU is defined in terms of other SMMU implementation choices, as:

IAS = MAX(SMMU\_IDR0.TTF[0]==1 ? 40 : 0), SMMU\_IDR0.TTF[1]==1 ? OAS : 0));

- -VMSAv8-32 LPAE always supports an IPA size of 40 bits, whereas VMSAv8-64 and VMSAv9-128 limits the maximum IPA size to the maximum PA size. Otherwise, when VMSAv8-32 LPAE is not implemented, the IPA size equals OAS, the PA size, and might be smaller than 40 bits.
- -The purpose of definition of the IAS term is to abstract away from these implementation variables.
- OAS reflects the maximum usable PA output from the last stage of VMSAv8-64 or VMSAv9-128 translations, and must match the system physical address size. The OAS is discoverable from SMMU\_IDR5.OAS. Final-stage VMSAv8-32 LPAE translations always output 40 bits which are zero-extended into a larger OAS, or truncated to a smaller OAS.

Note: Except where explicitly noted, all address translation and fault checking behavior is consistent with Armv8-A [2].

If the SMMU is disabled (with SMMU\_(*\_)CR0.SMMUEN == 0, and SMMU\_(*\_)GBPA.ABORT == 0 allows traffic bypass), the input address is presented directly to the output PA. If the input address of a transaction exceeds the size of the OAS, the transaction is terminated with an abort and no event is recorded. Otherwise, when SMMU\_(*\_)CR0.SMMUEN == 1, transactions are treated as described in the rest of this section.

When a stream selects an STE with STE.Config == 0b100 , transactions bypass all stages of translation. If the input address of a transaction exceeds the size of the OAS, the transaction is terminated with an abort and a stage 1 Address Size fault (F\_ADDR\_SIZE) is recorded.

Note: In Armv8-A PEs, when both stages of translation bypass, a (stage 1) Address Size fault might be generated where an (input) address is greater than the PA size, depending on whether a PE is in AArch32 or AArch64 state. This behavior does not directly translate to the SMMU because no configuration is available to select translation system when in bypass or disabled, therefore the address size is always tested.

When a stream selects an STE with one or more stages of translation present:

For input to stage 1, the input address is treated as a V A (see section 3.4.1 Input address size and Virtual Address size ) and if stage 1 is not bypassed the following stage 1 address checks are performed:

1. On input, a stage 1 Translation fault (F\_TRANSLATION) occurs if the VA is outside the range specified by the relevant CD:
- a. For a CD configured as VMSAv8-32 LPAE, the maximum input range is fixed at 32 bits, and the range of the address input into a given TTB0 or TTB1 translation table is determined by the T0SZ and T1SZ fields.

Note: The arrangement of the TTB0/TTB1 translation table input spans might be such that there is a range of 32-bit addresses that is outside both of the TTB0 and TTB1 spans and will always cause a Translation fault.

b. For a CD configured as VMSAv8-64, the range is determined by the T0SZ and T1SZ fields.

- i. For SMMUv3.0, up to a maximum of 49 bits (two 48-bit TTB0/TTB1).
- ii. For SMMUv3.1 and later, then for each TTBx, the maximum input size is:
- 48 bits, if any of the following are true:
4. -SMMU\_IDR5.VAX == 0b00 .
5. -The TTBx is configured for a 4KB or 16KB granule using CD.TGx and CD.DS == 0.
- 52 bits, if SMMU\_IDR5.VAX == 0b01 or 0b10 and one of the following is true:
7. -The TTBx is configured for a 64KB granule using CD.TGx.
8. -CD.DS == 1 and the TTBx is configured for a 4KB or 16KB granule using CD.TGx.
- c. For a CD configured as VMSAv9-128, the range is determined by the T0SZ and T1SZ fields. For each TTBx, the maximum input size is:
- 48 bits, if SMMU\_IDR5.VAX == 0b00 .
- 52 bits, if SMMU\_IDR5.VAX == 0b01 .
- 55 bits for EL1 and EL2-E2H, if SMMU\_IDR5.VAX == 0b10 .
- 56 bits for EL3, if SMMU\_IDR5.VAX == 0b10 .

A VA is inside the range only if it is correctly sign-extended from the top bit of the range size upwards, although an exception is made for Top Byte Ignore (TBI) configurations.

Note: For example, with a 49-bit VA range and TBI disabled, addresses 0x0000FFFFFFFFFFFF and 0xFFFF000000000000 are within the range but 0x0001000000000000 and 0xFFFE000000000000 are not. See 3.4.1 Input address size and Virtual Address size below for details.

2. The address output from the translation causes a stage 1 Address Size fault if it exceeds the range of the effective IPA size for the given CD:
- a. For VMSAv8-32 LPAE CDs, the IPA size is fixed at 40 bits (the IPS field of the CD is IGNORED).
- b. For VMSAv8-64 and VMSAv9-128 CDs, the IPA size is given by the effective value of the IPS field of the CD, which is capped to the OAS.

If bypassing stage 1 (because STE.Config == 0b1x0 , STE.S1DSS == 0b01 or if unimplemented), the input address is passed directly to stage 2 as the IPA. If the input address of a transaction exceeds the size of the IAS, a stage 1 Address Size fault occurs, the transaction is terminated with an abort and F\_ADDR\_SIZE is recorded. Otherwise, the address might still lie outside the range that stage 2 will accept. In this case, the stage 2 check 1 described in this section causes a stage 2 Translation fault.

Note: The TBI configuration can only be enabled when a CD is used (that is when stage 1 translates) and is always disabled when stage 1 is bypassed or disabled.

Note: The SMMU stage 1 bypass behavior is analogous to a PE with stage 1 disabled but stage 2 translating. The SMMU checks stage 1 bypassed addresses against the IAS, which (when VMSAv8-32 LPAE support is implemented) might be greater than the PA. This supports stage 2-only assignment of devices to guest VMs expecting to program 40-bit DMA addresses, which are input to stage 2 translation.

Note: This also means that an SMMU implementing only stage 2, or implementing both stages but translating through stage 2 only, can still produce a fault marked as coming from stage 1.

Stage 2 receives an IPA, and if not bypassing, the following stage 2 address size checks are performed:

1. On input, a stage 2 Translation fault occurs if the IPA is outside the range configured by the relevant S2T0SZ field of the STE.
- a. For an STE configured as VMSAv8-32 LPAE (see STE.S2AA64), the input range is capped at 40 bits (and cannot exceed 40 bits regardless of the IAS size.)

Note: This ensures, for a system having OAS &lt; 40, that a VMSAv8-64 stage 2 can accept a 40-bit IPA from a VMSAv8-32 LPAE stage 1, if the SMMU supports VMSAv8-32.

b. For an STE configured as VMSAv8-64 or VMSAv9-128, the input range is capped to the IAS.

- c. For SMMUv3.1 and later, when IAS is 52 bits or 56 bits, then for an STE configured as VMSAv8-64 the stage 2 input range is limited to 52 bits and is further limited to 48 bits unless STE.S2TG indicates 64KB granule or STE.S2DS == 1.
2. The address output from the translation causes a stage 2 Address Size fault if it exceeds the effective PA output range:
- a. For a VMSAv8-64 or VMSAv9-128 STE, this is the effective value configured in the S2PS field of the STE (which is capped to the OAS). Note: For information on the permitted effective output address sizes, see STE.S2PS.
- b. For a VMSAv8-32 LPAE STE, this output range is fixed at 40 bits and the STE.S2PS field is IGNORED. If the OAS is less than 40, and if the output address is outside the range of the OAS, the address is silently truncated to fit the OAS.

After this check, if the output address of stage 2 is smaller than the OAS, the address is zero-extended to match the OAS.

If bypassing stage 2 (because STE.Config == 0b10x or if unimplemented), the IPA is presented directly as the PA output address. If the IPA is outside the range of the OAS, the address is silently truncated to fit the OAS. If the IPA is smaller than the OAS, it is zero-extended.

Note: Because the SMMU contains configuration structures that are checked for validity before beginning translation table walks, certain configuration errors are detected as an invalid structure configuration. This includes STE.S2TTB being out of range of the effective stage 2 output address size, or CD.TTBx being out of range of the effective stage 1 output address size. These invoke C\_BAD\_STE or C\_BAD\_CD configuration faults, respectively, instead of an Address Size fault.

## 3.4.1 Input address size and Virtual Address size

The architectural input address size of the SMMU is 64 bits. If a client device outputs an address smaller than 64 bits, or if the interconnect between a client device and the SMMU input supports fewer than 64 bits of address, the smaller address is converted to a 64-bit SMMU input address in a system-specific manner. This conversion is outside of the scope of this specification, but must comply with the rules in this section.

The A-profile architecture provides support for different maximum VA size, as follows:

- Armv8.0 and Armv8.1 [2] support a maximum of a 49-bit VA in AArch64 state, meaning there are up to 49 significant lower bits that are sign-extended to a 64-bit address.
- Armv8.2 to Armv8.8 [2] supports a maximum of a 53-bit VA or 49-bit VA in AArch64 state, meaning there are up to 53 or 49 significant lower bits that are sign-extended to a 64-bit address.
- Armv8.9 [2] supports a maximum of a 56-bit VA, 53-bit VA or 49-bit VA in AArch64 state, meaning there are up to 56, 53 or 49 significant lower bits respectively, that are sign-extended to a 64-bit address. A 56-bit VA is supported for VMSAv9-128 translations.

Stage 1 translation contexts configured as VMSAv8-64 or VMSAv9-128 have an input VA range that is configurable up to the maximum supported size as described above (arranged as two halves and translated through TTB0 and TTB1).

The term, VAS, represents the VA size chosen for a given SMMU implementation, determined as follows:

- When SMMU\_IDR5.VAX == 0b00 , this is 49 bits (2 x 48 bits).
- When SMMU\_IDR5.VAX == 0b01 , this is 53 bits (2 x 52 bits).
- When SMMU\_IDR5.VAX == 0b10 , this is 56 bits (2 x 55 bits for EL1 and EL2-E2H StreamWorlds, or 1 x 56 bits for EL3 StreamWorld).

Note: In SMMUv3.0, SMMU\_IDR5.VAX is RES0 and therefore VAS is always 49 bits.

Stage 1's high translation table, TTB1, can only be selected if V AS significant bits of address are presented to the SMMUsign-extended. If applications require use of both TTB0 and TTB1 then the system design must transmit addresses of at least V AS bits end-to-end, from device address registers through the interconnect to the SMMU, and that sign-extension occurs from the input MSB upwards as described in this section.

Stage 1 translation contexts configured as VMSAv8-32 LPAE have a 32-bit VA. In this case, bits [31:0] of the input address are used directly as the V A. A Translation fault is raised if the upper 32 bits of the input address are not all zero. The TxSZ fields are used to select TTB0 or TTB1 from the upper bits [31:n] in the input range.

Input range checks made for a stage 1 VMSAv8-64 or VMSAv9-128 translation table configured (with TxSZ) for an input range of N significant bits fail unless bits V A[ AddrTop :N - 1] are identical.

- When Top Byte Ignore (TBI) is not enabled, AddrTop == 63.
- When TBI is enabled, AddrTop == 55, which means that VA[63:56] are ignored.

When TBI is enabled, only VA[55:N-1] must be identical and the effective VA[63:56] bits are taken to be a sign-extension of VA[55] for translation purposes.

Note: TBI configuration is part of the CD, so it can only be enabled when stage 1 translates. When stage 1 is bypassed or disabled, no CD is used and TBI is always disabled.

The term Upstream Address Size (UAS) represents the number of effective bits of address presented to the SMMU from a client device:

1. If 57 &lt;= UAS &lt; 64, TBI has meaning as there are bits supplied in VA[63:56] that might differ from VA[55:(VAS-1)]. TBI determines whether a Translation fault is invoked if they differ.
2. If VAS &lt;= UAS &lt; 57, TBI is meaningless as the input sign-extension means VA[63:56] cannot differ from VA[55].
3. If UAS &lt;= VAS, the range checks can only fail if translation table range is configured with a T0SZ, or T1SZ, if UAS == 49, smaller than the presented address. That is, the maximum configuration of stage 1 translation tables covers any presented input address.

For VMSAv8-64 and VMSAv9-128, the stage 1 translation table, TTB0 or TTB1, is selected based on VA[55]. Therefore, because an address size from the client device that is less than the V AS bits is zero-extended to 64, this means VA[55] == 0 and TTB1 is never selected.

If any upper address bits of a 64-bit address programmed into a peripheral are not available to the SMMU sign-checking logic, whether by truncation in the interconnect or peripheral, software must not rely on mis-programmed upper bits to cause a Translation fault in the SMMU. If such checking is required within such a system, software must check the validity of upper bits of DMA addresses programmed into such a device.

All input address bits are recorded unmodified in SMMU fault event records.

## 3.4.2 Address alignment checks

The SMMU architecture does not check the alignment of incoming transaction addresses.

Note: For a PE, the alignment check is based on the size of an access. This semantic is not directly applicable to client device accesses.

## 3.4.3 Address sizes of SMMU-originated accesses

Distinct from client device accesses forwarded into the system, the SMMU originates accesses to the system for the purposes of:

- Configuration structure access (STE, CD).
- Queue access (Command, Event, PRI).
- MSI interrupt writes.
- Last-stage translation table walks:
- -Note: Addresses output from stage 1 walks in a nested configuration are input to stage 2 and translated in the expected manner (including causing stage 1 Address Size faults, or stage 2 Translation faults from IPAs outside the stage 2 translation range), rather than being output into the system directly.

An access address can be out of range if it relates to a base address that is already greater than an allowed address size, or if an index is applied to a base address so that the result is greater than an allowed address size. If an

access address is calculated to be a PA value greater than the SMMU OAS or physical address size, or an IPA value greater than the IAS or intermediate address size, behavior is as follows:

| Access type                       | Configured by                                                                                                                                                                      | Address type            | Behavior when address too large                                       |
|-----------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------|-----------------------------------------------------------------------|
| CD fetch or L1CD fetch            | STE.S1ContextPtr                                                                                                                                                                   | If stage 1-only, PA     | Truncate to OAS or F_CD_FETCH or C_BAD_STE (1)                        |
| CD fetch or L1CD fetch            | STE.S1ContextPtr                                                                                                                                                                   | If stage 2 present, IPA | Truncate to IAS or C_BAD_STE or Stage 2 Translation fault (2)         |
| CD fetch                          | L1CD.L2Ptr                                                                                                                                                                         | If stage 1-only, PA     | Truncate to OAS or F_CD_FETCH or C_BAD_SUBSTREAMID (3)                |
| CD fetch                          | L1CD.L2Ptr                                                                                                                                                                         | If stage 2 present, IPA | Truncate to IAS or C_BAD_SUBSTREAMID or stage 2 Translation fault (4) |
| STE fetch                         | SMMU_(*_)STRTAB_BASE or L1STD.L2Ptr                                                                                                                                                | PA                      | Truncate to OAS or F_STE_FETCH (5)                                    |
| VMS fetch                         | STE.VMSPtr                                                                                                                                                                         | PA                      | C_BAD_STE                                                             |
| Queue access                      | SMMU_(*_)*Q_BASE                                                                                                                                                                   | PA                      | Truncate to OAS (6)                                                   |
| MSI write                         | SMMU_(*_)*_IRQ_CFG {0,1,2} or CMD_SYNC arguments                                                                                                                                   | PA                      | Truncate to OAS (6)                                                   |
| Last-stage translation table walk | Addresses derived from intermediate translation table descriptors located using STE.S2TTB or STE.S_S2TTB or CD.TTB{0,1}, after the first level translation table descriptor fetch. | PA                      | Stage 1/2 Address Size fault                                          |
| Last-stage translation table walk | Starting-level translation table descriptor address in STE.S2TTB or STE.S_S2TTB or CD.TTB{0,1}                                                                                     | PA                      | CD or STE ILLEGAL (see CD.TTB{0,1} and STE.S2TTB description).        |

## In the context of these respective access types:

1. An implementation of SMMUv3.1 or later generates C\_BAD\_STE and terminates the transaction. It is CONSTRAINED UNPREDICTABLE whether an SMMUv3.0 implementation:
- a. Generates an F\_CD\_FETCH and terminates the transaction. The event contains the non-truncated fetch address.
- b. Generates a C\_BAD\_STE and terminates the transaction.
- c. Truncates STE.S1ContextPtr to the OAS and initiates a read of a CD/L1CD from this address (translation continues).
2. It is CONSTRAINED UNPREDICTABLE whether an implementation:
- a. Generates a C\_BAD\_STE and terminates the transaction.
- b. Inputs the IPA to stage 2 without truncation, generating a stage 2 Translation fault that reports a non-truncated fault address.

- c. SMMUv3.0 only, inputs the IPA to stage 2 with truncation to the IAS. If translation is successful, initiates a read of a CD/L1CD from the result otherwise generates a stage 2 fault that reports a truncated fault address.
3. An implementation of SMMUv3.1 or later generates C\_BAD\_SUBSTREAMID and terminates the transaction. It is CONSTRAINED UNPREDICTABLE whether an SMMUv3.0 implementation:
- a. Generates an F\_CD\_FETCH and terminates the transaction. The event contains the non-truncated fetch address.
- b. Generates a C\_BAD\_SUBSTREAMID and terminates the transaction.
- c. Truncates L1CD.L2Ptr to the OAS and initiates a read of a CD from this address (translation continues).
4. It is CONSTRAINED UNPREDICTABLE whether an implementation:
- a. Generates a C\_BAD\_SUBSTREAMID and terminates the transaction.
- b. Inputs the IPA to stage 2 without truncation, generating a stage 2 Translation fault that reports a non-truncated fault address.
- c. SMMUv3.0 only, inputs the IPA to stage 2 with truncation to the IAS. If translation is successful, initiates a read of a CD from the result otherwise generates a stage 2 fault that reports a truncated fault address.
5. It is CONSTRAINED UNPREDICTABLE whether an implementation truncates an STE fetch address (and continues translation) or generates an F\_STE\_FETCH condition which terminates the transaction and might deliver an error event.
6. Note: When hypervisor software presents an emulated SMMU interface to a guest, Arm recommends that guest-provided addresses are correctly masked to the IPA size to ensure consistent SMMU behavior from the perspective of the guest driver.

In all cases where a non-truncated address is reported in a fault (for instance, a stage 2 Translation fault), the reported address is the calculated address of the structure being accessed, for example an L1CD address calculated from a base address of STE.S1ContextPtr indexed by the incoming SubstreamID to locate a L1CD structure.

The address of an L1CD or CD, given by STE.S1ContextPtr or L1CD.L2Ptr, is not subject to a stage 1 Address Size fault check.

In summary, configuration registers, command fields, and structure fields programmed with out-of-range physical addresses might truncate the addresses to the OAS or PA size.

Note: This behavior in part arises from the fact that register address fields are not required to provide storage for high-order physical address bits beyond the OAS. See section 6.3 Register formats for details.

Note: Commands, register, and structure fields taking IPA addresses store the entire field width so that a potential stage 2 fault can be correctly raised (providing a full non-truncated IPA in a fault record).